---
id: 3300
title: "אינטגרלים כפולים, משולשים ו-d-ממדיים"
date: 2015-11-09 17:35:32
layout: post
categories: 
  - אנליזה מתמטית
tags: 
  - אינטגרל
  - אינטגרלים רב ממדיים
  - אנליזה וקטורית
  - משפט פוביני
---
בסדרת הפוסטים שלי על אנליזה וקטורית סיימנו לעת עתה לדבר על נגזרות, ואנחנו עוברים אל עמוד התווך השני של האנליזה - אינטגרלים. הדיון באינטגרלים מתחלק לשלושה שלבים: בשלב הראשון, שהוא מה שנעשה הפעם, אנחנו לוקחים את אינטגרל רימן התמים והנחמד מחדו"א בסיסית ורואים איך ההגדרות שלו מוכללות באופן טבעי ל-{::nomarkdown}\( \mathbb{R}^{d}\){:/nomarkdown} לכל {::nomarkdown}\( d\){:/nomarkdown} טבעי. בשלב השני אנחנו רואים שדרך ההתבוננות הזו היא צרה מדי ובעצם צריך לדבר על עוד סוגים של אינטגרלים שרלוונטיים למרחבים רב-ממדיים, ואז מתחיל לצוץ ערב-רב של משפטים שמחברים את סוגי האינטגרלים השונים (משפטי גרין, גאוס, וסטוקס). בשלב השלישי, המטורלל ביותר, אנחנו מרחיבים מאוד את נקודת המבט שלנו ומגיעים מכך למשפט כללי מאוד (משפט סטוקס הכללי) שמכליל את כל המשפטים הללו, ובאופן כללי אנחנו מצליחים לראות שכל סוגי האינטגרלים השונים הם בעצם היבטים שונים של אותו דבר. זה היעד שאני חותר אליו, אבל הרבה לפני שנגיע לשם, בואו נתחיל מלדבר על ההכללה הפשוטה של אינטגרל רימן, שאנחנו מקבלים על ידי כך שאנחנו לוקחים את ההגדרה הרגילה של אינטגרל רימן ומנסים להפעיל אותה ב-{::nomarkdown}\( d\){:/nomarkdown} ממדים. אנחנו נראה שההגדרות הן פשוטות למדי - אין כאן סיבוך רציני ביחס למה שקורה במימד אחד - אבל שה<strong>חישוב</strong> של אינטגרל כזה הוא מן הסתם מסובך יותר, ובדרך כלל מסתמך על היכולת שלנו לבצע רדוקציה לאינטגרלים במימד אחד.

אני מניח כאן שאתם כבר מכירים אינטגרלים במימד אחד ואין צורך לתת שיחת מוטיבציה מיוחדת או לחזור על ההגדרות במימד אחד. מי שמעוניין יכול לקרוא את <a href="http://www.gadial.net/2010/11/27/integral/">הפוסט שלי בנושא</a>. אז בואו נעבור ישר לאקשן - איך מגדירים את זה?

במימד אחד אינטגרל מוגדר על קטע {::nomarkdown}\( \left[a,b\right]\){:/nomarkdown}. ב-{::nomarkdown}\( d\){:/nomarkdown}-מימדים הוא מוגדר מעל קוביה {::nomarkdown}\( d\){:/nomarkdown}-ממדית, שהיא קבוצה מהצורה {::nomarkdown}\( Q=\left[a_{1},b_{1}\right]\times\dots\times\left[a_{d},b_{d}\right]\){:/nomarkdown}. כלומר, יש לנו פונקציה <strong>חסומה </strong>{::nomarkdown}\( f:Q\to\mathbb{R}\){:/nomarkdown} ואנו רוצים להגדיר את האינטגרל שלה. לקטע מאורך 1 היה <strong>אורך</strong>, {::nomarkdown}\( b-a\){:/nomarkdown}; לקוביה כזו יש <strong>נפח</strong>, {::nomarkdown}\( v\left(Q\right)\triangleq\prod_{i=1}^{d}\left(b_{i}-a_{i}\right)\){:/nomarkdown}. במימד אחד הרעיון היה לחלק את הקטע {::nomarkdown}\( \left[a,b\right]\){:/nomarkdown} לחלקים קטנים, לכפול את אורך כל חלק כזה בערך המקסימלי/מינימלי בקטע של הפונקציה שמאנטגרלים, ולסכום. חלוקה של {::nomarkdown}\( \left[a,b\right]\){:/nomarkdown} מסומנת בתור {::nomarkdown}\( P\){:/nomarkdown} (מלשון Partition) והיא סדרה סופית של נקודות בקטע {::nomarkdown}\( \left[a,b\right]\){:/nomarkdown} שכוללת את הקצוות, כלומר {::nomarkdown}\( P=\left(x_{1},x_{2},\dots,x_{t}\right)\){:/nomarkdown} כך ש-{::nomarkdown}\( x_{1}=a,x_{t}=b\){:/nomarkdown} ו-{::nomarkdown}\( x_{1}&lt;x_{2}&lt;\dots&lt;x_{t}\){:/nomarkdown}. דרך אחת לחלק קוביה {::nomarkdown}\( d\){:/nomarkdown}-ממדית להרבה קוביות קטנות היא על ידי כך שלוקחים חלוקה של כל אחד מהקטעים שמגדירים את הקוביה, {::nomarkdown}\( \left(P_{1},\dots,P_{d}\right)\){:/nomarkdown}, כלומר {::nomarkdown}\( P_{i}\){:/nomarkdown} היא חלוקה של הקטע {::nomarkdown}\( \left[a_{i},b_{i}\right]\){:/nomarkdown}. תחשבו על איך אנחנו מציירים טבלה בדו מימד - קווים אנכיים ואופקיים שחוצים זה את זה ויוצרים ריבועים. כמובן, יש <strong>עוד דרכים</strong> לחלק קוביה {::nomarkdown}\( d\){:/nomarkdown}-ממדית לקוביות קטנות, אבל אנחנו פשוט לא נזקקים להן. העיקר מבחינתנו הוא שבדרך החלוקה שלנו אפשר לקבל חלקים שקטנים עד לאינסוף.

בחלוקה {::nomarkdown}\( P=\left(P_{1},\dots,P_{d}\right)\){:/nomarkdown} אנחנו מקבלים תת-קוביות שהן מהצורה {::nomarkdown}\( I_{1}\times\dots\times I_{d}\){:/nomarkdown} כאשר {::nomarkdown}\( I_{i}\){:/nomarkdown} הוא קטע שמוגדר על ידי החלוקה {::nomarkdown}\( P_{i}\){:/nomarkdown}. נסמן תת-קוביה ב-{::nomarkdown}\( R\){:/nomarkdown}. נסמן את הנפח של הקוביה ב-{::nomarkdown}\( v\left(R\right)\){:/nomarkdown}. עכשיו, זכרו שיש לנו פונקציה {::nomarkdown}\( f:Q\to\mathbb{R}\){:/nomarkdown}; נסמן ב-{::nomarkdown}\( M_{R}\left(f\right)=\sup\left\{ f\left(x\right)\ \|\ x\in R\right\} \){:/nomarkdown} את החסם העליון על הערך של {::nomarkdown}\( f\){:/nomarkdown} במלבן {::nomarkdown}\( R\){:/nomarkdown} ובדומה ב-{::nomarkdown}\( m_{R}\left(f\right)=\sup\left\{ f\left(x\right)\ \|\ x\in R\right\} \){:/nomarkdown} את האינפימום (כאן העובדה ש-{::nomarkdown}\( f\){:/nomarkdown} חסומה באה לידי ביטוי, אחרת הערכים הללו לאו דווקא היו מוגדרים והיינו בצרות). עכשיו אפשר לחקות את ההגדרה של סכומי דארבו מאינטגרלים חד ממדיים: להגדיר <strong>סכום תחתון</strong> של הפונקציה {::nomarkdown}\( f\){:/nomarkdown} ביחס לחלוקה {::nomarkdown}\( P\){:/nomarkdown} בתור הסכום {::nomarkdown}\( L\left(f,P\right)=\sum_{R}m_{R}\left(f\right)v\left(R\right)\){:/nomarkdown} ואת <strong>הסכום העליון</strong> בתור {::nomarkdown}\( U\left(L,P\right)=\sum_{R}M_{R}\left(f\right)v\left(R\right)\){:/nomarkdown} כאשר בשני המקרים הסכום נלקח על כל תת-הקוביות שמוגדרות על ידי {::nomarkdown}\( P\){:/nomarkdown} - קל לראות שהמספר שלהן הוא סופי ולכן הסכום בוודאי מוגדר היטב. השלב האחרון הוא הגדרה של אינטגרל תחתון ועליון: {::nomarkdown}\( \underline{\int_{Q}}f=\sup_{P}L\left(f,P\right)\){:/nomarkdown} ו-{::nomarkdown}\( \overline{\int_{Q}}f=\inf_{P}U\left(f,P\right)\){:/nomarkdown}. אם {::nomarkdown}\( \underline{\int_{Q}}f=\overline{\int_{Q}}f\){:/nomarkdown} אומרים ש-{::nomarkdown}\( f\){:/nomarkdown} <strong>אינטגרבילית</strong> מעל {::nomarkdown}\( Q\){:/nomarkdown} ומסמנים את הערך המשותף הזה פשוט ב-{::nomarkdown}\( \int_{Q}f\){:/nomarkdown}.

השלב האחרון, של האינטגרל העליון והתחתון, דורש עוד הבהרה מסויימת כדי שיהיה ברור למה "נכון" לנקוט בו. לא קשה לראות שאם ניקח חלוקה קיימת {::nomarkdown}\( P\){:/nomarkdown} ונחלק אותה עוד קצת על ידי הוספת נקודות עד לקבלת חלוקה {::nomarkdown}\( P^{\prime}\){:/nomarkdown}, אנחנו יכולים רק <strong>להגדיל</strong> את הסכום התחתון ו<strong>להקטין</strong> את הסכום העליון, כלומר {::nomarkdown}\( L\left(f,P\right)\le L\left(f,P^{\prime}\right)\){:/nomarkdown} ו-{::nomarkdown}\( U\left(f,P\right)\ge U\left(f,P^{\prime}\right)\){:/nomarkdown}. למה? כי השטח הכולל שעליו אנחנו סוכמים לא משתנה, אבל ה-{::nomarkdown}\( M_{R}\left(f\right),m_{R}\left(f\right)\){:/nomarkdown} שלנו עשויים להשתנות ולהיות יותר מדוייקים. לדוגמה, נאמר שבתת-קוביה עם נפח 10 יש לנו {::nomarkdown}\( m_{R}\left(f\right)=3\){:/nomarkdown}, אז תת-הקוביה הזו תתרום לסכום 30; אבל עכשיו, אם נחלק אותה לשתי תת-קוביות שכל אחד מנפח 5, לא ייתכן שה-{::nomarkdown}\( m_{R}\left(f\right)\){:/nomarkdown} של אף אחד משתי תת-הקוביות הללו יהיה קטן יותר מ-3 (אחרת ה-{::nomarkdown}\( m_{R}\left(f\right)\){:/nomarkdown} המקורי היה נמוך יותר) ולכן ייתכן, למשל, שבאחת הקוביות הוא עדיין 3 אך בשניה הוא 4, ואז נקבל סכום כולל של {::nomarkdown}\( 3\cdot5+4\cdot5=35\){:/nomarkdown}, שגדול מ-30. עוד דבר שברור מייד הוא שעבור חלוקה {::nomarkdown}\( P\){:/nomarkdown} נתונה מתקיים {::nomarkdown}\( L\left(f,P\right)\le U\left(f,P\right)\){:/nomarkdown}, פשוט כי {::nomarkdown}\( \inf\){:/nomarkdown} תמיד קטן או שווה ל-{::nomarkdown}\( \sup\){:/nomarkdown} שנלקח על אותה פונקציה ואותו תחום.

עכשיו, בואו ניקח שתי חלוקות {::nomarkdown}\( P_{1},P_{2}\){:/nomarkdown} <strong>כלשהן</strong>. אפשר לבנות מהן חלוקה חדשה שמתקבלת מאיחוד קבוצות הנקודות של שתיהן (חשבו על שתי טבלאות שונות שאנחנו שמים אחת על השניה תוך שימוש בנייר שקוף). נסמן את החלוקה שנקבל כך ב-{::nomarkdown}\( P^{\prime}\){:/nomarkdown}. אז נקבל

{::nomarkdown}\( L\left(f,P_{1}\right)\le L\left(f,P^{\prime}\right)\le U\left(f,P^{\prime}\right)\le U\left(f,P_{2}\right)\){:/nomarkdown}

המסקנה: <strong>לכל</strong> שתי חלוקות, הסכום התחתון של האחת קטן מהסכום העליון של השניה. זה מצביע מייד על כך שהסכומים העליונים והתחתונים חסומים, ולכן האינטגרלים העליון והתחתון שהגדרתי אכן מוגדרים היטב, ושהאינטגרל העליון תמיד גדול או שווה מהאינטגרל התחתון, כלומר שניהם מהווים את הקירוב "הטוב ביותר" שאנחנו מסוגלים להשיג בשיטת האינטגרציה הנוכחית שלנו אל מה שאנחנו תופסים בתור האינטגרל של הפונקציה - קירוב אחד הוא מלמעלה והשניה מלמטה, ואם הם משתווים, מה טוב (ואם הם לא משתווים? יש שיטות אינטגרציה חכמות יותר - למשל, אינטגרל לבג - שהדיון בהן שייך לזמן אחר).

כדאי לתת עוד הערה קטנה על הסימון. אינטגרלים במימד אחד לרוב נכתבים בתור {::nomarkdown}\( \int_{a}^{b}f\left(x\right)dx\){:/nomarkdown}. אנחנו שינינו שני דברים. הראשון הוא שאנחנו לא כותבים את הגבולות העליונים והתחתונים אלא סתם כותבים {::nomarkdown}\( Q\){:/nomarkdown}; זה זהה לכך שבמימד אחד היינו כותבים {::nomarkdown}\( \int_{\left[a,b\right]}f\){:/nomarkdown}. הדבר השני הוא שחיסלנו את ה-{::nomarkdown}\( dx\){:/nomarkdown} הזה שתקוע בתוך אינטגרלים במימד אחד. ליצור הזה יש במימד אחד שימוש פרקטי, של להגיד לנו מי משתנה האינטגרציה במקרה שבו ב-{::nomarkdown}\( f\){:/nomarkdown} יש גם פרמטרים; אבל יש לו גם משמעות מעבר לכך, שעדיין לא פירמלנו בהקשר שלנו ולכן בינתיים נוותר עליה לחלוטין.

עם זאת, יש כתיב מקובל לאינטגרלים עבור {::nomarkdown}\( d=2\){:/nomarkdown} ו-{::nomarkdown}\( d=3\){:/nomarkdown} שהכרחי להציג כי הוא מה שמשתמשים בו רוב הזמן בשימושים מעשיים. כאשר {::nomarkdown}\( d=2\){:/nomarkdown} האינטגרל שהגדרנו נקרא <strong>אינטגרל כפול</strong> ומסומן ב-{::nomarkdown}\( \iint_{Q}f\left(x,y\right)dxdy\){:/nomarkdown}, וכאשר {::nomarkdown}\( d=3\){:/nomarkdown} הוא נקרא <strong>אינטגרל משולש</strong> ומסומן ב-{::nomarkdown}\( \iiint_{Q}f\left(x,y,z\right)dxdydz\){:/nomarkdown}. זאת, כמובן, בנוסף לסימון ה"כללי" שכבר הצגתי.

עוד נקודה שכדאי להתייחס אליה כבר עכשיו היא ש-{::nomarkdown}\( Q\){:/nomarkdown} לא חייב להיות קוביה. אפשר להגדיר את האינטגרל על כל קבוצה <strong>חסומה </strong>{::nomarkdown}\( S\){:/nomarkdown}, כאשר "חסומה" פירושו שקיימת קוביה {::nomarkdown}\( Q\){:/nomarkdown} שמכילה אותה. דהיינו, אם יש לנו פונקציה {::nomarkdown}\( f:S\to\mathbb{R}\){:/nomarkdown} יש משמעות לאינטגרל {::nomarkdown}\( \int_{S}f\){:/nomarkdown}. בסיטואציה הזו אפשר להגדיר פונקציה {::nomarkdown}\( f_{Q}:Q\to\mathbb{R}\){:/nomarkdown} כאשר {::nomarkdown}\( Q\){:/nomarkdown} היא קוביה כלשהי שמכילה את {::nomarkdown}\( S\){:/nomarkdown}, ומוגדרת על ידי {::nomarkdown}\( f_{Q}\left(x\right)=\begin{cases}f\left(x\right) &amp; x\in S\\0 &amp; x\notin S\end{cases}\){:/nomarkdown} ואז להגדיר {::nomarkdown}\( \int_{S}f=\int_{Q}f_{Q}\){:/nomarkdown}. כמובן, נדרשת כאן הוכחה לכך שההגדרה הזו <strong>מוגדרת היטב</strong> - שעבור בחירות שונות של {::nomarkdown}\( Q\){:/nomarkdown} נקבל את אותו אינטגרל. אני קופץ על ההוכחה הזו כי אני מניח שהתוצאה אינטואיטיבית מספיק גם כך.

עכשיו עולות מאליהן שתי שאלות - הראשונה, באילו מצבים האינטגרל של {::nomarkdown}\( f\){:/nomarkdown} קיים? ראינו שהיות {::nomarkdown}\( f\){:/nomarkdown} חסומה היא תנאי הכרחי לכך שבכלל ננסה להגדיר את האינטגרל, אבל זה בוודאי לא תנאי מספיק. השאלה השניה היא - אם האינטגרל קיים, איך מחשבים אותו?

נתחיל מהשאלה הראשונה. הדוגמה הנגדית הקלאסית של פונקציה חסומה שאיננה אינטגרבילית היא פונקציית דיריכלה, שבמימד אחד מוגדרת להיות {::nomarkdown}\( f\left(x\right)=\begin{cases}1 &amp; x\in\mathbb{Q}\\0 &amp; x\notin\mathbb{Q}\end{cases}\){:/nomarkdown} - בניסוח אחר, זוהי הפונקציה המציינת של הרציונליים, {::nomarkdown}\( \chi_{\mathbb{Q}}\){:/nomarkdown}. היא לא אינטגרבילית מכיוון שכל קטע לא מנוון מכיל גם רציונליים וגם אי רציונליים, ולכן {::nomarkdown}\( m_{R}\){:/nomarkdown} יוצא תמיד 0 ו-{::nomarkdown}\( M_{R}\){:/nomarkdown} יוצא תמיד 1 ולכן האינטגרל העליון יצא האורך של הקטע שעליו מבצעים את האינטגרציה והאינטגרל התחתון יצא תמיד 0; אותו דבר יקרה גם עבור גרסה {::nomarkdown}\( d\){:/nomarkdown}-ממדית של הפונקציה. עכשיו, אינטגרל לבג שהזכרתי למעלה פותר את הבעיה ויוצא שאינטגרל לבג של הפונקציה הזו הוא 0; האינטואיציה הוא ש-{::nomarkdown}\( \mathbb{Q}\){:/nomarkdown} היא קבוצה "קטנה" למדי מבחינת ה"נפח" (ה<strong>מידה</strong> שלה) ולכן היא לא משפיעה לנו על האינטגרל ואפשר לחשוב על האינטגרל כאילו הוא נלקח רק מעל האי-רציונליים, ומעליהם הפונקציה היא 0 (ברמה אינטואיטיבית יותר, אפשר לשנות כרצוננו את הערכים של הפונקציה על הרציונליים ועדיין לקבל את אותו אינטגרל, ולכן אם נשנה את ערכי הפונקציה ל-0 נקבל את הפונקציה הקבועה 0 ואין פלא שהאינטגרל יוצא 0).

מצד שני, די קל להוכיח שאם {::nomarkdown}\( f\){:/nomarkdown} היא רציפה, אז האינטגרל שלה קיים תמיד. ההוכחה מתבססת על כך שאם {::nomarkdown}\( f\){:/nomarkdown} היא רציפה בקבוצה סגורה וחסומה, אז היא רציפה בה <strong>במידה שווה</strong>. רציפות במידה שווה פירושה שאפשר לתת גודל כלשהו של תת-קוביות, כך ש<strong>כל</strong> זוג נקודות <strong>בכל</strong> תת-מלבן מהגודל הזה יהיו בעלות התכונה שהתמונה של {::nomarkdown}\( f\){:/nomarkdown} עליהן היא יחסית קרובה. פורמלית, לכל {::nomarkdown}\( \varepsilon&gt;0\){:/nomarkdown} קיים {::nomarkdown}\( \delta&gt;0\){:/nomarkdown} כך שאם {::nomarkdown}\( \left\|x_{1}-x_{2}\right\|&lt;\delta\){:/nomarkdown} אז {::nomarkdown}\( \left\|f\left(x_{1}\right)-f\left(x_{2}\right)\right\|&lt;\varepsilon\){:/nomarkdown}. המשמעות היא שככל ש-{::nomarkdown}\( R\){:/nomarkdown} נהיה קטן יותר ויותר, כך {::nomarkdown}\( m_{R}\){:/nomarkdown} ו-{::nomarkdown}\( M_{R}\){:/nomarkdown} הופכים לקרובים יותר ויותר, ולכן {::nomarkdown}\( L\left(f,P\right)\){:/nomarkdown} ו{::nomarkdown}\( U\left(f,P\right)\){:/nomarkdown} מתקרבים יותר ויותר וניתן להראות שהאינטגרלים העליון והתחתון ישתוו. בדרך כלל רואים את ההוכחה הזו עבור אינטגרל חד ממדי ואין טעם לחזור עליה כאן.

המשפט הכללי על אינטגרביליות רימן של {::nomarkdown}\( f\){:/nomarkdown} הוא מעין שילוב של שני הדברים שדיברנו עליהם לעיל: זה לא <strong>הכרחי</strong> שהפונקציה תהיה רציפה, אבל היא צריכה להיות <strong>כמעט רציפה</strong>. הניסוח הפורמלי הוא ש-{::nomarkdown}\( f\){:/nomarkdown} אינטגרבילית רימן ב-{::nomarkdown}\( Q\){:/nomarkdown} אם ורק אם קבוצת נקודות אי-הרציפות שלה ב-{::nomarkdown}\( Q\){:/nomarkdown} היא ממידה אפס. אני לא מוכיח את התוצאה הזו כאן כי לדעתי נכון לדבר עליה רק במסגרת דיון על מידת לבג (למרות שאפשר להגדיר את "מידה אפס" גם בלי להגדיר את מידת לבג הכללית, וזה מה שבדרך כלל עושים בספרי לימוד בנושא - קבוצה היא ממידה אפס אם לכל {::nomarkdown}\( \varepsilon\){:/nomarkdown} אפשר לכסות אותה על ידי סדרת קוביות שסכום נפחיה הכולל - וזה עשוי להיות סכום אינסופי - הוא קטן מ-{::nomarkdown}\( \varepsilon\){:/nomarkdown}). כל הדיון הזה מתבצע לרוב כבר עבור פונקציה חד ממדית; העניין הוא בכך ש-{::nomarkdown}\( d\){:/nomarkdown}-ממדים לא הופכים את הסיפור למסובך כמעט בכלל.

נעבור, אם כן, לשאלה של איך <strong>מחשבים</strong> אינטגרלים {::nomarkdown}\( d\){:/nomarkdown}-ממדים. וכאן זו כבר בעיה קשה בהרבה. התשובה הקצרה היא שלרוב עושים את זה על ידי <strong>רדוקציה</strong> למקרה החד-ממדי, כלומר מסתמכים בעיקר על כך שאנחנו יודעים לפתור אינטגרלים חד-ממדיים, אז כדאי להיזכר מה קורה במקרה החד-ממדי. גם במקרה החד-ממדי, חישוב אינטגרלים יכול להיות עניין קשה. עבור {::nomarkdown}\( f\){:/nomarkdown} שאינה רציפה, לרוב מפצלים את האינטגרל לסכום של כמה אינטגרלים שכל אחד מהם נוגע לתחום שבו {::nomarkdown}\( f\){:/nomarkdown} רציפה. כאשר {::nomarkdown}\( f\){:/nomarkdown} כן רציפה, יש לנו קסם, קסם מדהים לחלוטין, שנקרא <strong>המשפט היסודי של החדו"א</strong>. המשפט הזה אומר שאם {::nomarkdown}\( f\){:/nomarkdown} היא רציפה בקטע {::nomarkdown}\( \left[a,b\right]\){:/nomarkdown} ואם {::nomarkdown}\( F\){:/nomarkdown} היא <strong>פונקציה קדומה</strong> של {::nomarkdown}\( f\){:/nomarkdown}, כלומר מתקיים {::nomarkdown}\( F^{\prime}=f\){:/nomarkdown} - הנגזרת של {::nomarkdown}\( F\){:/nomarkdown} היא {::nomarkdown}\( f\){:/nomarkdown} - אז {::nomarkdown}\( \int_{a}^{b}f\left(x\right)dx=F\left(b\right)-F\left(a\right)\){:/nomarkdown}. בעיני זו תוצאה מדהימה לגמרי, וכבר מהפעם הראשונה שבה ראיתי אותה התקשיתי להאמין לה. ה"קסם" פה הוא שכדי לדעת מה האינטגרל של {::nomarkdown}\( f\){:/nomarkdown} על <strong>כל הקטע</strong> {::nomarkdown}\( \left[a,b\right]\){:/nomarkdown} אנחנו רק צריכים לדעת את הערכים של {::nomarkdown}\( F\){:/nomarkdown} <strong>בקצוות הקטע</strong>. איך זה אפשרי בכלל? האם {::nomarkdown}\( f\){:/nomarkdown} לא יכולה "להשתגע" בתוך הקטע? התשובה היא כמובן שהיא יכולה, אבל זה ישפיע על {::nomarkdown}\( F\){:/nomarkdown}. איכשהו {::nomarkdown}\( F\){:/nomarkdown} "דוחסת" את כל המורכבות של {::nomarkdown}\( f\){:/nomarkdown} אל תוך קצוות הקטע. אחרי קצת מחשבה על הנושא המשפט נראה כמעט מובן מאליו - {::nomarkdown}\( F\left(b\right)\){:/nomarkdown} הוא <strong>בדיוק</strong> סכום כל השינויים שה"שיגועים" של {::nomarkdown}\( f\){:/nomarkdown} בתוך הקטע גרמו ל-{::nomarkdown}\( F\){:/nomarkdown}, החל מהערך ההתחלתי {::nomarkdown}\( F\left(a\right)\){:/nomarkdown} - אבל זה שמבינים למה הקסם עובד לא מפחית מהמגניבות שלו, לטעמי.

למי שעדיין חושבים שהמשפט מגניב, הבשורה הטובה שלי היא שמשפט סטוקס - הדבר המאוד-כללי ומאוד-מאוד-מגניב שאני מבטיח שנגיע אליו כל הזמן - הוא בעצם הכללה אדירה של המשפט היסודי של החדו"א. דוגמה לכך היא במקרה פרטי פשוט במיוחד שלו, <strong>משפט גרין</strong>, שאומר שהאינטגרל הדו-ממדי של פונקציה בקטע שמוגדר על ידי עקום סגור במישור שווה ל<strong>אינטגרל מסלולי</strong> על העקום הזה של משהו שהוא כמו פונקציה קדומה של הפונקציה הדו ממדית. נשמע מעורפל, נכון? כי אני מקדים את זמני ומדבר על הגדרות שעוד לא קיימות כמו "אינטגרל מסלולי". נעזוב את זה לבינתיים.

ה"קסם" שנותן לנו המשפט היסודי של החדו"א לא בא בלי מחיר. בהינתן {::nomarkdown}\( f\){:/nomarkdown}, זה יכול להיות קשה מאוד למצוא לה פונקציה קדומה {::nomarkdown}\( F\){:/nomarkdown}. יש פונקציות תמימות למראה, כמו {::nomarkdown}\( e^{x^{2}}\){:/nomarkdown}, שאין להן פונקציה קדומה שניתנת להצגה בצורה "נחמדה" בכלל. אין אלגוריתם כללי שמאפשר לנו למצוא פונקציה קדומה של פונקציה נתונה (בעוד שעבור נגזרת כן יש אלגוריתם עבור מחלקה רחבה מאוד של פונקציות). יש שלל טריקים מגניבים שמאפשרים להקל על החיפוש, אבל לא אכנס אליהם כרגע.

אם כן, יש לנו פתרון שמבוסס על רדוקציה למקרה החד-ממדי. אני אחזור עוד רגע לשאלה איך עושים את זה, ועם השאלה הזו נסיים את הפוסט, אבל אני כבר רוצה לרמוז אל המקום הבא שאני הולך אליו. הרבה פעמים לפני שמבצעים רדוקציה למקרה החד ממדי אנחנו רוצים להביא את האינטגרל לצורה <strong>פשוטה</strong> יותר, על ידי שינוי של {::nomarkdown}\( f\){:/nomarkdown} לפונקציה שיותר קל לנו לבצע לה אינטגרציה חד-ממדית. התעלול הזה נקרא <strong>החלפת משתנים</strong> (קצת מוקדם מדי להציג דוגמה). המשפט הרלוונטי לעניין מגדיר לנו מה זו "החלפת משתנים" לגיטימית, ואיך האינטגרל הולך להשתנות עקב כך - ההבדל העיקרי הוא שצריך יהיה לכפול את {::nomarkdown}\( f\){:/nomarkdown} ב"תיקון" כלשהו שמחושב מתוך הפונקציה שמבצעת את החלפת המשתנים. התוצאה יוצאת אלגנטית למראה ושימושית בצורה מטורפת; לרוע המזל, <strong>ההוכחה</strong> של המשפט הזה היא אחת מהקשות ביותר שבהן ניתן להיתקל בקורסי המבוא לנושא. אני אקח על עצמי לנסות ולהציג את ההוכחה כאן, ובתקווה לחפף כמה שפחות, אבל זה באמת שייך כבר לפוסט (או סדרת פוסטים) אחר.

בואו נעבור לדוגמה. נניח שאנחנו רוצים לחשב את האינטגרל של {::nomarkdown}\( f\left(x,y\right)=x+y\){:/nomarkdown} על המלבן {::nomarkdown}\( Q=\left[0,1\right]\times\left[0,1\right]\){:/nomarkdown}. חשבו על המלבן הזה כאילו הוא מורכב מאינסוף קווים אופקיים דקים באורך 1 - קו לכל ערך של {::nomarkdown}\( y\){:/nomarkdown} בין 0 ל-1. על כל קו כזה, {::nomarkdown}\( f\left(x,y\right)\){:/nomarkdown} היא פונקציה במשתנה יחיד {::nomarkdown}\( y\){:/nomarkdown}, כאשר {::nomarkdown}\( x\){:/nomarkdown} הוא פרמטר - אינטגרל חד ממדי של הדבר הזה אנחנו בוודאי יודעים לחשב לכל {::nomarkdown}\( x\){:/nomarkdown}: {::nomarkdown}\( \int_{0}^{1}\left(x+y\right)dy=\left[xy+\frac{y^{2}}{2}\right]_{0}^{1}=\frac{1}{2}+x\){:/nomarkdown}. עכשיו, {::nomarkdown}\( f\left(x,y\right)\){:/nomarkdown} מתאר כמה הערך של הפונקציה {::nomarkdown}\( f\){:/nomarkdown} בקואורדינטה {::nomarkdown}\( \left(x,y\right)\){:/nomarkdown} תורם לסכום שהאינטגרל מהווה (כמובן, זה לא שהערך {::nomarkdown}\( f\left(x,y\right)\){:/nomarkdown} מתווסף לסכום כמות שהוא; אינטואיטיבית, הוא מתווסף כשהוא משוקלל על פי ה"גודל" של הנקודה {::nomarkdown}\( \left(x,y\right)\){:/nomarkdown}, שהוא אינפיניטסימלי. זה שאפשר לפרמל את האינטואיציה הזו ומקבלים משהו שעובד, זה מה שמגניב באינטגרל). באופן דומה, האינטואיציה היא ש-{::nomarkdown}\( \frac{1}{2}+x\){:/nomarkdown} כאן מתאר מה <strong>כל הקו</strong> האנכי עם קו רוחב {::nomarkdown}\( x\){:/nomarkdown} תורם לסכום. לכן כדי לדעת מה הסכום הכולל צריך לבצע אינטגרציה על הערכים הללו - להגדיר פונקציה {::nomarkdown}\( I\left(x\right)=\frac{1}{2}+x\){:/nomarkdown} ולחשב את האינטגרל {::nomarkdown}\( \int_{0}^{1}I\left(x\right)dx=\int_{0}^{1}\left(\frac{1}{2}+x\right)=\left[\frac{1}{2}x+\frac{1}{2}x^{2}\right]_{0}^{1}=1\){:/nomarkdown}.

את כל התהליך הזה אפשר לתאר אינטואיטיבית בעזרת המשוואה הבאה:

{::nomarkdown}\( \iint_{Q}\left(x+y\right)dxdy=\int_{0}^{1}\left(\int_{0}^{1}\left(x+y\right)dy\right)dx\){:/nomarkdown}

כלומר, אנחנו מפרקים את האינטגרל הכפול להפעלה כפולה של אינטגרל רגיל. הסימונים נבחרו בקפידה כדי שההפרדה הזו תיראה לנו טבעית ככל הניתן, אבל מן הסתם זו תוצאה לא טריוויאלית שצריך להוכיח. למרבה המזל, ההוכחה היא יחסית ישירה ולא יהיה לנו קושי לראות אותה כאן.

יש נקודה טכנית מעצבנת אחת שחייבים לתת עליה את הדעת לפני שאני מציג את הניסוח הכללי של המשפט, והיא שלפעמים פירוק לא יכול לעבוד בכלל. הנה דוגמה פשוטה: {::nomarkdown}\( f\left(x,y\right)=\begin{cases}1 &amp; x=0\wedge y\in\mathbb{Q}\\0 &amp; \mbox{else}\end{cases}\){:/nomarkdown}. הפונקציה הזו היא 0 כמעט בכל מקום, למעט נקודות מהצורה {::nomarkdown}\( \left(0,r\right)\){:/nomarkdown} כאשר {::nomarkdown}\( r\){:/nomarkdown} הוא מספר רציונלי. אני רוצה להסתכל על האינטגרל שלה על {::nomarkdown}\( \left[0,1\right]\times\left[0,1\right]\){:/nomarkdown}. בבירור הפונקציה אינטגרבילית; כל נקודות אי הרציפות שלה הן על הישר {::nomarkdown}\( \left(0,y\right)\){:/nomarkdown}, ולכן הן ממידה אפס (לקו במישור יש מידה אפס, לא קשה להראות את זה). עם זאת, ה"חתך" {::nomarkdown}\( f_{0}\left(y\right)=f\left(0,y\right)\){:/nomarkdown} שמתקבל מהצבת {::nomarkdown}\( x=0\){:/nomarkdown} הוא פונקציית דיריכלה שהזכרתי קודם, והיא לא אינטגרבילית. אז אני לא יכול לרשום פירוק כמו {::nomarkdown}\( \iint_{Q}f\left(x,y\right)dxdy=\int_{0}^{1}\left(\int_{0}^{1}f\left(x,y\right)dy\right)dx\){:/nomarkdown} מהטעם הפשוט שה-{::nomarkdown}\( \int_{0}^{1}f\left(x,y\right)dy\){:/nomarkdown} שבפנים לא בהכרח מוגדר (הפונקציה {::nomarkdown}\( I\left(x\right)=\int_{0}^{1}f\left(x,y\right)dy\){:/nomarkdown} לא מוגדרת לכל {::nomarkdown}\( x\){:/nomarkdown}).

פתרון אחד הוא לעבור לדבר על אינטגרל לבג שבו דברים מעצבנים כאלו לא קורים, אבל אין בכך צורך, אפשר לתקן את הבעיה על ידי שימוש באינטגרלים ש<strong>כן</strong> מוגדרים תמיד - האינטרלים העליונים והתחתונים. באיזה מהם להשתמש? לא משנה, שניהם יעבדו. אם כן, בואו נעבור לניסוח הגרסה הכללית של המשפט - <strong>משפט פוביני</strong>: אם {::nomarkdown}\( f:Q\to\mathbb{R}\){:/nomarkdown} היא פונקציה אינטגרבילית, ו-{::nomarkdown}\( Q=A\times B\){:/nomarkdown} כך ש-{::nomarkdown}\( A\){:/nomarkdown}קוביה ב-{::nomarkdown}\( \mathbb{R}^{k}\){:/nomarkdown} ו-{::nomarkdown}\( B\){:/nomarkdown} קוביה ב-{::nomarkdown}\( \mathbb{R}^{n}\){:/nomarkdown}, אז נסמן {::nomarkdown}\( f\left(x,y\right)\){:/nomarkdown} בתור הפונקציה {::nomarkdown}\( f\){:/nomarkdown} כאשר חילקנו את המשתנים שלה לשתי קבוצות, ה-{::nomarkdown}\( x\){:/nomarkdown}-ים וה-{::nomarkdown}\( y\){:/nomarkdown}-ים, עבור {::nomarkdown}\( x\in A\){:/nomarkdown} ו-{::nomarkdown}\( y\in B\){:/nomarkdown}. אז

{::nomarkdown}\( \int_{Q}f=\int_{x\in A}\underline{\int_{y\in B}}f\left(x,y\right)=\int_{x\in A}\overline{\int_{y\in B}}f\left(x,y\right)\){:/nomarkdown}

ההוכחה היא לא הרבה יותר מאשר משחק זהיר עם קוביות וסכומים עליונים ותחתונים וכל שאר המושגים שראינו בפוסט - הזדמנות טובה לתרגל אותם.

כדי להקל לעצמנו על החיים, בואו נשתמש בסימון המקוצר {::nomarkdown}\( \underline{I}\left(x\right)=\underline{\int_{y\in B}}f\left(x,y\right)\){:/nomarkdown} ו-{::nomarkdown}\( \overline{I}\left(x\right)=\overline{\int_{y\in B}}f\left(x,y\right)\){:/nomarkdown}. דהיינו, משפט פוביני אומר ש-{::nomarkdown}\( \int_{A\times B}f\left(x,y\right)=\int_{x\in A}\underline{I}\left(x\right)=\int_{x\in A}\overline{I}\left(x\right)\){:/nomarkdown}. שימו לב למה שנאמר כאן באופן מובלע - ש-{::nomarkdown}\( \underline{I}\left(x\right)\){:/nomarkdown} ו-{::nomarkdown}\( \overline{I}\left(x\right)\){:/nomarkdown} הם אינטגרביליים מעל {::nomarkdown}\( A\){:/nomarkdown}. נוכיח את השוויון ואת האינטגרביליות בבת אחת - התעלול יהיה להראות שאפשר לחסום סכומים עליונים ותחתונים של ה-{::nomarkdown}\( I\){:/nomarkdown}-ים בין סכומים עליונים ותחתונים של {::nomarkdown}\( f\){:/nomarkdown}; מכיוון ש-{::nomarkdown}\( f\){:/nomarkdown} אינטגרבילית, הסכומים הללו יכולים להיות קרובים ככל שנרצה, ולכן כך יהיו הסכומים עבור ה-{::nomarkdown}\( I\){:/nomarkdown}-ים.

עכשיו, סכומים עליונים ותחתונים הם תמיד ביחס לחלוקה {::nomarkdown}\( P\){:/nomarkdown} של {::nomarkdown}\( Q\){:/nomarkdown}. חלוקה של קוביה רב-ממדית מורכבת מחלוקות של הצירים, ולכן כל חלוקה {::nomarkdown}\( P\){:/nomarkdown} "מתפרקת" לזוג {::nomarkdown}\( \left(P_{A},P_{B}\right)\){:/nomarkdown} של החלוקות של ההיטלים {::nomarkdown}\( A,B\){:/nomarkdown} של {::nomarkdown}\( Q\){:/nomarkdown}. אם נסמן קוביה כלשהי בחלוקה של {::nomarkdown}\( A\){:/nomarkdown} בתור {::nomarkdown}\( R_{A}\){:/nomarkdown}, ובדומה {::nomarkdown}\( R_{B}\){:/nomarkdown} תהיה קוביה בחלוקה של {::nomarkdown}\( B\){:/nomarkdown}, אז {::nomarkdown}\( R_{A}\times R_{B}\){:/nomarkdown} תהיה קוביה בחלוקה של {::nomarkdown}\( Q\){:/nomarkdown}. מה שאני ארצה להוכיח הוא

{::nomarkdown}\( L\left(f,P\right)\le L\left(\underline{I}\left(x\right),P_{A}\right)\le U\left(\underline{I}\left(x\right),P_{A}\right)\le U\left(f,P\right)\){:/nomarkdown}

ובאופן דומה גם עבור {::nomarkdown}\( \overline{I}\left(x\right)\){:/nomarkdown}. כמובן, אי השוויון האמצעי כבר ידוע לנו. למה אי השוויון הזה מסיים את ההוכחה? כי לכל {::nomarkdown}\( \varepsilon&gt;0\){:/nomarkdown} ניקח {::nomarkdown}\( P\){:/nomarkdown} כך ש-{::nomarkdown}\( \left\|U\left(f,P\right)-L\left(f,P\right)\right\|&lt;\varepsilon\){:/nomarkdown} (קיים כזה {::nomarkdown}\( P\){:/nomarkdown} כי {::nomarkdown}\( f\){:/nomarkdown} אינטגרבילית). מאי השוויונים נקבל {::nomarkdown}\( \left\|U\left(\underline{I}\left(x\right),P_{A}\right)-L\left(\underline{I}\left(x\right),P_{A}\right)\right\|&lt;\varepsilon\){:/nomarkdown} וזה מוכיח ש-{::nomarkdown}\( \sup L\left(\underline{I}\left(x\right),P_{A}\right)=\inf U\left(\underline{I}\left(x\right),P_{A}\right)\){:/nomarkdown}.

אז בואו ננסה להבין למה {::nomarkdown}\( L\left(f,P\right)\le L\left(\underline{I}\left(x\right),P_{A}\right)\){:/nomarkdown}. אם נבין את זה, גם אי השוויון האחר ינבע באותו האופן. בשביל זה נצטרך לרדת רמה אחת נוספת למטה, מרמת הסכום התחתון אל רמת הסכום על קוביה בודדת:

{::nomarkdown}\( L\left(\underline{I}\left(x\right),P_{A}\right)=\sum_{R_{A}}m_{R_{A}}\left(\underline{I}\right)v\left(R_{A}\right)\){:/nomarkdown}

{::nomarkdown}\( L\left(f,P\right)=\sum_{R_{A}\times R_{B}}m_{R_{A}\times R_{B}}\left(f\right)v\left(R_{A}\times R_{B}\right)=\sum_{R_{A}}\sum_{R_{B}}m_{R_{A}\times R_{B}}\left(f\right)v\left(R_{A}\right)v\left(R_{B}\right)\){:/nomarkdown}

לכן אי השוויון שאנחנו רוצים להוכיח הוא בעצם

{::nomarkdown}\( \sum_{R_{A}}\sum_{R_{B}}m_{R_{A}\times R_{B}}\left(f\right)v\left(R_{A}\right)v\left(R_{B}\right)\le\sum_{R_{A}}m_{R_{A}}\left(\underline{I}\right)v\left(R_{A}\right)\){:/nomarkdown}

ואפשר לחלק ב-{::nomarkdown}\( v\left(R_{A}\right)\){:/nomarkdown} ולקבל

{::nomarkdown}\( \sum_{R_{A}}\left[\sum_{R_{B}}m_{R_{A}\times R_{B}}\left(f\right)v\left(R_{B}\right)\right]\le\sum_{R_{A}}m_{R_{A}}\left(\underline{I}\right)\){:/nomarkdown}

מסקנה: מספיק אם נוכיח, עבור {::nomarkdown}\( R_{A}\){:/nomarkdown} כללי, ש-

{::nomarkdown}\( \sum_{R_{B}}m_{R_{A}\times R_{B}}\left(f\right)v\left(R_{B}\right)\le m_{R_{A}}\left(\underline{I}\right)\){:/nomarkdown}

יפה. בואו נתמקד לרגע ב-{::nomarkdown}\( m_{R_{A}\times R_{B}}\left(f\right)\){:/nomarkdown}. זהו האינפימום של ערכי {::nomarkdown}\( f\){:/nomarkdown} על הקוביה {::nomarkdown}\( R_{A}\times R_{B}\){:/nomarkdown}. לכן הוא קטן או שווה <strong>לכל</strong> ערך של {::nomarkdown}\( f\){:/nomarkdown} על הקוביה הזו; בפרט, אם נקפיא את {::nomarkdown}\( x\){:/nomarkdown} לרגע (ונסמן אותו {::nomarkdown}\( x_{0}\in R_{A}\){:/nomarkdown} כדי שיהיה ברור, ועכשיו {::nomarkdown}\( f\left(x_{0},y\right)\){:/nomarkdown} היא הפונקציה של {::nomarkdown}\( y\){:/nomarkdown} שמתקבלת מהצבה ב-{::nomarkdown}\( f\){:/nomarkdown} כאשר {::nomarkdown}\( x_{0}\){:/nomarkdown} "מוקפא"), אנחנו יודעים ש-{::nomarkdown}\( m_{R_{A}\times R_{B}}\left(f\right)\le f\left(x_{0},y\right)\){:/nomarkdown} עבור כל {::nomarkdown}\( y\in R_{B}\){:/nomarkdown}. לכן אם ניקח את האינפימום של אגף ימין, אי השוויון ישתמר: {::nomarkdown}\( m_{R_{A}\times R_{B}}\left(f\right)\le m_{R_{B}}\left(f\left(x_{0},y\right)\right)\){:/nomarkdown}

בהינתן {::nomarkdown}\( x_{0}\){:/nomarkdown} קבוע, אי השוויון הזה נכון <strong>לכל</strong> קוביה {::nomarkdown}\( R_{B}\){:/nomarkdown}. לכן הוא ישתמר גם אם נכפול את שני האגפים ב-{::nomarkdown}\( v\left(R_{B}\right)\){:/nomarkdown} ונסכום על כלל ה-{::nomarkdown}\( R_{B}\){:/nomarkdown}-ים. קיבלנו:

{::nomarkdown}\( \sum_{R_{B}}m_{R_{A}\times R_{B}}\left(f\right)v\left(R_{B}\right)\le\sum_{R_{B}}m_{R_{B}}\left(f\left(x_{0},y\right)\right)v\left(R_{B}\right)=L\left(f\left(x_{0},y\right),P_{B}\right)\le\underline{\int_{y\in B}}f\left(x_{0},y\right)=\underline{I}\left(x_{0}\right)\){:/nomarkdown}

האם סיימנו? כמעט. אגף ימין הוא מה שרצינו לקבל, אבל באגף שמאל צריך להיות {::nomarkdown}\( m_{R_{A}}\left(\underline{I}\right)\){:/nomarkdown}. אבל זה מיידי: ראינו שאגף ימין קטן או שווה מכל ערך של {::nomarkdown}\( \underline{I}\){:/nomarkdown} על {::nomarkdown}\( x\){:/nomarkdown} ב-{::nomarkdown}\( R_{A}\){:/nomarkdown}, ולכן אגף ימין יהיה קטן או שווה לאינפימום - וסיימנו.

כאן גם סיימנו עם ההוכחות הפשוטות. האתגר הבא שלי הוא להוכיח את משפט החלפת המשתנים, מה שידרוש לא מעט הכנה מוקדמת ועבודה טכנית. יהיה כיף.
