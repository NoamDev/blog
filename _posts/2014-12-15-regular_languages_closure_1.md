---
id: 3199
title: "שפות רגולריות - תכונות סגור (חלק א')"
date: 2014-12-15 10:50:58
layout: post
categories: 
  - תורת הסיבוכיות
tags: 
  - אוטומטים
  - שפות רגולריות
---
בפוסטים הקודמים הצגתי כמה מודלים שונים של אוטומט סופי - דטרמיניסטי, לא דטרמיניסטי, ולא דטרמיניסטי עם מסעי {::nomarkdown}\( \varepsilon\){:/nomarkdown}. שלושת המודלים הללו היו <strong>שקולים חישובית</strong> - כל שפה שניתן היה לזהות באחד מהם, היה ניתן לזהות גם באחרים (אולי עם אוטומט יותר מסובך). לקבוצת השפות שאפשר לזהות עם אוטומט כזה קראנו <strong>אוסף השפות הרגולריות</strong> (למעשה, תמיד יש לנו ברקע גם א"ב כלשהו שהשפות מוגדרות מעליו, כך שלדבר על <strong>ה</strong>שפות הרגולריות זה טיפה בעייתי כי יש אוסף שפות רגולריות מעל כל א"ב, אבל עזבו אתכם מהדקויות הללו, לא סתם קוראים לבלוג לא מדויק).

כמובן, חיש קל עולה מאליה השאלה - אילו שפות הן רגולריות? קל לראות שהשפה הריקה {::nomarkdown}\( \emptyset\){:/nomarkdown} היא רגולרית - אוטומט עם מצב יחיד שאינו מקבל. קל גם לראות שאוסף כל המילים מעל {::nomarkdown}\( \Sigma\){:/nomarkdown}, שאותו סימנתי בסימון {::nomarkdown}\( \Sigma^{*}\){:/nomarkdown}, הוא רגולרי - אוטומט עם מצב יחיד שהוא מקבל וכל אות מובילה ממנו לעצמו. טיפה יותר מעניין לבנות אוטומט שמקבל בדיוק מילה אחת - לכל מילה {::nomarkdown}\( w=\sigma_{1}\dots\sigma_{n}\){:/nomarkdown} האוטומט הזה יכלול {::nomarkdown}\( n+1\){:/nomarkdown} מצבים שהאוטומט עובר בהם לפי הסדר כל עוד הוא קורא אותיות שמתאימות למילה {::nomarkdown}\( w\){:/nomarkdown}, ואם מתישהו משהו השתבש או שהוא קיבל יותר מ-{::nomarkdown}\( n\){:/nomarkdown} אותיות, הוא עובר למצב "בור" שאינו מקבל וכל קשת ממנו נכנסת חזרה אליו. נסו בעצמכם לצייר אוטומט כזה עבור מילים ספציפיות ולכתוב אותו פורמלית. זה קל.

מה שאני רוצה לטעון עכשיו הוא שכל שפה סופית היא רגולרית - זה צעד המשך מתבקש למה שכבר אמרתי. גם די ברור איך לבנות אוטומט לכל שפה סופית - בפרט אם מותר לי אי-דטרמיניזם, אני פשוט יכול לחזור על הבניה של האוטומט עבור מילה ספציפית עבור כמה מילים בבת אחת. אבל אני לא רוצה לעשות את זה. למעשה, אני רוצה לבנות כמה שפחות אוטומטים. לבנות אוטומטים זה לא מעניין. זו טרחה. יותר מכך, אם גם אני מרגיש מחוייב משום מה <strong>להוכיח</strong> שאוטומט נתון מקבל את השפה שאני טוען שהוא מקבל - זה כבר ממש קוץ בתחת. ומתמטיקאים הם עצלנים. אז מה שאני רוצה לעשות הוא למצוא דרך אלטרנטיבית לבנות שפות רגולריות חדשות מתוך שפות רגולריות קיימות. כלומר, אני מחפש <strong>פעולות</strong> שניתן להפעיל על שפות קיימות שיוצרות מהן שפות חדשות, באופן כזה שמובטח שאם הקלטים לפעולות הללו היו שפות רגולריות, גם השפה שמתקבלת כפלט היא רגולרית. לפעולות כאלו קוראים <strong>תכונות סגור</strong> (כי פורמלית, אלו הן פונקציות - אולי במספר משתנים - מקבוצות השפות לעצמה, שקבוצת השפות הרגולריות סגורה ביחס אליהן, במשמעות הסטנדרטית של "סגירות" שכזו במתמטיקה).

למעשה, כבר ראינו תכונת סגור בפוסט הקודם - לצורך חימום, הוכחתי שהשפות הרגולריות סגורות תחת חיתוך, על ידי בניית מה שקראתי לו "אוטומט מכפלה". אותה בניה, עם וריאציה חכמה על בחירת המצבים המקבלים, גם יכולה להראות סגירות תחת איחוד, אבל למעשה יש דרך פשוטה בהרבה להראות סגירות לאיחוד: בהינתן שפות רגולריות {::nomarkdown}\( L_{1},L_{2}\){:/nomarkdown} נבנה אוטומט אי-דטרמיניסטי שמקבל את {::nomarkdown}\( L_{1}\cup L_{2}\){:/nomarkdown} באופן הבא: הוא יורכב משני אוטומטים שאחד מהם מקבל את {::nomarkdown}\( L_{1}\){:/nomarkdown} והשני את {::nomarkdown}\( L_{2}\){:/nomarkdown}, ובנוסף מצב התחלתי חדש שכל מה שעושים בו הוא מסע-{::nomarkdown}\( \varepsilon\){:/nomarkdown} לאחד משני המצבים ההתחלתיים של האוטומטים הללו. כלומר, הדבר הראשון שהאוטומט עושה הוא להחליט אי-דטרמיניסטית אם בא לו היום לבדוק אם הקלט שלו שייך ל-{::nomarkdown}\( L_{1}\){:/nomarkdown} או אם הוא שייך ל-{::nomarkdown}\( L_{2}\){:/nomarkdown}, ואז הוא רץ בהתאם.

אם חושבים על זה עוד קצת, רואים שבעצם יש כאן רעיון כללי - אפשר לבנות <strong>אוטומט עם כמה מצבים התחלתיים</strong> במקום להסתפק בדרישה השרירותית שלי למצב התחלתי יחיד. בהינתן אוטומט עם כמה מצבים התחלתיים, תמיד אפשר להמיר אותו בכזה עם מצב התחלתי יחיד שיש ממנו מסעי-{::nomarkdown}\( \varepsilon\){:/nomarkdown} לכל המצבים ההתחלתיים של האוטומט המקורי. אם כן, הבניה של האיחוד היא בעצם "בנה אוטומט חדש שכולל את שני האוטומטים עבור השפות, וקבוצת המצבים ההתחלתיים שלו היא קבוצת המצבים ההתחלתיים של שני האוטומטים". הבניה הכי קלה בעולם, בערך (מרגע שיש לנו את השקילות הלא טריוויאלית של המודלים השונים לאוטומט).

עוד פעולת סגור קלילה היא משלים - קחו רגע כדי לשכנע את עצמכם שהאוטומט עבור משלים של שפה (המשלים של {::nomarkdown}\( L\){:/nomarkdown}, שאסמן {::nomarkdown}\( \overline{L}\){:/nomarkdown}, הוא כל המילים ב-{::nomarkdown}\( \Sigma^{*}\){:/nomarkdown} שאינן ב-{::nomarkdown}\( L\){:/nomarkdown}) הוא פשוט האוטומט של השפה, בהיפוך של המצבים המקבלים (מי שהיה מקבל הופך ללא-מקבל, ומי שקודם לא היה מקבל הופך למקבל); <strong>אבל</strong>, רק בתנאי שהאוטומט הזה הוא אוטומט סופי דטרמיניסטי.

נקודה שנוטה לבלבל אנשים היא שאם ניקח אוטומט אי דטרמיניסטי ונהפוך את המצבים המקבלים שלו, הרבה דברים שונים ומשונים עלולים לקרות - ייתכן שנקבל את אותה שפה בדיוק כמו קודם; ייתכן שפתאום נקבל כל מילה אפשרית; וייתכנו עוד דברים. למה זה קורה? ובכן, זכרו שאוטומט אי דטרמיניסטי מקבל מילה אם <strong>קיים</strong> מסלול שבו האוטומט מגיע על המילה למצב מקבל. אבל בהחלט ייתכן שעל אותה מילה יש לו גם מסלול אחר שמגיע למצב <strong>לא מקבל</strong>. לכן, אחרי שנהפוך את קבוצת המצבים המקבלים של האוטומט המסלול הזה יהפוך למסלול שמגיע למצב מקבל, ולכן גם באוטומט החדש יהיה קיים מסלול מקבל על אותה מילה, והמילה תתקבל גם בו.

כעת, הראינו סגירות לאיחוד וחיתוך רק עבור זוגות של שפות, אבל באינדוקציה קל להראות שיש סגירות לחיתוך ואיחוד של כל <strong>מספר סופי</strong> של שפות. מכאן אנחנו מקבלים מייד את הטענה על כך שכל שפה סופית היא רגולרית - היא איחוד של מספר סופי של סינגלטונים, וראינו שסינגלטון הוא שפה רגולרית. עם זאת, הדרישה על הסופיות כאן היא קריטית - אפשר לבנות את השפה {::nomarkdown}\( \left\{ a^{n}b^{n}\ \|\ n\in\mathbb{N}\right\} \){:/nomarkdown} בתור איחוד אינסופי של סינגלטונים, וכבר ראינו שזו לא שפה רגולרית. אם כן, אין לנו סגירות לאיחוד אינסופי. מכך נובע גם שאין סגירות לחיתוך אינסופי, שכן אפשר להציג איחוד באמצעות חיתוך ומשלים - זה מה שמכונה "כלל דה-מורגן" (אחד משניהם, יש שניים שדואליים זה לזה): {::nomarkdown}\( \bigcup L_{n}=\overline{\bigcap\overline{L_{n}}}\){:/nomarkdown}. אם חיתוך אינסופי היה פעולת סגור, אז מכיוון שבאגף ימין מתרחשות רק פעולות סגור, היינו מקבלים שגם אגף שמאל הוא תכונת סגור, וכרגע הסברתי למה הוא לא.

עד עכשיו השתעשענו עם תכונות סגור שהן פעולות "רגילות" על קבוצות. אבל שפה היא לא סתם קבוצה - היא קבוצה של מילים, ועל מילים אפשר לעשות פעולות מגניבות שלא דיברתי עליהן עד עכשיו. הפעולה הבסיסית שאפשר לבצע על מילים היא <strong>לשרשר</strong> שתי מילים - לחבר אותן זו לזו כדי ליצור מילה חדשה. אם {::nomarkdown}\( u=\sigma_{1}\dots\sigma_{n}\){:/nomarkdown} ו-{::nomarkdown}\( v=\tau_{1}\dots\tau_{k}\){:/nomarkdown} הן שתי מילים כלשהן, אז השרשור שלהן הוא {::nomarkdown}\( u\cdot v=\sigma_{1}\dots\sigma_{n}\tau_{1}\dots\tau_{k}\){:/nomarkdown}. לרוב אני אשמיט את הנקודה, כפי שעושים לעתים קרובות עם סימונים דמויי כפל שכאלו.

השימוש הזה ב"מילים" וב"כפל" עשוי להישמע מוכר לחלק מהקוראים - זו טרמינולוגיה שנפוצה גם ב<strong>תורת החבורות</strong>. ואכן, לרגע נראה ש-{::nomarkdown}\( \Sigma^{*}\){:/nomarkdown} היא חבורה ביחס לפעולת השרשור הזו. זו פעולה בינארית, אסוציאטיבית, ואפילו עם איבר יחידה נייטרלי (המילה הריקה {::nomarkdown}\( \varepsilon\){:/nomarkdown}, כמובן). רק מה, אין לנו "הופכי". אם {::nomarkdown}\( u\){:/nomarkdown} היא מילה לא ריקה, אז לא קיימת מילה {::nomarkdown}\( v\){:/nomarkdown} כך ש-{::nomarkdown}\( uv=\varepsilon\){:/nomarkdown}. זה כאילו ש-{::nomarkdown}\( \Sigma^{*}\){:/nomarkdown} היא המספרים השלמים, בלי האפשרות לכפול בהופכי של מספר ("לחלק"). עדיין, גם מבנה אלגברי שהוא כמעט-כמו-חבורה-רק-בלי-הופכי הוא מעניין ונקרא <strong>מונואיד</strong>. לא חייבים להיות בקיאים במונואידים כדי להבין את מה שאעשה בהמשך, אבל נחמד לדעת שהמושג קיים.

כעת, שרשור היא פעולה על מילים, לא על שפות, אבל נובעת ממנה די בקלות פעולה על שפות: {::nomarkdown}\( L_{1}\cdot L_{2}=\left\{ uv\ \|\ u\in L_{1},v\in L_{2}\right\} \){:/nomarkdown}. דהיינו, לוקחים את כל הזוגות של מילה מפה ומילה משם, ומשרשרים. תשוו את זה עם הגדרה סטנדרטית מאלגברה לינארית וכדומה - {::nomarkdown}\( V+U=\left\{ v+u\ \|\ v\in V,u\in U\right\} \){:/nomarkdown}.

כמובן, לגמרי לא יפתיע אתכם לגלות ששרשור הוא תכונת סגור של שפות רגולריות. האינטואיציה כאן פשוטה - לוקחים אוטומטים עבור שתי השפות, ומכל מצב מקבל באוטומט אחד מוסיפים מעבר-{::nomarkdown}\( \varepsilon\){:/nomarkdown} למצב ההתחלתי של האוטומט השני. למה זה עובד? ובכן, האוטומט קורא מילה {::nomarkdown}\( w\){:/nomarkdown}. הוא אמור לקבל אותה רק אם קיימים {::nomarkdown}\( u,v\){:/nomarkdown} כך ש-{::nomarkdown}\( w=uv\){:/nomarkdown} וכמו כן {::nomarkdown}\( u\in L_{1}\){:/nomarkdown} ו-{::nomarkdown}\( v\in L_{2}\){:/nomarkdown}. אז בהתחלה האוטומט רץ על {::nomarkdown}\( w\){:/nomarkdown} עם האוטומט של {::nomarkdown}\( L_{1}\){:/nomarkdown}. בכל פעם שבה הוא מגיע למצב מקבל, הוא אומר לעצמו - אה, אולי זה עתה סיימתי לקרוא את ה-{::nomarkdown}\( u\){:/nomarkdown} שלי ועכשיו צריך להתחיל לקרוא את ה-{::nomarkdown}\( v\){:/nomarkdown}? אם התשובה שלו לעצמו על כך היא חיובית, הוא יתחיל לרוץ מעכשיו כמו האוטומט של {::nomarkdown}\( L_{2}\){:/nomarkdown}. מכיוון שאנחנו באוטומט אי דטרמיניסטי פה זה לא חשוב שאולי הניחוש שלו היה לא נכון - אם קיים פירוק נכון, יהיה ניחוש שבו האוטומט בוחר בו, ומגלה שהמילה אכן שייכת לשרשור השפות, ולכן מקבל. כמקודם, אני משאיר לכם לטפל בפרטים אם אתם רוצים תרגול.

סגירות לשרשור חוסכת לנו עוד קצת עבודה - כדי להגיד שכל השפות הסופיות הן רגולריות, מספיק להיווכח בכך שהשפה הריקה רגולרית, שהשפה שמכילה רק את המילה הריקה היא רגולרית, ושכל שפה עם מילה אחת שהיא אות בודדת היא רגולרית. עכשיו אפשר לקבל כל שפה עם מילה מאורך כלשהו בעזרת שרשור של שפות של אותיות בודדות (איך?) ואז להשתמש באיחוד כדי להגיע לכל שפה סופית.

אוקיי, אבל יש המון שפות רגולריות שאינן סופיות. האם אני יכול להגיע אליהן באמצעות מה שדיברתי עליו כרגע, דהיינו השפה הריקה, השפה שכוללת את המילה הריקה, כל השפות שכוללות אות יחידה, פעולת האיחוד ופעולת השרשור? ובכן, לא. די בבירור (הוכחה באינדוקציה!) אני יכול להגיע <strong>רק</strong> לשפות הסופיות. אפשר לומר זאת כך: הקבוצה הנוצרת מהבסיס של השפות שהזכרתי ומפעולות היצירה של איחוד ושרשור היא בדיוק אוסף השפות הסופיות. אם כן, אני צריך להרחיב את הבסיס או את פעולות היצירה שלי אם אני רוצה להגיע לכל השפות הרגולריות. למי מכם שמכיר, הסיטואציה הזו דומה לאקסיומות צרמלו-פרנקל של תורת הקבוצות - מתחילים עם אקסיומה על קיום הקבוצה הריקה, ועל כך שאפשר לבנות קבוצה שמכילה זוג קבוצות נתונות, ואקסיומה על איחוד, וכו'; אבל כל אלו לא מספיקות כדי להוכיח שקיימת קבוצה אינסופית וצריך להוסיף אקסיומה מפורשת עבור כך.

אפשרי ומתבקש לומר שנוסיף את {::nomarkdown}\( \Sigma^{*}\){:/nomarkdown} לבסיס ואת פעולת המשלים לתכונות הסגור - הרי כבר ראינו שהשפה הזו היא רגולרית ושמשלים היא תכונת סגור (למעשה, אין צורך להוסיף את {::nomarkdown}\( \Sigma^{*}\){:/nomarkdown} במפורש, הרי היא מתקבלת מהשפה הריקה על ידי משלים). רק מה, זה לא יהיה מספיק. לא קשה להוכיח שאחרי שנעשה את זה, נקבל שאנחנו יודעים ליצור את כל השפות שהן או סופיות או <strong>קו-סופיות</strong>, כלומר המשלימה שלהן סופית. יש עוד המון שפות רגולריות אחרות (למשל, שפת כל המילים מאורך זוגי). אז לא, תשכחו ממשלים. אנחנו צריכים להוסיף פעולת סגור אחרת, חזקה יותר, שמאפשרת לנו ליצור שפות אינסופיות "מעניינות".

מה הפעולה הנוספת שלנו תהיה? זו אולי השאלה המעניינת ביותר מבין השאלות הבסיסיות שצצות כשמתעסקים בשפות רגולריות, ולכן די עצוב לי שהיא "מספויילרת" בקורסים בנושא שמציגים את הפעולה הזו הרבה לפני שמבינים עד כמה היא מגניבה. אני בעצם אומר שאני מסוגל לתת פעולה אחת נוספת שביחד עם אלו שכבר תיארתי תאפשר לנו לקבל <strong>בדיוק את כל</strong> השפות הרגולריות - לא יותר מדי (כלומר, זו תהיה תכונת סגור, כמובן) ולא פחות מדי. תחשבו עכשיו שאתם החוקרים הראשונים בג'ונגל הזה של תורת השפות הפורמליות - מאיפה בכלל תתחילו לחפש כזו פעולה? (למעשה, בעצם כבר ספיילרתי די הרבה - אמרתי ש<strong>קיימת</strong> פעולה כזו אז אתם בכלל יודעים שיש טעם לחפש; חוקרי הג'ונגל המקוריים לא ידעו).

בואו ננסה להבין רגע מה קורה בשפה הרגולרית הטיפוסית. את השפות הסופיות הבנו, אז בואו ניקח שפה רגולרית אינסופית. יש אוטומט סופי דטרמיניסטי {::nomarkdown}\( A\){:/nomarkdown} שמקבל אותה. ננקוט בתעלול דומה לזה שבו השתמשתי כדי להוכיח ש-{::nomarkdown}\( \left\{ a^{n}b^{n}\ \|\ n\in\mathbb{N}\right\} \){:/nomarkdown} אינה רגולרית: נסמן ב-{::nomarkdown}\( n\){:/nomarkdown} את מספר המצבים של {::nomarkdown}\( A\){:/nomarkdown}, ועכשיו נשאל את עצמנו איך {::nomarkdown}\( A\){:/nomarkdown} רץ על מילה {::nomarkdown}\( z\){:/nomarkdown} שאורכה הוא לפחות {::nomarkdown}\( n\){:/nomarkdown}. מכיוון שעל מילה באורך לפחות {::nomarkdown}\( n\){:/nomarkdown} האוטומט {::nomarkdown}\( A\){:/nomarkdown} יראה בריצה שלו לפחות {::nomarkdown}\( n+1\){:/nomarkdown} מצבים, יהיה מצב {::nomarkdown}\( q\){:/nomarkdown} שבו הוא מבקר פעמיים. לכן אפשר לפרק את {::nomarkdown}\( z\){:/nomarkdown} לשלושה חלקים: {::nomarkdown}\( z=uvw\){:/nomarkdown}, כאשר {::nomarkdown}\( u\){:/nomarkdown} הוא המילה שנקראת <strong>עד</strong> שמגיעים ל-{::nomarkdown}\( q\){:/nomarkdown}; {::nomarkdown}\( v\){:/nomarkdown} הוא המילה שנקראת כשהולכים מ-{::nomarkdown}\( q\){:/nomarkdown} אל עצמו, ו-{::nomarkdown}\( w\){:/nomarkdown} היא המילה שנקראת מ-{::nomarkdown}\( q\){:/nomarkdown} בדרך אל מצב מקבל כלשהו.

האבחנה המרכזית כעת היא שגם אם נוותר על {::nomarkdown}\( v\){:/nomarkdown} נקבל מילה שבשפה - {::nomarkdown}\( uw\){:/nomarkdown}. החישוב עליה הוא פשוט - לך מהמצב ההתחלתי עד {::nomarkdown}\( q\){:/nomarkdown}, ואז לך מ-{::nomarkdown}\( q\){:/nomarkdown} אל מצב מקבל. אבל שימו לב, גם {::nomarkdown}\( uvvw\){:/nomarkdown} בשפה - החישוב עליה הוא "לך מהמצב ההתחלתי עד {::nomarkdown}\( q\){:/nomarkdown}, תחזור פעם אחת ל-{::nomarkdown}\( q\){:/nomarkdown}, תחזור עוד פעם ל-{::nomarkdown}\( q\){:/nomarkdown}, ואז לך מ-{::nomarkdown}\( q\){:/nomarkdown} אל מצב מקבל". וגם {::nomarkdown}\( uvvvw\){:/nomarkdown} בשפה, וכן הלאה.

די ברור שאנחנו צריכים קיצור כלשהו כאן - במקום לכתוב {::nomarkdown}\( vvvvv\){:/nomarkdown} יותר הגיוני לכתוב {::nomarkdown}\( v^{4}\){:/nomarkdown}. נוח גם להגדיר {::nomarkdown}\( v^{0}=\varepsilon\){:/nomarkdown}, ואז את הטענה שלי למעלה ניתן לסכם כך: {::nomarkdown}\( uv^{k}w\){:/nomarkdown} שייכת לשפה לכל {::nomarkdown}\( k\ge0\){:/nomarkdown}.

אם כן, הנה רעיון לפעולה שאנחנו מחפשים: העלאה בחזקה. אבל "סתם" העלאה בחזקה כבר מכוסה על ידי שרשור; מה שאנחנו רוצים הוא פעולה שמחזירה קבוצה של <strong>כל</strong> החזקות של מילה נתונה. האם זה יהיה מספיק טוב?

ובכן, לא. וכדי לראות את זה, בואו ניקח שפה מעל {::nomarkdown}\( \Sigma=\left\{ a,b\right\} \){:/nomarkdown} שכוללת את כל המילים מאורך זוגי. האם אפשר לבנות אותה על ידי אברי הבסיס והפעולות שלנו?

אפשר להתחיל מהשפה {::nomarkdown}\( \left\{ a\right\} \){:/nomarkdown}, לשרשר אותה לעצמה ולקבל את השפה {::nomarkdown}\( \left\{ aa\right\} \){:/nomarkdown}, לאחד עם {::nomarkdown}\( \left\{ bb\right\} \){:/nomarkdown} שנבנית באופן דומה ועם {::nomarkdown}\( \left\{ \varepsilon\right\} \){:/nomarkdown} ולקבל {::nomarkdown}\( \left\{ aa,bb,\varepsilon\right\} \){:/nomarkdown}. זו התחלה טובה, אבל זה עדיין לא מכסה את כל המילים מאורך 2 שאמורות להיות בשפה - עם עוד קצת עבודה אפשר לקבל את {::nomarkdown}\( \left\{ aa,bb,ab,ba,\varepsilon\right\} \){:/nomarkdown}, וזה אכן מכסה לנו את כל המילים עד וכולל אורך 2. עכשיו, אם אני אפעיל על השפה הזו את הפעולה "החזר את השפה שכוללת את כל החזקות של המילים בשפת הקלט", אני אקבל שפה נאה למדי - היא תהיה אינסופית, ויהיה בה למשל את {::nomarkdown}\( \left(aa\right)^{k}\){:/nomarkdown} לכל {::nomarkdown}\( k\){:/nomarkdown}, וגם מילים כמו {::nomarkdown}\( abababab\){:/nomarkdown}. הבעיה היא שזה לא מספיק. מי חסר? למשל, המילה {::nomarkdown}\( abba\){:/nomarkdown}. היא לא מתקבלת בתור חזקה של אף אחת מהמילים {::nomarkdown}\( aa,bb,ab,ba\){:/nomarkdown}.

האינטואיציה היא ש-{::nomarkdown}\( abba\){:/nomarkdown} מתקבלת משרשור של שתי מילים - {::nomarkdown}\( ab\){:/nomarkdown} ו-{::nomarkdown}\( ba\){:/nomarkdown}. אם נסתכל על האוטומט הפשוט ביותר עבור השפה של כל המילים מאורך זוגי, נראה ששתי המילים הללו מעבירות אותנו מהמצב ההתחלתי חזרה לעצמו - לולאה. אם כן, מה שפספסתי קודם עם הדוגמה שלי הוא שלפעמים אפשר להגיע מ-{::nomarkdown}\( q\){:/nomarkdown} אל עצמו <strong>עם כמה מילים שונות</strong>. מה שאני רוצה הוא לא סתם חזקה של אותה מילה, אלא "כל השרשורים של מילים שמעבירות את {::nomarkdown}\( q\){:/nomarkdown} לעצמו".

זה מוביל אותנו להגדרת חזקה של שפה, שמוגדרת באופן המתבקש: {::nomarkdown}\( L^{0}=\left\{ \varepsilon\right\} \){:/nomarkdown} ו-{::nomarkdown}\( L^{k}=L\cdot L^{k-1}\){:/nomarkdown}. כלומר, החזקה ה-{::nomarkdown}\( k\){:/nomarkdown} של {::nomarkdown}\( L\){:/nomarkdown} היא כל המילים שמתקבלות משרשור של {::nomarkdown}\( k\){:/nomarkdown} מילים מתוך {::nomarkdown}\( L\){:/nomarkdown}. עכשיו, הפעולה שאני מעוניין בה היא כזו שלוקחת את כל החזקות של השפה "בבת אחת":

{::nomarkdown}\( L^{*}=\bigcup_{k=0}^{\infty}L^{k}\){:/nomarkdown}

הפעולה הזאת נקראת "איטרציה" או "סגור קלייני" או "כוכב קלייני" וכדומה. אני קורא לה לרוב סגור קלייני. זו הפעולה שחיפשנו: הטענה שלי היא שאפשר לבנות את <strong>כל השפות הרגולריות</strong> מתוך {::nomarkdown}\( \emptyset,\left\{ \varepsilon\right\} \){:/nomarkdown}, כל הסינגלטונים של אותיות ב-{::nomarkdown}\( \Sigma\){:/nomarkdown} ופעולות האיחוד, השרשור וסגור קלייני. זו טענה כבדה שדורשת הוכחה, וההוכחה היא מבריקה ויפהפיה ולא קלה בכלל, ולכן אחכה איתה להמשך.

לבינתיים, אנחנו רוצים להבין למה סגור קלייני היא בכלל תכונת סגור. דהיינו, למה אם {::nomarkdown}\( L\){:/nomarkdown} היא רגולרית כך גם {::nomarkdown}\( L^{*}\){:/nomarkdown}. הרי {::nomarkdown}\( L^{*}\){:/nomarkdown} מוגדרת בעזרת איחוד אינסופי ואמרנו שאיחוד אינסופי הוא לא תכונות סגור, לא? ובכן נכון; איחוד אינסופי <strong>כללי</strong> הוא לא תכונת סגור, אבל כאן עושים איחוד אינסופי על קבוצות מאוד ספציפיות - החזקות של {::nomarkdown}\( L\){:/nomarkdown}.

בואו נחשוב על איך יתנהג אוטומט שמקבל את {::nomarkdown}\( L^{*}\){:/nomarkdown}. הוא מן הסתם יהיה מבוסס על אוטומט {::nomarkdown}\( A\){:/nomarkdown} שמקבל את {::nomarkdown}\( L\){:/nomarkdown}, ויהיה בו רעיון דומה לזה שהיה באוטומט עבור שרשור שפות: מסמלצים את {::nomarkdown}\( A\){:/nomarkdown} ובכל פעם שבה מגיעים למצב מקבל, אפשר "לנחש" שסיימנו לקרוא מילה אחת וצריך להתחיל את ריצת {::nomarkdown}\( A\){:/nomarkdown} מהתחלה - כלומר, לבצע מסע-{::nomarkdown}\( \varepsilon\){:/nomarkdown} למצב ההתחלתי של {::nomarkdown}\( A\){:/nomarkdown}. זה <strong>כמעט</strong> עובד, למעט נקודה מעצבנת אחת: שימו לב לכך ש-{::nomarkdown}\( \varepsilon\in L^{*}\){:/nomarkdown} תמיד, מכיוון ש-{::nomarkdown}\( L^{0}=\left\{ \varepsilon\right\} \){:/nomarkdown} נכלל באיחוד. בפתרון שהצעתי זה עתה, אם המצב ההתחלתי של {::nomarkdown}\( A\){:/nomarkdown} הוא לא מקבל, אז {::nomarkdown}\( \varepsilon\){:/nomarkdown} לא תתקבל (למה?).

אפשר כמובן להגיד - אוקיי, אז בואו נעשה מעבר-{::nomarkdown}\( \varepsilon\){:/nomarkdown} מהמצב ההתחלתי של {::nomarkdown}\( A\){:/nomarkdown} למצב מקבל שאי אפשר לצאת ממנו. כלומר, בתחילת הריצה שלו האוטומט יחליט אם בא לו להמר שהקלט שלו ריק ולקבל אותו ישר, או להתחיל חישוב ישיר. אבל גם זה ייכשל. למה? כי במהלך הריצה שלו {::nomarkdown}\( A\){:/nomarkdown} עשוי להגיע חזרה אל המצב ההתחלתי באופן תמים תוך כדי קריאת מילה למרות שאותה מילה לא בשפה (ולא על ידי הגעה למצב מקבל ואז מעבר-{::nomarkdown}\( \varepsilon\){:/nomarkdown} למצב ההתחלתי). בעצם, אין הבדל בין הפתרון שהצעתי כרגע ובין להפוך את {::nomarkdown}\( q_{0}\){:/nomarkdown} למצב מקבל.

אז מה עושים? אפשר, כמובן, לומר שזה לא באמת חשוב - שמספיק להוכיח ש-{::nomarkdown}\( \bigcup_{k=1}^{\infty}L^{k}\){:/nomarkdown} רגולרית כי אחר כך אפשר לאחד אותה עם {::nomarkdown}\( \left\{ \varepsilon\right\} \){:/nomarkdown} הרגולרית. אבל זה תרגיל סביר בבניית אוטומטים לבנות אוטומט שיודע לקבל את {::nomarkdown}\( L^{*}\){:/nomarkdown} ישירות. הפתרון טיפה מסורבל אבל לא כזה נורא כשברור מה הוא בא להשיג. אנחנו פשוט מוסיפים מצב התחלתי חדש ומצב מקבל חדש (ומבטלים את שאר המצבים המקבלים). מהמצב ההתחלתי אפשר לעבור במסע-{::nomarkdown}\( \varepsilon\){:/nomarkdown} ישירות למצב המקבל, או למצב ההתחלתי של {::nomarkdown}\( A\){:/nomarkdown}; ומכל מצב מקבל של {::nomarkdown}\( A\){:/nomarkdown} אפשר לעבור למצב המקבל "האמיתי" או לחזור למצב ההתחלתי של {::nomarkdown}\( A\){:/nomarkdown}, שוב באמצעות מסע-{::nomarkdown}\( \varepsilon\){:/nomarkdown}. נסו לצייר את זה לעצמכם ולהשתכנע שזה יעבוד.

בפוסט הבא - עוד תכונות סגור! אפילו יותר מופרעות!
