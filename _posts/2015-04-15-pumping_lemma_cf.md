---
id: 3235
title: "שפות חסרות הקשר - למת הניפוח, הלמה של אוגדן ושפות רב משמעיות"
date: 2015-04-15 14:19:09
layout: post
categories: 
  - תורת הסיבוכיות
tags: 
  - הלמה של אוגדן
  - למת הניפוח לשפות חסרות הקשר
  - שפות פורמליות
  - שפות רב משמעיות
---
אני ממשיך לדבר על תכונות שונות ומשונות של שפות חסרות הקשר, וממשיך עם האנלוגיה לשפות רגולריות. אחד מהדברים שעשינו בשפות רגולריות היה להוכיח משהו שנקרא "<a href="http://www.gadial.net/2015/02/03/pumping_lemma_regular_languages/">למת הניפוח</a>", שהצביע על סוג של תבניתיות שכל שפה רגולרית חייבת לקיים. משהו מאוד דומה קיים גם עבור שפות חסרות הקשר, אבל כרגיל עם שפות חסרות הקשר, זה קצת יותר מסובך. אני אראה את המשהו המאוד דומה. ואז אני אכליל אותו עוד קצת. ואז אני אשתמש בהכללה כדי להראות משהו שנראה בלתי קשור בעליל. בלמת הניפוח לשפות רגולריות השתמשנו כדי להוכיח ששפות <strong>אינן</strong> רגולריות, ובאופן דומה אפשר להשתמש בלמת הניפוח לשפות חסרות הקשר כדי להוכיח ששפות אינן חסרות הקשר; אבל אני אוכיח גם משהו שונה לחלוטין - ששפה חסרת הקשר מסויימת היא <strong>רב-משמעית טבועה</strong>, דהיינו שכל דקדוק עבור השפה בהכרח יהיה רב משמעי (אזכיר את כל ההגדרות בהמשך). זה שימוש יפה שאני מאוד מחבב כי על פניו בכלל לא ברור מה הקשר.

.נתחיל עם להיזכר מה הלך בשפות רגולריות. שם, בהינתן שפה רגולרית {::nomarkdown}\( L\){:/nomarkdown}, הוכחנו שקיים {::nomarkdown}\( n\){:/nomarkdown} טבעי כך שלכל מילה {::nomarkdown}\( z\in L\){:/nomarkdown} המקיימת {::nomarkdown}\( \left\|z\right\|\ge n\){:/nomarkdown} קיים פירוק {::nomarkdown}\( z=uvw\){:/nomarkdown} כך ש-{::nomarkdown}\( \left\|uv\right\|\le n\){:/nomarkdown} ו-{::nomarkdown}\( \left\|v\right\|\ge1\){:/nomarkdown} ו-{::nomarkdown}\( uv^{i}w\in L\){:/nomarkdown} לכל {::nomarkdown}\( i\ge0\){:/nomarkdown}. הרעיון מאחורי ההוכחה היה פשוט ויפה - ניקח אוטומט עבור השפה, ונריץ אותו על מילה ארוכה מספיק - מתישהו בהכרח תהיה בריצה "לולאה" (מצב כלשהו שהופיע פעמיים), ואז נוכל לקחת את תת-המילה שהאוטומט קרא על הלולאה ולהעלים אותה או לחזור עליה כמה פעמים שנרצה, ועדיין נקבל את המילה.

הרעיון של למת הניפוח לשפות חסרות הקשר הוא <strong>בדיוק אותו דבר</strong>, אבל בהקשר קצת שונה - לא של אוטומט (אמנם הצגתי אוטומט מחסנית עבור שפות חסרות הקשר, אבל אני לא אשתמש בו כאן), אלא של דקדוק חסר הקשר. מה שארצה לומר הוא שאם דקדוק חסר הקשר מייצר מילה שהיא ארוכה מספיק, אז בעץ הגזירה של המילה יהיה חייב להיות מסלול ארוך מאוד - כל כך ארוך, עד שמשתנה כלשהו של הדקדוק יופיע בו פעמיים. כלומר, יהיה משתנה שגוזר "את עצמו ועוד קצת". ואז נוכל לוותר על הגזירה הזו או לחזור עליה כמה פעמים שנרצה, ובכך להשיג אפקט ניפוח שדומה לזה של הלמה עבור שפות פורמליות, אבל הניסוח המדוייק שלו קצת יותר מסובך. בואו ניתן את הניסוח הזה:

אם {::nomarkdown}\( L\){:/nomarkdown} היא שפה חסרת הקשר אז קיים {::nomarkdown}\( n\){:/nomarkdown} טבעי כך שלכל מילה {::nomarkdown}\( z\in L\){:/nomarkdown} קיים פירוק {::nomarkdown}\( z=uvwxy\){:/nomarkdown} כך ש-{::nomarkdown}\( \left\|vwx\right\|\le n\){:/nomarkdown} ו-{::nomarkdown}\( \left\|vx\right\|\ge1\){:/nomarkdown} ו-{::nomarkdown}\( uv^{i}wx^{i}y\in L\){:/nomarkdown} לכל {::nomarkdown}\( i\ge0\){:/nomarkdown}.

במבט ראשון זה קצת מפחיד - יש פה פתאום פירוק לחמישה חלקים במקום שלושה, והניפוח הוא של שני חלקים בו זמנית, וכל העסק נראה מוזר - אבל אחרי שנראה את ההוכחה נבין למה זה טבעי ופשוט למדי. בינתיים, תרגיל פשוט כדי לידד אתכם עם הניסוח החדש - תוכיחו שאם שפה מקיימת את למת הניפוח לשפות רגולריות, אז היא מקיימת את למת הניפוח לשפות חסרות הקשר ("מקיימת את למת הניפוח" פירושו, "מקיימת את החלק של ה"אז קיים", בלי להתחייב על ה"אם").

כדי להוכיח את הלמה אני צריך לקחת דקדוק עבור {::nomarkdown}\( L\){:/nomarkdown}, אבל כדי שהחיים יהיו קלים אני לא לוקח סתם דקדוק, אלא דקדוק שנמצא ב<strong>צורה נורמלית</strong> פשוטה מאוד - הצורה הנורמלית של חומסקי. דקדוק בצורה הזו כולל רק שני סוגים של כללי גזירה: {::nomarkdown}\( A\to a\){:/nomarkdown} או {::nomarkdown}\( A\to BC\){:/nomarkdown}. כלומר, משתנה יכול או לגזור אות אחת, או להתפצל לשני משתנים. שימו לב שדקדוק בצורה הנורמלית הזו לא יכול לגזור את {::nomarkdown}\( \varepsilon\){:/nomarkdown} כך שאני מניח לכאורה ש-{::nomarkdown}\( L\){:/nomarkdown} לא כוללת את {::nomarkdown}\( \varepsilon\){:/nomarkdown}, אבל זה לא ממש משנה - אם {::nomarkdown}\( L\){:/nomarkdown} כוללת את {::nomarkdown}\( \varepsilon\){:/nomarkdown} אני אוכיח את למת הניפוח על {::nomarkdown}\( L\backslash\left\{ \varepsilon\right\} \){:/nomarkdown} והמסקנה שאקבל תהיה תקפה גם עבור {::nomarkdown}\( L\){:/nomarkdown} באותה מידה (כי אני אקח {::nomarkdown}\( n\ge1\){:/nomarkdown} ולכן {::nomarkdown}\( \varepsilon\){:/nomarkdown} ממילא לא רלוונטית).

כמובן, צריך להסביר למה לכל שפה חסרת הקשר בלי {::nomarkdown}\( \varepsilon\){:/nomarkdown} יש דקדוק מהצורה הנורמלית של חומסקי. אני אקדיש לזה בדיוק פסקה אחת, ואתם <strong>לא חייבים להבין </strong>אותה ואם אתם מסתבכים פשוט תדלגו הלאה. האינטואיציה לא קשה - כל גזירה שמערבת גם משתנים וגם טרמינלים אפשר להחליף בגזירה שיש בה רק משתנים על ידי הוספת משתני עזר. למשל, אם יש לי את הגזירה {::nomarkdown}\( A\to BaC\){:/nomarkdown} אני יכול להוסיף משתנה עזר חדש {::nomarkdown}\( A_{a}\){:/nomarkdown} שהגזירה היחידה שלו היא {::nomarkdown}\( A_{a}\to a\){:/nomarkdown} ואז להחליף את הגזירה הנתונה ב-{::nomarkdown}\( BA_{a}C\){:/nomarkdown}. עכשיו, אם יש לי גזירה של שלושה משתנים או יותר, אני יכול "להקטין" אותה בעזרת משתני עזר. למשל, אם {::nomarkdown}\( A\to B_{1}B_{2}B_{3}B_{4}\){:/nomarkdown} אני אוסיף משתני עזר חדשים {::nomarkdown}\( C_{1},C_{2},C_{3}\){:/nomarkdown} ואת הגזירות {::nomarkdown}\( A\to B_{1}C_{1}\){:/nomarkdown} ו-{::nomarkdown}\( C_{1}\to B_{2}C_{2}\){:/nomarkdown} ו-{::nomarkdown}\( C_{3}\to B_{3}B_{4}\){:/nomarkdown}. אז בעצם, הדבר היחיד שמסובך לטפל בו הוא גזירות מהצורה {::nomarkdown}\( A\to B\){:/nomarkdown} (גזירות כאלו נקראות "כללי יחידה") וגזירות מהצורה {::nomarkdown}\( A\to\varepsilon\){:/nomarkdown}. מגזירות כאלו תמיד אפשר להיפטר באופן דומה לאיך שנפטרים מכללי-{::nomarkdown}\( \varepsilon\){:/nomarkdown} באוטומט סופי דטרמיניסטי - קודם כל מגלים את כל המשתנים {::nomarkdown}\( B\){:/nomarkdown} שעבורם מתקיים {::nomarkdown}\( A\Rightarrow^{*}B\){:/nomarkdown} (סתם לקחת משתנים כך ש-{::nomarkdown}\( A\to B\){:/nomarkdown} לא מספיק, כי מה קורה אם {::nomarkdown}\( B\to C\){:/nomarkdown}? אז נקבל ש-{::nomarkdown}\( A\Rightarrow^{*}C\){:/nomarkdown} - זה דומה ל"סגור-{::nomarkdown}\( \varepsilon\){:/nomarkdown}" עבור שפות רגולריות), ועכשיו מוסיפים לדקדוק את כל הגזירות מהצורה {::nomarkdown}\( A\to\alpha\){:/nomarkdown} כך ש-{::nomarkdown}\( B\to\alpha\){:/nomarkdown} היה גזירה בדקדוק המקורי. לבסוף, מעיפים את כל כללי היחידה. באופן דומה אפשר גם לטפל בגזירות מהצורה {::nomarkdown}\( A\to\varepsilon\){:/nomarkdown} - קודם כל מגלים את כל המשתנים שהם "אפיסים", כלומר {::nomarkdown}\( A\Rightarrow^{*}\varepsilon\){:/nomarkdown}, ואחר כך לכל גזירה {::nomarkdown}\( A\to X_{1}X_{2}\dots X_{n}\){:/nomarkdown} (כאשר כל {::nomarkdown}\( X\){:/nomarkdown} כזה יכול להיות או משתנה או טרמינל) מחליפים אותה בכל הגזירות מהצורה {::nomarkdown}\( A\to Y_{1}\dots Y_{n}\){:/nomarkdown} כאשר {::nomarkdown}\( Y_{i}=X_{i}\){:/nomarkdown} אם {::nomarkdown}\( X_{i}\){:/nomarkdown} לא אפיס, ו-{::nomarkdown}\( Y_{i}\in\left\{ \varepsilon,X_{i}\right\} \){:/nomarkdown} אם הוא כן. ואז מסירים את כל הגזירות מהצורה {::nomarkdown}\( A\to\varepsilon\){:/nomarkdown} מהדקדוק.

עכשיו, מה שאני הולך להוכיח הוא שאם {::nomarkdown}\( z\in L\){:/nomarkdown} מקיימת {::nomarkdown}\( \left\|z\right\|\ge n\){:/nomarkdown} אז קיים לה פירוק {::nomarkdown}\( z=uvwxy\){:/nomarkdown} עם {::nomarkdown}\( \left\|vwx\right\|\le n\){:/nomarkdown} ו-{::nomarkdown}\( \left\|vx\right\|\ge1\){:/nomarkdown} כך שמתקיימים שלושת הדברים הבאים:

{::nomarkdown}\( S\Rightarrow^{*}uAy\){:/nomarkdown} עבור משתנה {::nomarkdown}\( A\){:/nomarkdown} כלשהו.

{::nomarkdown}\( A\Rightarrow^{*}vAx\){:/nomarkdown}

{::nomarkdown}\( A\Rightarrow^{*}w\){:/nomarkdown}

זה מסביר את המבנה ה"מוזר" של הפירוק. בואו נגיד במילים מה הם שלושת הדברים הללו: יש בדקדוק משתנה {::nomarkdown}\( A\){:/nomarkdown} שגוזר את עצמו, ואותו המשתנה ניתן לגזירה מתוך {::nomarkdown}\( S\){:/nomarkdown}, ובנוסף הוא יודע לגזור מילה טרמינלית. כאשר גוזרים אותו מתוך {::nomarkdown}\( S\){:/nomarkdown} נסמן ב-{::nomarkdown}\( u,y\){:/nomarkdown} את "מה שמתפזר לצדדים", ובאופן דומה כאשר {::nomarkdown}\( A\){:/nomarkdown} גוזר את עצמו נסמן ב-{::nomarkdown}\( v,x\){:/nomarkdown} את "מה שמתפזר לצדדים", וב-{::nomarkdown}\( w\){:/nomarkdown} אנחנו מסמנים את המילה הטרמינלית שאנחנו יודעים שהוא יודע לגזור. אם הראינו את שלושת הדברים הללו, ברור שאפשר לייצר את {::nomarkdown}\( uv^{i}wx^{i}z\){:/nomarkdown} לכל {::nomarkdown}\( i\ge0\){:/nomarkdown}: על ידי ביצוע הגזירה {::nomarkdown}\( S\Rightarrow^{*}uAy\){:/nomarkdown}, הפעלה {::nomarkdown}\( i\){:/nomarkdown} פעמים של הגזירה {::nomarkdown}\( A\Rightarrow^{*}vAx\){:/nomarkdown} ולבסוף הפעלה אחת של {::nomarkdown}\( A\Rightarrow^{*}w\){:/nomarkdown}.

עיקר האתגר יהיה להוכיח ש-{::nomarkdown}\( A\){:/nomarkdown} כזה קיים בכלל. הרעיון הוא כזה: אם {::nomarkdown}\( z\){:/nomarkdown} היא מילה גדולה מספיק, אז עץ הגזירה שלה יהיה חייב להיות עמוק, מסיבה שאסביר בהמשך. בואו נסמ ב-{::nomarkdown}\( k=\left\|V\right\|\){:/nomarkdown} את גודל קבוצת המשתנים של הדקדוק. אם אצליח לגרום לכך שהמסלול העמוק ביותר בעץ יהיה בן לפחות {::nomarkdown}\( k+1\){:/nomarkdown} צמתים פנימיים, זה מבטיח שיהיה משתנה שמופיע עליו פעמיים (זכרו - בעץ גזירה הצמתים הפנימיים הם משתנים, והעלים הם טרמינלים). המשתנה הזה יהיה ה-{::nomarkdown}\( A\){:/nomarkdown} שלי. כדי להבטיח את הטענה על כך ש-{::nomarkdown}\( \left\|vwx\right\|\le n\){:/nomarkdown} אני אצטרך לבחור משתנה שמופיע פעמיים והוא "נמוך ככל האפשר" בעץ (קרוב ככל האפשר לעלים). בואו עכשיו ניגש לפורמליזציה.

הפואנטה של שימוש בצורה הנורמלית של חומסקי היא שעץ הגזירה הוא בעל צורה מאוד ספציפית - הוא <strong>עץ בינארי</strong>, כלומר לכל צומת יש שני בנים, פרט לצמתים שהבנים שלהם הם עלים, ולצמתים כאלו יש רק בן יחיד. מה שנחמד בעצים בינאריים (ובאופן כללי, בעצים שבהם יש חסם קבוע על מספר הבנים של צומת) הוא שקל לקשור בין מספר העלים של העץ ובין העומק שלו. בואו ניקח לרגע עץ בינארי <strong>מושלם</strong>, שפירושו שכל העלים בעץ הם באותו עומק, וכל צומת שאינו עלה הוא בעל שני בנים. נניח שהעומק שלו הוא {::nomarkdown}\( d\){:/nomarkdown}, כלומר שאורך המסלול מהשורש אל עלה כלשהו הוא בן {::nomarkdown}\( d\){:/nomarkdown} צעדים (ולכן אנחנו רואים בדרך {::nomarkdown}\( d+1\){:/nomarkdown} צמתים). כמה עלים יש לעץ? הכי קל לעבוד עם מקרים פרטיים: עבור {::nomarkdown}\( d=0\){:/nomarkdown} העץ כולו כולל רק צומת יחיד. עבור {::nomarkdown}\( d=1\){:/nomarkdown} יש לנו את השורש ושני בנים. עבור {::nomarkdown}\( d=2\){:/nomarkdown} לכל אחד משני הבנים יש שני בנים, ולכן יש ארבעה עלים. עבור {::nomarkdown}\( d=3\){:/nomarkdown} כל אחד מארבעת העלים הוא עכשיו אב גאה לשני בנים נוספים, ולכן יש שמונה עלים... הבנתם את העיקרון. בעץ בינארי מושלם מעומק {::nomarkdown}\( d\){:/nomarkdown} יש בדיוק {::nomarkdown}\( 2^{d}\){:/nomarkdown} עלים. זה אומר שאם יש לנו עץ בינארי <strong>כלשהו</strong> (לאו דווקא מושלם) שבו יש יותר מ-{::nomarkdown}\( 2^{d}\){:/nomarkdown} עלים, אז בהכרח העומק שלו גדול מ-{::nomarkdown}\( d\){:/nomarkdown}.

אז מה שנעשה, אם {::nomarkdown}\( k\){:/nomarkdown} הוא מספר המשתנים של הדקדוק שלנו, נבחר {::nomarkdown}\( n=2^{k}\){:/nomarkdown}. עכשיו בואו ניקח עץ גזירה כלשהו עבור {::nomarkdown}\( z\){:/nomarkdown}. אם נעיף את הצמתים של הטרמינלים, נקבל עץ בינארי שבו העלים הם המשתנים שהגזירה שהם ביצעו היא גזירה של טרמינלים. מכיוון שכל משתנה כזה גזר טרמינל אחד, מספר המשתנים הללו הוא בדיוק {::nomarkdown}\( \left\|z\right\|\){:/nomarkdown}, כלומר מספר העלים בעץ הוא לפחות {::nomarkdown}\( 2^{k}\){:/nomarkdown}, ולכן עומק העץ הוא לפחות {::nomarkdown}\( k\){:/nomarkdown}. ניקח את המסלול הארוך ביותר בעץ - מכיוון שהעומק שלו הוא לפחות {::nomarkdown}\( k\){:/nomarkdown}, הרי שכשאנחנו הולכים עליו אנחנו רואים לפחות {::nomarkdown}\( k+1\){:/nomarkdown} משתנים. מסקנה - קיימים משתנים שמופיעים פעמיים על המסלול הזה. בואו נתחיל ללכת על המסלול מהעלה לכיוון השורש, ונסמן ב-{::nomarkdown}\( A\){:/nomarkdown} את המשתנה הראשון שמופיע פעמיים. עכשיו אפשר לתת את פירוק המילה שלנו - נסמן ב-{::nomarkdown}\( w\){:/nomarkdown} את המילה שהמופע השני, הנמוך יותר, של {::nomarkdown}\( A\){:/nomarkdown} גוזר; על כן המופע הראשון של {::nomarkdown}\( A\){:/nomarkdown} גוזר מילה ש-{::nomarkdown}\( w\){:/nomarkdown} היא חלק ממנה, ונסמן את החלקים שלפני ואחרי {::nomarkdown}\( w\){:/nomarkdown} ב-{::nomarkdown}\( v,w\){:/nomarkdown} בהתאמה, כלומר {::nomarkdown}\( A\){:/nomarkdown} הראשון גוזר את המילה {::nomarkdown}\( vwx\){:/nomarkdown}. המילה הזו היא בתורה חלק מהמילה ש-{::nomarkdown}\( S\){:/nomarkdown} גוזר (כלומר, המילה של עץ הגזירה כולו) ונסמן את הלפני ואחרי ב-{::nomarkdown}\( u,y\){:/nomarkdown}, כלומר המילה כולה היא {::nomarkdown}\( uvwxy\){:/nomarkdown} - הנה הפירוק שלנו. זה מאוד מבלבל אז הנה תמונה:

<strong><a href="http://www.gadial.net/wp-content/uploads/2015/04/pumping_lemma_cf.png"><img class="aligncenter size-full wp-image-3236" alt="pumping_lemma_cf" src="http://www.gadial.net/wp-content/uploads/2015/04/pumping_lemma_cf.png" width="637" height="622" /></a></strong>

עכשיו מגיע הטיעון העדין ביותר בהוכחה. אני טוען שמבין שני המופעים של {::nomarkdown}\( A\){:/nomarkdown} שראינו, הגבוה יותר הוא כזה שתת-העץ שלו הוא מגובה {::nomarkdown}\( k\){:/nomarkdown} <strong>לכל היותר</strong>. זה נובע משני דברים. ראשית, אני טוען שהגובה של ה-{::nomarkdown}\( A\){:/nomarkdown} הזה <strong>על המסלול העמוק ביותר</strong> הוא לא יותר מ-{::nomarkdown}\( k\){:/nomarkdown}. זה די ברור, מכיוון שאם הגובה היה יותר מ-{::nomarkdown}\( k\){:/nomarkdown}, אז עוד לפני שהיינו מגיעים אל המופע הגבוה יותר של {::nomarkdown}\( A\){:/nomarkdown} כבר היינו רואים {::nomarkdown}\( k+1\){:/nomarkdown} משתנים, ולכן היה משתנה <strong>אחר</strong> שכבר היה מופיע פעמיים והיינו רואים אותו. כעת, בנוסף לכך, אני צריך לטעון שאין מסלול <strong>אחר</strong> שעובר דרך ה-{::nomarkdown}\( A\){:/nomarkdown} הזה ומגיע לעלים, והוא ארוך יותר מ-{::nomarkdown}\( k\){:/nomarkdown} - זה נובע מכך שהמסלול שלקחתי היה <strong>המסלול העמוק ביותר</strong> ולכן אין מסלול שיותר עמוק ממנו. אני מתעכב על הטיעון הזה כי זו הנקודה שבה אני טעיתי בעבר שוב ושוב כאשר הצגתי את המשפט: פשוט אמרתי משהו בסגנון "עומק העץ הוא לפחות {::nomarkdown}\( k\){:/nomarkdown} אז קיים מסלול שבו יש משתנה שמופיע פעמיים". זה נכון, אבל לא מבטיח לנו שהמופע הראשון מבין השניים של המשתנה הזה יהיה נמוך יחסית - מגובה {::nomarkdown}\( k\){:/nomarkdown} לכל היותר.

ולמה זה חשוב, שהוא מגובה {::nomarkdown}\( k\){:/nomarkdown} לכל היותר? כי זה מגביל את מספר העלים בתת-העץ שלו להיות לכל היותר {::nomarkdown}\( 2^{k}\){:/nomarkdown}. ותת העץ הזה הוא בדיוק תת-העץ שמייצר את {::nomarkdown}\( vwx\){:/nomarkdown} שלנו, כך שאנחנו מקבלים את הדרישה {::nomarkdown}\( \left\|vwx\right\|\le n\){:/nomarkdown}. אם לא היה אכפת לנו מהדרישה הזו (שנראית קצת מלאכותית במבט ראשון) ההוכחה הייתה יותר קלה כי לא היינו צריכים את כל הנימוקים העדינים הללו, אבל הדרישה הזו מאוד מועילה לנו כשאנחנו רוצים <strong>להשתמש</strong> בלמה (כמו הדרישה הדומה ש-{::nomarkdown}\( \left\|uv\right\|\le n\){:/nomarkdown} בלמת הניפוח לשפות רגולריות) ולכן התעקשנו עליה.

עדיין צריך להסביר למה {::nomarkdown}\( \left\|vx\right\|\ge1\){:/nomarkdown} וזה לא לגמרי מובן מאליו. הטענה היא שכאשר {::nomarkdown}\( A\){:/nomarkdown} הראשון גוזר את {::nomarkdown}\( A\){:/nomarkdown} השני, חייב להיות משהו ש"ייגזר בצד", כלומר לא ייתכן שהגזירה היא מהצורה {::nomarkdown}\( A\Rightarrow^{*}A\){:/nomarkdown}. בדקדוקים כלליים אין לנו משהו שיבטיח את זה, אבל בצורה הנורמלית של חומסקי זה קל. הגזירה שה-{::nomarkdown}\( A\){:/nomarkdown} הראשון מבצע בצעד הראשון שלו חייבת להיות מהצורה {::nomarkdown}\( A\Rightarrow BC\){:/nomarkdown}, ועכשיו אם (בלי הגבלת הכלליות) {::nomarkdown}\( A\){:/nomarkdown} השני הוא בתת-העץ של {::nomarkdown}\( B\){:/nomarkdown}, אז בתת-העץ של {::nomarkdown}\( C\){:/nomarkdown} יהיה לפחות טרמינל אחד (כי {::nomarkdown}\( C\){:/nomarkdown} יודע רק לגזור שני דברים: או טרמינל, או עוד משתנים שמחוייבים בתורם לגזור משתנים או טרמינלים). אין ל-{::nomarkdown}\( C\){:/nomarkdown} דרך פשוט "להעלים את עצמו".

זה מסיים את ההוכחה של למת הניפוח לשפות חסרות הקשר. בואו נראה עכשיו דוגמה זריזה לשימוש בה, בלי להיכנס לכל הפרטים - נוכיח ש-{::nomarkdown}\( L=\left\{ a^{n}b^{n}c^{n}\ \|\ n\ge0\right\} \){:/nomarkdown} היא לא חסרת הקשר. לצורך כך נניח בשלילה שהיא חסרת הקשר, יהא {::nomarkdown}\( n\){:/nomarkdown} שקיומו מובטח על ידי הלמה ונסתכל במילה {::nomarkdown}\( z=a^{n}b^{n}c^{n}\){:/nomarkdown}. אנחנו צריכים להראות שאפשר "לקלקל" כל פירוק אפשרי שלה. הנקודה היא שפירוק {::nomarkdown}\( z=uvwxy\){:/nomarkdown} כלשהו חייב להיות מאחת מחמש צורות אפשריות, בגלל המגבלה {::nomarkdown}\( \left\|vwx\right\|\le n\){:/nomarkdown}: או ש-{::nomarkdown}\( vwx\){:/nomarkdown} חי כולו בתוך אחד משלושת הרצפים {::nomarkdown}\( a^{n},b^{n},c^{n}\){:/nomarkdown}, או שהוא נמצא אי שם בתוך הרצף {::nomarkdown}\( a^{n}b^{n}\){:/nomarkdown} וחוצה אותו באמצע, או שהוא נמצא בתוך הרצף {::nomarkdown}\( b^{n}c^{n}\){:/nomarkdown} וחוצה אותו באמצע. בכל מקרה אין ל-{::nomarkdown}\( vwx\){:/nomarkdown} יכולת לכלול בתוכו גם {::nomarkdown}\( a\){:/nomarkdown}-ים, גם {::nomarkdown}\( b\){:/nomarkdown}-ים וגם {::nomarkdown}\( c\){:/nomarkdown}-ים כי זה יצריך ממנו להכיל לפחות {::nomarkdown}\( n+2\){:/nomarkdown} תווים (לפחות {::nomarkdown}\( a\){:/nomarkdown} אחד, לפחות {::nomarkdown}\( c\){:/nomarkdown} אחד ואת כל ה-{::nomarkdown}\( b^{n}\){:/nomarkdown} שבאמצע) ולכן אם נבחר {::nomarkdown}\( i=0\){:/nomarkdown} בהכרח נקבל מילה שמספר האותיות משלושת הסוגים בה לא מאוזן (כי הקטנו לפחות סוג אחד של אותיות, אבל באחד מהסוגים לא נגענו).

יש הכללה מאוד ברורה של הלמה שלא כל כך קשה להבין. הרעיון בה הוא שיש לנו קצת יותר שליטה על המיקום של ה-{::nomarkdown}\( vwx\){:/nomarkdown}, שכרגע כל מה שאנחנו יודעים עליו זה שהוא מאורך לכל היותר {::nomarkdown}\( n\){:/nomarkdown} ונמצא במקום <strong>כלשהו</strong> במילה (בניגוד ללמת הניפוח לשפות רגולריות, ששם הוא היה חייב להיות בהתחלה). הרעיון הוא שאם {::nomarkdown}\( z\){:/nomarkdown} היא יותר ארוכה מ-{::nomarkdown}\( n\){:/nomarkdown}, אז אין צורך להסתכל על <strong>כל</strong> {::nomarkdown}\( z\){:/nomarkdown} כדי להפעיל את הלמה; מספיק להסתכל על מקום כלשהו שהוא ארוך מ-{::nomarkdown}\( n\){:/nomarkdown} והלמה תפעל עליו. אבל למעשה, אפילו לא חייבים {::nomarkdown}\( n\){:/nomarkdown} תווים <strong>רציפים</strong>; אפשר להסתכל על כל סדרה של {::nomarkdown}\( n\){:/nomarkdown} תווים, גם לא רציפים, ולדבר על החלק מעץ הגזירה שמייצר את כל התווים בסדרה הזו. החלק הזה יהיה חייב להיות עמוק מספיק, וכן הלאה וכן הלאה. אז הנה הניסוח הפורמלי: בהינתן שפה חסרת הקשר {::nomarkdown}\( L\){:/nomarkdown} קיים קבוע {::nomarkdown}\( n\){:/nomarkdown} כך שלכל מילה {::nomarkdown}\( z\in L\){:/nomarkdown} <strong>ולכל בחירה</strong> של לפחות {::nomarkdown}\( n\){:/nomarkdown} תווים ב-{::nomarkdown}\( z\){:/nomarkdown}, שנקרא להם "מסומנים", קיים פירוק {::nomarkdown}\( z=uvwxy\){:/nomarkdown} כך ש-{::nomarkdown}\( vwx\){:/nomarkdown} כולל לכל היותר {::nomarkdown}\( n\){:/nomarkdown} תווים מסומנים, {::nomarkdown}\( vx\){:/nomarkdown} כולל לפחות תו מסומן אחד, ו-{::nomarkdown}\( uv^{i}wx^{i}z\in L\){:/nomarkdown} לכל {::nomarkdown}\( i\ge0\){:/nomarkdown}. למת הניפוח לשפות רגולריות היא פשוט מקרה פרטי של זה כאשר כל התווים של {::nomarkdown}\( z\){:/nomarkdown} הם מסומנים.

ההכללה הזו נקראת לפעמים "הלמה של אוגדן" - כך היא מופיעה בספר האוטומטים של הופקרופט ושות', שהוא כנראה הספר הידוע ביותר על הנושא כיום, וכך היא מופיעה גם בויקיפדיה האנגלית (כנראה בעקבות הופקרופט). אבל הניסוח במאמר המקורי של אוגדן היה שונה וחזק יותר והוא זה שאציג עכשיו (הסיבה לכך היא שאוגדן הוכיח את הלמה שלו כדי להוכיח את עניין רב המשמעות שאגיע אליו בסוף הפוסט; עד כמה שאני רואה, בניסוח של הופקרופט ושות' אי אפשר לעשות את זה, והם אפילו לא מנסים אלא סתם מזכירים את הלמה בתוך תרגיל כבדרך אגב). הטענה של אוגדן היא כזו: אם {::nomarkdown}\( L\){:/nomarkdown} היא חסרת הקשר, אז קיים {::nomarkdown}\( n\){:/nomarkdown} טבעי כך שלכל מילה {::nomarkdown}\( z\in L\){:/nomarkdown} וסימון של לפחות {::nomarkdown}\( n\){:/nomarkdown} תווים ב-{::nomarkdown}\( z\){:/nomarkdown}, קיים ל-{::nomarkdown}\( z\){:/nomarkdown} פירוק {::nomarkdown}\( z=uvwxy\){:/nomarkdown} כך שמתקיים {::nomarkdown}\( uv^{i}wx^{i}y\in L\){:/nomarkdown} כרגיל לכל {::nomarkdown}\( i\ge0\){:/nomarkdown}, אבל התכונות של הפירוק יותר מורכבות: ראשית, {::nomarkdown}\( w\){:/nomarkdown} מכיל לפחות תו מסומן אחד; שנית, או שגם {::nomarkdown}\( u\){:/nomarkdown} וגם {::nomarkdown}\( v\){:/nomarkdown} מכילים תו מסומן, או שגם {::nomarkdown}\( x\){:/nomarkdown} וגם {::nomarkdown}\( y\){:/nomarkdown} מכילים תו מסומן. לבסוף, כרגיל, {::nomarkdown}\( vwx\){:/nomarkdown} לא מכיל יותר מ-{::nomarkdown}\( n\){:/nomarkdown} תווים מסומנים.

הניסוח הזה שונה ממה שראינו עד כה בכך שיש דרישה כלשהי על {::nomarkdown}\( u,w,y\){:/nomarkdown} - החלקים ש"לא מנפחים" - ב-{::nomarkdown}\( w\){:/nomarkdown} מובטח לנו שיהיה תו מסומן, ואילו ב-{::nomarkdown}\( u,y\){:/nomarkdown} מובטח לנו שלאחד מהם יהיה תו מסומן (וכך גם לחלק שכן מנפחים שנמצא יחד איתו). עוד מעט נראה למה הניסוח הזה מועיל כל כך, אבל לעת עתה בואו נבין איך מוכיחים אותו. ההוכחה אמנם היא בעלת אותו רעיון כמו למת הניפוח, אבל הטיעונים זהירים יותר.

כמקודם, נרצה למצוא מסלול ארוך מספיק בעץ הגזירה, עם משתנה {::nomarkdown}\( A\){:/nomarkdown} שמופיע עליו פעמיים. אבל אנחנו צריכים להקפיד שתת-עץ הגזירה של {::nomarkdown}\( A\){:/nomarkdown} הזה יכיל מספיק תווים מסומנים. צמתים "מוצלחים" בהיבט הזה הם צמתים שבתת-העץ של כל אחד משני הבנים שלהם יש תווים מסומנים - אוגדן קורא להם "צמתי {::nomarkdown}\( B\){:/nomarkdown}". עכשיו אוגדן בוחר בתוך המסלול שלו מסלול בעץ שיש בו מספר מקסימלי של צמתי {::nomarkdown}\( B\){:/nomarkdown}, ושמסתיים בתו מסומן (הסיום של המסלול יהיה בתוך ה-{::nomarkdown}\( w\){:/nomarkdown} שלנו, ולכן הדרישה הזו תבטיח שב-{::nomarkdown}\( w\){:/nomarkdown} יהיה תו מסומן). עכשיו, מה שאוגדן רוצה כדי שהלמה תעבוד הוא שבמסלול שלו יהיו לפחות {::nomarkdown}\( 2\left\|V\right\|+3\){:/nomarkdown} צמתי {::nomarkdown}\( B\){:/nomarkdown} - זה משמעותית יותר גדול מאשר ה-{::nomarkdown}\( \left\|V\right\|+1\){:/nomarkdown} שרצינו עבור למת הניפוח הרגילה, ולכן הבחירה של {::nomarkdown}\( n\){:/nomarkdown} תהיה גדולה יותר - {::nomarkdown}\( n=2^{2\left\|V\right\|+3}\){:/nomarkdown}. הטיעון שמסביר למה עבור {::nomarkdown}\( n\){:/nomarkdown} כזה בהכרח יש לנו מספיק צמתי {::nomarkdown}\( B\){:/nomarkdown} דומה לטיעון הרגיל בלמה, כשלא היו צמתים מסומנים בכלל; הרעיון הוא שרק צומת {::nomarkdown}\( B\){:/nomarkdown} יגדיל את מספר התווים המסומנים במילה הסופית, בזמן שצומת שרק לאחד משני בניו יש תווים מסומנים לא הולך להגדיל את מספר התווים המסומנים הכולל. נסו להוכיח זאת לעצמכם אם אתם לא משוכנעים.

עכשיו החלק הטריקי. אנחנו רוצים להבטיח שיהיו מקומות מסומנים גם ב-{::nomarkdown}\( u,v\){:/nomarkdown} או {::nomarkdown}\( x,y\){:/nomarkdown}. בואו ניקח צומת {::nomarkdown}\( B\){:/nomarkdown} שהבן הימני שלו ממשיך על גבי המסלול שבחרנו - מה קורה עם הבן השמאלי שלו? לבן השמאלי הזה יהיה תת-עץ שמכיל תו מסומן, והוא בא לפני תת-העץ של הבן השמאלי של הצומת. כלומר, אם הצומת גבוה מספיק, התו המסומן הזה יהיה בתוך משהו שבא לפני {::nomarkdown}\( w\){:/nomarkdown}.

אז הנה מה שנעשה. נחלק את צמתי ה-{::nomarkdown}\( B\){:/nomarkdown} על המסלול שלנו לשתי קבוצות, {::nomarkdown}\( C_{L}\){:/nomarkdown} ו-{::nomarkdown}\( C_{R}\){:/nomarkdown}, כך שכל צמתי ה-{::nomarkdown}\( B\){:/nomarkdown} ב-{::nomarkdown}\( C_{L}\){:/nomarkdown} הם כאלו שהבן <strong>הימני</strong> שלהם ממשיך על המסלול, ועבור הצמתים ב-{::nomarkdown}\( C_{R}\){:/nomarkdown} הבן <strong>השמאלי</strong> ממשיך על המסלול. מכיוון שהיו {::nomarkdown}\( 2\left\|V\right\|+3\){:/nomarkdown} צמתי {::nomarkdown}\( B\){:/nomarkdown} במסלול, בהכרח אחת משתי הקבוצות הללו כוללת לפחות {::nomarkdown}\( \left\|V\right\|+2\){:/nomarkdown} צמתים - בואו נניח שזו {::nomarkdown}\( C_{L}\){:/nomarkdown}. ניקח את הצומת הראשון ב-{::nomarkdown}\( C_{L}\){:/nomarkdown} ונסמן אותו ב-{::nomarkdown}\( D\){:/nomarkdown}- הצומת הזה הולך ליצור תו מסומן בתוך {::nomarkdown}\( u\){:/nomarkdown} עם הבן השמאלי שלו. עכשיו נשארו לנו {::nomarkdown}\( \left\|V\right\|+1\){:/nomarkdown} צמתים ב-{::nomarkdown}\( C_{L}\){:/nomarkdown} על המסלול, שכולם באים אחרי {::nomarkdown}\( D\){:/nomarkdown}, אז ניקח כמו קודם משתנה {::nomarkdown}\( A\){:/nomarkdown} שמופיע פעמיים ועושה את זה הכי נמוך שרק אפשר. המשתנה הזה שייך ל-{::nomarkdown}\( C_{L}\){:/nomarkdown}, ולכן הבן השמאלי של המופע הראשון שלו הולך ליצור תו מסומן אחד לפחות - התו הזה יהיה ב-{::nomarkdown}\( v\){:/nomarkdown}. קיבלנו את מה שרצינו, במחיר של ניתוח עדין יותר של הלמה, ובחירה של {::nomarkdown}\( n\){:/nomarkdown} גדול יותר.

אני רק רוצה לחדד עוד נקודה עדינה - בניסוח הלמה שלו, אוגדן לא אומר רק ש-{::nomarkdown}\( uv^{i}wx^{i}y\in L\){:/nomarkdown} לכל {::nomarkdown}\( i\ge0\){:/nomarkdown} - הוא אומר במפורש שקיים משתנה {::nomarkdown}\( A\){:/nomarkdown} כך ש-{::nomarkdown}\( S\Rightarrow^{*}uAy\Rightarrow^{*}uvAxy\Rightarrow^{*}uvwxy\){:/nomarkdown}. זה יהיה לנו חשוב בהמשך.

כדי להראות למה זה שימושי, בואו נדבר על רב-משמעות. כזכור, דקדוק הוא <strong>רב משמעי</strong> אם קיימת מילה אחת לפחות שיש לה שני עצי גזירה שונים. כלומר, יש שתי דרכים שונות לגזור אותה, שנבדלות לא רק בשאלה <strong>מתי</strong> מופעל כלל גזירה על משתנה, אלא גם <strong>איזה</strong> כלל גזירה הופעל. לדוגמה, שתי הגזירות {::nomarkdown}\( A\Rightarrow BC\Rightarrow bC\Rightarrow bc\){:/nomarkdown} ו-{::nomarkdown}\( A\Rightarrow BC\Rightarrow Bc\Rightarrow bc\){:/nomarkdown} מתאימות לאותו עץ גזירה ונבדלות רק בסדר שבו בוצעו הגזירות של המשתנים; לעומת זאת {::nomarkdown}\( A\Rightarrow BC\Rightarrow bbC\Rightarrow bbb\){:/nomarkdown} ו-{::nomarkdown}\( A\Rightarrow BC\Rightarrow Bbb\Rightarrow bbb\){:/nomarkdown} הן גזירות שמתאימות לעצי גזירה שונים (בראשון {::nomarkdown}\( B\){:/nomarkdown} גוזר שני {::nomarkdown}\( b\){:/nomarkdown}-ים, ובשני דווקא {::nomarkdown}\( C\){:/nomarkdown} גוזר שני {::nomarkdown}\( b\){:/nomarkdown}-ים). לכן דקדוק שמאפשר את הגזירות מהדוגמה השניה הוא רב משמעי.

רב משמעות היא עניין בעייתי כאשר אנחנו רוצים להשתמש בעץ הגזירה של מילה כדי להבין את המבנה שלה - למשל, להשתמש בעץ הגזירה של תוכנית מחשב כדי להבין את מבנה התוכנית, ואנחנו מן הסתם לא רוצים לאפשר שתי משמעויות שונות (ועצי גזירה שונים לאותה תוכנית מחשב אכן יובילו לרוב לשתי תוכניות שמתנהגות בצורה שונה - די אסון). זה מעלה מייד שתי שאלות - ראשית, בהינתן דקדוק, האם ניתן לבדוק האם הוא רב משמעי? ושנית, בהינתן דקדוק, האם ניתן להמיר אותו בדקדוק אחר עבור אותה שפה, שהוא כן חד משמעי?

באופן די עגום, התשובה לשתי השאלות הללו היא "לא", או ליתר דיוק, "לא תמיד". לא אסביר כרגע למה לא תמיד ניתן לבדוק האם דקדוק נתון הוא רב משמעי, אבל אגיע לזה בהמשך; עכשיו אסביר למה לא תמיד ניתן להמיר דקדוק רב משמעי בדקדוק חד משמעי - זה בגלל שיש שפות שהן <strong>רב משמעיות טבועות</strong>, דהיינו כל דקדוק עבורן יהיה בהכרח רב משמעי. והן לא חייבות להיות מסובכות; הדוגמה שלי היא השפה התמימה למראה {::nomarkdown}\( L=\left\{ a^{n}b^{n}c^{k}\ \|\ n,k\in\mathbb{N}\right\} \cup\left\{ a^{k}b^{n}c^{n}\ \|\ n,k\in\mathbb{N}\right\} \){:/nomarkdown}. כלומר, אוסף כל המילים מהצורה {::nomarkdown}\( a^{*}b^{*}c^{*}\){:/nomarkdown} כך שמספר ה-{::nomarkdown}\( b\){:/nomarkdown}-ים שווה למספר ה-{::nomarkdown}\( a\){:/nomarkdown}-ים או למספר ה-{::nomarkdown}\( c\){:/nomarkdown}-ים. ברור שזו שפה חסרת הקשר כי תחשבו על אוטומט מחסנית שמקבל אותה: הוא מחליט אי דטרמיניסטית מראש למי מספר ה-{::nomarkdown}\( b\){:/nomarkdown}-ים יהיה שווה ואז מתנהג כמו אוטומט עבור {::nomarkdown}\( \left\{ a^{n}b^{n}\ \|\ n\in\mathbb{N}\right\} \){:/nomarkdown} תוך שאת האותיות מהסוג השלישי הוא סתם קורא ולא נוגע במחסנית (תרגיל קל: כתבו דקדוק עבור השפה הזו).

נותר לי להוכיח שהשפה היא רב משמעית טבועה. קחו רגע ותנסו לחשוב איך מוכיחים את זה. ועוד יותר מכך - איך הלמה של אוגדן תהיה קשורה לכך. לי עצמי אין מושג, כשאני כותב את הפוסט; הספקתי כבר לשכוח איך זה עובד, ולכן זה הולך להרגיש לי (שקורא את ההוכחה תוך כדי הכתיבה) כמו קסם בדיוק כמו לכם. כרגע אני לא ממש רואה קשר.

אוקיי, בואו נתחיל (קראתי את ההוכחה - וואו, מגניב!). נניח ש-{::nomarkdown}\( n\){:/nomarkdown} הוא הקבוע שהלמה של אוגדן מבטיחה לנו (וניקח {::nomarkdown}\( n&gt;3\){:/nomarkdown} כי נזדקק בהמשך לכך ש-{::nomarkdown}\( 2n&lt;n!\){:/nomarkdown}). המילה שאראה שחייבים להיות לה שני עצי גזירה שונים תהיה באופן ממש אינטואיטיבי המילה {::nomarkdown}\( a^{n+n!}b^{n+n!}c^{n+n!}\){:/nomarkdown}, כאשר {::nomarkdown}\( n!\){:/nomarkdown} ({::nomarkdown}\( n\){:/nomarkdown} עצרת), כזכור, הוא קיצור ל-{::nomarkdown}\( 1\cdot2\cdots n\){:/nomarkdown} (במבט ראשון זה נראה לא קשור בעליל, אבל עצרת היא מספר שימושי שצץ בהרבה הוכחות בגלל התכונה הנחמדה שלה שהיא מתחלקת בכל מספר מ-1 ועד {::nomarkdown}\( n\){:/nomarkdown}).

כדי להראות את שני עצי הגזירה השונים הללו, ניקח שתי מילים שונות שהן תת-מילים של המילה שלנו, נפעיל עליהן את הלמה של אוגדן ונראה שאפשר "לנפח" אותן כדי לקבל את המילה שלנו, ושני הניפוחים חייבים להיות שונים באופיים ולכן לא יכולים להתאים לאותו עץ גזירה. נתחיל מהמילה {::nomarkdown}\( a^{n}b^{n}c^{n+n!}\){:/nomarkdown}. הלמה של אוגדן מבקשת מאיתנו לסמן לפחות {::nomarkdown}\( n\){:/nomarkdown} אותיות, אז בואו נסמן בדיוק את ה-{::nomarkdown}\( a\){:/nomarkdown}-ים במילה. עכשיו קיבלנו פירוק {::nomarkdown}\( uvwxy\){:/nomarkdown} של המילה, שבו {::nomarkdown}\( w\){:/nomarkdown} כולל לפחות אות מסומנת אחת - כלומר, {::nomarkdown}\( w\){:/nomarkdown} מוכל בחלק של ה-{::nomarkdown}\( a\){:/nomarkdown}-ים. לכן גם {::nomarkdown}\( u,v\){:/nomarkdown} שבאות לפני {::nomarkdown}\( w\){:/nomarkdown} מוכלות בחלק של ה-{::nomarkdown}\( a\){:/nomarkdown}-ים (אבל שימו לב - שום דבר לא מונע מ-{::nomarkdown}\( u,v\){:/nomarkdown} להיות שתיהן ריקות; הלמה של אוגדן לא מבטיחה שיהיה בהן משהו).

בואו נבין עכשיו איך {::nomarkdown}\( x\){:/nomarkdown} נראה. הוא בא אחרי {::nomarkdown}\( w\){:/nomarkdown} ולכן יכול להיות בעצם בכל מקום במילה, אבל אם {::nomarkdown}\( x\){:/nomarkdown} יכלול שתי אותיות שונות, {::nomarkdown}\( uv^{2}wx^{2}y\){:/nomarkdown} בהכרח לא תהיה שייכת לשפה (כי השפה כוללת רק מילים שבהן קודם באים כל ה-{::nomarkdown}\( a\){:/nomarkdown}-ים, אחר כך כל ה-{::nomarkdown}\( b\){:/nomarkdown}-ים ובסוף כל ה-{::nomarkdown}\( c\){:/nomarkdown}-ים; אם {::nomarkdown}\( x\){:/nomarkdown} כולל שתי אותיות שונות ונחזור עליו פעמיים, נראה אותיות נעלמות ואז חוזרות שוב). לכן {::nomarkdown}\( x\){:/nomarkdown} מורכב כולו מאחת משלוש האותיות האפשריות (וייתכן שהוא ריק).

עכשיו, בואו נסמן את הגדלים של החלקים המנופחים: {::nomarkdown}\( \left\|v\right\|=p,\left\|x\right\|=q\){:/nomarkdown}. אז {::nomarkdown}\( p,q\ge0\){:/nomarkdown} ובנוסף אנחנו יודעים ש-{::nomarkdown}\( 0&lt;p+q\le2n&lt;n!\){:/nomarkdown}. כמו כן אפשר עכשיו לכתוב את המבנה של החלקים הללו: {::nomarkdown}\( v=a^{p}\){:/nomarkdown} תמיד, בזמן ש-{::nomarkdown}\( x\){:/nomarkdown} שייך לאחת משלוש צורות אפשריות: {::nomarkdown}\( x=a^{q}\){:/nomarkdown} או {::nomarkdown}\( x=b^{q}\){:/nomarkdown} או {::nomarkdown}\( x=c^{q}\){:/nomarkdown}.

עכשיו בואו ונראה מה קורה כשמנפחים את המילה, ונבדיל בין אפשרויות שונות על בסיס הערכים הפוטנציאליים של {::nomarkdown}\( x\){:/nomarkdown}.

אם {::nomarkdown}\( x=a^{q}\){:/nomarkdown} אז {::nomarkdown}\( uv^{2}wx^{2}y=a^{n+p+q}b^{n}c^{n+n!}\){:/nomarkdown} וזו בבירור לא מילה בשפה כי מספר ה-{::nomarkdown}\( a\){:/nomarkdown}-ים שונה ממספר ה-{::nomarkdown}\( b\){:/nomarkdown}-ים ששונה ממספר ה-{::nomarkdown}\( c\){:/nomarkdown}-ים. מסקנה: {::nomarkdown}\( x\ne a^{q}\){:/nomarkdown}. מכאן אנחנו לומדים משהו קריטי להמשך - {::nomarkdown}\( x\){:/nomarkdown} לא כולל אותיות מסומנות, ולכן {::nomarkdown}\( v\){:/nomarkdown} חייב לכלול כאלו, כלומר {::nomarkdown}\( \left\|v\right\|=p&gt;0\){:/nomarkdown}.

אם {::nomarkdown}\( x=c^{q}\){:/nomarkdown} אז {::nomarkdown}\( uv^{2}wx^{2}y=a^{n+p}b^{n}c^{n+n!+q}\){:/nomarkdown}. כבר ראינו ש-{::nomarkdown}\( p&gt;0\){:/nomarkdown} ולכן {::nomarkdown}\( n+p\ne n\){:/nomarkdown} ושוב קיבלנו מילה שאינה בשפה.

המסקנה היא שבהכרח {::nomarkdown}\( x=b^{q}\){:/nomarkdown}, כדי שיוכל "לאזן" את {::nomarkdown}\( v\){:/nomarkdown}: {::nomarkdown}\( uv^{2}wx^{2}y=a^{n+p}b^{n+q}c^{n+n!}\){:/nomarkdown}. מכיוון שהמילה הזו חייבת להיות שייכת לשפה (אחרת נגיע לסתירה כללית), בהכרח {::nomarkdown}\( p=q\){:/nomarkdown}. זה אומר שכשאנחנו מנפחים את המילה, אנחנו מגדילים את מספר ה-{::nomarkdown}\( a\){:/nomarkdown}-ים וה-{::nomarkdown}\( b\){:/nomarkdown}-ים באותה כמות בדיוק - בואו ננפח עד שנגיע ל-{::nomarkdown}\( n+n!\){:/nomarkdown}. כאן השימוש בעצרת משתלם לנו - אנחנו לא יודעים מהו {::nomarkdown}\( p\){:/nomarkdown}, אבל אנחנו יודעים ש-{::nomarkdown}\( p\le n\){:/nomarkdown} (כי כבר ראינו ש-{::nomarkdown}\( v\){:/nomarkdown} כלול כולו ב-{::nomarkdown}\( a\){:/nomarkdown}-ים ויש רק {::nomarkdown}\( n\){:/nomarkdown} כאלו) ולכן {::nomarkdown}\( p\|n!\){:/nomarkdown}, כלומר קיים {::nomarkdown}\( t\){:/nomarkdown} כך ש-{::nomarkdown}\( pt=n!\){:/nomarkdown}. וכעת: {::nomarkdown}\( uv^{t+1}wx^{t+1}y=a^{n+pt}b^{n+pt}c^{n+n!}=a^{n+n!}b^{n+n!}c^{n+n!}\){:/nomarkdown}. הוכחנו שהדקדוק שלנו יודע לגזור את {::nomarkdown}\( a^{n+n!}b^{n+n!}c^{n+n!}\){:/nomarkdown}.

בואו נחדד את מה שראינו, תוך שאנו זוכרים מה אוגדן בדיוק אומר - הוא אומר שקיים משתנה {::nomarkdown}\( A\){:/nomarkdown} כך ש-{::nomarkdown}\( S\Rightarrow^{*}uAy\Rightarrow^{*}uvAxy\Rightarrow^{*}uv^{t+1}Ax^{t+1}y\Rightarrow^{*}uv^{t+1}wx^{t+1}y=a^{n+n!}b^{n+n!}c^{n+n!}\){:/nomarkdown}. מה שחשוב כאן הוא ש-{::nomarkdown}\( A\){:/nomarkdown} מייצר את {::nomarkdown}\( v,x\){:/nomarkdown} ולכן גוזר רק את האותיות {::nomarkdown}\( a,b\){:/nomarkdown}.

עכשיו אפשר לחזור על כל מה שאמרנו עד כה אבל כשמתחילים מהמילה {::nomarkdown}\( a^{n+n!}b^{n}c^{n}\){:/nomarkdown} שגם כן שייכת לשפה. הלמה של אוגדן תראה לנו בסופו של דבר שקיים משתנה {::nomarkdown}\( A^{\prime}\){:/nomarkdown} כך ש-

{::nomarkdown}\( S\Rightarrow^{*}u^{\prime}A^{\prime}y^{\prime}\Rightarrow^{*}u^{\prime}v^{\prime}A^{\prime}x^{\prime}y^{\prime}\Rightarrow^{*}u^{\prime}\left(v^{\prime}\right)^{t+1}A^{\prime}\left(x^{\prime}\right)^{t+1}y^{\prime}\Rightarrow^{*}u^{\prime}\left(v^{\prime}\right)^{t+1}w^{\prime}\left(x^{\prime}\right)^{t+1}y^{\prime}=a^{n+n!}b^{n+n!}c^{n+n!}\){:/nomarkdown}

רק שהפעם יצא ש-{::nomarkdown}\( A^{\prime}\){:/nomarkdown} גוזר רק {::nomarkdown}\( b\){:/nomarkdown}-ים ו-{::nomarkdown}\( c\){:/nomarkdown}-ים.

קיבלנו שתי גזירות של {::nomarkdown}\( a^{n+n!}b^{n+n!}c^{n+n!}\){:/nomarkdown} בדקדוק שלנו. אבל האם הן באמת מתאימות לעצי גזירה שונים? אינטואיטיבית כנראה כבר ברור שכן כי איכשהו {::nomarkdown}\( A\){:/nomarkdown} ו-{::nomarkdown}\( A^{\prime}\){:/nomarkdown} לא מסתדרים לנו טוב ביחד, אבל צריך לתת פה נימוק פורמלי יותר. ראשית נשים לב לכך ש-{::nomarkdown}\( A\){:/nomarkdown} לא יודעת לגזור את {::nomarkdown}\( A^{\prime}\){:/nomarkdown} וגם ההפך נכון (כי {::nomarkdown}\( A\){:/nomarkdown} גוזרת רק {::nomarkdown}\( a,b\){:/nomarkdown} בעץ הגזירה שלה, ולכן אם {::nomarkdown}\( A^{\prime}\){:/nomarkdown} הייתה בעץ הגזירה, אז היו גם {::nomarkdown}\( c\){:/nomarkdown}-ים בפנים). זה אומר שאם שתי הגזירות שלעיל הן גזירה אחת, אז על ידי כך שנבצע את הגזירה הזו אבל "נתאפק" ולא נגזור לא את {::nomarkdown}\( A\){:/nomarkdown} ולא את {::nomarkdown}\( A^{\prime}\){:/nomarkdown} אחרי שהן מופיעות לראשונה, נקבל את הדבר הבא: {::nomarkdown}\( S\Rightarrow^{*}t_{1}At_{2}A^{\prime}t_{3}\){:/nomarkdown}. עכשיו אני יכול להמשיך ולגזור את {::nomarkdown}\( A,A^{\prime}\){:/nomarkdown} כמה פעמים שנרצה לפני שנגזור אותן ל-{::nomarkdown}\( w,w^{\prime}\){:/nomarkdown} - בואו נגזור את {::nomarkdown}\( A\){:/nomarkdown} במשך {::nomarkdown}\( i\){:/nomarkdown} פעמים ואת {::nomarkdown}\( A^{\prime}\){:/nomarkdown} במשך {::nomarkdown}\( j\){:/nomarkdown} פעמים, עבור {::nomarkdown}\( i,j\){:/nomarkdown} שמשתלמים לנו (נראה עוד מעט מה זה אומר). נקבל את המילה הבאה, ששייכת כמובן לשפה {::nomarkdown}\( L\){:/nomarkdown} כי היא נגזרה על ידי הדקדוק:

{::nomarkdown}\( t_{1}v^{i}wx^{i}t_{2}\left(v^{\prime}\right)^{j}w^{\prime}\left(x^{\prime}\right)^{j}t_{3}\){:/nomarkdown}

מה שאני רוצה לומר הוא שעבור {::nomarkdown}\( i,j\){:/nomarkdown} גדולים מספיק, מספר ה-{::nomarkdown}\( b\){:/nomarkdown}-ים במילה הזו בהכרח יהיה גדול ממספר ה-{::nomarkdown}\( a\){:/nomarkdown}-ים וגם ממספר ה-{::nomarkdown}\( c\){:/nomarkdown}-ים, ולכן המילה לא תהיה שייכת לשפה. כדי לראות את זה, בואו נחשב כמה אותיות מכל סוג יש במילה הזו. לא נוכל לדעת במדויק, אבל נוכל לקבל חסם. למשל, אנחנו יודעים שהמקום שבו ה-{::nomarkdown}\( a\){:/nomarkdown}-ים נגמרים הוא לכל היותר בתוך {::nomarkdown}\( w\){:/nomarkdown}, כי כבר ראינו ש-{::nomarkdown}\( x\){:/nomarkdown} חייב להכיל רק {::nomarkdown}\( b\){:/nomarkdown}-ים. לכן מספר ה-{::nomarkdown}\( a\){:/nomarkdown}-ים במילה חסום מלמעלה על ידי {::nomarkdown}\( \left\|t_{1}\right\|+i\left\|v\right\|+\left\|w\right\|\){:/nomarkdown}. באופן דומה, מספר ה-{::nomarkdown}\( c\){:/nomarkdown}-ים במילה חסום מלמעלה על ידי {::nomarkdown}\( \left\|t_{3}\right\|+j\left\|x^{\prime}\right\|+\left\|w^{\prime}\right\|\){:/nomarkdown}. לעומת זאת, את מספר ה-{::nomarkdown}\( b\){:/nomarkdown}-ים במילה אני יכול לחסום <strong>מלמטה</strong>: אני יודע שלכל הפחות כל {::nomarkdown}\( x\){:/nomarkdown} הוא {::nomarkdown}\( b\){:/nomarkdown}-ים, ושכל {::nomarkdown}\( v^{\prime}\){:/nomarkdown} הוא {::nomarkdown}\( b\){:/nomarkdown}-ים, ולכן גם {::nomarkdown}\( t_{2}\){:/nomarkdown} שכלוא בין שניהם חייב להיות כולו {::nomarkdown}\( b\){:/nomarkdown}-ים, ולכן קיבלנו שמספר ה-{::nomarkdown}\( b\){:/nomarkdown}-ים הוא לפחות {::nomarkdown}\( i\left\|x\right\|+\left\|t_{2}\right\|+j\left\|v^{\prime}\right\|\){:/nomarkdown}. ואני יודע גם קצת יותר מזה - אני יודע ש-{::nomarkdown}\( \left\|x\right\|=\left\|v\right\|\){:/nomarkdown} וש-{::nomarkdown}\( \left\|v^{\prime}\right\|=\left\|x^{\prime}\right\|\){:/nomarkdown}.

יש כאן כבר יותר מדי אותיות ותגים וסימונים, אז בואו נשנה אותם כדי שיהיה יותר קל להבין מה קורה פה. נסמן ב-{::nomarkdown}\( f\left(\sigma\right)\){:/nomarkdown} את מספר המופעים של {::nomarkdown}\( \sigma\){:/nomarkdown}. אז יש לנו את המשוואות הבאות:

{::nomarkdown}\( f\left(a\right)\le A+i\alpha\){:/nomarkdown}

{::nomarkdown}\( f\left(c\right)\le C+j\beta\){:/nomarkdown}

{::nomarkdown}\( f\left(b\right)\ge B+i\alpha+j\beta\){:/nomarkdown}

כאשר {::nomarkdown}\( A,B,C,\alpha,\beta\){:/nomarkdown} הם קבועים חיוביים כלשהם. עכשיו הרבה יותר קל לראות מה קורה פה. כך למשל נניח שאנו רוצים להבטיח ש-{::nomarkdown}\( f\left(a\right)&lt;f\left(b\right)\){:/nomarkdown}, כלומר ש-{::nomarkdown}\( A+i\alpha&lt;B+i\alpha+j\beta\){:/nomarkdown}; נעביר אגפים ונקבל שצריך להתקיים {::nomarkdown}\( j&gt;\frac{A-B}{\beta}\){:/nomarkdown}. באופן דומה כדי שיתקיים {::nomarkdown}\( f\left(c\right)&lt;f\left(b\right)\){:/nomarkdown} צריך להתקיים {::nomarkdown}\( i&gt;\frac{C-B}{\alpha}\){:/nomarkdown}. שימו לב שהחסמים הללו על הערכים של {::nomarkdown}\( i,j\){:/nomarkdown} לא תלויים זה בזה, כך שאין לנו בעיה לבחור ערכים מספיק גדולים עבור שניהם, מה שיסיים את ההוכחה - הראינו שאם אין למילה שלנו שני עצי גזירה שונים אלא עץ גזירה יחיד, אז אפשר לנצל את עץ הגזירה הזה כדי לגזור מילה אחרת שהיא בבירור לא בשפה. זה מסיים את ההוכחה כולה.

אני מקווה שלא כולם הלכו לאיבוד בים הפרטים הטכניים. הם לא היו נוראיים כל כך, לדעתי; אולי בגלל שאני כותב את הפוסט ולכן מוכרח להרגיש "בידיים" מה הולך שם (בקריאה נטו של פרטים טכניים תמיד יותר קל ללכת לאיבוד). התוצאה אינה כה מסובכת מבחינה רעיונית - בעזרת הלמה של אוגדן יש לנו שליטה רבה יותר על האופן שבו מילים מנופחות, וכדי להראות שלא קיים דקדוק חד משמעי אנחנו מייצרים את אותה מילה בשתי דרכים שונות מהותית על ידי ניפוחים שונים של מילים פשוטות יותר. לטעמי זו הייתה תוצאה יפה מאוד.
