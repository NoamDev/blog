---
id: 206
title: "פונקציות יוצרות"
date: 2009-09-08 07:27:56
layout: post
categories: 
  - אנליזה מתמטית
  - קומבינטוריקה
---
אחת מהבעיות הבסיסיות בקומבינטוריקה היא בעיית הספירה של אובייקטים. יש קבוצה של אובייקטים מסוג מסויים - נניח, מספרים שמקיימים תכונה מסויימת, גרפים שנראים כך וכך, דרכים לחלק גלידה לילדים, קלטים האפשריים לאלגוריתם וכו', ואנחנו רוצים לדעת כמה בדיוק יש. לרוב התשובה הפשוטה לשאלות הללו היא "אינסוף" (כמה מספרים ראשוניים יש? אינסוף. לא הכי אינפורמטיבי) וצריך לחדד את השאלה - למשל, לשאול "כמה אובייקטים מכל גודל יש", כש"גודל" מוגדר בהתאם לשאלה. את שאלת המספרים הראשוניים אפשר לחדד ל"כמה מספרים ראשוניים בני {::nomarkdown}\( n\){:/nomarkdown} ספרות יש" (אם כי בפועל, השאלה שבה מתעניינים היא בעיקר "כמה מספרים ראשוניים הקטנים מ-{::nomarkdown}\( n\){:/nomarkdown} קיימים", וזה ראוי לפוסט נפרד). ב"דרכים לחלק גלידה לילדים" אפשר לדבר על הדרכים לחלק גלידה ל-{::nomarkdown}\( n\){:/nomarkdown} ילדים. כשמדברים על גרפים בעלי תכונה מסויימת, אפשר לדבר על גרפים בעלי {::nomarkdown}\( n\){:/nomarkdown} צמתים שמקיימים את התכונה, וכדומה. בשורה התחתונה, לכל אוסף אובייקטים שכזה אנחנו מתאימים סדרה אינסופית {::nomarkdown}\( a_{0},a_{1},a_{2},\dots,a_{n},\dots\){:/nomarkdown} של מספרים טבעיים, שמתארת כמה אובייקטים מכל "גודל" קיימים.

אלא מה? מכיוון שזוהי סדרה אינסופית, לא בהכרח קל לתת לה תיאור קומפקטי. כמובן שכל בעיה קומבינטורית מתחילה מהגדרה מילולית כלשהי של הקבוצה שאותה מונים, אבל זה לא בהכרח מספק מידע כלשהו על הכמות שלהם. אתן דוגמה מייצגת אחת, שאשתמש בה בהמשך - <a href="http://en.wikipedia.org/wiki/Motzkin_number">מסלולי מוצקין</a>. חשבו שאתם מטיילים על דף משבצות - מתחילים מנקודה שאתם מסמנים שרירותית בתור {::nomarkdown}\( \left(0,0\right)\){:/nomarkdown}, ובכל פעם הולכים לנקודה שמימין לנקודה הנוכחית. יש לכם שלוש אפשרויות - או ללכת באלכסון ימינה ולמעלה (כלומר, לזוז מ-{::nomarkdown}\( \left(0,0\right)\){:/nomarkdown} אל {::nomarkdown}\( \left(1,1\right)\){:/nomarkdown}), או ללכת ימינה בלבד (אל {::nomarkdown}\( \left(1,0\right)\){:/nomarkdown}) או ללכת באלכסון ימינה ולמטה (אל {::nomarkdown}\( \left(1,-1\right)\){:/nomarkdown}). כעת מבצעים עוד צעד, ועוד אחד, וכן הלאה וכן הלאה. באופן כללי נגיע לקוארדינטות מהצורה {::nomarkdown}\( \left(a,b\right)\){:/nomarkdown} כאשר {::nomarkdown}\( a,b\){:/nomarkdown} שניהם שלמים ו-{::nomarkdown}\( a\){:/nomarkdown} חיובי (ליתר דיוק, אחרי {::nomarkdown}\( n\){:/nomarkdown} צעדים נגיע לקוארדינטה {::nomarkdown}\( \left(n,b\right)\){:/nomarkdown}, כלומר רק "הגובה" שבו אנו נמצאים אחרי {::nomarkdown}\( n\){:/nomarkdown} צעדים יכול להיות שונה מטיול לטיול).

הבה נשית עוד מגבלה על המסלולים - נאסור על {::nomarkdown}\( b\){:/nomarkdown} להיות שלילי, בכלל, בכל שלב של הטיול. לכן הצעד הראשון כבר לא יכול להיות "ימינה ולמטה"; רק אחרי שנבצע צעד ימינה ולמעלה, ירידה למטה תהיה בכלל לגיטימית. מגבלה אחרונה היא שהמסלול חייב להסתיים בגובה 0. כעת אפשר להגדיר במדוייק - מסלול מוצקין מאורך {::nomarkdown}\( n\){:/nomarkdown} הוא מסלול בן {::nomarkdown}\( n\){:/nomarkdown} צעדים שעונה לדרישות הללו (ולכן מסתיים ב-{::nomarkdown}\( \left(n,0\right)\){:/nomarkdown}). כעת נשאלת השאלה - כמה מסלולים כאלו יש? אם תשחקו קצת עם דף משבצות תגלו שיש מסלול בודד מאורך 1 ("רק ימינה"), שני מסלולים מאורך 2 ("פעמיים ימינה" או "למעלה וימינה ואז למטה וימינה), ארבעה מסלולים מאורך 3 וכן הלאה. נסמן ב-{::nomarkdown}\( a_{n}\){:/nomarkdown} את מספר המסלולים מאורך {::nomarkdown}\( n\){:/nomarkdown} - מהו {::nomarkdown}\( a_{n}\){:/nomarkdown}? האם יש נוסחה עבורו?

וכאן הגענו לבעיה - אמנם, את {::nomarkdown}\( a_{n}\){:/nomarkdown} עלה בידינו להגדיר מילולית, אבל נוסחה אין. זו בעיה נפוצה למדי - לפעמים קשה למצוא את הנוסחה, ולפעמים אפילו לא קיימת נוסחה שאפשר לכתוב במדוייק. אם כן, כדאי לחפש דרכי ייצוג נוספות לכל הסדרה {::nomarkdown}\( a_{0},a_{1},a_{2},\dots\){:/nomarkdown}, רצוי דרכים שבהן קל לבצע מניפולציות לייצוג ולהפיק ממנו מידע על הסדרה. <a href="http://he.wikipedia.org/wiki/%D7%A4%D7%95%D7%A0%D7%A7%D7%A6%D7%99%D7%94_%D7%99%D7%95%D7%A6%D7%A8%D7%AA">פונקציה יוצרת</a> היא אחת מהדרכים המעניינות לעשות זאת.

ישנם מספר סוגים שונים של פונקציות יוצרות, ואציג כאן את הסטנדרטית. אתחיל מהגדרה פורמלית ורק אחר כך אעבור להצדקות. פורמלית, אם כן, פונקציה יוצרת היא הפונקציה {::nomarkdown}\( f\left(x\right)=\sum_{n=0}^{\infty}a_{n}x^{n}\){:/nomarkdown}. כלומר, טור אינסופי של חזקות של {::nomarkdown}\( x\){:/nomarkdown}, כך שהמקדם של החזקה ה-{::nomarkdown}\( n\){:/nomarkdown}-ית הוא בדיוק המספר {::nomarkdown}\( a_{n}\){:/nomarkdown} שאנחנו מנסים "לקודד". מה המשמעות של לקרוא ליצור הזה "פונקציה"? פונקציה היא בדרך כלל יצור שאם מציבים לו ערכים של {::nomarkdown}\( x\){:/nomarkdown} מקבלים פלטים - האם זה כך במקרה של {::nomarkdown}\( f\left(x\right)\){:/nomarkdown}? התשובה היא "כן ולא", וזה אולי מה שהופך את הפונקציות היוצרות לעסק די מבלבל.

התשובה הבסיסית היא "לא". אנחנו לא חושבים על הפונקציה היוצרת כמשהו שמחוייב לתת תשובה ל"מה אני מקבל אם אני מציב כך וכך במקום {::nomarkdown}\( x\){:/nomarkdown}". אנחנו חושבים עליה בתור אובייקט "פורמלי", בתור אוסף הסימנים {::nomarkdown}\( \sum_{n=0}^{\infty}a_{n}x^{n}\){:/nomarkdown} ותו לא. לאוסף הזה ניתן לבצע מניפולציות - למשל, לכפול אותו בפונקציה יוצרת אחרת - אבל אנחנו לא מטריחים את עצמנו בשאלה של הצבת ערכים ל-{::nomarkdown}\( x\){:/nomarkdown}. דרך התבוננות זו עשויה להיראות מוזרה מאוד בתחילה, ולכן כדאי להזכיר שזו בדיוק הגישה של המתמטיקה ל<a href="http://he.wikipedia.org/wiki/%D7%A4%D7%95%D7%9C%D7%99%D7%A0%D7%95%D7%9D">פולינומים</a>. במתמטיקה מתייחסים ליצורים כמו {::nomarkdown}\( x^{3}+2x+5\){:/nomarkdown} בתור יצור עם זכות קיום עצמאית - אפשר לכפול אותו בפולינום {::nomarkdown}\( x+1\){:/nomarkdown} ולקבל פולינום חדש; אפשר אפילו לחלק אותו בפולינום הזה ולקבל שארית; אפשר לחבר ולחסר אותו; אפשר אפילו "לגזור" אותו (הנגזרת תהיה {::nomarkdown}\( 3x^2+2\){:/nomarkdown}) מבלי להשתמש כלל במושגים מחשבון אינפיניטסימלי. כל הדברים הללו הם פשוט הגדרות; אפשר להגדיר במפורש שסכום של שני פולינומים הוא הפולינום שבו כל מקדם הוא סכום של מקדמי הפולינומים המחוברים (יש כאן הסתמכות על כך שמושג ה"סכום של מקדמים" כבר קיים). ההבדל היחיד הוא שפולינום הוא יצור סופי, ואילו הפונקציה היוצרת מתוארת על ידי סכום אינסופי - "פולינום אינסופי" אם תרצו. זה הבדל פחות משמעותי משזה עשוי להיראות.

עם זאת, אעדיף לא לדבוק בדרך ההצגה הזו, כי ממילא אני מחבב את השניה וארצה לדבר עליה הרבה בהמשך - אז בואו נחשוב על הפונקציה היוצרת כן בתור פונקציה, ונשאל את עצמנו - עבור אילו ערכים של {::nomarkdown}\( x\){:/nomarkdown} היא בכלל מוגדרת? מה בכלל המשמעות של טור אינסופי שכזה?

אם נציב ערך כלשהו ב-{::nomarkdown}\( x\){:/nomarkdown}, נאמר מספר ממשי {::nomarkdown}\( t\){:/nomarkdown}, נקבל טור של מספרים: {::nomarkdown}\( \sum_{n=0}^{\infty}a_{n}t^{n}\){:/nomarkdown}. בחשבון האינפיניטסימלי נותנים הגדרה סבירה לסכום של טור שכזה - <a href="http://www.gadial.net/?p=134">דיברתי על כך בעבר</a>. עם זאת, לא מובטח כי לכל ערך של {::nomarkdown}\( t\){:/nomarkdown} ההגדרה "תעבוד" (בניסוח פורמלי - "הטור יתכנס"). לכן הפונקציה {::nomarkdown}\( f\left(x\right)=\sum_{n=0}^{\infty}a_{n}x^{n}\){:/nomarkdown} אינה מוגדרת בהכרח לכל {::nomarkdown}\( t\){:/nomarkdown}. למרבה המזל, בגלל הצורה המיוחדת של הטור הזה (סכום של מכפלת מקדם בחזקה של {::nomarkdown}\( x\){:/nomarkdown}), ניתן להגיד דברים בצורה יותר מסודרת על הטור - בפרט, או שהוא מתכנס לכל {::nomarkdown}\( x\){:/nomarkdown}, או שקיים מספר ממשי {::nomarkdown}\( R\){:/nomarkdown} כך שלכל {::nomarkdown}\( \left\|x\right\|&lt;R\){:/nomarkdown} הטור מתכנס. ל-{::nomarkdown}\( R\){:/nomarkdown} הזה קוראים "רדיוס ההתכנסות של הטור" מסיבה שאסביר בקרוב.

לדוגמה, הטור {::nomarkdown}\( 1+x+\frac{x^{2}}{2}+\frac{x^{3}}{6}+\dots\){:/nomarkdown}, שאפשר לכתוב באופן קומפקטי כ-{::nomarkdown}\( \sum_{n=0}^{\infty}\frac{x^{n}}{n!}\){:/nomarkdown} (ובמילים אחרות - {::nomarkdown}\( a_{n}=\frac{1}{n!}\){:/nomarkdown}) מתכנס לכל ערך של {::nomarkdown}\( x\){:/nomarkdown}. מתברר כי הפונקציה שטור זה מייצג היא הפונקציה האקספוננציאלית, {::nomarkdown}\( e^{x}\){:/nomarkdown}. לעומת זאת, הטור {::nomarkdown}\( 1+x+x^{2}+x^{3}+\dots\){:/nomarkdown} (כלומר, {::nomarkdown}\( a_{n}=1\){:/nomarkdown}) מתכנס לכל {::nomarkdown}\( \left\|x\right\|&lt;1\){:/nomarkdown} אך לא עבור {::nomarkdown}\( x=1\){:/nomarkdown} או ערכים גדולים יותר. הטור הזה מייצג את הפונקציה {::nomarkdown}\( \frac{1}{1-x}\){:/nomarkdown} (ניתן לראות זאת באמצעות הנוסחה לטור הנדסי אינסופי), שבה אכן קל לראות "בעיניים" כי יש לנו בעיה כלשהי בנקודה 1. עם זאת, וזה הדבר המעניין כאן, הטור אינו מתכנס גם עבור {::nomarkdown}\( x=-1\){:/nomarkdown}, למרות שהפונקציה {::nomarkdown}\( f\left(x\right)=\frac{1}{1-x}\){:/nomarkdown} דווקא "מתנהגת יפה" באותה נקודה (היא שווה {::nomarkdown}\( \frac{1}{2}\){:/nomarkdown}). מכאן שהטור והפונקציה מפסיקים להתנהג באותו האופן ברגע שבו מגיעים אל רדיוס ההתכנסות, ולא בהכרח רק בנקודות שהן בעייתיות מבחינת הפונקציה.

עד כה התעסקנו רק במספרים ממשיים, אבל זה לא הכרחי - כל התורה של טורים מתכנסים עוברת היטב גם למספרים מרוכבים, עם אותן תוצאות - לטור מהצורה {::nomarkdown}\( \sum_{n=0}^{\infty}a_{n}x^{n}\){:/nomarkdown} (עכשיו כבר אפשר לומר שיש לו שם מיוחד - "<a href="http://he.wikipedia.org/wiki/%D7%98%D7%95%D7%A8_%D7%97%D7%96%D7%A7%D7%95%D7%AA">טור חזקות</a>", Power series) יהיה רדיוס התכנסות {::nomarkdown}\( R\){:/nomarkdown} כך שלכל מספר מרוכב המקיים {::nomarkdown}\( \left\|z\right\|&lt;R\){:/nomarkdown}, הטור יתכנס. מכיוון שאפשר לחשוב על המספרים המרוכבים כעל נקודות במישור דו ממדי, שציר ה-{::nomarkdown}\( x\){:/nomarkdown} שלו הוא המספרים הממשיים, יש משמעות ברורה כעת למונח "רדיוס התכנסות" - לטור חזקות בעל רדיוס התכנסות {::nomarkdown}\( R\){:/nomarkdown} יש עיגול ברדיוס {::nomarkdown}\( R\){:/nomarkdown} שמרכזו בראשית הצירים ובכל נקודה בו (למעט נקודות על השפה) הטור מתכנס. ההרחבה הזו למרוכבים היא מאירת עיניים למדי. לדוגמה, נתבונן בטור {::nomarkdown}\( 1-x^{2}+x^{4}-x^{6}+\dots\){:/nomarkdown}, שמתכנס לפונקציה {::nomarkdown}\( \frac{1}{1+x^{2}}\){:/nomarkdown}; הטור לא מתכנס לא עבור {::nomarkdown}\( 1\){:/nomarkdown} ולא עבור {::nomarkdown}\( -1\){:/nomarkdown}, ועם זאת הפונקציה {::nomarkdown}\( f\left(x\right)=\frac{1}{1+x^{2}}\){:/nomarkdown} בכלל לא רומזת שיהיו בעיות בנקודות אלו (שהרי ערכה בהן הוא {::nomarkdown}\( \frac{1}{2}\){:/nomarkdown}). התובנה מגיעה רק כשחושבים על הפונקציה הזו כפונקציה מרוכבת ושמים לב לכך שבנקודה {::nomarkdown}\( x=i\){:/nomarkdown} היא בכלל לא מוגדרת - והרי {::nomarkdown}\( \left\|i\right\|=\left\|1\right\|=\left\|-1\right\|=1\){:/nomarkdown}. הדוגמה הזו זכורה לי כאחת הדוגמאות הראשונות שנתקלתי בהן כהמחשה לצורה שבה המספרים המרוכבים הם הרחבה טבעית של הממשיים, ולטעמי היא עדיין אחת מהיפות שבהן.

טוב, חזרה לענייננו. הטור {::nomarkdown}\( f\left(x\right)=\sum_{n=0}^{\infty}a_{n}x^{n}\){:/nomarkdown} מתכנס תמיד בנקודה {::nomarkdown}\( 0\){:/nomarkdown} אז אפשר להיות רגועים ולחשוב על {::nomarkdown}\( \sum_{n=0}^{\infty}a_{n}x^{n}\){:/nomarkdown} תמיד כפונקציה חוקית, פשוט עם רדיוס התכנסות לא ידוע. כעת ניתן להתייחס לפונקציה הזו כפונקציה מרוכבת לכל דבר ולהתעלל בה - לכפול אותה באחרות, לגזור אותה וכו' - ומאחורי כל הדברים הללו יהיה הגיון מתמטי כלשהו ולא רק פורמליזם. כעת אפשר לעבור לשאלה הבאה - איך מוצאים תיאור נוח של הפונקציה הזו, ומה עושים איתו?

לשאלה הראשונה אין תשובה חד משמעית - כל בעיה קומבינטורית מציבה אתגר שונה. עם זאת, לעתים קרובות מציאת הפונקציה היוצרת של סדרה קלה בהרבה ממציאת נוסחה לאיבר הכללי. הבעיה של מסלולי מוצקין היא דוגמה טובה לכך - איני מכיר שום נוסחה כללית לאיבר ה-{::nomarkdown}\( n\){:/nomarkdown}-י של מספרי מוצקין שאינה מערבת סכום כלשהו, אבל ניתן למצוא מאוד בקלות את הפונקציה היוצרת שלהם. הרעיון הוא לבנות משוואה כלשהי שהפונקציה היוצרת מקיימת ולחלץ אותה ממנה. אעשה זאת במהירות יחסית, כי זה לא העיקר כאן - מי שאין לו נסיון כלשהו בקומבינטוריקה כנראה יאבד אותי - זה לא סוף העולם.

המשוואה שאציג מתבססת על אבחנה פשוטה: אם {::nomarkdown}\( f\left(x\right)\){:/nomarkdown} היא הפונקציה היוצרת של הסדרה {::nomarkdown}\( a_{n}\){:/nomarkdown}, אז {::nomarkdown}\( x\cdot f\left(x\right)\){:/nomarkdown} הוא הפונקציה היוצרת של הסדרה {::nomarkdown}\( b_{n}\){:/nomarkdown} שמוגדרת על ידי {::nomarkdown}\( b_{0}=0\){:/nomarkdown} ו-{::nomarkdown}\( b_{n}=a_{n-1}\){:/nomarkdown} לכל {::nomarkdown}\( n&gt;0\){:/nomarkdown} (למה?). כלומר, אם {::nomarkdown}\( a_{n}\){:/nomarkdown} הוא "מספר האיברים מגודל {::nomarkdown}\( n\){:/nomarkdown}", אז {::nomarkdown}\( b_{n}\){:/nomarkdown} יהיה דווקא "מספר האיברים מגודל {::nomarkdown}\( n-1\){:/nomarkdown}". כעת לפאנץ': מהו מספר מסלולי מוצקין מאורך {::nomarkdown}\( n\){:/nomarkdown}? אפשר לחלק את בעיית הספירה הזו לשתי אפשרויות, על פי הצעד הראשון במסלול. אם הצעד הראשון היה פשוט ימינה, אז מספר הדרכים להמשיך את המסלול ולקבל מסלול חוקי הוא כמספר מסלולי מוצקין מאורך {::nomarkdown}\( n-1\){:/nomarkdown} (שוב, מדוע?). הפונקציה שמתארת את הסדרה הזו היא בדיוק {::nomarkdown}\( xf\left(x\right)\){:/nomarkdown} שלעיל.

אם הצעד הראשון היה למעלה, הרי שמתישהו בהמשך הדרך חייב להיות צעד למטה שיחזיר אותנו לגובה 0. מה קורה בין שני הצעדים הללו? יש תת מסלול, שגם הוא נראה כמו מסלול מוצקין, אם ממקמים את ראשית הצירים שלנו דווקא בנקודה {::nomarkdown}\( \left(1,1\right)\){:/nomarkdown} שאליה הגיע המסלול אחרי העליה. ומה קורה אחרי הירידה? שוב, יהיה לנו מסלול מוצקין חדש, מנקודת הירידה ועד לנקודת הסיום. כלומר, מה היה לנו? שני צעדים "מבוזבזים", ושני מסלולי מוצקין, כך שכל זוג של שני מסלולים אפשריים ייתן לנו את המסלול המשולב. הפונקציה שמתארת את זה היא {::nomarkdown}\( x^{2}f^{2}\left(x\right)\){:/nomarkdown} ({::nomarkdown}\( x^{2}\){:/nomarkdown} כדי "להפחית" את שני הצעדים שבוצעו; {::nomarkdown}\( f^{2}\left(x\right)\){:/nomarkdown} כי כל מסלול בנפרד הוא {::nomarkdown}\( f\left(x\right)\){:/nomarkdown}, ולכן השילוב של שניהם בזה אחר זה נותן {::nomarkdown}\( f\left(x\right)\cdot f\left(x\right)\){:/nomarkdown} - כאן אנחנו מבצעים בדיוק את התעלול שלא היה ניתן לבצע אם היינו מסתכלים על כל {::nomarkdown}\( a_{n}\){:/nomarkdown} לבדו ולא על "כולם ביחד" כמו שמאפשרת לנו {::nomarkdown}\( f\left(x\right)\){:/nomarkdown}). מחיבור שתי האפשרויות (או צעד ימינה, או צעד באלכסון) מקבלים את המשוואה {::nomarkdown}\( f\left(x\right)=xf\left(x\right)+x^{2}f^{2}\left(x\right)+1\){:/nomarkdown}, כאשר ה-{::nomarkdown}\( +1\){:/nomarkdown} מגיע מכך שאנו סופרים גם את המסלול מאורך 0 (זה "תנאי העצירה" של ההסתכלות הרקורסיבית שלנו על הבעיה). קיבלנו משוואה ריבועית ב"נעלם" {::nomarkdown}\( f\left(x\right)\){:/nomarkdown}, שניתן לחלץ ממנה את {::nomarkdown}\( f\left(x\right)\){:/nomarkdown} בטכניקות אלגבריות רגילות - מקבלים {::nomarkdown}\( f\left(x\right)=\frac{1-x-\sqrt{1-2x-3x^{2}}}{2x^{2}}\){:/nomarkdown} (למה בחרתי את הפתרון הזה מבין שני פתרונות המשוואה? כי כפי שאראה בהמשך, בסביבות {::nomarkdown}\( x=0\){:/nomarkdown} הוא מתנהג נחמד ואילו הפתרון השני לא, ולכן לא ייתכן שהפתרון השני מייצג את הטור שלנו).

אוקיי, לנשום עמוק. לא חייבים להבין עד הסוף את מה שעשיתי כאן - זה תרגיל בקומבינטוריקה. מה שמעניין הוא שעשיתי טריקים שלא ניתן לבצע אם מחפשים נוסחת נסיגה "רגילה" עבור {::nomarkdown}\( a_{n}\){:/nomarkdown} - הייתה לי יותר גמישות, ולכן בסוף עלה בידי להגיע לנוסחה סגורה (זה לא תמיד כך - בוריאציות יותר מורכבות על מסלולים אפשר לקבל משוואות ממעלה גבוהה שלא קיים להן פתרון סגור - אבל לא תמיד חייבים אפילו פתרון סגור כדי להפיק מידע על הפונקציה היוצרת).

משמצאנו את הפונקציה היוצרת, השאלה הבאה היא תמיד "מה הלאה?". מה כבר יצא לנו ממציאת הפונקציה? האם זה אומר שנוכל בעזרתה לחשב את {::nomarkdown}\( a_{n}\){:/nomarkdown}? לפעמים זה אכן כך, אבל לא במקרה שלפנינו. מה כן אפשר לעשות? להשתמש בפונקציה היוצרת כדי לקבל הערכה כלשהי לגבי סדר הגודל של {::nomarkdown}\( a_{n}\){:/nomarkdown}, בפרט "כמה מהר" הוא גדל. לא אציג כאן את כל התיאוריה של מדידת קצב הגידול אלא אסתפק במדד בסיסי יחסית. נתחיל בדוגמה פשוטה: נניח כי {::nomarkdown}\( a_{n}=2^{n}\){:/nomarkdown}, כלומר כשמגדילים את {::nomarkdown}\( n\){:/nomarkdown} ב-1, {::nomarkdown}\( a_{n}\){:/nomarkdown} גדל "פי שתיים". עבור {::nomarkdown}\( a_{n}=3^{n}\){:/nomarkdown} הגדלה ב-1 גוררת גידול "פי 3". ומה קורה עבור סדרות שבהן הגידול אינו תמיד במדוייק פי משהו? האם עדיין ניתן להגיד כי "הסדרה גדלה בערך פי {::nomarkdown}\( \lambda\){:/nomarkdown} כשמגדילים את {::nomarkdown}\( n\){:/nomarkdown} ב-1"? התשובה חיובית אם הגבול {::nomarkdown}\( \lambda=\lim_{n\to\infty}\left(a_{n}\right)^{\frac{1}{n}}\){:/nomarkdown} קיים. המשמעות של הגבול כאן היא פשוט "כש-{::nomarkdown}\( a_{n}\){:/nomarkdown} גדול, הערך שלו מאוד קרוב לערך של {::nomarkdown}\( \lambda^{n}\){:/nomarkdown}" (עם פורמליסטיקה שהופכת את "מאוד קרוב" למשהו מדוייק מתמטית). לכן האתגר הוא לחשב את ה-{::nomarkdown}\( \lambda\){:/nomarkdown} הזה. אם ידועה לנו הפונקציה היוצרת של {::nomarkdown}\( a_{n}\){:/nomarkdown}, העסק נהיה פשוט יותר - משפט של קושי על טורי חזקות מראה כי {::nomarkdown}\( \lambda=\frac{1}{R}\){:/nomarkdown} כאשר {::nomarkdown}\( R\){:/nomarkdown} הוא רדיוס ההתכנסות של טור החזקות - לכן כל מה שצריך לעשות הוא לגלות את רדיוס ההתכנסות הזה. כאן הפונקציה היוצרת נכנסת לעניין - מסתכלים עליה כעל פונקציה מרוכבת, ומחפשים את הנקודות שלה שבהן יש "תקלה" - למשל, חלוקה באפס, או הוצאת שורש ממספר שלילי, וכדומה. לתקלות כאלו קוראים "סינגולריות" בתורת הפונקציות המרוכבות - להסביר במדוייק איך הן מוגדרות ואיך מסווגים אותם זה בהחלט משהו שלא ניתן לבצע במסגרת הפוסט הזה. עם זאת, השורה התחתונה פשוטה - לרוב ניתן להסיק את רדיוס ההתכנסות מנקודות הסינגולריות. במקרה של מספרי מוצקין זה פשוט יחסית. הנקודות ה"בעייתיות" הן {::nomarkdown}\( x=0\){:/nomarkdown} (שמאפס את המכנה) והשורשים של {::nomarkdown}\( 1-2x-3x^{2}\){:/nomarkdown} (למה ה"פיצוץ" קורה דווקא בשורשים ולא בנקודות שנותנות כבר ערך שלילי? שוב, זה מסובך מדי מכדי שאוכל להסביר זאת על רגל אחת; רק אעיר שהשורשים הללו הם מה שנקרא "נקודות הסתעפות" של הפונקציה).

הנקודה {::nomarkdown}\( x=0\){:/nomarkdown} אינה בעייתית באמת - שוב, קשה להסביר מדוע על רגל אחת, אבל כאשר {::nomarkdown}\( x\){:/nomarkdown} שואף לאפס, {::nomarkdown}\( f\left(x\right)\){:/nomarkdown} שואף ל-{::nomarkdown}\( 1\){:/nomarkdown} בצורה "רגועה" כך שהאפס במכנה לא באמת גורם להתפוצצות - היה אפשר להגדיר {::nomarkdown}\( f\left(0\right)=1\){:/nomarkdown} וחסל. לכן נשאר לטפל בנקודות שמאפסות את {::nomarkdown}\( 1-2x-3x^{2}\){:/nomarkdown}. למצוא אותן זה פתרון משוואה ריבועית - אלו הן {::nomarkdown}\( \frac{1}{3}\){:/nomarkdown} ו-{::nomarkdown}\( -1\){:/nomarkdown}. שתיהן בעייתיות "באמת". רדיוס ההתכנסות הוא כמרחק הנקודה הבעייתית הראשונה מהראשית - כלומר, {::nomarkdown}\( R=\frac{1}{3}\){:/nomarkdown}, ולכן קצב הגידול של מספרי מוצקין הוא {::nomarkdown}\( \lambda=3\){:/nomarkdown}. זו תוצאה מעניינת, כי היא מראה שהמגבלה של "אסור לרדת מתחת לציר {::nomarkdown}\( x\){:/nomarkdown}, חייבים לסיים בגובה 0" אינה מהותית כל כך - מספר המסלולים <strong>הכולל</strong> מאורך {::nomarkdown}\( n\){:/nomarkdown} שבהם מותרים שלושת הצעדים של מוצקין אבל בלי שום מגבלה אחרת הוא {::nomarkdown}\( 3^{n}\){:/nomarkdown}, כלומר גם לו אותו קצב גידול.

כל המהומה הזו הייתה רק דוגמה אחת למידע שניתן להפיק מפונקציות יוצרות. השורה התחתונה של כל זה היא שהן יצורים מעניינים ומועילים, והיינו רוצים להיות מסוגלים לחשב אותן אלגוריתמית עבור מחלקה גדולה ככל האפשר של אובייקטים קומבינטוריים.

וכאן חוזרות לתמונה השפות הרגולריות של <a href="http://www.gadial.net/?p=204">הפוסט הקודם</a>.
