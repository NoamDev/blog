---
id: 195
title: "משפט דיריכילה על סדרות חשבוניות"
date: 2009-05-25 11:48:14
layout: post
categories: 
  - תורת המספרים
tags: 
  - מספרים ראשוניים
  - משפט דיריכלה
  - פונקצית הזטא של רימן
  - תורת המספרים האנליטית
---
פרט להיותו מעניין (ואפילו שימושי) לכשעצמו, משפט דיריכלה יכול להיחשב לתוצאה המשמעותית הראשונה של <a href="http://en.wikipedia.org/wiki/Analytic_number_theory">תורת המספרים האנליטית</a> - אולי אפילו לתוצאה שפתחה את התחום והראתה שאפשר להוכיח דברים לא טריוויאליים, שהניסוח שלהם הוא אלגברי למהדרין, בעזרת שיטות אנליטיות, וזאת כשלא ידועות על שיטות אלגבריות פשוטות יותר (בכך הוא שונה מ<a href="http://www.gadial.net/?p=194">הוכחת אוילר על קיום אינסוף ראשוניים</a>, שכן קיימת לטענה ההיא הוכחה אלגברית פשוטה). לטעמי, הוכחת המשפט היא אכן יפה - פתאום מתברר מדוע ניתוחים של התנהגות אנליטית של פונקציות בסביבת נקודה מסויימת יכולות לתת מידע אלגברי לא טריוויאלי.

אם כן, נתחיל בלהסביר על מה בכלל מדובר. <a href="http://he.wikipedia.org/wiki/%D7%9E%D7%A1%D7%A4%D7%A8_%D7%A8%D7%90%D7%A9%D7%95%D7%A0%D7%99">מספר ראשוני</a>, כזכור, הוא מספר שמתחלק רק בעצמו וב-1, והמספרים הראשוניים מעניינים שכן במובן מסויים הם "אבני הבניין" של כל יתר המספרים (כל מספר ניתן לכתיבה באופן יחיד כמכפלת ראשוניים). ניתן להוכיח שיש אינסוף ראשוניים, אבל האם ניתן להגיד משהו מעניין על ההתפלגות שלהם?

דוגמה לשאלה פשוטה שאפשר לשאול היא "האם יש אינסוף ראשוניים שמשאירים שארית 0 כשמחלקים אותם ב-4?" והתשובה כמובן שלילית, שכן אם השארית היא 0, אז המספר מתחלק ב-4 וודאי שאינו ראשוני. בדומה, שאלה כמו "האם יש אינסוף ראשוניים שמשאירים שארית 2 כשמחלקים אותם ב-4?" היא טיפשית, שכן מספר שמקיים תכונה זו מתחלק בודאות ב-2, ולכן יש רק ראשוני אחד בעל תכונה זו - 2 עצמו. באופן דומה, אין טעם לשאול שאלה בסגנון "האם יש אינסוף ראשוניים שמשאירים שארית {::nomarkdown}\( b\){:/nomarkdown} כשמחלקים אותם ב-{::nomarkdown}\( a\){:/nomarkdown}?" כאשר יש ל-{::nomarkdown}\( a,b\){:/nomarkdown} מחלק משותף גדול מ-1, שכן המחלק המשותף הזה יחלק כל מספר שמשאיר שארית {::nomarkdown}\( b\){:/nomarkdown} כשמחלקים אותו ב-{::nomarkdown}\( a\){:/nomarkdown}. אם כן, משויתרנו על המקרה הטריוויאלי הזה, נותר לנו לשאול את עצמנו "האם יש אינסוף ראשוניים שמשאירים שארית {::nomarkdown}\( b\){:/nomarkdown} כשמחלקים אותם ב-{::nomarkdown}\( a\){:/nomarkdown}, אם ל-{::nomarkdown}\( a,b\){:/nomarkdown} אין מחלק משותף?" והתשובה המדהימה של דיריכלה היא "כן!". ולא סתם כן - אלא גם שההתפלגות של הראשוניים היא אחידה - במובן מסויים. אם קובעים את {::nomarkdown}\( a\){:/nomarkdown}, אז "כמות" הראשוניים שמשאירים שארית {::nomarkdown}\( b\){:/nomarkdown} בחלוקה ב-{::nomarkdown}\( a\){:/nomarkdown}, כאשר {::nomarkdown}\( b\){:/nomarkdown} הוא מספר שזר ל-{::nomarkdown}\( a\){:/nomarkdown} וקטן ממנו, היא זהה.

את התיאור לעיל של חלוקה אפשר לנסח גם בלשון של <a href="http://he.wikipedia.org/wiki/%D7%A1%D7%93%D7%A8%D7%94_%D7%97%D7%A9%D7%91%D7%95%D7%A0%D7%99%D7%AA">סדרות חשבוניות</a>. נתבונן בסדרה החשבונית שהאיבר הכללי שלה הוא {::nomarkdown}\( an+b\){:/nomarkdown}. הטענה היא שבסדרה הזו, אם {::nomarkdown}\( a,b\){:/nomarkdown} זרים (ללא מחלק משותף גדול מ-1), יש אינסוף ראשוניים.

כדי להבין עד כמה התוצאה הזו מעניינת כדאי לנסות ולהוכיח כמה מקרים פרטיים - למשל, להוכיח שיש אינסוף ראשוניים מהצורה {::nomarkdown}\( 4n+3\){:/nomarkdown} (זה קל, וניתן לרוב כתרגיל לסטודנטים שמתחילים ללמוד אלגברה מופשטת), או אינסוף ראשוניים מהצורה {::nomarkdown}\( 4n+1\){:/nomarkdown} (כבר יותר קשה). דיריכלה, להבדיל, לא נוקט בשיטות אד-הוקיות כדי לפתור מקרים פרטיים - הוא הורג את הבעיה כולה, לחלוטין, והוא עושה זאת על ידי הכללה של ההוכחה של אוילר לקיום אינסוף ראשוניים.

אני מזהיר מראש - ההוכחה אינה טריוויאלית כלל ועיקר. אציג את הרעיונות והכלים העיקריים שלה, אבל אפסח בצורה בוטה על ההוכחות המדוייקות ועל הפרטים העדינים (ויש הרבה פרטים עדינים), ובפרט אציין ללא הוכחה את הטענה המרכזית שבסופו של דבר מכריעה את המשפט (ונשמעת מאוד לא מרכזית במבט ראשון: "הפונקציה הזו והזו חסומה על הקטע הזה והזה").

בתור התחלה, בואו ניזכר במה שאוילר "הראה" (כאמור, מה שאני מראה כאן הוא ניסוח מדוייק יותר של מה שאוילר עשה). ראשית, הגדרנו פונקציה {::nomarkdown}\( \zeta\left(s\right)=\sum_{n=1}^{\infty}\frac{1}{n^{s}}\){:/nomarkdown} עבור ערכים ממשיים {::nomarkdown}\( s&gt;1\){:/nomarkdown} (זהו הבסיס ל<a href="http://he.wikipedia.org/wiki/%D7%A4%D7%95%D7%A0%D7%A7%D7%A6%D7%99%D7%99%D7%AA_%D7%96%D7%98%D7%90_%D7%A9%D7%9C_%D7%A8%D7%99%D7%9E%D7%9F">פונקצית הזטה</a> המפורסמת של רימן). כעת, הראינו שיש לטור הזה גם הצגה "כפלית", שבה באורח פלא הכפל הוא על פני כל המספרים הראשוניים: {::nomarkdown}\( \zeta\left(s\right)=\prod_{p}\frac{1}{1-p^{-s}}\){:/nomarkdown}. ההצגה הזו נותנת כפל על פני כל הראשוניים, אבל קל גם לקבל ממנה סכום על פני כל הראשוניים: הצורה הסטנדרטית להפיכת מכפלה לסכום היא הפעלת לוגריתם עליה (זהו אחד משימושיו המקוריים של הלוגריתם: הוא איפשר לבצע פעולות כפל על מספרים גדולים באמצעות פעולות חיבור - זהו הרעיון הבסיסי שמאחורי <a href="http://he.wikipedia.org/wiki/%D7%A1%D7%A8%D7%92%D7%9C_%D7%97%D7%99%D7%A9%D7%95%D7%91">סרגלי החישוב</a> מנוחתם עדן). ובכן, אחרי שמפעילים לוגריתם ועושים כמה להטוטים (שהבולט בהם הוא שימוש בזהות הקסומה {::nomarkdown}\( -\ln\left(1-x\right)=\sum_{n=1}^{\infty}\frac{x^{n}}{n}\){:/nomarkdown} שתקפה עבור {::nomarkdown}\( \left\|x\right\|&lt;1\){:/nomarkdown}) מקבלים כי {::nomarkdown}\( \ln\zeta\left(s\right)=\sum_{p}\frac{1}{p^{s}}+O\left(1\right)\){:/nomarkdown}. הסימון {::nomarkdown}\( O\left(1\right)\){:/nomarkdown} כאן מציין גודל שאולי משתנה כאשר {::nomarkdown}\( s\){:/nomarkdown} משתנה, אבל חסום על ידי קבוע (לסקרנים: הקבוע הוא {::nomarkdown}\( 2\zeta\left(2\right)\){:/nomarkdown}).

כעת, כאשר משאיפים את {::nomarkdown}\( s\){:/nomarkdown} ל-1, הרי ש-{::nomarkdown}\( \zeta\left(s\right)\){:/nomarkdown} שואף לאינסוף (כי כפי שאמרתי בפוסט הקודם, הטור {::nomarkdown}\( \sum_{n=1}^{\infty}\frac{1}{n}\){:/nomarkdown} מתבדר לאינסוף), ולכן גם {::nomarkdown}\( \ln\zeta\left(s\right)\){:/nomarkdown} שואף לאינסוף, ולכן הטור {::nomarkdown}\( \sum_{p}\frac{1}{p^{s}}\){:/nomarkdown} שואף לאינסוף כש-{::nomarkdown}\( s\){:/nomarkdown} שואף ל-1, כלומר {::nomarkdown}\( \sum_{p}\frac{1}{p}\){:/nomarkdown} מתבדר. זוהי ההרחבה המידיית הראשונה של הוכחת אוילר, והיא כבר הייתה ידועה בימי דיריכלה. שימו לב שהתוצאה הזו אינה סתמית כלל ועיקר - היא לא רק מראה שיש אינסוף ראשוניים (כי אם היה מספר סופי, הטור לא היה יכול להתבדר) אלא גם נותנת הערכה מיידית לפיזור שלהם. מכיוון ש-{::nomarkdown}\( \sum_{n=1}^{\infty}\frac{1}{n^{s}}\){:/nomarkdown} מתכנס לכל {::nomarkdown}\( s&gt;1\){:/nomarkdown}, מה שמעיד על כך שיש "חורים יחסית גדולים" בין האיברים אותם סוכמים בטור, המסקנה היא שהפיזור של הראשוניים בין המספרים גדול יותר מאשר הפיזור של המספרים מהצורה {::nomarkdown}\( n^{s}\){:/nomarkdown}. למשל, אם ניקח {::nomarkdown}\( s=2\){:/nomarkdown}, נוכל לומר במדוייק שהפיזור של הראשוניים בין המספרים גדול יותר מאשר הפיזור של המספרים שהם ריבוע - כלומר, אם נעבור מספר מספר ונצעק "בום" כשנראה ראשוני, זה יקרה לעתים יותר קרובות מאשר אם נצעק כשנראה ריבוע. קיימת הערכה טובה בהרבה לפיזור הזה של הראשוניים - היא נקראת "<a href="http://he.wikipedia.org/wiki/%D7%9E%D7%A9%D7%A4%D7%98_%D7%94%D7%9E%D7%A1%D7%A4%D7%A8%D7%99%D7%9D_%D7%94%D7%A8%D7%90%D7%A9%D7%95%D7%A0%D7%99%D7%99%D7%9D">משפט המספרים הראשוניים</a>" ומהווה את התוצאה הקלאסית המרכזית של תורת המספרים האנליטית. לא אכנס לכך כעת.

מה שדיריכלה ניסה לעשות הוא לבנות משוואה דומה ל-{::nomarkdown}\( \ln\zeta\left(s\right)=\sum_{p}\frac{1}{p^{s}}+O\left(1\right)\){:/nomarkdown}, כך שבאגף ימין הסכימה תהיה רק על הראשוניים {::nomarkdown}\( p\equiv a\left(q\right)\){:/nomarkdown} עבור {::nomarkdown}\( q,a\){:/nomarkdown} כלשהם שזרים זה לזה, וכך שהפונקציה שבאגף שמאל עדיין תשאף לאינסוף כש-{::nomarkdown}\( s\){:/nomarkdown} שואף ל-1. האתגר הראשון, אם כן, הוא למצוא פונקציות אנליטיות שמבטאות בצורה כלשהי את המושג של "להיות שקול ל-{::nomarkdown}\( a\){:/nomarkdown} מודולו {::nomarkdown}\( q\){:/nomarkdown}". הפונקציות שדיריכלה השתמש בהן נקראות <strong>קרקטרים</strong>. מבלי להיכנס לתורה הכללית (שניתן לסכמה, למי שמכיר, כך: קרקטר דיריכלה הוא ההרחבה הטבעית ל-{::nomarkdown}\( \mathbb{Z}\){:/nomarkdown}של הומומורפיזם מ-{::nomarkdown}\( \mathbb{Z}_{q}^{*}\){:/nomarkdown} אל {::nomarkdown}\( \mathbb{C}\){:/nomarkdown}), דיריכלה מסתכל על פונקציות {::nomarkdown}\( \chi:\mathbb{Z}\to\mathbb{C}\){:/nomarkdown}, כלומר שמקבלות מספר שלם ומחזירות מספר מרוכב, כך שמתקיימות התכונות הבאות:
<ol>
	<li> {::nomarkdown}\( \chi\left(x\right)=\chi\left(x+q\right)\){:/nomarkdown} לכל {::nomarkdown}\( x\in\mathbb{Z}\){:/nomarkdown} (עבור ה-{::nomarkdown}\( q\){:/nomarkdown} הספציפי שלנו).</li>
	<li> {::nomarkdown}\( \chi\left(xy\right)=\chi\left(x\right)\chi\left(y\right)\){:/nomarkdown} לכל {::nomarkdown}\( x,y\in\mathbb{Z}\){:/nomarkdown} - לתכונה הזו קוראים "כפליות".</li>
	<li> {::nomarkdown}\( \chi\left(x\right)\ne0\){:/nomarkdown} אם ורק אם {::nomarkdown}\( x\){:/nomarkdown} זר ל-{::nomarkdown}\( q\){:/nomarkdown}.</li>
</ol>
התכונות הללו אינן שרירותיות, כמובן; אם נחזור לתיאור שנתתי בסוגריים, 1 ו-3 נובעים מכך ש-{::nomarkdown}\( \chi\){:/nomarkdown} הוא הרחבה של משהו שהוגדר במקור על {::nomarkdown}\( \mathbb{Z}_{q}^{*}\){:/nomarkdown} - אוסף המספרים השלמים הזרים ל-{::nomarkdown}\( q\){:/nomarkdown} - ו-2 נובע מכך שאותו "משהו" הוא הומומורפיזם. כאמור, מי שאינו מכיר את המושגים הללו, לא נורא.

קרקטרים הם יצורים מעניינים וחשובים לכשעצמם, ויש להם תכונות מועילות רבות. למשל, קל לראות מהר מאוד (תוך שימוש בכפליות {::nomarkdown}\( \chi\){:/nomarkdown} ובכך ש-{::nomarkdown}\( \mathbb{Z}_{q}^{*}\){:/nomarkdown} היא חבורה) כי לכל {::nomarkdown}\( x\){:/nomarkdown} שזר ל-{::nomarkdown}\( q\){:/nomarkdown}, בהכרח {::nomarkdown}\( \chi\left(x\right)\){:/nomarkdown} יהיה אחד משורשי היחידה מסדר {::nomarkdown}\( q\){:/nomarkdown} - מספר מרוכב שכשהוא מועלה בחזקת {::nomarkdown}\( q\){:/nomarkdown}, מתקבל 1. מכאן שלמרות ש-{::nomarkdown}\( \chi\){:/nomarkdown} הוגדר כפונקציה למספרים המרוכבים כולם, למעשה יש מספר קטן מאוד יחסית של ערכים שהוא יכול לקבל. לא אציג את כל הניתוח שאפשר לעשות לאוסף הקרקטרים (שעיקרו במסקנה היפה הבאה: אוסף כל הקרקטרים של חבורה אבלית סופית {::nomarkdown}\( G\){:/nomarkdown} הוא בעצמו חבורה, שאיזומורפית ל-{::nomarkdown}\( G\){:/nomarkdown}) ואדלג למסקנה שנשתמש בה: {::nomarkdown}\( \sum_{\chi}\chi\left(x\right)\overline{\chi\left(y\right)}=\phi\left(q\right)\delta\left(x,y\right)\){:/nomarkdown}.

מה הולך כאן? ובכן, מבצעים סכום של איברים מהצורה {::nomarkdown}\( \chi\left(x\right)\overline{\chi\left(y\right)}\){:/nomarkdown} (קו עליון מסמן כאן את הצמוד המרוכב), כאשר {::nomarkdown}\( x,y\){:/nomarkdown} שניהם קבועים, ומה שמשתנה הוא הקרקטר - הסכום הוא על כל הקרקטרים האפשריים מודולו {::nomarkdown}\( q\){:/nomarkdown}. התוצאה? אחד משניים. אם {::nomarkdown}\( x\equiv y\left(q\right)\){:/nomarkdown} ({::nomarkdown}\( x\){:/nomarkdown} שקול ל-{::nomarkdown}\( y\){:/nomarkdown} מודולו {::nomarkdown}\( q\){:/nomarkdown}), אז היא {::nomarkdown}\( \phi\left(q\right)\){:/nomarkdown} - פונקצית אוילר, שמתארת כמה מספרים קטנים מ-{::nomarkdown}\( q\){:/nomarkdown} וזרים לו קיימים; אחרת, אם {::nomarkdown}\( x\not\equiv y\left(q\right)\){:/nomarkdown}, התוצאה היא 0. זה מה ש-{::nomarkdown}\( \delta\left(x,y\right)\){:/nomarkdown} מסמן - הוא 1 אם {::nomarkdown}\( x\equiv y\left(q\right)\){:/nomarkdown} ואחרת הוא 0 (לדבר כזה קוראים "הדלתא של קרונקר" והוא סימון מקוצר סטנדרטי למדי במתמטיקה. אל תדאגו - קרונקר עשה עוד דברים בחיים).

אם כן, זה הצעד הראשון בכיוון של מה שדיריכלה צריך - סכום של פונקציות שמסוגל "לזהות" מתי שני מספרים הם שקולים מודולו {::nomarkdown}\( q\){:/nomarkdown}. הצעד השני הוא לשלב את הקרקטרים הללו בהוכחה המקורית של אוילר. כלומר, לבנות פונקציות שמשלבות את הטוב שבשני העולמות - גם מכילות קרקטרים במובן מסויים, וגם מכילות את פונקצית הזטה של רימן במובן מסויים. השילוב הזה נקרא "פונקציות ה-{::nomarkdown}\( L\){:/nomarkdown} של דיריכלה". פונקצית {::nomarkdown}\( L\){:/nomarkdown} היא פונקציה במשתנה יחיד {::nomarkdown}\( s\){:/nomarkdown}, שמוגדרת באמצעות קרקטר דיריכלה כלשהו {::nomarkdown}\( \chi\){:/nomarkdown}. ההגדרה של הפונקציה היא {::nomarkdown}\( L_{\chi}\left(s\right)=\sum_{n=1}^{\infty}\frac{\chi\left(n\right)}{n^{s}}\){:/nomarkdown}. לצורך ההשוואה, פונקצית הזטה של רימן היא {::nomarkdown}\( \zeta\left(s\right)=\sum_{n=1}^{\infty}\frac{1}{n^{s}}\){:/nomarkdown}; כלומר, ההבדל היחיד בינה ובין פונקצית {::nomarkdown}\( L\){:/nomarkdown} של דיריכלה הוא שבמונה לא חייב להיות 1, אלא באופן כללי יש את התוצאה של הפעלת {::nomarkdown}\( \chi\){:/nomarkdown} על הערכים השונים שעליהם רץ {::nomarkdown}\( n\){:/nomarkdown} (וזה, כזכור, יכול להיות שורשי יחידה או 0).

הצעד הראשון בהוכחה המקורית של אוילר הוא מעבר להצגה כפלית של הפונקציה, וזה גם מה שדיריכלה עושה - לא קשה לראות שמתקיים {::nomarkdown}\( L_{\chi}\left(s\right)=\prod_{p}\left(1-\frac{\chi\left(p\right)}{p^{s}}\right)^{-1}\){:/nomarkdown}, מאותם שיקולים שפעלו על פונקצית הזטה של רימן, ותוך שימוש חזק בכפליות של {::nomarkdown}\( \chi\){:/nomarkdown}. הצעד הבא, כפי שהראיתי בפוסט הזה, הוא לקיחת לוגריתם של שני הצדדים. כאן העלילה מסתבכת - באופן כללי, {::nomarkdown}\( L_{\chi}\left(s\right)\){:/nomarkdown} אינה פונקציה ממשית כי חלק משורשי היחידה שמופיעים בסכום שמגדיר אותה הם מרוכבים. כלומר, זוהי פונקציה מרוכבת, ולפונקציות שכאלו הוצאת לוגריתמים מלווה בסיבוך נוסף. אני הולך לדלג בקלילות מעל החלק הזה (שאינו מיידי) אל התוצאה הסופית - אפשר להראות, במובן מאוד מדוייק וקונקרטי, ש-{::nomarkdown}\( \ln L_{\chi}\left(s\right)=\sum_{p}\frac{\chi\left(p\right)}{p^{s}}+O\left(1\right)\){:/nomarkdown} (הסכום הוא על כל הראשוניים {::nomarkdown}\( p\){:/nomarkdown} שאינם מחלקים את {::nomarkdown}\( q\){:/nomarkdown} - זכרו ש-{::nomarkdown}\( q\){:/nomarkdown} אינו בהכרח ראשוני).

גם התוצאה הזו מאוד מזכירה את מה שכבר ראינו עם פונקצית הזטה - ההבדל היחיד (פרט להוכחה הקשה יותר) הוא בכך ש-{::nomarkdown}\( \chi\left(p\right)\){:/nomarkdown} הצליח להסתנן פנימה. כעת דיריכלה מתחיל לבצע להטוטים במטרה להשתמש בזהות {::nomarkdown}\( \sum_{\chi}\chi\left(x\right)\overline{\chi\left(y\right)}=\phi\left(q\right)\delta\left(x,y\right)\){:/nomarkdown} שראינו קודם - ראשית, הוא מכפיל את שני האגפים של המשוואה ב-{::nomarkdown}\( \overline{\chi\left(a\right)}\){:/nomarkdown} ({::nomarkdown}\( a\){:/nomarkdown} הוא המספר הקבוע שאנו רוצים להראות שיש אינסוף ראשוניים השקולים לו מודולו {::nomarkdown}\( q\){:/nomarkdown}) ומקבל את המשוואה {::nomarkdown}\( \ln L_{\chi}\left(s\right)\overline{\chi\left(a\right)}=\sum_{p}\frac{\chi\left(p\right)\overline{\chi\left(a\right)}}{p^{s}}+O\left(1\right)\){:/nomarkdown}. אם כן, התקרבנו לתבנית של {::nomarkdown}\( \chi\left(x\right)\overline{\chi\left(y\right)}\){:/nomarkdown} שרצינו. מה חסר? סכימה על כל ה-{::nomarkdown}\( \chi\){:/nomarkdown}. על כן, דיריכלה עובר לשלב הבא: את המשוואה {::nomarkdown}\( \ln L_{\chi}\left(s\right)\overline{\chi\left(a\right)}=\sum_{p}\frac{\chi\left(p\right)\overline{\chi\left(a\right)}}{p^{s}}+O\left(1\right)\){:/nomarkdown} הוא קיבל<strong> לכל</strong> קרקטר {::nomarkdown}\( \chi\){:/nomarkdown} מודולו {::nomarkdown}\( q\){:/nomarkdown}, ולכן אפשר לבצע סכום של כל המשוואות הללו (יש רק מספר סופי של קרקטרים כך שאין כאן שום בעייתיות), ולקבל:

{::nomarkdown}\( \sum_{\chi}\ln L_{\chi}\left(s\right)\overline{\chi\left(a\right)} = \sum_{p}\sum_{\chi}\frac{\chi\left(p\right)\overline{\chi\left(a\right)}}{p^{s}}+O\left(1\right)\){:/nomarkdown}

וכאן השגנו בדיוק את מה שרצינו - סכום על כל הקרקטרים, שלא ייעלם רק כאשר {::nomarkdown}\( p\){:/nomarkdown} שקול ל-{::nomarkdown}\( a\){:/nomarkdown} מודולו {::nomarkdown}\( q\){:/nomarkdown}. פורמלית, מקבלים:

{::nomarkdown}\( \sum_{\chi}\ln L_{\chi}\left(s\right)\overline{\chi\left(a\right)} = \sum_{p\equiv a\left(q\right)}\frac{\phi\left(q\right)}{p^{s}}+O\left(1\right)\){:/nomarkdown}

אם כן, באגף ימין יש סכום כלשהו שנלקח על הראשוניים השקולים ל-{::nomarkdown}\( a\){:/nomarkdown} מודולו {::nomarkdown}\( q\){:/nomarkdown}; באגף שמאל יש איזו פונקציה מפלצתית. אם נראה שכאשר {::nomarkdown}\( s\){:/nomarkdown} שואף ל-1, המפלצת באגף שמאל שואפת לאינסוף, סיימנו; גם המפלצת באגף ימין חייבת לשאוף לאינסוף, ומכאן שיש אינסוף ראשוניים השקולים ל-{::nomarkdown}\( a\){:/nomarkdown} מודולו {::nomarkdown}\( q\){:/nomarkdown} (למעשה, אפשר לדעת יותר - ה-{::nomarkdown}\( \phi\left(q\right)\){:/nomarkdown} גורר, בסופו של דבר, שהפרופורציה שלהם מכלל הראשוניים היא בדיוק {::nomarkdown}\( \frac{1}{\phi\left(q\right)}\){:/nomarkdown}, ומכיוון שיש בדיוק {::nomarkdown}\( \phi\left(q\right)\){:/nomarkdown} מספרים {::nomarkdown}\( a\){:/nomarkdown} שזרים ל-{::nomarkdown}\( q\){:/nomarkdown} וקטנים ממנו, נובע מכך שבכל סדרה חשבונית {::nomarkdown}\( a+nq\){:/nomarkdown} יש "בערך אותה כמות ראשוניים", אבל לא אכנס לזה).

כאן בדיוק נכנס הניתוח האנליטי של פונקציות ה-{::nomarkdown}\( L\){:/nomarkdown} לתמונה. לא קשה להראות (נסו! זה מסתמך על מה שידוע על פונקצית הזטה של רימן) שאם {::nomarkdown}\( \chi\){:/nomarkdown} הוא הקרקטר הטריוויאלי {::nomarkdown}\( \chi_{0}\){:/nomarkdown}, זה שנותן 1 לכל ערך שזר ל-{::nomarkdown}\( q\){:/nomarkdown} ו-0 ליתר, אז {::nomarkdown}\( \ln L_{\chi_{0}}\left(s\right)\){:/nomarkdown} שואף לאינסוף כאשר {::nomarkdown}\( s\){:/nomarkdown} שואף ל-1. אם כן, האם סיימנו? לא מיידית; הבעיה היא שאת {::nomarkdown}\( \ln L_{\chi_{0}}\left(s\right)\){:/nomarkdown} מחברים עם עוד הרבה פונקציות {::nomarkdown}\( L\){:/nomarkdown} אחרות; אולי אחרת מהן מתנהגת בדיוק כמו {::nomarkdown}\( L_{\chi_{0}}\left(s\right)\){:/nomarkdown}, רק עם סימן הפוך, ולכן היא מבטלת אותה? לכן צריך להראות ש-{::nomarkdown}\( \ln L_{\chi}\left(s\right)\){:/nomarkdown} <strong>נשאר חסום</strong> כאשר {::nomarkdown}\( s\){:/nomarkdown} שואף ל-1, וזאת לכל {::nomarkdown}\( \chi\){:/nomarkdown} שאיננו טריוויאלי. אולי במפתיע, אבל זהו החלק המורכב ביותר של הוכחת המשפט. לא רק שהניתוח של פונקציות ה-{::nomarkdown}\( L\){:/nomarkdown} הוא טכני למדי, הוא גם מתפצל - ההוכחה שונה לגמרי עבור קרקטר {::nomarkdown}\( \chi\){:/nomarkdown} שיכול לתת ערכים מרוכבים, וקרקטר {::nomarkdown}\( \chi\){:/nomarkdown} שנותן רק ערכים ממשיים (אולי במפתיע, המקרה הראשון הוא דווקא הקל יותר). אולי בעתיד אכתוב פוסט טכני שמתאר את ההוכחה, אך לעת עתה הפוסט הזה טכני דיו.

אם כן, זוהי הוכחת משפט דיריכלה, מודולו פרטים טכניים רבים (שחלקם יפים מאוד לכשעצמם). אני מקווה שגם אם חלק מהפרטים לא ברורים, התמונה הגדולה ברורה, ובפרט איך הגענו מלהראות שיש אינסוף ראשוניים השקולים ל-{::nomarkdown}\( a\){:/nomarkdown} מודולו {::nomarkdown}\( q\){:/nomarkdown}, לטענה לכאורה לא קשורה כמו "הפונקציה הזו והזו נותרת חסומה כש-{::nomarkdown}\( s\){:/nomarkdown} שואף ל-1". אני סבור שאחרי תקופת התרגלות כלשהי, כמעט כל העוסקים במתמטיקה יראו את היופי הרב שבהוכחה הזו.
