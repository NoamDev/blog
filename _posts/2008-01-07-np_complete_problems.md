---
id: 99
title: "על בעיות שהן בכלל תסבוכת שלמה"
date: 2008-01-07 16:40:40
layout: post
categories: 
  - תורת הסיבוכיות
---
פעם, לפני שנים רבות (שבועיים?), <a href="http://www.gadial.net/?p=96">דיברתי</a> על מחלקת הבעיות <a href="http://he.wikipedia.org/wiki/NP">NP</a>. כזכור, היא כללה את כל בעיות ההכרעה (שאלות "כן/לא") שעבורן ניתן לבדוק ב"בקלות" הוכחה לכך שהתשובה חיובית <strong>אם</strong> היא חיובית. המחלקה הזו כוללת בעיות מעניינות ומעשיות רבות - למשל, האם מספר הוא <a href="http://he.wikipedia.org/wiki/%D7%9E%D7%A1%D7%A4%D7%A8_%D7%A8%D7%90%D7%A9%D7%95%D7%A0%D7%99">ראשוני</a> או פריק, האם מערכת <a href="http://he.wikipedia.org/wiki/%D7%9E%D7%A9%D7%95%D7%95%D7%90%D7%94_%D7%9C%D7%99%D7%A0%D7%90%D7%A8%D7%99%D7%AA">משוואות לינאריות</a> היא בעלת פתרון במספרים שלמים בלבד (והמהדרין יגידו, עם הערכים 0 או 1 בלבד), האם קיים מסלול בקבוצה נתונה של ערים וכבישים המחברים אותן, כך שעוברים בכל עיר פעם אחת בלבד (דבר כזה מכונה "<a href="http://he.wikipedia.org/wiki/%D7%9E%D7%A1%D7%9C%D7%95%D7%9C_%D7%94%D7%9E%D7%99%D7%9C%D7%98%D7%95%D7%A0%D7%99">מסלול המילטוני</a>"), ועוד כהנה וכהנה. כעת אני רוצה לדבר על הקבוצה החשובה ביותר של בעיות (את חלקן הזכרתי כרגע) - <a href="http://he.wikipedia.org/wiki/%D7%9E%D7%97%D7%9C%D7%A7%D7%AA_%D7%A1%D7%99%D7%91%D7%95%D7%9B%D7%99%D7%95%D7%AA_NPC">הבעיות ה-NP-שלמות</a>.

נתחיל בבדיחה מוכרת על מתמטיקאים: שמים פיזיקאי ומתמטיקאי בחדר עם קומקום ריק ומבקשים מהם להכין תה. הפיזיקאי נוהג כך: הוא ממלא את הקומקום במים, מרתיח אותם, ומוזג אותם לכוס תה. המתמטיקאי, כדי להכין את התה שלו, לוקח את הקומקום המלא במים רותחים, מרוקן אותו לכיור ואומר "עכשיו חזרנו לבעיה שכבר פתרנו".

הרעיון כאן הוא שהמתמטיקאי השתמש ב<a href="http://he.wikipedia.org/wiki/%D7%A8%D7%93%D7%95%D7%A7%D7%A6%D7%99%D7%94_%D7%97%D7%99%D7%A9%D7%95%D7%91%D7%99%D7%AA"><strong>רדוקציה</strong></a>. הוא לקח בעיה כלשהי שהיה עליו לפתור (הכנת תה עם קומקום חצי-מלא של מים רותחים) והמיר אותה בבעיה שאת פתרונה הוא כבר ראה (הכנת תה עם קומקום ריק). זה מבטיח לו שהוא לא יצטרך כלל לחשוב על המשך הפתרון - מספיק היה לו לחשוב על הצמצום עצמו לבעיה שכבר נפתרה.

גם במדעי המחשב (שהם, לטעמי, פשוט ענף של המתמטיקה) נוהגים לפי אותה גישה. כאשר רוצים לפתור בעיה כלשהי, הדבר הנוח ביותר לעשותו (אם כי לא בהכרח היעיל ביותר) הוא לצמצם אותה לבעיה שכבר הכרנו. זה כך בתכנות "אמיתי", שבו משתדלים כל הזמן להשתמש בפונקציות ספריה מוכנות (שמיועדות, מן הסתם, לבעיות כלליות ולא בהכרח לבעיה הספציפית שאנו רוצים לפתור) במקום להמציא את הגלגל מחדש; וזה נכון שבעתיים במדעי המחשב התיאורטיים, שבהם רדוקציות משמשות ככלי יעיל לדיבור על "קושי" של בעיות. באופן גס אפשר לומר שבעיה A קשה יותר מבעיה B אם הבעיה B ניתנת לרדוקציה לבעיה A - כלומר, אם העובדה שאנו יודעים לפתור את A מבטיחה שנוכל לפתור גם את B.

דוגמה טריוויאלית היא הקשר שבין בעיית בדיקת הראשוניות של מספר ובין מציאת הפירוק לגורמים שלו. ברור שאם אנו יודעים איך לפרק מספר לגורמים, נוכל גם לבדוק בקלות אם הוא ראשוני או לא - פשוט נפרק אותו לגורמים ונבדוק האם יש רק שני גורמים - הוא עצמו ו-1. על כן, בעיית בדיקת הראשוניות "קלה יותר" מאשר בעיית הפירוק לגורמים. למעשה, נכון לומר "קלה לכל היותר כמו" כי ייתכן שוויון - אבל כרגע לא מוכר שוויון שכזה. בפרט, בעיית בדיקת הראשוניות נפתרה בזמן פולינומי (<a href="http://en.wikipedia.org/wiki/AKS_primality_test">אלגוריתם AKS</a> המפורסם) אבל בעיית הפירוק לגורמים - טרם (ואם תיפתר, זה יהיה סופה של <a href="http://he.wikipedia.org/wiki/RSA">שיטת ההצפנה RSA</a>, שגם היא "קלה לכל היותר כמו" פירוק לגורמים).

אגדיר בצורה פורמלית רק רדוקציות מבעיות הכרעה לבעיות הכרעה, למרות שקיימת דרך כללית יותר לדבר על רדוקציות (בפרט, באמצעות המושג של "אורקל", שעליו אני מקווה לדבר בעתיד). סוג הרדוקציות שאציג הזה נראה מגביל למדי, וזה אינו מקרי; המטרה היא להפיק כמה שיותר אינפורמציה ממושג הרדוקציה הזה, והגדרה רחבה יותר הייתה עשויה לפגוע בכך.

אם כן, בהינתן בעיה A ובעיה B, רדוקציה מ-B ל-A היא פונקציה {::nomarkdown}\( f\){:/nomarkdown} שלוקחת קלט אפשרי {::nomarkdown}\( x\){:/nomarkdown} לבעיה B והופכת אותו לקלט {::nomarkdown}\( f(x)\){:/nomarkdown} לבעיה A, כך שפתרון של A יענה "כן" על {::nomarkdown}\( f(x)\){:/nomarkdown} אם ורק אם פתרון של B צריך לענות "כן" על {::nomarkdown}\( x\){:/nomarkdown}.

דוגמה קלאסית לרדוקציה היא מ<a href="http://he.wikipedia.org/wiki/%D7%91%D7%A2%D7%99%D7%99%D7%AA_%D7%94%D7%A2%D7%A6%D7%99%D7%A8%D7%94">בעיית העצירה</a> (האם מכונת טיורינג M מסיימת את ריצתה על קלט x נתון) אל הבעיה של בדיקה האם מכונת טיורינג M מסיימת ריצה על הקלט ה"ריק" (כלומר, בלי קלט). לכאורה, אפשר היה לחשוב שהבעיה השניה עשויה להיות קלה "ממש" מהראשונה - הרי בשניה צריך לענות רק על מקרה פרטי מאוד של הראשונה. בפועל, קיימת רדוקציה כזו: אם מקבלים קלט לבעיית העצירה, {::nomarkdown}\( M,x\){:/nomarkdown}, בונים באמצעותו מכונה חדשה - {::nomarkdown}\( M_x\){:/nomarkdown}, שפועלת כך על הקלט הריק: ראשית, היא כותבת את {::nomarkdown}\( x\){:/nomarkdown} על הסרט שלה. שנית, היא מחזירה את הראש הקורא להתחלה. שלישית, מאותו הרגע היא מתנהגת בדיוק כמו {::nomarkdown}\( M\){:/nomarkdown}. מה עשינו? יצרנו מכונה שעוצרת על הקלט הריק אם ורק אם המכונה המקורית {::nomarkdown}\( M\){:/nomarkdown} עוצרת על הקלט {::nomarkdown}\( x\){:/nomarkdown}. על כן, פתרון לבעיה השניה מבטיח שנפתור גם את בעיית העצירה; ולכן, בעיית העצירה לא קשה יותר מאשר הבעיה השנייה. מן הסתם הבעייה השנייה לא קשה יותר מבעיית העצירה, ולכן שתי הבעיות שקולות מבחינת כוחן החישובי.

צריך להיות מאוד זהירים כאן. הדרך הפשוטה ביותר להמחיש זאת היא עם ה"רדוקציה" הבאה מבעיית העצירה (הבלתי פתירה) לבעיית בדיקת הראשוניות (הפתירה מאוד): בהינתן מכונה M וקלט x, הפונקציה {::nomarkdown}\( f\){:/nomarkdown} תחזיר 3 אם {::nomarkdown}\( M\){:/nomarkdown} עוצרת על {::nomarkdown}\( x\){:/nomarkdown}, ו-4 אחרת.... ברור שהפונקציה הזו היא חוקית, וגם ברור שהיא רדוקציה על פי ההגדרה שנתתי, ועם זאת גם ברור שבעיית העצירה קשה הרבה יותר מבעיית בדיקת הראשוניות. מה השתבש כאן?

מה שהשתבש הוא ש"החבאנו" את אי הפתירות של בעיית העצירה בתוך הרדוקציה עצמה. הרדוקציה עצמה "פותרת" את בעיית העצירה, ועל פי הפתרון מחליטה האם למפות את הקלט למספר 3 או 4. לכן, כדי שרדוקציה תהיה בעלת ערך כלשהי, היא לא צריכה להיות חזקה מדי; במקרה שלנו, היינו צריכים לדרוש שהרדוקציה תהיה פונקציה ניתנת לחישוב; זה ימנע מצב שבו בעיה בלתי ניתנת לחישוב ניתנת לרדוקציה אל בעיה הניתנת לחישוב, ולכן זה פותח פתח להוכחה שהמוני דברים בלתי ניתנים לחישוב - אם נצליח להראות רדוקציה ניתנת לחישוב מבעיית העצירה אל משהו, זה אומר שגם ה"משהו" לא פתיר.

דבר דומה קיים גם עבור המחלקה NP, רק שכאן הדרישה מהרדוקציות חריפה יותר מאשר סתם "ניתנות לחישוב" - דורשים שהן יהיו ניתנות לחישוב בזמן פולינומי. שוב, מאותן סיבות. הדבר מבטיח שאם A ניתנת להכרעה בזמן פולינומי (כלומר, שייכת ל-P) וקיימת רדוקציה פולינומית מ-B אל A, אז גם B ניתנת לחישוב בזמן פולינומי. וכאן נכנס לתמונה מושג ה<strong>שלמות</strong> (Completeness) בפעם הראשונה, בשאלה הבאה: האם קיימת איזו שהיא בעיה ב-NP ש<strong>כל</strong> בעיה אחרת ששייכת ל-NP ניתנת לרדוקציה אליה?

התשובה היא שקיימת בעיה כזו, ויותר מכך - קיימות אלפי בעיות כאלו. חלק מהן כבר איזכרתי קודם - למשל, המסלול ההמילטוני. אלו הן הבעיות ה-NP-שלמות המדוברות. מאחורי התיאור הפורמלי של "כל בעיה ב-NP ניתנת לרדוקציה אליהן" מסתתרת המשמעות הפשוטה של "אלו הבעיות הקשות ביותר ב-NP", ושל "אם פתרנו בעיה NP-שלמה אחת באופן יעיל, פתרנו את כל הבעיות ב-NP באופן יעיל". במילים אחרות, הבעיות ה-NP שלמות הן בעיות ששייכות ל-NP, ופתרון יעיל לאחת ויחידה מהן יוכיח ש-<a href="http://he.wikipedia.org/wiki/P%3DNP">P=NP</a>. מכיוון שמניחים שהשוויון אינו נכון, הרי שהבעיות ה-NP-שלמות הן הבעיות שהכי פחות סביר להניח שיהיו פתירות, מבין כל הבעיות ב-NP.

פירוק לגורמים, למשל, אינו NP-שלם (או לפחות אינו ידוע ככזה) ולכן אפשר לתאר סיטואציה שבה ניתן יהיה לפרק ביעילות לגורמים ועדיין לא ינבע מכך ש-P=NP. לעומת זאת, <a href="http://he.wikipedia.org/wiki/%D7%91%D7%A2%D7%99%D7%99%D7%AA_SAT">הבעיה של בדיקה האם פסוק לוגי בתחשיב הפסוקים ספיק</a> היא כן בעיה NP-שלמה; למעשה, זו הבעיה ה-NP-שלמה ה"מעניינת" הראשונה שהתגלתה, לאחר ש<a href="http://he.wikipedia.org/wiki/%D7%9E%D7%A9%D7%A4%D7%98_%D7%A7%D7%95%D7%A7-%D7%9C%D7%95%D7%99%D7%9F">קוק ולוין הוכיחו</a>, באופן בלתי תלוי, שכל בעיה ב-NP ניתנת לרדוקציה אליה (ההוכחה אינה טריוויאלית, אך גם לא מסובכת עד כדי כך; היא מבוססת על תרגום של <a href="http://www.gadial.net/?p=97">מכונת טיורינג אי דטרמיניסטית</a> עבור בעיית NP "כללית" לסדרת פסוקים שמתארים את ריצת המכונה, והם ספיקים רק אם המכונה מקבלת). ההוכחה הזו פרצה דרך לשלל הוכחות אחרות שדברים הם NP-שלמים - שכן אם יש לנו בעיה NP-שלמה כלשהי, ואנו מבצעים רדוקציה ממנה אל בעיה חדשה, זה גורר מיידית שגם הבעיה החדשה NP-שלמה (למה?) ולכן אין יותר צורך לבצע הוכחות כלליות מסובכות שמראות ש<strong>הכל</strong> ניתן לרדוקציה לבעיה שלנו; מספיק להראות שבעיה אחרת, ספציפית, הידועה כ-NP-שלמה ניתנת לרדוקציה לבעיה שלנו.

רק הערה אחת לסיום - המושג "<a href="http://he.wikipedia.org/wiki/NP-%D7%A7%D7%A9%D7%94">NP-קשה</a>" (NP-Hard) נשמע לעתים קרובות בדיונים על סיבוכיות. תקופה ארוכה לא הבנתי מה ההבדל בינו ובין NP-שלם. ההבדל פשוט: בעיה NP-שלמה שייכת ל-NP. בעיה NP-קשה, לא בהכרח יודעים אפילו שהיא שייכת ל-NP - רק שניתן לבצע רדוקציה מכל בעיה ב-NP אליה. דוגמה נאה לכך היא בעיית העצירה, שהיא בבירור NP-קשה; בהינתן פסוק לוגי שרוצים לדעת אם הוא ספיק, בונים מכונה שמה שהיא עושה הוא פשוט להציב את כל ההשמות האפשריות, ואם השמה אחת שמספקת את הפסוק נמצאה, עוצרים; אחרת, נכנסים ללולאה אינסופית. הזמן שנדרש כדי <strong>לבנות</strong> מכונה כזו הוא פולינומי (להבדיל מהזמן שנדרש <strong>להריץ</strong> אותה), אבל התשובה לשאלה "האם המכונה עוצרת או לא" זהה לתשובה לשאלה "האם הפסוק המקורי היה ספיק או לא", ולכן הרדוקציה תקפה לחלוטין (אבל קשה להגיד שמספקת לנו הרבה מידע).
