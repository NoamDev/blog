---
id: 3220
title: "למת הניפוח לשפות רגולריות"
date: 2015-02-03 21:32:59
layout: post
categories: 
  - תורת הסיבוכיות
tags: 
  - למת הניפוח
  - שפות רגולריות
---
עד עכשיו בסדרת הפוסטים שלי על שפות רגולריות נראה לי שהצלחנו לקבל מושג לא רע לגבי מה הן: ראינו מצד אחד אפיון שלהן בתור שפות שניתנות לזיהוי על ידי מספר מודלי חישוב (אוטומטים), ומצד שני אפיון שלהן בתור קבוצה אינדוקטיבית של שפות שניתן להרכיב מתוך השפות הסופיות על ידי איחוד, שרשור וסגור-קלייני, והאפיון הזה גם נתן לנו שיטת תיאור נוחה לשפות כאלו - ביטויים רגולריים. ראינו שהן מקיימות שלל תכונות סגור נוספות. מה שלא באמת ראינו עד עכשיו הוא שיטה שתאפשר לנו לזהות מתי שפה <strong>איננה </strong>רגולרית.

להראות ששפה נתונה איננה רגולרית זה עניין מורכב. נניח שאנחנו מנסים לבנות אוטומט לשפה הזו ולא מצליחים - האם זה אומר שהשפה לא רגולרית? לאו דווקא - אולי אנחנו פשוט גרועים בבניית אוטומטים. כדי להראות שהשפה אינה רגולרית צריך להוכיח ש<strong>כל</strong> בניה של אוטומט, ולא משנה כמה מתוחכם בונה האוטומטים יהיה, תיכשל. ואיך ייראה "כישלון" שכזה? ובכן, רמז אפשר למצוא בהוכחה שכן הראיתי בעבר לכך ש-{::nomarkdown}\( L=\left\{ a^{n}b^{n}\ \|\ n\in\mathbb{N}\right\} \){:/nomarkdown} אינה רגולרית - שם הראיתי שאם אוטומט מקבל מילה ארוכה דיו ששייכת לשפה, אז הוא בהכרח "יתבלבל" ויקבל גם מילה אחרת שאינה שייכת לשפה.

את ההוכחה שהראיתי אז אפשר להכליל בקלות רבה ולקבל כלי נשק מועיל מאוד בהוכחה כללית ששפות אינן רגולריות, מבלי לטרוח ולחזור שוב ושוב על הטיעון מבוסס האוטומטים. בניסוח "נקי" בכלל לא צריך לדבר על אוטומטים. כדי לא להשאיר אתכם במתח אציג את הניסוח הזה עכשיו, אבל אזהיר מראש שהוא לא טריוויאלי להבנה אז לא לדאוג - הכל יתברר בהמשך.

אם כן, הנה למת הניפוח לשפות רגולריות: אם {::nomarkdown}\( L\){:/nomarkdown} אם היא שפה רגולרית אז קיים קבוע {::nomarkdown}\( n\ge1\){:/nomarkdown} כך שלכל {::nomarkdown}\( z\in L\){:/nomarkdown} מאורך {::nomarkdown}\( \left\|z\right\|\ge n\){:/nomarkdown} קיים פירוק {::nomarkdown}\( z=uvw\){:/nomarkdown} המקיים ש-{::nomarkdown}\( \left\|uv\right\|\le n\){:/nomarkdown}, ו-{::nomarkdown}\( \left\|v\right\|\ge1\){:/nomarkdown} ולכל {::nomarkdown}\( i\ge0\){:/nomarkdown} מתקיים {::nomarkdown}\( uv^{i}w\in L\){:/nomarkdown}.

אני חושב שיהיה הרבה יותר קל להבין את הלמה אחרי שנראה את ההוכחה. אז בואו נתחיל. מכיוון ש-{::nomarkdown}\( L\){:/nomarkdown} רגולרית אז קיים אוטומט סופי דטרמיניסטי {::nomarkdown}\( A\){:/nomarkdown} כך ש-{::nomarkdown}\( L\left(A\right)=L\){:/nomarkdown}. נסמן {::nomarkdown}\( \left\|Q\right\|=n\){:/nomarkdown}, דהיינו הקבוע {::nomarkdown}\( n\){:/nomarkdown} שלנו יהיה מספר מצבי האוטומט. כעת ניקח מילה {::nomarkdown}\( z\in L\){:/nomarkdown} המקיימת {::nomarkdown}\( \left\|z\right\|\ge n\){:/nomarkdown}. מהנתון הראשון עולה ש-{::nomarkdown}\( \hat{\delta}\left(q_{0},z\right)\in F\){:/nomarkdown} - קריאת המילה מביאה אותנו למצב מקבל. הנתון השני אומר שריצת {::nomarkdown}\( A\){:/nomarkdown} על {::nomarkdown}\( z\){:/nomarkdown} כוללת לפחות {::nomarkdown}\( n\){:/nomarkdown} צעדים. אחרי שביצענו {::nomarkdown}\( k\){:/nomarkdown} צעדים, האוטומט כבר ביקר ב-{::nomarkdown}\( k+1\){:/nomarkdown} מצבים, לאו דווקא שונים (כי יש את המצב שבו הוא התחיל, ואחרי כל צעד הוא משנה את המצב שלו). לכן אחרי קריאת {::nomarkdown}\( n\){:/nomarkdown} התווים הראשונים של {::nomarkdown}\( z\){:/nomarkdown}, מעקרון שובך היונים נקבל ש-{::nomarkdown}\( A\){:/nomarkdown} היה במצב כלשהו פעמיים. נסמן את המצב הזה ב-{::nomarkdown}\( p\){:/nomarkdown}, וכעת נפרק את {::nomarkdown}\( z\){:/nomarkdown} לשלושה חלקים {::nomarkdown}\( z=uvw\){:/nomarkdown} באופן הבא: {::nomarkdown}\( u\){:/nomarkdown} היא תת-המילה שהביאה את האוטומט אל {::nomarkdown}\( p\){:/nomarkdown} בפעם הראשונה; {::nomarkdown}\( v\){:/nomarkdown} היא תת המילה שהביאה אותו אל {::nomarkdown}\( p\){:/nomarkdown} בפעם השניה; ו-{::nomarkdown}\( w\){:/nomarkdown} זה כל היתר.

מייד ברור שאכן מתקיים {::nomarkdown}\( \left\|uv\right\|\le n\){:/nomarkdown} מהנימוק שנתתי קודם - אחרי {::nomarkdown}\( n\){:/nomarkdown} הצעדים הראשונים כבר היה מצב שהופיע פעמיים, ולכן כל המילה שאנחנו מספיקים לקרוא עד הפעם השניה שבה הגענו למצב הזה לא ארוכה מ-{::nomarkdown}\( n\){:/nomarkdown}. גם ברור ש-{::nomarkdown}\( \left\|v\right\|\ge1\){:/nomarkdown} כי אחרת היינו מקבלים ש"הפעם הראשונה" ו"הפעם השניה" שבה האוטומט מבקר ב-{::nomarkdown}\( p\){:/nomarkdown} הן אותה פעם, בסתירה לכך שזה מצב שאנחנו רואים פעמיים. נשאר רק להוכיח שהדבר הזה עם ה-{::nomarkdown}\( uv^{i}w\){:/nomarkdown} מתקיים. זה פשוט למדי אחרי שמסכמים את מה שאנחנו כבר יודעים באיור הזה, שהוא וריאציה על האיור מהפוסט הראשון עם {::nomarkdown}\( \left\{ a^{n}b^{n}\ \|\ n\in\mathbb{N}\right\} \){:/nomarkdown}:

<strong><a href="http://www.gadial.net/wp-content/uploads/2015/02/pumping_lemma2.png"><img class="aligncenter size-large wp-image-3221" alt="pumping_lemma2" src="http://www.gadial.net/wp-content/uploads/2015/02/pumping_lemma2-1024x280.png" width="584" height="159" /></a></strong>

מה שקורה פה הוא פשוט שלא משנה כמה פעמים נחזור על הלולאה באמצע או נוותר עליה בכלל - בסוף עדיין נגיע למצב מקבל. כמובן, הוכחה באמצעות איור אינה לגיטימית, אז הנה הפורמליזם למי שזה באמת חשוב לו:

{::nomarkdown}\( \hat{\delta}\left(q_{0},u\right)=p\){:/nomarkdown}

{::nomarkdown}\( \hat{\delta}\left(p,v\right)=p\){:/nomarkdown}

{::nomarkdown}\( \hat{\delta}\left(p,w\right)\in F\){:/nomarkdown}

טריוויאלי להוכיח ש-{::nomarkdown}\( \hat{\delta}\left(p,v^{i}\right)=p\){:/nomarkdown} לכל {::nomarkdown}\( i\ge0\){:/nomarkdown} (באינדוקציה, כמובן), ומכאן זה סתם משחק בסימבולים:

{::nomarkdown}\( \hat{\delta}\left(q_{0},uv^{i}w\right)=\hat{\delta}\left(\hat{\delta}\left(\hat{\delta}\left(q_{0},u\right),v^{i}\right),w\right)=\hat{\delta}\left(\hat{\delta}\left(p,v^{i}\right),w\right)=\hat{\delta}\left(p,w\right)\in F\){:/nomarkdown}

ועל כן {::nomarkdown}\( uv^{i}w\in L\left(A\right)=L\){:/nomarkdown}. הוכחה קלה ופשוטה ואלגנטית ויפה מאוד.

אבל איך זה עוזר לנו להוכיח ששפה היא <strong>לא</strong> רגולרית?

אפשר לחשוב על הלמה בתור סוג של משחק לשני שחקנים, אליס ובוב. המשחק מתנהל עבור שפה מסויימת {::nomarkdown}\( L\){:/nomarkdown} שבוב טוען שאינה רגולרית ואליס מנסה להקשות עליו את החיים (אני בכוונה לא כותב "ואליס טוענת שהיא כן רגולרית" כי כלל לא ניתן לטעון את זה, ואני אחזור לנקודה הזו בפירוט בהמשך). המשחק מתנהל כך: ראשית כל אליס אומרת מספר טבעי {::nomarkdown}\( n\){:/nomarkdown} כלשהו. עכשיו בוב מגיב למהלך של אליס בכך שהוא מספק מילה {::nomarkdown}\( z\in L\){:/nomarkdown} שמקיימת {::nomarkdown}\( \left\|z\right\|\ge n\){:/nomarkdown} (שימו לב שהמהלכים הללו אינם בלתי תלויים - המילה שבוב נותן תלויה ב-{::nomarkdown}\( n\){:/nomarkdown} שאליס אמרה). כעת אליס מציעה פירוק {::nomarkdown}\( z=uvw\){:/nomarkdown} כלשהו, ולכך בוב משיב עם מספר טבעי {::nomarkdown}\( i\ge0\){:/nomarkdown}. ואז בודקים מה קורה. אם {::nomarkdown}\( uv^{i}w\in L\){:/nomarkdown} אז אליס ניצחה, ואחרת בוב ניצח.

הטענה שלי היא שאם {::nomarkdown}\( L\){:/nomarkdown} היא שפה רגולרית אז אליס תמיד יכולה להבטיח את הנצחון שלה במשחק אם תשחק היטב. את הטענה הזו ניתן לנסח באופן שקול, שלילי באופיו: אם אליס <strong>אינה</strong> יכולה להבטיח את הנצחון שלה במשחק, אז {::nomarkdown}\( L\){:/nomarkdown} בודאות אינה רגולרית. כלומר, כשאנחנו באים להראות ששפה אינה רגולרית אנחנו בעד בוב ואנחנו צריכים להסביר איך הוא יוכל להביס את אליס. לשם כך, בואו ננסח מחדש את הלמה בגרסה ה"שלילית" שלה (שהיא שקולה לוגית לגרסה שנתתי):

עבור שפה {::nomarkdown}\( L\){:/nomarkdown} כלשהי, אם <strong>לכל</strong> קבוע {::nomarkdown}\( n\ge1\){:/nomarkdown} <strong>קיימת</strong> מילה {::nomarkdown}\( z\in L\){:/nomarkdown} עם {::nomarkdown}\( \left\|z\right\|\ge n\){:/nomarkdown} כך ש<strong>לכל</strong> פירוק {::nomarkdown}\( z=uvw\){:/nomarkdown} המקיים {::nomarkdown}\( \left\|uv\right\|\le n\){:/nomarkdown} ו-{::nomarkdown}\( \left\|v\right\|\ge1\){:/nomarkdown}<strong>קיים</strong> {::nomarkdown}\( i\ge0\){:/nomarkdown} כך ש-{::nomarkdown}\( uv^{i}w\notin L\){:/nomarkdown} - אם זה קורה, אז {::nomarkdown}\( L\){:/nomarkdown} אינה רגולרית.

בואו נשחק את המשחק עבור {::nomarkdown}\( L=\left\{ a^{n}b^{n}\ \|\ n\in\mathbb{N}\right\} \){:/nomarkdown} הישנה והטובה. את המשחק מתחילה אליס, בכך שהיא זורקת קבוע {::nomarkdown}\( n\){:/nomarkdown} כלשהו לחלל האוויר. אני לא מניח שום דבר על {::nomarkdown}\( n\){:/nomarkdown} פרט לכך שזה מספר טבעי חיובי. עכשיו אני צריך להסביר איך בוב יכול להגיב ל-{::nomarkdown}\( n\){:/nomarkdown} הזה של אליס בצורה שעדיין תאפשר לו לנצח במשחק. למרבה המזל, במשחק על השפה {::nomarkdown}\( L\){:/nomarkdown} שלנו קל לתת תשובה כללית, שאמנם תלויה ב-{::nomarkdown}\( n\){:/nomarkdown} אבל מתאימה לתבנית פשוטה - בוב פשוט יגיד את המילה {::nomarkdown}\( z=a^{n}b^{n}\){:/nomarkdown}. בוודאי שמתקיים {::nomarkdown}\( \left\|z\right\|\ge n\){:/nomarkdown} (למעשה, {::nomarkdown}\( \left\|z\right\|=2n\){:/nomarkdown}; אין שום בעיה עם כך שהאורך של {::nomarkdown}\( z\){:/nomarkdown} <strong>גדול</strong> מ-{::nomarkdown}\( n\){:/nomarkdown} ובקרוב נראה שזה אפילו מועיל מאוד) ובוודאי שמתקיים {::nomarkdown}\( z\in L\){:/nomarkdown}.

עכשיו אליס מגיבה בפירוק כלשהו של {::nomarkdown}\( z\){:/nomarkdown}: {::nomarkdown}\( z=uvw\){:/nomarkdown}. כמקודם, אנחנו לא יכולים להניח שום דבר על הפירוק, <strong>פרט לכך</strong> שהוא מציית לתנאי הלמה. אבל אלו תנאים <strong>לא טריוויאליים</strong>: ראשית, {::nomarkdown}\( \left\|v\right\|\ge1\){:/nomarkdown}, אבל שנית וחשוב בהרבה מכך, {::nomarkdown}\( \left\|uv\right\|\le n\){:/nomarkdown}. התנאי הקטן הזה הוא שמאפשר לבוב להביס את אליס - בלעדיו, לא הייתה לו תקווה לנצח במשחק, כפי שאראה עוד רגע. כדי להבין למה הוא כל כך מועיל, בואו נראה את המשמעות שלו - המשמעות היא ש-{::nomarkdown}\( uv\){:/nomarkdown} נמצאת כולה <strong>בחצי הראשון</strong> של {::nomarkdown}\( a^{n}b^{n}\){:/nomarkdown}; כלומר, {::nomarkdown}\( uv\){:/nomarkdown} כוללים רק {::nomarkdown}\( a\){:/nomarkdown}-ים. לכן אפשר לסמן {::nomarkdown}\( u=a^{k},v=a^{t}\){:/nomarkdown} עם הנתון {::nomarkdown}\( t\ge1\){:/nomarkdown}, ולכן. וכעת מגיע מהלך הניצחון של בוב: הוא יבחר {::nomarkdown}\( i=0\){:/nomarkdown} ונקבל ש-{::nomarkdown}\( uv^{i}w=uv^{0}w=uw=a^{n-t}b^{n}\){:/nomarkdown} (למה {::nomarkdown}\( n-t\){:/nomarkdown}? כי הורדנו מ-{::nomarkdown}\( a^{n}\){:/nomarkdown} בדיוק את ה-{::nomarkdown}\( a\){:/nomarkdown}-ים שהיו שייכים ל-{::nomarkdown}\( v\){:/nomarkdown}, וכאלו יש {::nomarkdown}\( t\){:/nomarkdown}). מכיוון ש-{::nomarkdown}\( t\ge1\){:/nomarkdown} הרי ש-{::nomarkdown}\( n-t\ne n\){:/nomarkdown}, ולכן {::nomarkdown}\( a^{n-t}b^{n}\notin L\){:/nomarkdown}, ובוב ניצח. הוכחנו שהשפה לא רגולרית.

עכשיו, מה היה קורה אם אליס לא הייתה מוגבלת על ידי האילוץ {::nomarkdown}\( \left\|uv\right\|\le n\){:/nomarkdown}? היא תמיד הייתה מנצחת במשחק עם המהלך המבריק הבא: לא משנה איזו מילה {::nomarkdown}\( z=a^{n}b^{n}\){:/nomarkdown} בוב זרק לחלל האוויר, היא תבחר את הפירוק {::nomarkdown}\( u=a^{n-1},v=ab,w=b^{n-1}\){:/nomarkdown}. קל לראות ש-{::nomarkdown}\( uv^{i}w=a^{n-1+i}b^{n-1+i}\in L\){:/nomarkdown} תמיד. לכן למת הניפוח בלי {::nomarkdown}\( \left\|uv\right\|\le n\){:/nomarkdown} הייתה <strong>חסרת ערך</strong> כבר נגד שפה פשוטה כמו {::nomarkdown}\( L\){:/nomarkdown}. חשוב לי להדגיש את הנקודה הזו כי האילוץ {::nomarkdown}\( \left\|uv\right\|\le n\){:/nomarkdown} נראה קצת מלאכותי כשקוראים לראשונה את תיאור הלמה - לא ברור למה מתעקשים להתעסק איתו, כשיותר "טבעי" פשוט לא לדבר עליו. אז זו הסיבה - בלעדיו הלמה <strong>לא שימושית</strong>. כמובן, אני מניח שדי ברור לנו שהאילוץ הזה הוא לא הדבר הכי חזק שיכלנו לדרוש ואפשר להכליל אותו עוד קצת - נדבר על זה בסוף, אחרי שנראה דברים שעליהם הלמה כושלת.

בואו נראה עכשיו עוד שימוש של הלמה, הפעם עבור {::nomarkdown}\( L=\left\{ ww\ \|\ w\in\Sigma^{*}\right\} \){:/nomarkdown} (כאשר {::nomarkdown}\( \left\|\Sigma\right\|\ge2\){:/nomarkdown} - למשל, {::nomarkdown}\( \Sigma=\left\{ a,b\right\} \){:/nomarkdown}). כמקודם, אליס נותנת {::nomarkdown}\( n\){:/nomarkdown} ובוב נותן מילה. מפתה אולי לתת את המילה {::nomarkdown}\( a^{n}b^{n}\){:/nomarkdown} שבה השתמשנו קודם, אבל {::nomarkdown}\( a^{n}b^{n}\notin L\){:/nomarkdown} כי היא לא בנויה מחזרה על אותה תת-מילה פעמיים. אז אפשר פשוט להכפיל אותה: נגדיר {::nomarkdown}\( z=a^{n}b^{n}a^{n}b^{n}\){:/nomarkdown}. עכשיו, כמו קודם, כל פירוק שאליס תיתן יהיה בהכרח מהצורה {::nomarkdown}\( u=a^{k},v=a^{t}\){:/nomarkdown} ולכן עבור {::nomarkdown}\( i=0\){:/nomarkdown} נקבל ש-{::nomarkdown}\( uv^{i}w=uw=a^{n-t}b^{n}a^{n}b^{n}\){:/nomarkdown}. צריך עכשיו לתת עוד נימוק קצר שמסביר למה לא קיימת {::nomarkdown}\( w\){:/nomarkdown} כך ש-{::nomarkdown}\( ww=a^{n-t}b^{n}a^{n}b^{n}\){:/nomarkdown}, אבל זה די ברור (יש בדיוק אפשרות אחת ל-{::nomarkdown}\( w\){:/nomarkdown} כזו - שאורכה הוא בדיוק {::nomarkdown}\( \frac{4n-t}{2}\){:/nomarkdown}, וקל לראות שהיא לא תעבוד).

בינתיים אולי מתקבל הרושם שכל הקטע הזה עם {::nomarkdown}\( i\){:/nomarkdown} מיותר ושתמיד אפשר לבחור {::nomarkdown}\( i=0\){:/nomarkdown}. אז בואו נסתכל על דוגמה נחמדה יותר וכנראה שגם מעניינת יותר. הפעם {::nomarkdown}\( \Sigma=\left\{ a\right\} \){:/nomarkdown} ולכן אפשר לחשוב על כל שפה בתור אוסף של מספרים טבעיים בייצוג אונרי. בואו נסתכל על שפת כל הראשוניים: {::nomarkdown}\( L=\left\{ a^{p}\ \|\ p\mbox{ is prime}\right\} \){:/nomarkdown}. איך נפיל אותה?

אליס נותנת {::nomarkdown}\( n\){:/nomarkdown}. בוב, בתגובה, נותן {::nomarkdown}\( z=a^{p}\){:/nomarkdown} כאשר {::nomarkdown}\( p\){:/nomarkdown} ראשוני המקיים {::nomarkdown}\( p\ge n\){:/nomarkdown}. כבר יש לנו טענה עם תחכום מתמטי לא טריוויאלי - איך אנחנו יודעים שראשוני כזה קיים? התשובה היא שקימים אינסוף ראשוניים. ההוכחה הסטנדרטית (של אוקלידס) לטענה הזו היא פשוטה - נניח שיש מספר סופי של ראשוניים, אז נכפול את כולם ונחבר 1 לתוצאה, והנה קיבלנו מספר שאינו מתחלק על ידי אף אחד מהראשוניים הללו אבל חייב להיות ראשוני כלשהו שמחלק אותו, או שהוא בעצמו יהיה ראשוני. יש עוד הוכחות משעשעות - <a href="http://www.gadial.net/2009/05/17/euler_proof_infinity_of_primes/">הנה</a> אחת עם אנליזה, והנה <a href="http://www.gadial.net/2009/03/16/topological_proof_infinity_of_primes/">אחת</a> עם טופולוגיה.

אליס, בתגובה, נותנת פירוק {::nomarkdown}\( z=uvw\){:/nomarkdown}. מכיוון ש-{::nomarkdown}\( z\){:/nomarkdown} מורכבת כולה מ-{::nomarkdown}\( a\){:/nomarkdown}-ים, אפשר לתאר את הפירוק הזה בתור {::nomarkdown}\( u=a^{k},v=a^{t},w=a^{p-\left(k+t\right)}\){:/nomarkdown}, כאשר {::nomarkdown}\( k+t\le n\){:/nomarkdown} ו-{::nomarkdown}\( t\ge1\){:/nomarkdown}. וכעת עולה השאלה - איזה {::nomarkdown}\( i\){:/nomarkdown} כדאי לבוב לבחור?

מה שאנחנו רוצים לעשות הוא לבחור {::nomarkdown}\( i\){:/nomarkdown} כזה שעבורו {::nomarkdown}\( uv^{i}w\notin L\){:/nomarkdown}. כעת, {::nomarkdown}\( uv^{i}w=a^{k}a^{it}a^{p-\left(k+t\right)}=a^{p+\left(i-1\right)t}\){:/nomarkdown}. לכן אנחנו רוצים לבחור {::nomarkdown}\( i\){:/nomarkdown} שעבורו {::nomarkdown}\( p+\left(i-1\right)t\){:/nomarkdown} בודאות אינו ראשוני. אם נבחר {::nomarkdown}\( i=0\){:/nomarkdown} זה לא יבטיח זאת; למשל, אם {::nomarkdown}\( p=17\){:/nomarkdown} ו-{::nomarkdown}\( t=4\){:/nomarkdown} אז {::nomarkdown}\( p+\left(0-1\right)t=13\){:/nomarkdown} וגם {::nomarkdown}\( 13\){:/nomarkdown} ראשוני.

אז מה עושים? פשוט מאוד: בוחרים {::nomarkdown}\( i=p+1\){:/nomarkdown} ומקבלים ש-{::nomarkdown}\( p+\left(i-1\right)t=p+pt=p\left(t+1\right)\){:/nomarkdown}, וזה בבירור לא מספר ראשוני כי הוא שווה למכפלה של {::nomarkdown}\( p\){:/nomarkdown} ושל {::nomarkdown}\( t+1\){:/nomarkdown} שהוא לפחות 2.

נראה לי שאלו מספיק דוגמאות כדי שנבין את הרעיון הכללי ועד כמה הלמה הזו נוחה. עכשיו בואו נעבור לחדשות המצערות - היא לא תמיד עובדת. דהיינו, היא לא משפט של "אם ורק אם" - ייתכנו שפות לא רגולריות שעדיין מקיימות את תנאי הלמה - כלומר, שאליס מנצחת במשחק עליהן. בואו נראה איך אפשר לבנות כזו.

נתחיל משפה שאנחנו כבר יודעים שהיא קשה - נאמר, שפת הראשוניים {::nomarkdown}\( L\){:/nomarkdown}. אם אנחנו רוצים "לנטרל" את למת הניפוח, נוכל לתקוע בהתחלה של מילים איזור שנראה כמו שפה רגולרית, ורק אחרי האיזור הזה יגיע החלק הלא רגולרי. אז נעשה את התעלול הבא: נסתכל על השפה {::nomarkdown}\( b^{*}L\){:/nomarkdown}, כלומר כל המילים שמתחילות ברצף מאורך כלשהו של {::nomarkdown}\( b\){:/nomarkdown}-ים ואז {::nomarkdown}\( a\){:/nomarkdown} בחזקת מספר ראשוני. כעת, אם בוב נותן לנו מילה מהצורה {::nomarkdown}\( z=bz^{\prime}\){:/nomarkdown}, ולא משנה בכלל איך {::nomarkdown}\( z^{\prime}\){:/nomarkdown} נראה, אליס תמיד תוכל לבחור {::nomarkdown}\( u=\varepsilon,v=b,w=z^{\prime}\){:/nomarkdown} ונקבל ש-{::nomarkdown}\( uv^{i}w\){:/nomarkdown} שייך לשפה החדשה שלנו.

למה זה עדיין לא עובד? כי בוב יכול לתת לנו מילה שלא מתחילה ב-{::nomarkdown}\( b\){:/nomarkdown} בכלל. לכן נשתמש בעוד תעלול: "נטביע" את {::nomarkdown}\( L\){:/nomarkdown} בתוך {::nomarkdown}\( a^{*}\){:/nomarkdown}. כלומר, השפה שאני בונה היא השפה {::nomarkdown}\( a^{*}\cup b^{*}L\){:/nomarkdown}. כעת, אם בוב יתן בתור {::nomarkdown}\( z\){:/nomarkdown} מילה כלשהי שכוללת רק {::nomarkdown}\( a\){:/nomarkdown}-ים, אז לא משנה בכלל איזה פירוק נבחר עבורה - עדיין נקבל משהו ששייך ל-{::nomarkdown}\( a^{*}\){:/nomarkdown} לכל {::nomarkdown}\( i\){:/nomarkdown} שבוב יבחר. ניצחון קל של אליס.

השפה הזו עדיין נותרת לא רגולרית, כמובן, למרות המניפוליצות שעשינו לה, כי המרכיב ה"קשה" שלה נותר בצורה שאפשר לשחזר אותו: {::nomarkdown}\( L=h\left(\left(a^{*}\cup b^{*}L\right)\cap b\Sigma^{*}\right)\){:/nomarkdown} כאשר {::nomarkdown}\( h\){:/nomarkdown} הוא הומומורפיזם המקיים {::nomarkdown}\( h\left(b\right)=\varepsilon\){:/nomarkdown} ו-{::nomarkdown}\( h\left(a\right)=a\){:/nomarkdown}. זו סיבה עיקרית למה הגרסה של הלמה כפי שהצגתי אותה היא מספיקה לרוב הצרכים שלנו, במקום הגרסה הכללית יותר שאציג עוד מעט - בגלל שכדי להוכיח ששפה אינה רגולרית לא חייבים להשתמש עליה בלמה; מספיק להעביר אותה באמצעות תכונות סגור לשפה שכן פגיעה ללמה (ואפילו אם השפה המקורית פגיעה ללמה בעצמה, לפעמים יותר קל לטפל בשפה שמתקבלת ממנה אחרי הפעלת כמה תכונות סגור). הנשק העיקרי שלנו בהתמודדות עם שפות הוא תכונות סגור, כי הן מאפשרות לנו לפשט אותן במאמץ כמעט אפסי, וזה ניכר כאן.

בואו נעבור לדבר עכשיו על הגרסה הכללית של הלמה. הצבעתי על כך שהאילוץ {::nomarkdown}\( \left\|uv\right\|\le n\){:/nomarkdown} הוא האילוץ הקריטי כדי שהלמה תהיה שימושית. עכשיו, כדאי לשים לב לכך שבמובן מסויים האילוץ הזה הוא עדיין די חלש. אם נתבונן על ההוכחה של הלמה, היינו יכולים לעשות תעלול דומה עבור <strong>סוף</strong> המילה ולא תחילתה. כלומר, במקום {::nomarkdown}\( \left\|uv\right\|\le n\){:/nomarkdown} היינו מקבלים את התנאי {::nomarkdown}\( \left\|vw\right\|\le n\){:/nomarkdown}. זה היה מחסל, למשל, את השפה {::nomarkdown}\( a^{*}\cup b^{*}L\){:/nomarkdown}. אבל זה כמובן לא הסוף - אפשר לבנות שפה חדשה, שתהיה חסינה גם לגרסה הזו של הלמה - {::nomarkdown}\( a^{*}\cup b^{*}Lc^{*}\){:/nomarkdown}. כאן ריפדנו גם את ההתחלה וגם את הסוף של {::nomarkdown}\( L\){:/nomarkdown} בג'יבריש שמונע מהלמה - שמתמקדת בקצוות - לתפוס את החלק האמצעי ה"לא רגולרי".

אז איך מתמודדים עם זה? אם חושבים קצת על ההוכחה של הלמה ברור שהדבר היחיד שמעניין אותנו הוא שיש שלב <strong>כלשהו</strong> בריצת האוטומט שבו הוא מבצע לפחות {::nomarkdown}\( n\){:/nomarkdown} צעדים. אלו לא חייבים להיות {::nomarkdown}\( n\){:/nomarkdown} הצעדים הראשונים או האחרונים. די בבירור אפשר לנסח את הלמה בתור: לכל {::nomarkdown}\( z\in L\){:/nomarkdown} כך ש-{::nomarkdown}\( \left\|z\right\|\ge n\){:/nomarkdown} קיים פירוק {::nomarkdown}\( z=uvwxy\){:/nomarkdown} כך ש-{::nomarkdown}\( \left\|vw\right\|\le n\){:/nomarkdown} או {::nomarkdown}\( \left\|wx\right\|\le n\){:/nomarkdown} ו-{::nomarkdown}\( \left\|w\right\|\ge1\){:/nomarkdown} ו-{::nomarkdown}\( uvw^{i}xy\in L\){:/nomarkdown} לכל {::nomarkdown}\( i\ge0\){:/nomarkdown}. כאן {::nomarkdown}\( u\){:/nomarkdown} זה החלק של תחילת המילה שעליו אנחנו רוצים לדלג לפני שאנחנו מתחילים לספור {::nomarkdown}\( n\){:/nomarkdown} צעדים, אם סופרים מההתחלה לסוף; ו-{::nomarkdown}\( y\){:/nomarkdown} זה החלק בסוף שעליו אנחנו רוצים לדלג אם סופרים מהסוף להתחלה.

אבל הניסוח הזה לא טוב לנו בכלל, כי צריך לזכור שוב מה המטרה שלנו עם הלמה - להוכיח ששפות הן לא רגולריות. אם אנחנו נותנים <strong>יותר</strong> גמישות בבחירת פירוקים, אנחנו עוזרים דווקא לאליס, ולא לבוב. למשל, את המילה {::nomarkdown}\( a^{n}b^{n}\){:/nomarkdown} בדוגמה הראשונה שלי אליס תוכל עכשיו לפרק בתור {::nomarkdown}\( u=a^{n-1},v=\varepsilon,w=ab,x=\varepsilon,u=b^{n-1}\){:/nomarkdown}, ואז בוב אכל אותה. כלומר, הניסוח ה"כללי" של הלמה הוא שימושי <strong>פחות</strong>. ועם זאת ברור שצריכה להיות דרך להכליל את הלמה כדי שתוכל לתפוס דווקא יותר מקרים. אז מה עושים?

התשובה היא שעושים משהו טיפה מחוכם. במקום לתת לאליס לבחור את {::nomarkdown}\( u,v\){:/nomarkdown} נותנים ל<strong>בוב</strong> לבחור אותם, כבר כשהוא נותן את המילה {::nomarkdown}\( z\){:/nomarkdown}. הביטו בניסוח הבא:

אם {::nomarkdown}\( L\){:/nomarkdown} רגולרית אז קיים {::nomarkdown}\( n\ge1\){:/nomarkdown} כך שלכל מילה {::nomarkdown}\( z\){:/nomarkdown} ופירוק שלה {::nomarkdown}\( z=uvw\){:/nomarkdown}, קיים פירוק {::nomarkdown}\( v=xy\){:/nomarkdown} כך ש-{::nomarkdown}\( \left\|xy\right\|\le n\){:/nomarkdown} ו-{::nomarkdown}\( \left\|y\right\|\ge1\){:/nomarkdown} ו-{::nomarkdown}\( uxy^{i}w\in L\){:/nomarkdown} לכל {::nomarkdown}\( i\ge0\){:/nomarkdown}.

זה גם כן לא הניסוח הכי כללי, כי אפשר גם להחליף את תפקידי {::nomarkdown}\( x,y\){:/nomarkdown} כך ש-{::nomarkdown}\( x\){:/nomarkdown} יהיה זה שמנפחים, אבל נעזוב את זה. אני חושב שהרעיון הכללי כבר ברור. לרוע המזל, גם בניסוח הכללי ביותר למת הניפוח היא עדיין לא משפט של "אם ורק אם" - יש שפות לא רגולריות שמקיימות את תנאי הלמה. עוד יותר לרוע המזל אני לא מכיר אף דוגמה פשוטה, כך שלא אציג כאן דוגמאות.

לסיום, טיזר: הנושא של למת הניפוח מביא אותנו באופן טבעי אל משפט ש<strong>כן</strong> נותן אפיון של "אם ורק אם" לשפות הרגולריות - ועושה את זה בעזרת כלים חדשים ולא צפויים, שנותנים תובנה יפה ביותר לגבי "מה בעצם הולך שם" ומה המשמעות הפורמלית של זה ששפה לא רגולרית היא כזו שדורשת "זכרון לא חסום", ומה האוטומט ה<strong>מינימלי</strong> עבור שפה נתונה. המשפט הזה נקרא משפט מייהיל-נרוד והוא יהיה נושא הפוסט הבא.
