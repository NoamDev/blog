---
id: 1246
title: "ושאינו יודע מה שאלו"
date: 2011-07-23 23:44:39
layout: post
categories: 
  - קריפטולוגיה
tags: 
  - Private information retrieval
  - קצר וטוב
---
אם תשאלו אותי מהי קריפטוגרפיה, אני כנראה אענה את התשובה המשעממת של "התחום במדעי המחשב שעוסק באבטחה של מידע - הצפנה, הבטחת אותנטיות, הזדהות בטוחה וכדומה". התשובה שאני באמת ארצה לתת היא "התחום במדעי המחשב שבו קורים ניסים"; זה התחום שבו עשיית הבלתי אפשרי היא שגרת העבודה. למשל, לאפשר לשני גורמים שמעולם לא ראו זה את זה ולא תיאמו שום דבר מראש להיות מסוגלים לתקשר בצורה בטוחה (מה שמושג, למרות אי אלו בעיות שעדיין קיימות, בעזרת הצפנת מפתח ציבורי); או למשל, להוכיח לצד השני שאתה יודע דבר מה מבלי להדליף שום אינפורמציה על מה בעצם אתה יודע (מה שמושג בעזרת הוכחות אפס-ידע). אני רוצה להציג כאן עוד דוגמה - Private information retrieval, "אחזור מידע מאובטח". כפי שבדרך כלל קורה, הבעיה שאני מנסה לפתור נראית במבט ראשון קשה ביותר, אבל הפתרונות בסופו של דבר מתבררים כפשוטים ואפילו מתבקשים למדי (אם כי יש להודות שאני מציג כאן רק את הפתרונות הפשוטים והיעילים פחות).

הבעיה היא זו: נניח שיש לנו מסד נתונים מסויים, שלצורך פשטות נניח שהוא סדרה של {% equation %}n{% endequation %} ביטים (ביט הוא יחידת מידע שהיא או 0 או 1 ותו לא). המידע שמור בשרת כלשהו, ואנו רוצים לדעת מהו הביט ה-{% equation %}i{% endequation %}. אנחנו יכולים לבקש מהשרת שישלח לנו את הביט ה-{% equation %}i{% endequation %} וחסל - זה מה שקורה בדרך כלל במציאות - אבל יש כאן בעיה אבטחתית כלשהי: השרת (או מי שעוקב אחרי הגישה שלי לשרת) יודע בדיוק איזה מידע רציתי. זה מה שאנחנו רוצים למנוע.

אפשר לבלבל את האויב על ידי כך שאבקש גם את הביט ה-{% equation %}i{% endequation %} וגם את הביט ה-{% equation %}j{% endequation %} עבור איזה שהוא {% equation %}j{% endequation %} שאני בוחר באקראי; אבל היריב שבצד השני עדיין מקבל מידע כלשהו - הוא יודע שאחד משני הביטים {% equation %}i,j{% endequation %} מעניינים אותי. בקיצור, הוא למד משהו. אנחנו רוצים איכשהו לשלוף את המידע מהשרת בצורה כזו שבה היריב לא ילמד <strong>כלום</strong>. בלשון קצת יותר פורמלית, אנחנו רוצים בטיחות מושלמת, בטיחות במובן של תורת האינפורמציה. לא אציג כאן במדויק את ההגדרה הפורמלית (שאינה כה קשה) אבל הרעיון הוא שהתפלגות השאילתות שאני מפנה לשרת תהיה זהה בלי תלות בביט {% equation %}i{% endequation %} שאני רוצה לקרוא.

איך עושים את זה?

טוב, הפתרון המיידי כנראה קופץ לרובכם לראש מייד - פשוט תבקש מהשרת את כל {% equation %}n{% endequation %} הביטים ששמורים בו, וזהו; היריב לא לומד בכך כלום על זהות הביט {% equation %}i{% endequation %} שאתם רוצים (הוא לומד, כמובן, שאתם רוצים ביט כלשהו מתוך ה-{% equation %}n{% endequation %}-ים; אבל אם פניתם לשרת זה היה ברור מלכתחילה וזה לא משהו שאפשר לשפר). השיטה הזו היא בזבזנית למדי - <a href="http://www.gadial.net/?p=1034">סיבוכיות התקשורת</a> שלה (כמות הביטים שנשלחים מצד לצד) היא {% equation %}O\left(n\right){% endequation %}, וזו לא סיבוכיות טובה במיוחד (חשבו על סיטואציה שבה מסד הנתונים הוא בן כמה טרהבייטים של מידע ואנחנו צריכים לשאול כ-1,000 שאילתות ביום ויש עוד הרבה משתמשים כמונו). בפוסט הזה אני רוצה להציג שיפור שנובע מהקלה בכללי המשחק - נניח שיש יותר משרת אחד שבו מסד הנתונים מאוחסן, ונניח (וזו הנחה לא טריוויאלית) שאין קשר בין השרתים, דהיינו שהאויב המרושע שלנו מצותת רק לאחד מהם (במקרה הכי גרוע על כל שרת מתעלק אויב מרושע אחר, אבל כל אויב מרושע כזה יודע רק על מה שקורה בשרת "שלו"). האם עכשיו אפשר לשפר? התשובה היא שכן, משמעותית.

איך עושים את זה?

בואו נתחיל מהמקרה שבו יש לנו שני שרתים. הפתרון עדיין יהיה בעל סיבוכיות תקשורת {% equation %}O\left(n\right){% endequation %} אבל יהיה קל להכליל אותו אחר כך לפתרון שנותן שיפור משמעותי כשמספר השרתים גדול יותר. באופן די מפתיע, עכשיו יהיה די לנו בכך שכל שרת ישלח לנו ביט בודד, וסיבוכיות התקשורת תהיה טמונה בכך ש<strong>אנחנו</strong> נצטרך לשלוח להם הרבה מידע. השיטה פשוטה: נגריל סדרה {% equation %}S_{0}{% endequation %} של {% equation %}n{% endequation %} ביטים כשהערך של כל ביט נבחר בהסתברות שווה בין 0 ו-1 ובאופן בלתי תלוי ביתר, נבנה סדרה {% equation %}S_{1}{% endequation %} הזהה ל-{% equation %}S_{0}{% endequation %} פרט לכך שהערך של הביט במקום ה-{% equation %}i{% endequation %} הפוך, ונשלח את {% equation %}S_{0}{% endequation %} לשרת הראשון ואת {% equation %}S_{1}{% endequation %} לשרת השני. כל שרת יבצע פעולת XOR לביטים שהאינדקס שלהם בסדרה שהוא קיבל מסומן ב-1, וישלח חזרה את התוצאה. כשנקבל את התוצאה משני השרתים נבצע לה XOR, וגמרנו.

למי שלא מכיר, פעולת XOR בין שני ביטים (מלשון Exclusive Or) היא פעולה שלוקחת שני ביטים ומחזירה 1 רק אם ערכיהם שונים, ו-0 אם הם זהים (כלומר, {% equation %}0\oplus0=0{% endequation %} ו-{% equation %}1\oplus1=0{% endequation %} אבל {% equation %}1\oplus0=0\oplus1=1{% endequation %}). הסיבה שבגללה השיטה עובדת היא שכל ביט {% equation %}j{% endequation %} שאיננו הביט שרצינו או שמופיע ב-XOR של כל אחד משני השרתים ולכן שני המופעים שלו מבטלים זה את זה, או שהוא אינו מופיע כלל ולכן אינו משפיע. היחיד שבא לידי ביטוי באחד השרתים אבל לא בשני הוא הביט ה-{% equation %}i{% endequation %}. נסו זאת בעצמכם על מקרים פרטיים פשוטים (למשל {% equation %}n=3{% endequation %}) ותראו שזה עובד.

הסיבה שזה גם בטוח היא פשוטה - {% equation %}S_{0}{% endequation %} היא סדרה אקראית לחלוטין. לא קשה להראות שגם {% equation %}S_{1}{% endequation %} מתפלגת באופן אחיד. מי שרואה <strong>רק</strong> את {% equation %}S_{0}{% endequation %} או <strong>רק</strong> את {% equation %}S_{1}{% endequation %} רואה, אם כן, רצף ביטים אקראי לגמרי; כדי להפיק מידע כלשהו הכרחי לראות את שניהם גם יחד. זו תופעה דומה לזו שיש בצופן פנקס חד פעמי, או בשיתוף סוד.

יפה ככל שהשיטה הזו אולי נראית כרגע, היא למעשה עוד יותר גרועה מאשר לבקש משרת אחד את כל הביטים - אנחנו שולחים כאן {% equation %}2n{% endequation %} ביטים לשרתים. אז מה השגנו כאן? ובכן, השגנו שיטה שאפשר להכליל יפה למקרה שבו יש יותר שרתים, והאופן שבו עושים את זה הוא באמת חביב - אנחנו פשוט "מגדילים את המימד".

בואו נניח שיש לנו 4 שרתים. נניח גם, לצורך פשטות, ש-{% equation %}n{% endequation %} הוא ריבוע של מספר טבעי כלשהו, כלומר {% equation %}n=k^{2}{% endequation %} (תמיד אפשר להגדיל את {% equation %}n{% endequation %} עד לריבוע הקרוב ביותר). כעת אפשר לחשוב על מסד הנתונים לא בתור שורה ארוכה של ביטים שלכל אחד אינדקס מ-1 ועד {% equation %}n{% endequation %}; במקום זה אפשר לחשוב על טבלה של ביטים שלכל אחד מהם שני אינדקסים - שורה ועמודה, ששניהם מספרים מ-1 ועד {% equation %}k{% endequation %}.

כעת לתעלול. נניח שאנחנו רוצים את הביט שבשורה ה-{% equation %}i{% endequation %} ובעמודה ה-{% equation %}j{% endequation %}. אנחנו מגרילים <strong>שתי</strong> סדרות, {% equation %}S_{0}^{1},S_{0}^{2}{% endequation %}, בראשונה אנו הופכים את הביט שבמקום ה-{% equation %}i{% endequation %}, בשניה את הביט שבמקום ה-{% equation %}j{% endequation %} ומקבלים שתי סדרות חדשות {% equation %}S_{1}^{1},S_{1}^{2}{% endequation %}. כעת אנו שולחים לשרת הראשון את {% equation %}\left(S_{0}^{1},S_{0}^{2}\right){% endequation %}; לשרת השני את {% equation %}\left(S_{1}^{1},S_{0}^{2}\right){% endequation %}; לשלישי את {% equation %}\left(S_{0}^{1},S_{1}^{2}\right){% endequation %} ולרביעי את {% equation %}\left(S_{1}^{1},S_{1}^{2}\right){% endequation %}. אתם כבר מצליחים לנחש מה הם ישלחו בחזרה?

כל שרת שולח בחזרה את ה-XOR של הביטים שנמצאים בתת-הטבלה שמתקבלת אם מצטמצמים רק לאותן שורות ועמודות שהאינדקסים שלהן היו 1 בסדרה המוגרלת. כמקודם, כל ביט שאיננו במקום ה-{% equation %}\left(i,j\right){% endequation %} מופיע בפלטים ששולחים אלינו מספר זוגי של פעמים (לא בהכרח 4 או 0; נסו לבנות דוגמה שבה ביט שכזה נשלח בדיוק פעמיים), ואילו רק הביט במקום {% equation %}\left(i,j\right){% endequation %}נשלח פעם אחת בדיוק. לכן ביצוע XOR לכל הפלטים שקיבלנו מניב בדיוק את הביט שרצינו. הבטיחות נובעת מאליה מאותם שיקולים כמו קודם.

מה הסיבוכיות הפעם? ובכן, לכל שרת אנו שולחים שתי סדרות של {% equation %}k{% endequation %} ביטים, ולכן בסך הכל אנו שולחים {% equation %}8k{% endequation %} ביטים. אלא שכזכור, {% equation %}k^{2}=n{% endequation %} ולכן סיבוכיות התקשורת שלנו היא {% equation %}O\left(\sqrt{n}\right){% endequation %} - וזה שיפור משמעותי מאוד ביחס ל-{% equation %}n{% endequation %}. אם מסד הנתונים הוא בגודל של טרהבייט, אנחנו שולחים רק 8 מגהבייט; אני משער שתסכימו שזה שיפור משמעותי ביותר.

אבל למה לעצור בדו מימד? אפשר להכליל את השיטה גם ל-{% equation %}d{% endequation %} ממדים. אם עומדים לרשותנו {% equation %}2^{d}{% endequation %} שרתים, אנו בונים שתי סדרות של סדרות {% equation %}\left(S_{0}^{1},\dots,S_{0}^{d}\right){% endequation %} ו-{% equation %}\left(S_{1}^{1},\dots,S_{1}^{d}\right){% endequation %}, שולחים לשרתים את כל האפשרויות (כל האפשרויות לסדרה של {% equation %}d{% endequation %} סדרות שהאיבר הראשון שלה הוא אחד מבין {% equation %}S_{0}^{1},S_{1}^{1}{% endequation %}, השני הוא אחד מבין {% equation %}S_{0}^{2},S_{1}^{2}{% endequation %} וכן הלאה) ועושים XOR לתוצאה. כאן מתקיים {% equation %}n=k^{d}{% endequation %} ולכן סיבוכיות התקשורת שלנו היא {% equation %}O\left(\sqrt[d]{n}\right){% endequation %}. עם זאת, כדאי להתייחס גם ל-{% equation %}d{% endequation %} כחלק מהפרמטר שמודד את הסיבוכיות, מכיוון שאי אפשר להגדיל את {% equation %}d{% endequation %} באופן חופשי בלי מחיר - מספר השרתים קופץ משמעותית כשמגדילים את {% equation %}d{% endequation %} (מוכפל פי שתיים בכל פעם שבה מגדילים את {% equation %}d{% endequation %} ב-1) וכך גם סיבוכיות התקשורת גדולה - לכל שרת שולחים {% equation %}d\cdot k{% endequation %} ביטים, ולכן בסך הכל הסיבוכיות היא {% equation %}O\left(d\cdot2^{d}\cdot\sqrt[d]{n}\right){% endequation %} ביטים.

הפתרון הזה, כאמור, הוא רק הצעד הראשון בדרך אל עולם שלם של שיטות PIR; אולם מכיוון שאני רוצה שזה יהיה פוסט קצר וקולע אעצור כאן.
