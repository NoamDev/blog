---
id: 92
title: "המתמטיקה של RSA"
date: 2007-11-27 22:19:02
layout: post
categories: 
  - קריפטולוגיה
  - תורת המספרים
tags: 
  - RSA
  - הוכחות
  - טכני
---
בפוסט קודם אמרתי מילה או שתיים על שיטת ההצפנה RSA, אבל לא נכנסתי לעובי הקורה המתמטי. מכיוון שהמתמטיקה שמאחורי השיטה אינה מסובכת כל כך, אנסה להציג אותה בשלמותה כאן. כמו דברים רבים אחרים במתמטיקה, המורכבות של השיטה לא נובעת מרוחב אלא מעומק - כלומר, היא מתבססת על כמה מושגים ספציפיים מתורת המספרים, שנכונותם, בתורה, נובעת מדברים יותר בסיסיים, שנובעים מדברים יותר בסיסיים, וכדומה. בסופו של דבר, אפשר לחשוב עליה כעל "שרשרת לא טריוויאלית של אמירות טריוויאליות", כפי שאוהבים לקרוא לפעמים להוכחות מתמטיות באופן כללי.

על כן, אנסה להציג את השרשרת הזו מהסוף; בכל פעם אשאיר איזו הנחה או טענה בלתי מוכחת, אסיים את ההוכחה בעזרתה, ובשלב הבא אעבור לשלב הבא בשרשרת ואנסה לחסל את הטענה הלא מוכחת. לטעמי, יש יתרונות לשיטה הזו: ראשית, גם מי שלא יצליח לעקוב אחרי ההוכחה עד הסוף יוכל להבין איך RSA עובדת, ופשוט לא יהיה בטוח בנכונות של איזה שהוא פרט מסויים (שאני יכול להבטיח לו בכל מקרה שהוא נכון). שנית, עדיף להתחיל מה"תכל'ס" ולא ממושגים כלליים שלא ברור איך הם מתקשרים לנושא שלפנינו (עם זאת, בלימודים "אמיתיים" עדיף להתחיל מהבסיס, מהטעם הפשוט שאחר כך מיישמים אותו לאלף ואחד דברים שונים, ולא כדאי להתקבע על יישום אחד).
<h1>שלב א' - השיטה באופן כללי</h1>
אם כן, נתחיל. שדה המשחק הבסיסי שלנו הוא החבורה הכפלית {% equation %}\mathbb{Z}^*_n{% endequation %}. לא אגיד בינתיים מה המשמעות המדוייקת של הדבר הזה - מה זו "חבורה", למה כפלית, ומה זה הסימון המופרע הזה. לצרכנו מספיק לדעת שזוהי קבוצת המספרים בתחום {% equation %}0\dots n-1{% endequation %} (ואפילו לא כולם, אבל גם לזה לא ניכנס עכשיו), ושאנו מדברים על פעולת כפל "מודולרית" שלהם. כפל מודולרי פירושו שבהינתן {% equation %}a,b{% endequation %} ששייכים לקבוצה, אנו כופלים אותם, אבל אז מחלקים את התוצאה ב-{% equation %}n{% endequation %} ומתעניינים רק בשארית. למשל, אם {% equation %}a=3,b=5,n=9{% endequation %} אז תוצאת הכפל המודולרי היא 6. שימו לב שחלוקה ב-{% equation %}n{% endequation %} ולקיחת השארית תחזיר תמיד מספר שהוא בתחום {% equation %}0\dots n-1{% endequation %} (מדוע?)

מערכת ההצפנה נבנית כך (נניח, בידי אליס): ראשית אליס בוחרת את {% equation %}n{% endequation %} על ידי כך שהיא מגרילה שני מספרים ראשוניים {% equation %}p,q{% endequation %} שהם בערך מאותו סדר גודל (של מאות ספרות, בימינו), וכופלת אותם: {% equation %}n=pq{% endequation %}. בניה שכזו מבטיחה שיהיה קשה למדי לפרק את {% equation %}n{% endequation %} לגורמים ראשוניים (דרך נאיבית לראות את זה: שניים הוא המספר המינימלי האפשרי של גורמים למספר פריק). היתרון של אליס על פני כל שאר העולם הוא שהיא יודעת בדיוק מה הפירוק, פשוט כי כך היא בנתה את המספר.

כעת אליס מגרילה את ה"מנעול" שלה - מספר {% equation %}e{% endequation %} כלשהו. יש עליו מגבלות והוא נבחר מתוך תחום מסויים (גדול מאוד) של מספרים, אבל על זה ארחיב בהמשך. כעת היא משתמשת בידע שלה על הפירוק של {% equation %}n{% endequation %} כדי למצוא מספר נוסף {% equation %}d{% endequation %}, כך שמתקיימת התכונה הנאה הבאה:

לכל {% equation %}x\in\mathbb{Z}^*_n {% endequation %} מתקיים {% equation %}(x^e)^d=x{% endequation %}, כאשר החזקה מבוצעת מודולו {% equation %}n{% endequation %} (זה בסך הכל כפל של {% equation %}x{% endequation %} בעצמו מספר כלשהו של פעמים ולקיחת השארית כל הזמן). כלומר, העלאה בחזקת {% equation %}e{% endequation %} והעלאה בחזקת {% equation %}d{% endequation %} הן פעולות הופכיות זו לזו - האחת מבטלת את השנייה.

כעת אליס מפרסמת את {% equation %}e,n{% endequation %} ושומרת את {% equation %}d{% endequation %} סודי. כשבוב רוצה לשלוח לה הודעה, הוא מקודד אותה כמספר ב-{% equation %}\mathbb{Z}^*_n {% endequation %}, מעלה בחזקת {% equation %}e{% endequation %}, ושולח לאליס. מי שאינו יודע את {% equation %}d{% endequation %} כנראה יתקשה לבטל את פעולת ההעלאה בחזקה הזו - אליס עושה זאת בקלות, באמצעות {% equation %}d{% endequation %}. זה הכל.

שתי הערות "פרקטיות" - ראשית, למרות שלכאורה מבצעים בהצפנה פעולות מטורפות - למשל, מחשבים את {% equation %}5345345345^{345341235785}{% endequation %} מודולו {% equation %}89824342423{% endequation %} וכולי (מספרים מומצאים ואולי לא תקינים!), הרי שיש שיטות לא מסובכות כל כך לעשות זאת מהר. חשוב לזכור שאולי מדובר על מספרים גדולים ומפחידים, אבל בפועל הם מיוצגים על ידי מספר לא גדול של ספרות (כדי לייצג מפתח טיפוסי בימינו נדרשות 2048 סיביות - פחות מ-300 בתים) וסיבוכיות הזמן שנדרשת לבצע פעולות כמו כפל או העלאה בחזקה (כשעושים אותן נכון) היא ביחס ישר למספר הספרות, לא לגודל המספר. אם מכפילים את מספר הספרות פי 2, כל מה שקורה הוא שמכפילים פי 2 את הזמן שלוקח לבצע פעולות חשבון עליהן (אבל מבחינת הגדלת טווח המספרים, זו הגדלה אסטרונומית - מעלים בריבוע בערך את המספר שמיייצג את הטווח הנוכחי).

ההערה השנייה היא שלא הכי ברור איזה הודעות כבר אפשר לקודד בתור מספרים ב-{% equation %}\mathbb{Z}^*_n{% endequation %}. בסופו של דבר, למרות שהטווח נראה גדול, הרי שאפשר בסך הכל לקודד רק מספר קטן של בתים (כאמור, פחות מ-300) לפני שנסתכן ב"התנגשויות". התשובה לכך היא שבדרך כלל משתמשים במפתח ציבורי כדי להצפין מפתח קטן שמשמש להצפנה סימטרית (בימינו גם הפרנואידים משתמשים רק במפתח של 32 בתים), ואת התקשורת האמיתית להצפין בצורה סימטרית (שהיא מהירה יותר וכנראה גם בטוחה יותר). בעזרת שיטות ההצפנה הסימטרית של ימינו, אפילו הודעות עצומות של מאות מגה בייט ניתנות להצפנה סבירה בעזרת מפתחות קטנים - כלומר, הצפנת המפתח הציבורי לא באה להחליף את הצפנת המפתח הסימטרי, אלא להשלים אותה.

יאללה, עכשיו למתמטיקה.
<h1>שלב ב' - איך בדיוק בוחרים את הערכים?</h1>
אמרתי שב-{% equation %}\mathbb{Z}^*_n{% endequation %} אין את כל המספרים בטווח {% equation %}0\dots n-1{% endequation %}. לא אכנס כרגע לנימוק למה (כמובן, חוץ מהנימוק הטריוויאלי של: "על המספרים שמעיפים השיטה לא עובדת"), אבל כן אגיד את מי מעיפים: את כל מי שלא זר ל-{% equation %}n{% endequation %}. כלומר, כל מספר {% equation %}a{% endequation %} כך שקיים איזה שהוא {% equation %}t&gt;1{% endequation %} שמחלק גם את {% equation %}a{% endequation %} וגם את {% equation %}n{% endequation %}. דוגמה: 18 ו-16 אינם זרים, שכן 2 מחלק את שניהם גם יחד.

בחירת {% equation %}e{% endequation %} מסובכת יותר. אנחנו בוחרים אותו כך שיהיה זר ל-{% equation %}(p-1)(q-1){% endequation %}. למה? כי זה הוא מספר האיברים שזרים ל-{% equation %}n{% endequation %}, ולכן הגודל של {% equation %}\mathbb{Z}^*_n{% endequation %}. למה צריך ש-{% equation %}e{% endequation %} יהיה זר לגודל הזה? שוב, כי אחרת כל העסק לא היה עובד. שימו לב, אגב, ש-{% equation %}e=2{% endequation %} אף פעם לא יהיה זר ל-{% equation %}(p-1)(q-1){% endequation %}, ולכן מה שמכונה "שיטת רבין" מתפצל ברגע זה מ-RSA.

דרך אחרת לכתוב את ה-{% equation %}(p-1)(q-1){% endequation %} היא לכתוב {% equation %}\varphi(n){% endequation %}. קרי: "פונקצית אוילר של {% equation %}n{% endequation %}". הפונקציה מוגדרת בצורה פשוטה: עבור {% equation %}n{% endequation %}, היא שווה למספר המספרים הטבעיים שקטנים מ-{% equation %}n{% endequation %} וזרים לו. תכונה חשובה שלה היא שהיא כפלית עבור מספרים זרים - כלומר, ש-{% equation %}\varphi(x)\varphi(y)=\varphi(xy){% endequation %} אם {% equation %}x,y{% endequation %} זרים זה לזה. עוד דבר שקל להוכיח (נסו!) הוא שעבור ראשוני {% equation %}p{% endequation %} מתקיים {% equation %}\varphi(p)=p-1{% endequation %}. מכאן ברור למה אכן {% equation %}\varphi(n)=(p-1)(q-1){% endequation %}.

ואיך בוחרים את {% equation %}d{% endequation %}? מחפשים ומוצאים מספר כך שיתקיים {% equation %}e\cdot d=1(\text{mod} \varphi(n)){% endequation %}. איך עושים זאת? בעזרת מה שמכונה "האלגוריתם האוקלידי המורחב". עוד - בהמשך.
<h1>שלב ג' - למה הערכים הללו טובים לנו?</h1>
כאן מגיע המשפט ה"עמוק" הראשון. "עמוק" במרכאות, כי זה משפט פשוט למדי - אך הוא זה שהצדקתו הולכת הכי הרבה אחורה.

המשפט אומר כך: אם {% equation %}G{% endequation %} חבורה עם {% equation %}k{% endequation %} איברים, אז {% equation %}x^a=x^b{% endequation %} אם {% equation %}a\equiv b(\text{mod}k){% endequation %}. אין צורך כרגע להיכנס לשאלה "מהי חבורה" - מספיק להזכיר ש-{% equation %}\mathbb{Z}^*_n{% endequation %} היא חבורה.

אם כן, מה יש לנו? יש לנו חבורה עם {% equation %}k=\varphi(n){% endequation %} איברים. יש לנו {% equation %}e,d{% endequation %} שמקיימים {% equation %}ed\equiv 1(\text{mod}k){% endequation %}, ולכן יש לנו ש- {% equation %}(x^e)^d=x^{ed}=x^1=x{% endequation %}. גמרנו.
<h1>שלב ד' - אז איך מוצאים את d?</h1>
האלגוריתם האוקלידי מתבסס על העובדה הבאה: המחלק המשותף הגדול ביותר של {% equation %}x,y{% endequation %} הוא גם המחלק המשותף המקסימלי של {% equation %}y,r{% endequation %}, כאשר {% equation %}r{% endequation %} היא השארית שמקבלים כשמחלקים את {% equation %}x{% endequation %} ב-{% equation %}y{% endequation %}. תרגיל - להוכיח שזה נכון (רמז: מתקיים {% equation %}x=qy+r{% endequation %} עבור {% equation %}q{% endequation %} שלם כלשהו).

אם כן, האלגוריתם האוקלידי פשוט פועל כך (תוך הנחה ש-{% equation %}x\ge y{% endequation %}):
<ol>
	<li>אם {% equation %}y{% endequation %} מחלק את {% equation %}x{% endequation %}, החזר את {% equation %}y{% endequation %}.</li>
	<li>אחרת, חשב את {% equation %}r=x \% y{% endequation %} (% הוא אופרטור נפוץ בשפות תכנות לציון שארית של חלוקה).</li>
	<li>הצב {% equation %}x:=y, y:=r{% endequation %}.</li>
	<li>חזור לשלב 1.</li>
</ol>
זה האלגוריתם האוקלידי הפשוט. האלגוריתם המורחב לא סתם מוצא את המחלק המשותף המקסימלי; הוא גם מוצא {% equation %}a,b{% endequation %} כך ש-{% equation %}ax+by=d{% endequation %} (כש-{% equation %}d{% endequation %} הוא המחלק המדובר - זהירות, לא להתבלבל עם {% equation %}d{% endequation %} שלנו, שעליו נדבר אחר כך).

הרעיון הוא כזה: נניח שגילינו ש-{% equation %}x=qy+r{% endequation %}, אז בפרט {% equation %}r=x-qy{% endequation %}. כלומר, אפשר להציג את {% equation %}r{% endequation %} בתור צירוף לינארי של {% equation %}x,y{% endequation %}. זה כך גם בהמשך הדרך: אם {% equation %}x\prime=a_1x+b_1y{% endequation %} ו-{% equation %}y\prime=a_2x+b_2y{% endequation %} הם המשתנים של האיטרציה הנוכחית שלנו, אז:

{% equation %}r\prime=x\prime-qy\prime=(a_1x+b_1y)-(qa_2x+qb_2y)=(a_1-qa_2)x+(b_1-qb_2)y{% endequation %}

ברור לי שזה ממש לא ברור - הדרך הטובה ביותר להבין היא לעשות את זה על כמה דוגמאות עם נייר ועפרון, או לתכנת את זה.

בסיכומו של דבר, מה שיקרה הוא הדבר הבא: מכיוון ש-{% equation %}e{% endequation %} נבחר במפורש כך שיהיה זר ל-{% equation %}\varphi(n){% endequation %}, אז המחלק המשותף המקסימלי שלהם הוא 1, כלומר קיימים {% equation %}a,b{% endequation %} כך ש-{% equation %}ae+b\varphi(n)=1{% endequation %} - ואנחנו יודעים למצוא אותם די מהר. למה זה טוב? כי אם נסתכל על המשוואה הזו מודולו {% equation %}\varphi(n){% endequation %}, אנחנו נקבל {% equation %}ae\equiv 1(\text{mod}\varphi(n)){% endequation %} (למה?) ולכן {% equation %}d{% endequation %} שרצינו הוא בעצם המקדם {% equation %}a{% endequation %}.
<h1>שלב ה' - אז למה המשפט ה"עמוק" נכון?</h1>
את המשפט ה"עמוק" מוכיחים בעזרת משפט (חשוב למדי) שנקרא "משפט לגראנז'" ועוסק בחבורות סופיות, ולכן אין מנוס מלומר אחת ולתמיד מהי חבורה. חבורה היא פשוט קבוצה {% equation %}G{% endequation %} של איברים שמוגדרת עליהם פעולה בינארית כלשהי ("כפל") שמקיימת את התכונות הבאות:
<ol>
	<li>סגירות: אם {% equation %}x,y\in G{% endequation %} אז גם {% equation %}x\cdot y\in G{% endequation %}</li>
	<li>אסוציאטיביות: {% equation %}x\cdot(y\cdot z)=(x\cdot y)\cdot z{% endequation %}</li>
	<li>קיום איבר יחידה: קיים איבר {% equation %}1\in G{% endequation %} כך ש-{% equation %}x\cdot 1=1\cdot x=x{% endequation %}.</li>
	<li>קיום איבר הופכי: לכל {% equation %}x\in G{% endequation %} קיים {% equation %}x^{-1}\in G{% endequation %} כך ש-{% equation %}x\cdot x^{-1}=x^{-1}\cdot x=1{% endequation %}.</li>
</ol>
זה הכל.

דוגמאות לחבורות: המספרים הרציונליים בלי 0, המספרים השלמים כשפעולת ה"כפל" היא בעצם חיבור, וגם {% equation %}\mathbb{Z}^*_n{% endequation %}. הוכחה שאלו אכן חבורות - עזבו. לא עכשיו.

ועכשיו, מה אומר משפט לגראנז'? שבחבורה עם {% equation %}n{% endequation %} איברים, כל תת קבוצה של החבורה שבעצמה מקיימת את ארבע האקסיומות של החבורה (לדבר כזה קוראים "תת-חבורה") מכילה מספר איברים שמחלק את {% equation %}n{% endequation %}. למשל, אם יש לנו חבורה מסדר 6 ("סדר" של חבורה הוא מילה אחת ל"מספר האיברים שבחבורה"), תת החבורות היחידות האפשריות הן מסדר 1 (תת החבורה שמכילה רק את היחידה), 2, 3 ו-6 ("תת" החבורה שהיא בעצם החבורה עצמה). במילים אחרות - לא ייתכן שיש תת חבורות מסדר 4 או 5.

זה משפט די חזק, אם חושבים על כך: הוא מצליח ללמד אותנו משהו לא טריוויאלי על המבנים האפשריים של חבורות, ובפרט מה <strong>לא</strong> יכול להיות בתוכן. היינו רוצים שמשפט הפוך יהיה קיים - שלכל מספר שמחלק את הסדר של חבורה, קיימת לה תת חבורה מאותו הסדר, אלא שהמשפט אינו נכון (הוא נכון כשהמספר ראשוני; המשפט הזה מכונה "משפט קושי"). העיסוק בתת החבורות שכן אפשר לומר בביטחון שקיימות עבור חבורות סופיות הוא סבוך למדי ולא אכנס אליו עכשיו.

איך משפט לגראנז' מתקשר למה שאנחנו עוסקים בו? בצורה הבאה. אם יש לנו איבר {% equation %}x\in G{% endequation %} בחבורה מסדר {% equation %}n{% endequation %}, נתחיל להסתכל על האיברים {% equation %}x,x^2,x^3{% endequation %} וכן הלאה. מכיוון שיש אינסוף חזקות אפשריות של {% equation %}x{% endequation %} ורק מספר סופי של איברים בחבורה, עולה מכך (בגלל עיקרון שובך היונים) שחייב להתקיים {% equation %}x^a=x^b{% endequation %} עבור איזה שהם {% equation %}a,b{% endequation %} טבעיים. מזה נובע שמתקיים {% equation %}x^a\cdot x^{-b}=1{% endequation %}, או בסימון אחר: {% equation %}x^{a-b}=1{% endequation %} (צריך להוכיח שכל מה שאני עושה כאן נכון - כמובן שלא אעשה זאת כאן). במילים אחרות - קיימת חזקה של {% equation %}x{% endequation %} שמעבירה אותו ל-1. לחזקה הטבעית הקטנה ביותר שמקיימת זאת קוראים ה<strong>סדר</strong> של {% equation %}x{% endequation %}. הקשר ל"סדר של חבורה" אינו מקרי, כמובן; הסדר של {% equation %}x{% endequation %} הוא בדיוק הסדר של תת החבורה שמקבלים על ידי לקיחת כל החזקות שלו (למה? ולמה בעצם כל החזקות הן חבורה?)

אם כן, על פי לגראנז', הסדר של {% equation %}x{% endequation %} מחלק את סדר החבורה, {% equation %}n{% endequation %}. על כן, {% equation %}x^n=1{% endequation %} (למה?) וזה כבר מביא אותנו ממש אל מה שרצינו להוכיח. בואו ניזכר מה זה היה: אם {% equation %}G{% endequation %} חבורה עם {% equation %}n{% endequation %} איברים, אז {% equation %}x^a=x^b{% endequation %} אם {% equation %}a\equiv b(\text{mod}n){% endequation %}

אם כן, נניח כי {% equation %}a\equiv b(\text{mod}n){% endequation %}. מה זה אומר? זה אומר שקיים {% equation %}t{% endequation %} כלשהו כך ש-{% equation %}a-b=t\cdot n{% endequation %}. על כן, {% equation %}x^{a-b}=x^{tn}=(x^n)^t=1^t=1{% endequation %}. על ידי העברת אגף מקבלים {% equation %}x^a=x^b{% endequation %}, וזהו זה.
<h1>שלב ו' - אז למה משפט לגראנז' נכון?</h1>
עלה בידי מישהו/מישהי לשרוד עד עכשיו?

ההוכחה של משפט לגראנז' אינה מסובכת, אך גם היא דורשת קצת עבודה מוקדמת. הדרך הנכונה ללמוד אותה היא באמצעות ספר, ואני סתם אתן רמז: בהינתן חבורה {% equation %}G{% endequation %} מסדר {% equation %}n{% endequation %} ותת חבורה {% equation %}H{% endequation %} שלה, הביטו ביחס השקילות המוגדר על ידי "{% equation %}x{% endequation %} שקול ל-{% equation %}y{% endequation %} אם ורק אם {% equation %}xy^{-1}\in H{% endequation %}. הוכיחו שזה אכן יחס שקילות, ולכן משרה חלוקה של {% equation %}G{% endequation %}, ושכל מחלקת שקילות מכילה אותו מספר של איברים (מחלקת שקילות שכזו מכונה "קוסט"). למה זה מסיים את ההוכחה?
