---
id: 3339
title: "אינטגרל משטחי"
date: 2016-05-16 21:58:56
layout: post
categories: 
  - אנליזה מתמטית
tags: 
  - אינטגרל משטחי
  - מכפלה וקטורית
  - משפט גאוס
  - משפט הדיברגנץ
  - משפט סטוקס
---
<a href="http://www.gadial.net/2016/04/19/line_integral/">בפוסט הקודם</a> דיברנו על אינטגרל קווי, שהוא מה שמקבלים כשמנסים לבצע אינטגרציה על פונקציות שחיות ב-{::nomarkdown}\( \mathbb{R}^{n}\){:/nomarkdown} אבל על תחום שהוא חד-ממדי. הצליח לנו יפה, וכמובן שאצל מתמטיקאים הגישה היא שאם משהו עובד יפה במימד אחד למה לא לנסות גם בשני מימדים. זה מוביל אותנו אל <strong>אינטגרל משטחי</strong> שהוא האנלוג המתאים.

התוצאה? אסון טוטאלי. הכל יוצא סבוך יותר, ונצטרך להכניס מושגים חדשים כדי לקבל את ההכללות שאנחנו מחפשים, ואני הולך להוכיח עוד פחות דברים מאשר קודם. אבל זה, לדעתי, <strong>דבר טוב</strong>, כי הוא מכין אותנו לכך שבאמת נזדקק להגדרות המאוד כלליות שאני אצטרך בהמשך - המושגים של <strong>יריעה</strong> ושל <strong>תבנית דיפרנציאלית</strong>. פרט לכך, כמו אינטגרלים קוויים גם אינטגרלים משטחיים צצים מעצמם בשלל תחומים וכדאי להכיר אותם במשהו שעומד בפני עצמו.

כמו קודם, אני אצטמצם לדיבור על אינטגרלים במרחב ממימד קטן ככל הניתן - במקרה שלנו, {::nomarkdown}\( \mathbb{R}^{3}\){:/nomarkdown}. הפעם זה יותר קריטי - יש דברים שאגיד שלא עובדים ב-{::nomarkdown}\( \mathbb{R}^{n}\){:/nomarkdown} (וכמובן, אפשר לעשות את כל זה גם ב-{::nomarkdown}\( \mathbb{R}^{n}\){:/nomarkdown} אבל זה ידרוש ניסוחים מסובכים יותר שכבר עדיף לא להציג אותם עד שמגיעים למקרה הכללי ביותר).

צריך להתחיל, כמו עם אינטגרל קווי, בלהסביר מה זה בכלל "משטח". אינטואיטיבית זה מרחב דו-ממדי שחי לו ב-{::nomarkdown}\( \mathbb{R}^{3}\){:/nomarkdown}, והדרך הפשוטה שלנו לתאר מרחב כזה היא באמצעות <strong>פרמטריזציה:</strong> שלוש פונקציות {::nomarkdown}\( x\left(u,v\right),y\left(u,v\right),z\left(u,v\right)\){:/nomarkdown} בשני משתנים ({::nomarkdown}\( u,v\){:/nomarkdown}) שמוגדרות מעל קבוצה כלשהי {::nomarkdown}\( T\subseteq\mathbb{R}^{2}\){:/nomarkdown}. כמקודם, נדרוש כמה דרישות סבירות מהפונקציות הללו: שהן יהיו גזירות, וש-{::nomarkdown}\( T\){:/nomarkdown} תהיה קבוצה קשירה (ולכן שהמשטח שנקבל לא יהיה מורכב מכמה חתיכות נפרדות). הדוגמה הקלאסית למשטח בתלת-מימד היא <strong>ספירת היחידה</strong> ("ספירה" היא המעטפת של כדור, כלומר הכדור בלי כל הבפנוכו). ההגדרה הסטנדרטית של הספירה היא {::nomarkdown}\( \mathbb{S}^{2}=\left\{ \left(x,y,z\right)\ \|\ x^{2}+y^{2}+z^{2}=1\right\} \){:/nomarkdown}; אפשר לתת לה פרמטריזציה עם הפונקציות

{::nomarkdown}\( x\left(u,v\right)=\cos u\cos v\){:/nomarkdown}

{::nomarkdown}\( y\left(u,v\right)=\sin u\cos v\){:/nomarkdown}

{::nomarkdown}\( z\left(u,v\right)=\sin v\){:/nomarkdown}

והתחום {::nomarkdown}\( T=\left\{ \left(u,v\right)\ \|\ 0\le u,v\le2\pi\right\} \){:/nomarkdown} (ריבוע שאורך צלעו {::nomarkdown}\( 2\pi\){:/nomarkdown}). זה אולי נראה מפחיד במבט ראשון אבל קל לראות שזה עובד. בואו ניקח נקודה {::nomarkdown}\( \left(x,y,z\right)\){:/nomarkdown}על הספירה. אז בפרט {::nomarkdown}\( -1\le z\le1\){:/nomarkdown} ולכן קיים {::nomarkdown}\( v\){:/nomarkdown} כך ש-{::nomarkdown}\( \sin v=z\){:/nomarkdown}. לכן {::nomarkdown}\( x^{2}+y^{2}=1-z^{2}=1-\sin^{2}v=\cos^{2}v\){:/nomarkdown}. עכשיו, קיבלנו ש-{::nomarkdown}\( y^{2}\le\cos^{2}v\){:/nomarkdown}, ולכן {::nomarkdown}\( -\cos v\le y\le\cos v\){:/nomarkdown}, כלומר קיים {::nomarkdown}\( u\){:/nomarkdown} כך ש-{::nomarkdown}\( y=\sin u\cos v\){:/nomarkdown}. קיבלנו ש-

{::nomarkdown}\( x^{2}=\cos^{2}v-y^{2}=\cos^{2}v-\cos^{2}v\sin^{2}u=\cos^{2}v\left(1-\sin^{2}u\right)=\cos^{2}v\cos^{2}u\){:/nomarkdown}. מכאן כבר קל להשלים את הפרטים.

הפרמטריזציה נותנת לנו יכולת להגדיר אינטגרלים משטחיים בצורה די ברורה: אם {::nomarkdown}\( S\){:/nomarkdown} הוא משטח עם פרמטריזציה {::nomarkdown}\( r\left(u,v\right)=\left(x\left(u,v\right),y\left(u,v\right),z\left(u,v\right)\right)\){:/nomarkdown} ו-{::nomarkdown}\( f:\mathbb{R}^{3}\to\mathbb{R}\){:/nomarkdown} היא פונקציה סקלרית, אז אפשר יהיה להגדיר {::nomarkdown}\( \iint_{S}fdS\triangleq\iint_{T}f\left(r\left(u,v\right)\right)V_{r}\left(u,v\right)dudv\){:/nomarkdown}, כאשר {::nomarkdown}\( V_{r}\){:/nomarkdown} מייצג איכשהו יחידת שטח אינפיניטסימלית שמתאימה לאיזור במשטח ש-{::nomarkdown}\( \left(u,v\right)\){:/nomarkdown} עובר אליו. זה נפנוף ידיים, והדבר הראשון שנצטרך לעשות הוא להסביר במדויק יותר מה זה ואיך מחשבים את זה.

באינטגרל קווי, ה"תיקון" שכפלנו בו היה {::nomarkdown}\( \left\|\gamma^{\prime}\left(t\right)\right\|\){:/nomarkdown}. המספר הזה ייצג בערך את אורך העקומה {::nomarkdown}\( \gamma\){:/nomarkdown} בין הנקודה {::nomarkdown}\( \gamma\left(t\right)\){:/nomarkdown} לבין נקודה קרובה לה מאוד - וכפלנו במספר הזה את ערך הפונקציה כי זה הרעיון באינטגרל - סכום של המון מחוברים קטנים מהצורה ערך של פונקציה כפול שטח התחום שהערך הזה מייצג. במימד אחד, השטח הזה היה אורך, אבל עכשיו אנחנו בדו מימד. באופן ציורי אפשר לחשוב על זה ככה: אנחנו לוקחים מרובע קטנטן ב-{::nomarkdown}\( T\){:/nomarkdown} סביב {::nomarkdown}\( \left(u,v\right)\){:/nomarkdown}, מסתכלים על התמונה של כל הריבוע הזה על ידי {::nomarkdown}\( r\){:/nomarkdown}, ושואלים את עצמנו מה כעת השטח של הריבוע - כמה {::nomarkdown}\( r\){:/nomarkdown} "עיוותה" אותו וניפחה/כיווצה אותו ושינתה את השטח.

כרגיל, כדי לא לשמור אתכם במתח, אגלה לכם בדיוק מה הערך הזה הולך לצאת: הוא יהיה {::nomarkdown}\( \left\|\frac{\partial r}{\partial u}\times\frac{\partial r}{\partial v}\right\|\){:/nomarkdown}. כלומר, הערך המוחלט (שורש סכום הריבועים של הקואורדינטות) של וקטור שמחושב איכשהו מהנגזרות החלקיות של {::nomarkdown}\( r\){:/nomarkdown}, ונקרא <strong>המכפלה הוקטורית</strong> שלהן (זאת להבדיל ממכפלה סקלרית של וקטורים, שמחזירה סקלר). ייתכן שכבר שמעתם על מכפלות וקטוריות בעבר, אבל אציג את זה מחדש בכל מקרה.

בואו ניזכר לרגע מהי מכפלה סקלרית. מכפלה סקלרית של שני וקטורים היא סקלר ששווה למכפלה של שני האורכים שלהם, כפול קוסינוס הזווית ביניהם. מכפלה וקטורית דומה לכך - היא שווה למכפלה של שני האורכים של הוקטורים ב<strong>סינוס</strong> הזווית ביניהם, ואת הסקלר הזה לוקחים וכופלים בוקטור שמאונך למישור ששני הוקטורים הללו פורשים. כלומר, פורמלית אם {::nomarkdown}\( A,B\){:/nomarkdown} הם שני וקטורים שיש ביניהם זווית {::nomarkdown}\( \theta\){:/nomarkdown} במישור שמכיל את שניהם, אז {::nomarkdown}\( A\times B=\left\|A\right\|\left\|B\right\|\sin\theta\hat{n}\){:/nomarkdown} כאשר {::nomarkdown}\( \hat{n}\){:/nomarkdown} הוא וקטור יחידה (דהיינו, {::nomarkdown}\( \left\|\hat{n}\right\|=1\){:/nomarkdown}) שניצב למישור שמכיל את {::nomarkdown}\( A,B\){:/nomarkdown}. כמובן, יש <strong>שני</strong> וקטורים כאלו, שמצביעים לכיוונים מנוגדים, אז איך בוחרים מי מהם הוא הנכון? המוסכמה השרירותית היא להשתמש ב"כלל היד הימנית" - לוקחים את יד ימין, שמים את האצבעות על {::nomarkdown}\( A\){:/nomarkdown} ומסובבים אותן לכיוון {::nomarkdown}\( B\){:/nomarkdown}. האגודל מצביע לכיוון וקטור היחידה. זה תיאור מזעזע, כמובן, שהולם מהנדסים ופיזיקאים, אבל אני אתן הגדרה יותר מסודרת (שימו לב שכרגע זה בכלל לא חשוב לנו, כי בסוף לוקחים רק את הערך המספרי {::nomarkdown}\( \left\|A\right\|\left\|B\right\|\sin\theta\){:/nomarkdown} לצורך חישוב השטח). די בבירור המספר הזה מתאים לשטח המקבילית שצלעותיה הן הוקטורים {::nomarkdown}\( A\){:/nomarkdown} ו-{::nomarkdown}\( B\){:/nomarkdown} (כשהם יוצאים מאותו מקום), זאת בגלל ששטח מקבילית שווה למכפלת צלע בגובה שלה, ואם ניקח למשל את הצלע {::nomarkdown}\( A\){:/nomarkdown}, אז הגובה שלה הוא {::nomarkdown}\( \left\|B\right\|\sin\theta\){:/nomarkdown}.

מה שמעניין כאן הוא איך לחשב את המכפלה הוקטורית על פי הצגה קרטזית. הרי אצלנו וקטור ב-{::nomarkdown}\( \mathbb{R}^{3}\){:/nomarkdown} הוא שלשה {::nomarkdown}\( v=\left(v_{1},v_{2},v_{3}\right)\){:/nomarkdown}. למכפלה <strong>סקלרית</strong> הייתה הצגה נחמדה: {::nomarkdown}\( v\cdot u=\sum_{i=1}^{3}v_{i}u_{i}\){:/nomarkdown}. האם יש משהו דומה למכפלה וקטורית? ובכן, כן, אבל הוא קצת מסובך יותר. מה שהוא כמעט בלתי נמנע בהתחשב בכך שאנחנו צריכים להחזיר <strong>וקטור</strong>.

בואו נתחיל בלהבין איך המכפלה הוקטורית נראית עבור וקטורי הבסיס הסטנדרטי של {::nomarkdown}\( \mathbb{R}^{3}\){:/nomarkdown}, שבדרך כלל אני קורא להם {::nomarkdown}\( e_{1},e_{2},e_{3}\){:/nomarkdown} (והם מייצגים את {::nomarkdown}\( \left(1,0,0\right),\left(0,1,0\right),\left(0,0,1\right)\){:/nomarkdown}) אבל הפעם אקרא להם {::nomarkdown}\( \hat{x},\hat{y},\hat{z}\){:/nomarkdown} כדי שיהיה קל להבדיל ביניהם. ברור שה<strong>גודל</strong> של המכפלה שלהם הוא 1, אבל מה <strong>הכיוון</strong>?

ובכן, אם תנסו להפעיל את כלל יד ימין תראו שההגדרה ככל הנראה <strong>נבחרה</strong> כדי שהמכפלה של כל שני וקטורי יחידה, על פי הסדר ה"טבעי" של {::nomarkdown}\( \hat{x},\hat{y},\hat{z}\){:/nomarkdown}, נותנת את הבא בתור. כלומר, יש לנו את המשוואות:

{::nomarkdown}\( \hat{x}\times\hat{y}=\hat{z}\){:/nomarkdown}

{::nomarkdown}\( \hat{y}\times\hat{z}=\hat{x}\){:/nomarkdown}

{::nomarkdown}\( \hat{z}\times\hat{x}=\hat{y}\){:/nomarkdown}

אם הופכים את הסדר, לעומת זאת, מקבלים וקטורים לכיוון השני. כלומר, יש לנו כאן את מה שנקרא <strong>אנטי-קומוטטיביות</strong>: אפשר להפוך את סדר המוכפלים, אבל ה"מחיר" שמשלמים על כך הוא שכופלים את הביטוי במינוס 1:

{::nomarkdown}\( \hat{y}\times\hat{x}=-\hat{z}\){:/nomarkdown}

{::nomarkdown}\( \hat{z}\times\hat{y}=-\hat{x}\){:/nomarkdown}

{::nomarkdown}\( \hat{x}\times\hat{z}=-\hat{y}\){:/nomarkdown}

כמו כן, המכפלה של כל וקטור בעצמו שווה, כמובן, לאפס (כי סינוס של 0 הוא 0):

{::nomarkdown}\( \hat{x}\times\hat{x}=\hat{y}\times\hat{y}=\hat{z}\times\hat{z}=0\){:/nomarkdown}

הנוסחאות הללו מספיקות כדי שנוכל לחשב את המכפלה הוקטורית לכל זוג וקטורים, בתנאי ש-{::nomarkdown}\( \times\){:/nomarkdown} מקיים את התכונות הסטנדרטיות שאנחנו מצפים מ"כפל" לקיים במשוואות אלגבריות - לינאריות ודיסטריביוטיביות. ה"בתנאי" הזה דורש, כמובן, הוכחה, שאני לא הולך לתת כאן כי רחמים. המטרה שלי פה היא לא "להוכיח" לכם את הנוסחה של המכפלה הוקטורית אלא לנסות ולהבין למה היא נראית כפי שהיא הולכת להיראות.

אם כן, אם יש לכם הרבה סבלנות, בואו ותנסו לפתח את הביטוי בעצמכם, או לעקוב אחרי הפיתוח שלי; אחרת, אפשר לקפוץ לתוצאה. קחו שני וקטורים כלליים {::nomarkdown}\( v=v_{1}\hat{x}+v_{2}\hat{y}+v_{3}\hat{z}\){:/nomarkdown} ו-{::nomarkdown}\( u=u_{1}\hat{x}+u_{2}\hat{y}+u_{3}\hat{z}\){:/nomarkdown} ובואו נכפול אותם, ונפתח סוגריים תוך שימוש בדיסטריביוטיות. נקבל סכום של תשעה מחוברים. שלושה מהם יכילו כפל וקטורי של וקטור בסיס עם עצמו, ולכן ייעלמו; מבין ששת האחרים, אפשר לחלק אותם לשלוש קבוצות בנות שני ביטויים כל אחד, כך שאחד מהביטויים בקבוצה נותן וקטור יחידה והשני נותן את המינוס שלו. הנה מה שנקבל אחרי הפישוטים הללו:

{::nomarkdown}\( v\times u=\left(v_{2}u_{3}-v_{3}u_{2}\right)\hat{x}+\left(v_{3}u_{1}-v_{1}u_{3}\right)\hat{y}+\left(v_{1}u_{2}-v_{2}u_{1}\right)\hat{z}\){:/nomarkdown}

עכשיו, הביטויים בסוגריים נראים באופן חשוד כמו <strong>דטרמיננטה</strong> למי שמכיר את המושג. לכן אפשר לכתוב, ב"קיצור":

{::nomarkdown}\( v\times u=\left\|\begin{array}{cc}v_{2} &amp; v_{3}\\u_{2} &amp; u_{3}\end{array}\right\|\hat{x}+\left\|\begin{array}{cc}v_{3} &amp; v_{1}\\u_{3} &amp; u_{2}\end{array}\right\|\hat{y}+\left\|\begin{array}{cc}v_{1} &amp; v_{2}\\u_{1} &amp; u_{2}\end{array}\right\|\hat{z}\){:/nomarkdown}

והביטוי <strong>הזה</strong> מזכיר באופן חשוד את איך שנראה פיתוח של דטרמיננטה של מטריצה מסדר {::nomarkdown}\( 3\times3\){:/nomarkdown}. הגורם האמצעי קצת לא מסתדר, כי סדר האיברים בו הפוך ({::nomarkdown}\( v_{3}\){:/nomarkdown} בא לפני {::nomarkdown}\( v_{1}\){:/nomarkdown}), אבל זכרו שבפיתוח של דטרמיננטה, תת-הדטרמיננטות (מה שנקרא <strong>המינורים</strong>) לא סתם מחוברות אלא כופלים אותן במינוס 1 לפעמים; המחובר האמצעי כאן אמור להיות מינוס, וזה מתקזז בדיוק עם החלפת העמודה שנדרשת כדי לתקן את הסדר. לכן, אפשר לכתוב את כל {::nomarkdown}\( v\times u\){:/nomarkdown} בתור פיתוח של משהו שמזכיר דטרמיננטה:

{::nomarkdown}\( v\times u=\left\|\begin{array}{ccc}\hat{x} &amp; \hat{y} &amp; \hat{z}\\v_{1} &amp; v_{2} &amp; v_{3}\\u_{1} &amp; u_{2} &amp; u_{3}\end{array}\right\|\){:/nomarkdown}

אני אומר "משהו שמזכיר דטרמיננטה" כי דטרמיננטה היא בדרך כלל של מטריצות שכל אבריהן לקוחים מאותו שדה (או חוג). כאן השורה העליונה היא לא מספרים ממשיים אלא וקטורים; הדרך הקלה ביותר להחליק את העניין הזה היא לומר שמדובר על "דטרמיננטה פורמלית" (כלומר, לשכוח את המבנה האלגברי שקיים על הסמלים שבתוך המטריצה ולחשוב עליהם בתור סמלים ותו לא ועל "כפל" שלהם בתור לכתוב אותם אחד ליד השני). האם יש דרך אחרת לחשוב על העניין? כמובן! אבל לא נראה אותה כרגע אלא בפוסט מתקדם יותר שידבר על <strong>תבניות דיפרנציאליות</strong> והפורמליזם המתמטי שרלוונטי להן.

כעת, משאנחנו חמושים במכפלה וקטורית, אפשר להגדיר אינטגרל משטחי של שדה סקלרי באופן כמעט זהה לאופן שבו הגדרנו אינטרל קווי של שדה סקלרי:

{::nomarkdown}\( \iint_{S}fdS\triangleq\iint_{T}f\left(r\left(u,v\right)\right)\left\|\frac{\partial r}{\partial u}\times\frac{\partial r}{\partial v}\right\|dudv\){:/nomarkdown}

השלב הבא, אם כן, הוא להבין כיצד להגדיר אינטגרל משטחי עבור <strong>שדה וקטורי</strong>, כלומר פונקציה {::nomarkdown}\( F:\mathbb{R}^{3}\to\mathbb{R}^{3}\){:/nomarkdown}. כמו במקרה של אינטגרל קווי, בשביל האינטואיציה למה שהולך לקרות (כי הולך לקרות משהו מוזר) אני הולך לרוץ לאינטואיציה פיזיקלית. האינטואיציה כאן קשורה למושג שנקרא <strong>שטף</strong> (באנגלית Flux). בשביל להבין מה זה לכל הרוחות שטף, הכי קל לחשוב על גשם: כשיורד גשם על מגרש כלשהו, בכל יחידת זמן כמות כלשהי של מים פוגעת ברצפת המגרש ו"עוברת דרכו" (בואו נגיד שהכל מחלחל באדמה). השטף הכולל של הגשם על המגרש הוא הכמות של המים שעוברת דרך המגרש, ליחידת זמן (כלומר, משהו בסגנון "100 ליטר מים בכל שניה").

עכשיו תחשבו שהמים לא נופלים בקו ישר על המגרש. יש רוח שמעיפה את הטיפות לכל מקום ולכן ה<strong>כיוון</strong> של המים בכל נקודה במגרש הוא וקטור שלאו דווקא מצביע למטה. את זה מתארים עם <strong>שדה וקטורי</strong> שלכל נקודה במרחב מתאים את וקטור המים באותה נקודה (הכיוון של המים והכמות שלהם). כשמים פוגעים בנקודה כלשהי באלכסון, לא כולם חודרים לאדמה - תחשבו על הסיטואציה שבה המים מקבילים לגמרי לאדמה ואז שום דבר לא חודר, ולאט לאט "תסובבו" את וקטור כיוון המים כדי שיצביע לכיוון האדמה, וכמות המים שחודרת תגדל. פורמלית, כמות המים שחודרת שווה למכפלה הסקלרית של וקטור המים באותה נקודה, ב<strong>וקטור הניצב</strong> לאדמה באותה הנקודה.

עכשיו קחו את המגרש, שהוא משטח מאוד פשוט - מישור - ותתעללו בו קצת - תכווצ'צ'ו אותו, תעגלו אותו וצרו ממנו כדור, וכדומה - עדיין הרעיון נשאר זהה - השטף דרך המשטח שמתקבל שווה לכמות המים הכללית ש"עוברת דרכו" ביחידת זמן. זה בדיוק מה שהאינטגרל המשטחי בא לחשב. זה אומר שאנחנו הולכים לקחת <strong>וקטור ניצב</strong> למשטח בכל נקודה, לכפול בשדה הוקטורי, והתוצאה של זה תהיה שדה סקלרי שאנחנו כבר יודעים לחשב את האינטגרל המשטחי שלו.

רגע, מי זה הוקטור הניצב למשטח בנקודה כלשהי? אנחנו כבר מכירים אותו: הוקטור {::nomarkdown}\( \frac{\partial r}{\partial u}\times\frac{\partial r}{\partial v}\){:/nomarkdown} הוא וקטור שניצב למישור שנפרש על ידי שני הוקטורים שמתארים את "השינוי הרגעי" במשטח, ולכן זה הוקטור שאנחנו מחפשים; רק צריך לנרמל אותו: להגדיר {::nomarkdown}\( n\left(u,v\right)=\frac{\frac{\partial r}{\partial u}\times\frac{\partial r}{\partial v}}{\left\|\frac{\partial r}{\partial u}\times\frac{\partial r}{\partial v}\right\|}\){:/nomarkdown}. ועכשיו נקבל את ההגדרה של אינטגרל משטחי של שדה וקטורי:

{::nomarkdown}\( \iint_{S}F\cdot ndS=\iint_{T}F\left(r\left(u,v\right)\right)\cdot n\left(u,v\right)\left\|\frac{\partial r}{\partial u}\times\frac{\partial r}{\partial v}\right\|dudv=\iint_{T}F\left(r\left(u,v\right)\right)\cdot\left(\frac{\partial r}{\partial u}\times\frac{\partial r}{\partial v}\right)\){:/nomarkdown}

(לזוועה הזו של מכפלה סקלרית של וקטור אחד במכפלה הוקטורית של שני וקטורים אחרים קוראים "מכפלה מעורבת", אבל נעזוב את זה).

עכשיו, ההגדרה הזו נראית הגיונית אם אנחנו חושבים שמטרתנו בחיים היא לחשב שטף. שהוא מושג שהכנסתי לדיון לפני שתי שניות, בשביל לתת אינטואיציה להגדרה הזו. אבל עבורי, בתור מתמטיקאי מתלהב שרוצה להכליל את המושג של אינטגרל קווי, קורה פה משהו מוזר מאוד: באינטגרל קווי, לקחנו את השדה הוקטורי וכפלנו אותו סקלרית בוקטור <strong>המשיק</strong> לעקומה שעליה ביצענו את האינטגרציה. כאן אנחנו לוקחים את השדה הוקטורי וכופלים אותו סקלרית בוקטור <strong>הניצב</strong> למשטח שעליו אנחנו מבצעים את האינטגרציה. משיק וניצב הם כמעט דבר והיפוכו - הם נמצאים בזווית של 90 מעלות זה ביחס לזה ולכן כשהמכפלה הסקלרית עם אחד מהם מתאפסת, המכפלה הסקלרית עם השני מגיעה לערכה המקסימלי. מה פשר ההבדל הזה? למה שבאינטגרל קווי לא נכפול גם כן בוקטור הניצב לעקומה? מה הולך כאן?

להבדל ה"מוזר" הזה יש הסבר טוב כשמציגים את הפורמליזם הכללי של תבניות דיפרנציאליות, אבל כרגע אין לי דרך טובה להפיס את הדעת ביחס אליו. אני גם לא בטוח שצריך - אני <strong>רוצה</strong> שתרגישו שמשהו פה מוזר ולא מסתדר ותרצו לקבל נקודת מבט כללית יותר על כל העסק.

עכשיו אני רוצה לעבור להציג את ההכללה של משפט גרין עבור אינטגרלים משטחיים. כזכור, משפט גרין קושר בצורה מגניבה לחלוטין בין אינטגרל קווי של פונקציה על עקום סגור, ובין אינטגרל כפול של פונקציה אחרת על התחום שהעקום חוסם:

{::nomarkdown}\( \iint_{R}\left(\frac{\partial Q}{\partial x}-\frac{\partial P}{\partial y}\right)dxdy=\oint_{C}Pdx+Qdy\){:/nomarkdown}

איך אפשר להכליל את המשפט הזה עבור אינטגרלים משטחיים ב-{::nomarkdown}\( \mathbb{R}^{3}\){:/nomarkdown}? נראה לי שזה יכול להיות ניסוי מרתק לשאול את השאלה הזו לסטודנטים לחדו"א 2 שלא מכירים עדיין את התשובה אבל כן מתלהבים מספיק מהחומר כדי לנחש מה יהיו ההכללות. אני מנחש שהקולות יתפצלו בין <strong>שתי</strong> הכללות שונות שכל אחת מהן הגיונית מאוד בפני עצמה. לכל אחת משתי ההכללות הללו יש משפט מתאים: <strong>משפט הדיברגנץ</strong> (שנקרא לפעמים גם <strong>משפט גאוס</strong>) ו<strong>משפט סטוקס</strong>. אני אקרא למשפט סטוקס שאציג כאן <strong>משפט סטוקס הקלאסי</strong>, כי "משפט סטוקס" הוא גם השם של ההכללה החזקה שאני חותר אליה כל הזמן; אבל קרוב לודאי שכאשר תדברו עם הפיזקאי האקראי, "משפט סטוקס" שלו יהיה מה שאציג כאן ותו לא.

משפט הדיברגנץ מתעסק בקשר שבין אינטגרל על תחום ב-{::nomarkdown}\( \mathbb{R}^{3}\){:/nomarkdown} ואינטגרל משטחי <strong>על המעטפת של התחום</strong>. בדומה לאיך שמשפט גרין התעסק באינטגרל על תחום ב-{::nomarkdown}\( \mathbb{R}^{2}\){:/nomarkdown} והעקומה שמהווה את השפה של התחום. לעומת זאת, משפט סטוקס מתעסק בקשר שבין אינטגרל משטחי ב-{::nomarkdown}\( \mathbb{R}^{3}\){:/nomarkdown} והאינטגרל <strong>הקווי</strong> שמוגדר <strong>על השפה</strong> של המשטח. מבין שני המשפטים הללו, משפט סטוקס כנראה דומה יותר למשפט גרין - הוא מתעסק ישירות בשאלה מה קורה אם אנחנו לוקחים את התחום ב-{::nomarkdown}\( \mathbb{R}^{2}\){:/nomarkdown} שהופיע במשפט גרין וחושבים עליו בתור יצור שחי ב-{::nomarkdown}\( \mathbb{R}^{3}\){:/nomarkdown} ומתחילים להוסיף לו גבעות ועמקים וכדומה. משפט הדיברגנץ יותר "לוקח השראה" ממשפט גרין ומתעסק עם אותו הרעיון - אינטגרל של שדה סקלרי על תחום, שמומר לאינטגרל של שדה וקטורי על שפת התחום.

כמובן, עשיתי כאן רק חצי עבודה בינתיים, ואת החצי הקל שלה - אמרתי על אילו <strong>תחומים</strong> מבצעים את האינטגרציות. אבל צריך גם לומר <strong>על אילו פונקציות</strong> האינטגרציה תתבצע. במשפט גרין המבנה היה "פונקציה כללית על שפת התחום; משהו מזעזע לחלוטין שנובע ממנה על התחום עצמו". המבנה הזה יישמר גם כאן, אם כי ה"משהו מזעזע" יהיה שונה בין שני המשפטים. בואו נתחיל, אם כן, מלהציג את הניסוח הדומה של שניהם בלי להציג את פרטי ה"משהו מזעזע" ואז נדבר על המשהו המזעזע.

הניסוח של משפט הדיברגנץ הוא {::nomarkdown}\( \iiint_{V}\left(\nabla\cdot F\right)dxdydz=\iint_{\partial V}F\cdot ndS\){:/nomarkdown}

הניסוח של משפט סטוקס הוא {::nomarkdown}\( \iint_{S}\left(\nabla\times F\right)\cdot ndS=\oint_{\partial S}F\cdot d\gamma\){:/nomarkdown}

אני בכוונה <strong>לא</strong> נכנס כאן לפרטים המדוייקים של המשפטים הללו - יש דרישות שונות ומשונות מהמשטחים שמעורבים כאן (המילה <strong>אוריינטבילי</strong> משחקת פה תפקיד מפתח ואני אפילו לא אנסה להיכנס לזה כרגע). עדיין, את הרעיון הכללי אנחנו יכולים להבין מכאן. נשאר רק להסביר את פשר הסימונים שלי.

הסימונים {::nomarkdown}\( \partial V,\partial S\){:/nomarkdown} הם פשוטים: המשמעות של {::nomarkdown}\( \partial\){:/nomarkdown} בהקשר של מרחב כלשהו היא תמיד <strong>השפה</strong> שלו. האינטואיציה פה לא קשה וכבר הסברתי אותה קודם. נשאר רק להבין מה המשמעות של {::nomarkdown}\( \nabla\cdot F\){:/nomarkdown} ו-{::nomarkdown}\( \nabla\times F\){:/nomarkdown}. הסימונים המוזרים הללו הם חכמים מאוד; הם קיצורים שמאפשרים לנו לזכור מאוד בקלות את שני הדברים המוזרים יחסית שהם מתארים. <strong>{::nomarkdown}\( \nabla\cdot F\){:/nomarkdown} </strong>נקרא <strong>הדיברגנץ</strong> של השדה הוקטורי {::nomarkdown}\( F\){:/nomarkdown} (ומכאן השם, "משפט הדיברגנץ") ואילו {::nomarkdown}\( \nabla\times F\){:/nomarkdown} נקרא <strong>הרוטור</strong> של השדה הוקטורי {::nomarkdown}\( F\){:/nomarkdown} (באנגלית rotor, אבל השם הנפוץ הרבה יותר בטקסטים מתמטיים באנגלית הוא curl, בעוד שבעברית "קרל" לא ממש תפס).

לפני שאציג את החבר'ה הללו, זכרו שאנחנו לא מגדירים אותם סתם כי בא לנו - אלו הדברים שנדרשים <strong>כדי שהמשפטים יעבדו</strong>. אפשר לתת להם אינטואיציות פיזיקליות שונות ומשונות, ואנחנו גם חותרים לכיוון ההגדרה הכללית ששני האופרטורים הללו הם מקרים פרטיים שלה, אבל לעת עתה אין מנוס מקצת תחושה של שרירותיות כאן (והשרירותיות הזו, כאמור, היא דבר טוב, כי היא אמורה לגרום לנו לרצות לראות את ההכללה).

בואו נניח שהשדה הוקטורי {::nomarkdown}\( F\){:/nomarkdown} נכתב בעזרת שלוש פונקציות סקלריות {::nomarkdown}\( P,Q,R\){:/nomarkdown}, כלומר {::nomarkdown}\( F\left(x,y,z\right)=P\left(x,y,z\right)\hat{x}+Q\left(x,y,z\right)\hat{y}+R\left(x,y,z\right)\hat{z}\){:/nomarkdown}. עכשיו בואו נעשה משהו שדומה לדטרמיננטה הפורמלית שראינו קודם, בהגדרה של מכפלה וקטורית: נגדיר פורמלית את הסימון {::nomarkdown}\( \nabla\){:/nomarkdown} בתור וקטור של סימבולים, ואז נבצע את החישוב של {::nomarkdown}\( \nabla\cdot F\){:/nomarkdown} ו-{::nomarkdown}\( \nabla\times F\){:/nomarkdown} בתור מכפלות סקלריות ווקטוריות של סימבולים. ה"תוצאות" של החישובים הללו הן ההגדרות ה"אמיתיות" של הדיברגנץ והרוטור; {::nomarkdown}\( \nabla\cdot F\){:/nomarkdown} ו-{::nomarkdown}\( \nabla\times F\){:/nomarkdown} הם פשוט סימונים מקוצרים חכמים.

אז ככה זה הולך: נגדיר {::nomarkdown}\( \nabla=\left(\frac{\partial}{\partial x},\frac{\partial}{\partial y},\frac{\partial}{\partial z}\right)=\frac{\partial}{\partial x}\hat{x}+\frac{\partial}{\partial y}\hat{y}+\frac{\partial}{\partial z}\hat{z}\){:/nomarkdown} וכעת "נחשב" את ה"מכפלה הסקלרית":

{::nomarkdown}\( \nabla\cdot F=\frac{\partial P}{\partial x}+\frac{\partial Q}{\partial y}+\frac{\partial R}{\partial Z}\){:/nomarkdown}

זו ההגדרה של הדיברגנץ. שימו לב שקיבלנו <strong>שדה סקלרי</strong>: אנחנו מחשבים את הערך של נגזרת חלקית אחת (מבין השלוש האפשריות) עבור כל אחת מהפונקציות {::nomarkdown}\( P,Q,R\){:/nomarkdown} בנקודה שבה אנחנו מחשבים את הדיברגנץ, מקבלים חזרה מספר עבור כל אחת מהנגזרות, ואז מחברים את כל המספרים ומקבלים סקלר.

עבור הרוטור אנחנו נקבל <strong>וקטור</strong>, על פי ההגדרה של מכפלה וקטורית; כלומר, הרוטור הוא אופרטור שמקבל שדה וקטורי ומחזיר שדה וקטורי אחר. לכתוב את תוצאת החישוב במפורש זה כמובן עניין מתיש, אבל בואו נעשה את זה:

{::nomarkdown}\( \nabla\times F=\left\|\begin{array}{ccc}\hat{x} &amp; \hat{y} &amp; \hat{z}\\\frac{\partial}{\partial x} &amp; \frac{\partial}{\partial y} &amp; \frac{\partial}{\partial z}\\P &amp; Q &amp; R\end{array}\right\|=\left(\frac{\partial R}{\partial y}-\frac{\partial Q}{\partial z}\right)\hat{x}+\left(\frac{\partial P}{\partial z}-\frac{\partial R}{\partial x}\right)\hat{y}+\left(\frac{\partial Q}{\partial x}-\frac{\partial P}{\partial y}\right)\hat{z}\){:/nomarkdown}

לסיום, אי אפשר להמנע מלהעיר עוד הערה קטנה על הסימון: {::nomarkdown}\( \nabla\){:/nomarkdown} כבר הופיע לא אחת בפוסטים הללו בתיאור של ה<strong>גרדיאנט</strong> של פונקציה סקלרית - וקטור הנגזרות החלקיות שלה. {::nomarkdown}\( \nabla f=\left(\frac{\partial f}{\partial x},\frac{\partial f}{\partial y},\frac{\partial f}{\partial z}\right)\){:/nomarkdown}. הסימון הזה עקבי, כמובן, עם ההגדרה הסימבולית {::nomarkdown}\( \nabla=\left(\frac{\partial}{\partial x},\frac{\partial}{\partial y},\frac{\partial}{\partial z}\right)\){:/nomarkdown} - תחשבו שאנחנו כופלים את ה"וקטור" {::nomarkdown}\( \nabla\){:/nomarkdown} ב"סקלר" {::nomarkdown}\( f\){:/nomarkdown}. לאופרטור הזה, {::nomarkdown}\( \nabla\){:/nomarkdown}, קוראים <strong>דל</strong>. לסמל עצמו, המשולש ההפוך, קוראים <strong>נבלה</strong> (הדמיון למילה "נבל" בעברית אינו מקרי) ולפעמים קוראים כך גם לאופרטור. עד כמה הסימון הזה גאוני? עד כדי כך שהצלחתי להגיע להגדרה המפורשת של הדיברגנץ והרוטור בלי לטעות ובלי להסתכל בספר!
