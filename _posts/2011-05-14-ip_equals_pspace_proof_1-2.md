---
id: 1139
title: "IP=PSPACE - ההוכחה (חלק ב')"
date: 2011-05-14 23:29:15
layout: post
categories: 
  - תורת הסיבוכיות
tags: 
  - IP=PSPACE
  - הוכחות יפות
  - טכני
  - פרוייקט "תוצאות מפתיעות בסיבוכיות"
---
<a href="http://www.gadial.net/?p=1127">בפוסט הקודם שעסק בהוכחה</a> ש-{::nomarkdown}\( \mbox{IP}=\mbox{PSPACE}\){:/nomarkdown} הראיתי מערכת הוכחה אינטראקטיבית עבור השפה {::nomarkdown}\( \overline{3\mbox{SAT}}\){:/nomarkdown}. זו הייתה הדוגמה הראשונה למערכת הוכחה "רצינית", כזו שמשתמשת בכל הכוח של האינטראקטיביות; במערכות האחרות שהראיתי תוך סיבוב או שניים המשחק נגמר, ואילו כאן ההוכחה הייתה דיאלוג ארוך ומתמשך, שבו לאט לאט המוכיח והמוודא התקרבו אל עצם העניין. הרעיון, כזכור, היה כזה: בהינתן פסוק לוגי {::nomarkdown}\( \varphi\){:/nomarkdown}, אפשר היה לתרגם אותו לפולינום {::nomarkdown}\( P_{\varphi}\left(X_{1},\dots,X_{n}\right)\){:/nomarkdown} ב-{::nomarkdown}\( n\){:/nomarkdown} משתנים ואת שאלת הספיקות של {::nomarkdown}\( \varphi\){:/nomarkdown} לתרגם לשאלה האם {::nomarkdown}\( \sum_{b_{1}\in\left\{ 0,1\right\} }\dots\sum_{b_{n}\in\left\{ 0,1\right\} }P_{\varphi}\left(b_{1},\dots,b_{n}\right)=K\){:/nomarkdown} עבור {::nomarkdown}\( K\){:/nomarkdown} כלשהו. בפולינום הזה טיפלנו על ידי כך שהצלחנו לצמצם את הבדיקה של המשוואה לעיל לבדיקה של משוואה מהצורה {::nomarkdown}\( \sum_{b_{1}\in\left\{ 0,1\right\} }\dots\sum_{b_{n-1}\in\left\{ 0,1\right\} }P^{\prime}\left(b_{1},\dots,b_{n-1}\right)=K^{\prime}\){:/nomarkdown} - כלומר, צמצנו את הבעיה באופן רקורסיבי לבעיה קטנה יותר (עם משתנה אחת פחות בפולינום החדש) מאותו הסוג. הרעיונות הללו הם בדיוק הרעיונות שנשתמש בהם גם בהוכחה ש-{::nomarkdown}\( \mbox{IP=PSPACE}\){:/nomarkdown}, שהיא פשוט הוכחה לכך שהשפה {::nomarkdown}\( \mbox{TQBF}\){:/nomarkdown} שייכת ל-{::nomarkdown}\( \mbox{IP}\){:/nomarkdown}.

פסוק של {::nomarkdown}\( \mbox{TQBF}\){:/nomarkdown}, כזכור, הוא פסוק מהצורה {::nomarkdown}\( \exists x_{1}\forall x_{2}\exists x_{3}\dots\forall x_{n}\varphi\left(x_{1},\dots,x_{n}\right)\){:/nomarkdown}, כלומר כזה שבו מחליפים לסירוגין בין כמתי "קיים" ו"לכל". זה הבדל משמעותי מפסוק {::nomarkdown}\( \mbox{CNF}\){:/nomarkdown} רגיל שבו כל הכמתים היו "קיים". הערך {::nomarkdown}\( \sum_{b_{1}\in\left\{ 0,1\right\} }\dots\sum_{b_{n}\in\left\{ 0,1\right\} }P_{\varphi}\left(b_{1},\dots,b_{n}\right)\){:/nomarkdown} כבר לא ממש עוזר לנו - הוא אומר לנו מה מספר ההצבות של ערכים למשתני {::nomarkdown}\( \varphi\){:/nomarkdown} שיניבו {::nomarkdown}\( \mbox{T}\){:/nomarkdown}, אבל המספר הזה לא עוזר לנו ממש - למשל, נניח ש-{::nomarkdown}\( \varphi\){:/nomarkdown} הוא הפסוק {::nomarkdown}\( \varphi\left(x_{1},x_{2}\right)=\left(x_{1}\vee x_{2}\right)\wedge\left(\overline{x_{1}}\vee\overline{x_{2}}\right)\){:/nomarkdown}, שמוכר גם בסימון קצת יותר פופולרי כ-{::nomarkdown}\( x_{1}\oplus x_{2}\){:/nomarkdown} (פעולת XOR). לא קשה לראות כי {::nomarkdown}\( \sum_{b_{1}\in\left\{ 0,1\right\} }\sum_{b_{2}\in\left\{ 0,1\right\} }\varphi\left(b_{1},b_{2}\right)=2\){:/nomarkdown}, אבל {::nomarkdown}\( \exists x_{1}\forall x_{2}\varphi\left(x_{1},x_{2}\right)\){:/nomarkdown} הוא בבירור בעל ערך {::nomarkdown}\( \mbox{F}\){:/nomarkdown} (כי לא קיים {::nomarkdown}\( x_{1}\){:/nomarkdown} שעבורו <strong>כל</strong> {::nomarkdown}\( x_{2}\){:/nomarkdown} יניב ערך אמת כשמציבים את שניהם ב-{::nomarkdown}\( \varphi\){:/nomarkdown}). לעומת זאת, {::nomarkdown}\( \varphi\left(x_{1},x_{2}\right)=x_{1}\){:/nomarkdown} הוא פסוק קטן ביותר ומטופש שגם בו הסכום יהיה בדיוק 2, אבל בו התכונה כן מתקיימת (הצבה של {::nomarkdown}\( \mbox{T}\){:/nomarkdown} ל-{::nomarkdown}\( x_{1}\){:/nomarkdown} מספקת את הפסוק בלי תלות ב-{::nomarkdown}\( x_{2}\){:/nomarkdown}, כמובן).

למרבה המזל, טריק פשוט יחסית פותר את הבעיה הזו. כל מה שאנחנו רוצים לדעת בהינתן פסוק {::nomarkdown}\( \mbox{TQBF}\){:/nomarkdown} הוא אם ערך האמת שלו הוא {::nomarkdown}\( \mbox{T}\){:/nomarkdown} או {::nomarkdown}\( \mbox{F}\){:/nomarkdown}. אז בואו נשים לב שערך האמת של {::nomarkdown}\( \exists x_{1}\forall x_{2}\exists x_{3}\dots\forall x_{n}\varphi\left(x_{1},\dots,x_{n}\right)\){:/nomarkdown} הוא {::nomarkdown}\( \mbox{T}\){:/nomarkdown} אם ורק אם {::nomarkdown}\( \sum_{b_{1}\in\left\{ 0,1\right\} }\prod_{b_{2}\in\left\{ 0,1\right\} }\sum_{b_{3}\in\left\{ 0,1\right\} }\dots\prod_{b_{n}\in\left\{ 0,1\right\} }P_{\varphi}\left(b_{1},\dots,b_{n}\right)\ne0\){:/nomarkdown}. נסו להוכיח את זה לעצמכם - ההוכחה היא באינדוקציה פשוטה על מספר הכמתים, ומתבססת על כך ש-{::nomarkdown}\( P_{\varphi}\){:/nomarkdown} מקבל או 0 או 1, ושמכפלה של שני ערכים שהוא מקבל היא 1 רק אם שניהם היו 1, ושסכום של שני ערכים שהוא מקבל הוא 0 רק אם שניהם היו 0.

אז איך הפרוטקול של הפוסט הקודם יעבוד כאן? פשוט מאוד: המוכיח ישלח למוודא פולינום במשתנה יחיד {::nomarkdown}\( g\left(X_{1}\right)\){:/nomarkdown} שבתיאוריה מוגדר באמצעות הנוסחה {::nomarkdown}\( g\left(X_{1}\right)=\prod_{b_{2}\in\left\{ 0,1\right\} }\sum_{b_{3}\in\left\{ 0,1\right\} }\dots\prod_{b_{n}\in\left\{ 0,1\right\} }P_{\varphi}\left(X_{1},b_{2},\dots,b_{n}\right)\){:/nomarkdown}, והמוודא יוודא ש-{::nomarkdown}\( g\left(0\right)+g\left(1\right)\ne0\){:/nomarkdown}; וכעת המוודא ירצה להשתכנע ש-{::nomarkdown}\( g\left(X_{1}\right)\){:/nomarkdown} אכן הוגדר על פי הנוסחה הנ"ל ושהמוכיח לא סתם שלח לו פולינום מונפץ, אז הוא יגריל ערך {::nomarkdown}\( a\){:/nomarkdown} כלשהו מהשדה שמעליו עובדים (שהוא כזכור {::nomarkdown}\( \mathbb{Z}_{p}\){:/nomarkdown} עבור {::nomarkdown}\( p\){:/nomarkdown} ראשוני גדול מספיק), יחשב את {::nomarkdown}\( K=g\left(a\right)\){:/nomarkdown} ויתבע מהמוכיח שיוכיח לו כעת ש-{::nomarkdown}\( \prod_{b_{2}\in\left\{ 0,1\right\} }\sum_{b_{3}\in\left\{ 0,1\right\} }\dots\prod_{b_{n}\in\left\{ 0,1\right\} }P_{\varphi}\left(a,b_{2},\dots,b_{n}\right)=K\){:/nomarkdown}, והמשחק יימשך. בסיבוב הבא, המוודא יבדוק שהפולינום {::nomarkdown}\( g\left(X_{2}\right)\){:/nomarkdown} שהוא קיבל מקיים דווקא {::nomarkdown}\( g\left(0\right)\cdot g\left(1\right)=K\){:/nomarkdown}, אבל זה לא הבדל עקרוני.

פוף! סיימנו. זה היה קל!

...

כן, ברור לכם שזה לא כזה קל, נכון? אחרת הייתי מראה את זה כבר בפוסט הקודם. האם כבר הבנתם מה הבעיה? אני בכוונה משאיר אתכם קצת במתח, ובכוונה קצת ניסיתי לעבוד עליכם. חשוב לראות, ולהרגיש, עד כמה העסק הזה חמקמק ועד כמה הדקויות קריטיות כאן. זה מה שקורה כשמתעסקים קצת במתמטיקה "אמיתית" - מצד אחד חייבים להשתמש בקיצורי דרך ונפנופי ידיים והוכחות שאינן פורמליות עד הסוף, ומצד שני יש הרבה סכנות לקיצורי הדרך הללו ואפשר בקלות ליפול לתהום.

אז מה הבעיה? הבעיה היא שלא בטוח שהמוכיח יהיה מסוגל לשלוח למוודא את {::nomarkdown}\( g\left(X_{1}\right)\){:/nomarkdown}, כי הדרגה של {::nomarkdown}\( g\left(X_{1}\right)\){:/nomarkdown} עשויה להיות גבוהה מדי מכדי ששליחה שלו תאפשר לפרוטוקול להמשיך להיות יעיל מבחינת זמן הריצה. בואו נעשה סדר בדברים: זמן הריצה של הבעיה נמדד ביחס לגודל הקלט, כלומר גודל הנוסחה {::nomarkdown}\( \varphi\){:/nomarkdown}. אפשר גם כאן להניח שזו נוסחת {::nomarkdown}\( 3\mbox{CNF}\){:/nomarkdown} - נוסחה שמורכבת מפסוקיות כך שכל פסוקית מכילה שלושה משתנים בדיוק; נסמן ב-{::nomarkdown}\( m\){:/nomarkdown} את מספר הפסוקיות. את {::nomarkdown}\( P_{\varphi}\){:/nomarkdown} מייצגים בתור מכפלה של פולינומים שכל אחד מהם מייצג את אחת מהפסוקיות; פולינום שכזה, עם שיטת התרגום שהצגתי בפוסט הקודם, יהיה מדרגה 3, ולכן קל לייצוג (צריך לזכור את המקדמים של הפולינום, אבל יש מעט כאלו - כמה?). בסך הכל צריך כמות זכרון שהיא "בערך {::nomarkdown}\( m\){:/nomarkdown}" כדי לייצג את {::nomarkdown}\( P_{\varphi}\){:/nomarkdown}, כש"בערך" פירושו "{::nomarkdown}\( m\){:/nomarkdown} כפול קבוע כלשהו" - מסמנים זאת {::nomarkdown}\( O\left(m\right)\){:/nomarkdown}.

כעת, בפרוטוקול שהראינו בפוסט הקודם, שבו {::nomarkdown}\( g\left(X_{1}\right)\){:/nomarkdown} הוגדר בתור {::nomarkdown}\( \sum_{b_{2}\in\left\{ 0,1\right\} }\sum_{b_{3}\in\left\{ 0,1\right\} }\dots\sum_{b_{n}\in\left\{ 0,1\right\} }P_{\varphi}\left(X_{1},b_{2},\dots,b_{n}\right)\){:/nomarkdown}, מה שקרה הוא ש-{::nomarkdown}\( g\left(X_{1}\right)\){:/nomarkdown} היה פולינום שהתקבל מחיבור הרבה פולינומים במשתנה יחיד שדרגתם לכל היותר {::nomarkdown}\( 3m\){:/nomarkdown} (כי דרגת {::nomarkdown}\( P_{\varphi}\){:/nomarkdown} הייתה {::nomarkdown}\( 3m\){:/nomarkdown}). חיבור פולינומים לא יכול להגדיל את הדרגה שלהם, ולכן {::nomarkdown}\( 3m\){:/nomarkdown} נותר חסם גם על דרגת {::nomarkdown}\( g\left(X_{1}\right)\){:/nomarkdown}, מה שאומר שכמות המקדמים שהמוכיח צריך לשלוח למוודא כדי לשדר אליו את {::nomarkdown}\( g\left(X_{1}\right)\){:/nomarkdown} הייתה סבירה ביחס לגודל הקלט של הפרוטוקול, והכל עבד יופי טופי.

בפרוטוקול החדש, לעומת זאת, הכשל הוא מוחץ, שכן {::nomarkdown}\( g\left(X_{1}\right)\){:/nomarkdown} נבנה לא רק באמצעות חיבור פולינומים אלא גם הכפלתם; והכפלה של שני פולינומים בהחלט יכולה להגדיל את הדרגה של התוצאה: {::nomarkdown}\( \left(x+1\right)\left(x-1\right)=x^{2}-1\){:/nomarkdown}. מכיוון שהדרגה של פולינום התוצאה יכולה להכפיל את עצמה בכל פעם שבה אנחנו נתקלים בפעולת כפל בהגדרה של {::nomarkdown}\( g\left(X_{1}\right)\){:/nomarkdown}, הדרגה של {::nomarkdown}\( g\left(X_{1}\right)\){:/nomarkdown} עשויה להיות אקספוננציאלית (ב-{::nomarkdown}\( n\){:/nomarkdown}; שהוא בתורו עשוי בהחלט לפעמים להיות מאותו סדר גודל של {::nomarkdown}\( m\){:/nomarkdown}). בקיצור, רק לשלוח את כל המקדמים של {::nomarkdown}\( g\left(X_{1}\right)\){:/nomarkdown} מהמוכיח אל המוודא ייקח זמן רב מדי מכדי שהפרוטוקול ייחשב יעיל והכל הלך לעזאזל.

אז מה עושים? מכניסים לתמונה עוד טריק אחד, שפותר את הבעיה - <strong>לינאריזציה</strong>. לינאריזציה פירושה לקחת פולינום {::nomarkdown}\( P\left(X_{1},\dots,X_{n}\right)\){:/nomarkdown} כלשהו, שבו המשתנה {::nomarkdown}\( X_{i}\){:/nomarkdown} עשוי להופיע בדרגה גבוהה, ולהחליף אותו בפולינום חדש, {::nomarkdown}\( Q\left(X_{1},\dots,X_{n}\right)\){:/nomarkdown} שבו הדרגה של {::nomarkdown}\( X_{i}\){:/nomarkdown} היא 1 (כלומר, ב-{::nomarkdown}\( Q\){:/nomarkdown} לא מופיע {::nomarkdown}\( X_{i}^{2}\){:/nomarkdown}, או {::nomarkdown}\( X_{i}^{3}\){:/nomarkdown} וכדומה), ועם זאת {::nomarkdown}\( Q\){:/nomarkdown} הוא "שקול" ל-{::nomarkdown}\( P\){:/nomarkdown} במובן זה שעל הצבה של ערכי 0 ו-1 למשתנים שלהם מתקבלת אותה התוצאה (וזה, כזכור, כל מה שחשוב לנו - אנחנו מנסים לברר מה מתקבל מ-{::nomarkdown}\( P_{\varphi}\){:/nomarkdown} כשמציבים בו 0 ו-1 בכל הצורות האפשריות ואז עושים מיש-מש מכל התוצאות).

בואו נעבור לתאר את העסק בצורה פורמלית, וכזו שלוכדת בו זמנית הן את פעולת הלינאריזציה והן את האופן שבו "מחסלים" כמתים - בעזרת אופרטורים. "אופרטור" כאן זה שם מפוצץ לפונקציה שלוקחת פולינום אחד ומחזירה פולינום אחר, במקרה שלנו אחד פשוט יותר. בשביל פעולת הלינאריזציה נגדיר אופרטור {::nomarkdown}\( L_{X_{i}}\){:/nomarkdown} - "לינאריזציה על פי המשתנה {::nomarkdown}\( X_{i}\){:/nomarkdown}", שפועל כך:

{::nomarkdown}\( L_{X_{i}}P\left(X_{1},\dots,X_{i},\dots,X_{n}\right)=X_{i}\cdot P\left(X_{1},\dots,1,\dots X_{n}\right)+\left(1-X_{i}\right)\cdot P\left(X_{1},\dots,0,\dots X_{n}\right)\){:/nomarkdown}

כלומר, האופרטור לוקח את {::nomarkdown}\( P\){:/nomarkdown}, מציב פעם 0 ופעם 1 במקום {::nomarkdown}\( X_{i}\){:/nomarkdown}, מקבל שני פולינומים חדשים עם משתנה אחד פחות, כופל את האחד במשתנה {::nomarkdown}\( X_{i}\){:/nomarkdown} ואת השני במשתנה {::nomarkdown}\( 1-X_{i}\){:/nomarkdown}, ומחבר. הנה דוגמה: נניח ש-{::nomarkdown}\( P\left(X_{1},X_{2}\right)=X_{1}^{5}+2X_{1}^{2}X_{2}+X_{2}^{3}\){:/nomarkdown}. אז נקבל:

{::nomarkdown}\( L_{X_{1}}P=X_{1}\left(1+2X_{2}+X_{2}^{3}\right)+\left(1-X_{1}\right)X_{2}^{3}=X_{1}+2X_{1}X_{2}+X_{2}^{3}\){:/nomarkdown}

שימו לב שקיבלנו את הפולינום המקורי, רק שבכל מקום שבו הופיע {::nomarkdown}\( X_{1}\){:/nomarkdown} בחזקה כלשהי, עכשיו הוא מופיע בלי חזקה (או פורמלית, עם החזקה 1). זה לא מקרי, כמובן; {::nomarkdown}\( P\left(X_{1},\dots,1,\dots X_{n}\right)\){:/nomarkdown} הוא הפולינום {::nomarkdown}\( P\){:/nomarkdown} על כל מחובריו, כשהמשתנה {::nomarkdown}\( X_{i}\){:/nomarkdown} פשוט נמחק ממנו. לכן {::nomarkdown}\( X_{i}\cdot P\left(X_{1},\dots,1,\dots X_{n}\right)\){:/nomarkdown} הוא הפולינום {::nomarkdown}\( P\){:/nomarkdown} כאשר כל מופע קיים של {::nomarkdown}\( X_{i}\){:/nomarkdown} בחזקה כלשהי שונה למופע בחזקה 1; אבל לרוע המזל גם מחוברים שבהם {::nomarkdown}\( X_{i}\){:/nomarkdown} לא הופיע כעת כוללים אותו. זה מתוקן עם {::nomarkdown}\( \left(1-X_{i}\right)P\left(X_{1},\dots,0,\dots X_{n}\right)\){:/nomarkdown} - נסו להסביר לעצמכם מדוע!

כעת הבה ונגדיר אופרטורים עבור {::nomarkdown}\( \forall\){:/nomarkdown} ו-{::nomarkdown}\( \exists\){:/nomarkdown}:

{::nomarkdown}\( \forall_{X_{i}}P\left(X_{1},\dots,X_{n}\right)=P\left(X_{1},\dots,0,\dots,X_{n}\right)\cdot P\left(X_{1},\dots,1,\dots,X_{n}\right)\){:/nomarkdown}

{::nomarkdown}\( \exists_{X_{i}}P\left(X_{1},\dots,X_{n}\right)=P\left(X_{1},\dots,0,\dots,X_{n}\right)+P\left(X_{1},\dots,1,\dots,X_{n}\right)\){:/nomarkdown}

כעת אפשר לנסח מחדש את הבעיה שלנו: בהינתן פולינום {::nomarkdown}\( P\left(X_{1},\dots,X_{n}\right)\){:/nomarkdown}, נשים לב ש-{::nomarkdown}\( \exists_{X_{1}}\forall_{X_{2}}\dots\exists_{X_{n}}P\left(X_{1},\dots,X_{n}\right)\){:/nomarkdown} הוא פולינום קבוע, ללא משתנים, כלומר הוא ערך מספרי; האתגר של המוכיח יהיה להוכיח כי {::nomarkdown}\( \exists_{X_{1}}\forall_{X_{2}}\dots\exists_{X_{n}}P\left(X_{1},\dots,X_{n}\right)=K\){:/nomarkdown} עבור {::nomarkdown}\( K\){:/nomarkdown} נתון כלשהו.

האבחנה החשובה כאן היא שאם מגניבים לתוך הפעלות האופרטורים הללו גם הפעלות של אופרטור הלינאריזציה, זה לא משנה את התוצאה הסופית - זאת מכיוון שהתוצאה הזו מתקבלת אך ורק על ידי הצבת 0 ו-1 לפולינומים שבדרך, ואמרנו כבר שלינאריזציה לא משפיעה על הערכים שהפולינום מחזיר עבור הצבות שכאלו. לכן אפשר לעדכן את החישוב שאנחנו רוצים לבצע - המוכיח רוצה להוכיח כי:

{::nomarkdown}\( \exists_{X_{1}}L_{X_{1}}\forall_{X_{2}}L_{X_{1}}L_{X_{2}}\dots\exists_{X_{n}}L_{X_{1}}\dots L_{X_{n}}P\left(X_{1},\dots,X_{n}\right)=K\){:/nomarkdown}

יש כאן בסך הכל {::nomarkdown}\( 1+2+\dots+n=O\left(n^{2}\right)\){:/nomarkdown} הפעלות של אופרטור הלינאריזציה, כך שהוא לא מבזבז יותר מדי זמן ריצה.

הפרוטוקול כעת "מקלף" את הכמתים משמאל לימין באותה שיטה של הפוסט הקודם. למשל, שימו לב לכך ש-{::nomarkdown}\( L_{X_{1}}\forall_{X_{2}}L_{X_{1}}L_{X_{2}}\dots\exists_{X_{n}}L_{X_{1}}\dots L_{X_{n}}P\left(X_{1},\dots,X_{n}\right)\){:/nomarkdown} הוא פולינום במשתנה יחיד, {::nomarkdown}\( X_{1}\){:/nomarkdown}, ושבגלל אופרטור הלינאריזציה בקצה השמאלי, זה פולינום ממעלה נמוכה (מעלה 1, למעשה!) ולכן המוכיח בוודאי יכול לשלוח למוודא פולינום {::nomarkdown}\( g\left(X_{1}\right)\){:/nomarkdown} שלכאורה אמור להיות שווה אליו. המוודא יבדוק ש-{::nomarkdown}\( g\left(0\right)+g\left(1\right)=K\){:/nomarkdown}, ואז יציב אתגר חדש למוכיח, שמטרתו להוכיח ש-{::nomarkdown}\( g\left(X_{1}\right)\){:/nomarkdown} הוא מה שהוא מתיימר להיות: הוא יגריל {::nomarkdown}\( a_{1}\){:/nomarkdown} כלשהו מהשדה, יחשב את {::nomarkdown}\( K^{\prime}=g\left(a_{1}\right)\){:/nomarkdown}, ויבקש מהמוכיח להוכיח לו ש-{::nomarkdown}\( L_{X_{1}}\forall_{X_{2}}L_{X_{1}}L_{X_{2}}\dots\exists_{X_{n}}L_{X_{1}}\dots L_{X_{n}}P\left(a_{1},\dots,X_{n}\right)=K^{\prime}\){:/nomarkdown} (חשבו על זה כעל הפולינום {::nomarkdown}\( L_{X_{1}}\forall_{X_{2}}L_{X_{1}}L_{X_{2}}\dots\exists_{X_{n}}L_{X_{1}}\dots L_{X_{n}}P\left(X_{1},\dots,X_{n}\right)\){:/nomarkdown}, שהוא פולינום במשתנה היחיד {::nomarkdown}\( X_{1}\){:/nomarkdown}, שאחר כך מציבים בו גם {::nomarkdown}\( a_{1}\){:/nomarkdown}).

מה יקרה עכשיו? המוכיח ישלח למוודא איזה {::nomarkdown}\( g\left(X_{1}\right)\){:/nomarkdown} שאמור להיות {::nomarkdown}\( \forall_{X_{2}}L_{X_{1}}L_{X_{2}}\dots\exists_{X_{n}}L_{X_{1}}\dots L_{X_{n}}P\left(X_{1},\dots,X_{n}\right)\){:/nomarkdown}; המוודא יוודא ש-{::nomarkdown}\( a_{1}g\left(1\right)+\left(1-a_{1}\right)g\left(0\right)=K^{\prime}\){:/nomarkdown}, כלומר שאם עושים ל-{::nomarkdown}\( g\){:/nomarkdown} לינאריזציה לפיה {::nomarkdown}\( X_{1}\){:/nomarkdown} ואז מציבים ב-{::nomarkdown}\( X_{1}\){:/nomarkdown} את הערך {::nomarkdown}\( a_{1}\){:/nomarkdown}, אכן מקבלים את ה-{::nomarkdown}\( K^{\prime}\){:/nomarkdown} שאנו מצפים לקבל. כעת המוודא יבחן את המוכיח על ה-{::nomarkdown}\( g\){:/nomarkdown} הזה על ידי הגרלת ערך {::nomarkdown}\( a\){:/nomarkdown} חדש, ותביעה מהמוכיח להוכיח ש-{::nomarkdown}\( g\left(a\right)=\forall_{X_{2}}L_{X_{1}}L_{X_{2}}\dots\exists_{X_{n}}L_{X_{1}}\dots L_{X_{n}}P\left(a,\dots,X_{n}\right)\){:/nomarkdown} (הערך {::nomarkdown}\( a_{1}\){:/nomarkdown} הקודם נזרק לפח), וכן הלאה וכן הלאה. בסופו של דבר כל האופרטורים מקולפים, ולמוודא נשאר רק לוודא שמתקיים {::nomarkdown}\( P\left(a_{1},a_{2},\dots,a_{n}\right)=K\){:/nomarkdown} עבור ערכים {::nomarkdown}\( a_{1},\dots,a_{n}\){:/nomarkdown} ספציפיים, ואת זה הוא כמובן מסוגל לעשות בעצמו.

בואו נתאר את התהליך באופן כללי. בכל שלב של האלגוריתם יש למוודא פולינום כלשהו, {::nomarkdown}\( h\left(X_{1},\dots,X_{n}\right)\){:/nomarkdown} (שהוא {::nomarkdown}\( P\left(X_{1},\dots,X_{n}\right)\){:/nomarkdown} אחרי שהופעלו עליו חלק מהאופרטורים, מימין לשמאל) ותפקידו של המוודא בחיים הוא לבדוק ש-{::nomarkdown}\( h\left(a_{1},\dots,a_{n}\right)=K\){:/nomarkdown} עבור {::nomarkdown}\( K\){:/nomarkdown} קבוע וערכים {::nomarkdown}\( a_{1},\dots,a_{n}\){:/nomarkdown} מסויימים. שימו לב שהשימוש שלי בסימונים עשוי להיות מבלבל למדי כאן - למשל, בסיבוב הראשון של הפרוטוקול {::nomarkdown}\( h\){:/nomarkdown} הוא פשוט {::nomarkdown}\( \exists_{X_{1}}L_{X_{1}}\forall_{X_{2}}L_{X_{1}}L_{X_{2}}\dots\exists_{X_{n}}L_{X_{1}}\dots L_{X_{n}}P\left(X_{1},\dots,X_{n}\right)\){:/nomarkdown}, וזה פולינום בלי משתנים חופשיים כלל. אז את הסימון {::nomarkdown}\( h\left(X_{1},\dots,X_{n}\right)\){:/nomarkdown} יש לקרוא כאומר שהמשתנים ש<strong>עשויים</strong> להופיע ב-{::nomarkdown}\( h\){:/nomarkdown} הם {::nomarkdown}\( X_{1},\dots,X_{n}\){:/nomarkdown}, וש-{::nomarkdown}\( h\left(a_{1},\dots,a_{n}\right)\){:/nomarkdown} הוא מה שמתקבל ב-{::nomarkdown}\( h\){:/nomarkdown} כשמציבים להם את הערכים {::nomarkdown}\( a_{1},\dots,a_{n}\){:/nomarkdown}, כאשר משתנה שכלל לא מופיע ב-{::nomarkdown}\( h\){:/nomarkdown} מן הסתם לא משפיע על התוצאה. כמו כן, לא ברור מיהם {::nomarkdown}\( a_{1},\dots,a_{n}\){:/nomarkdown} בתחילת הפרוטוקול (ראינו שהם נקבעים במהלכו, ולפעמים עוברים מספר שינויים) - אז אפשר לאתחל את כולם להיות 0 או כל ערך שרירותי אחר, אבל אם אתם עדיין מצליחים לעקוב אחרי מה שהולך כאן בוודאי תראו שזה לא באמת משנה.

מה שהמוודא עושה הוא לקלף את האופרטור הבא, אם עוד קיים כזה: כלומר, לשים לב לכך ש-{::nomarkdown}\( h\left(X_{1},\dots,X_{n}\right)=\Phi f\left(X_{1},\dots,X_{n}\right)\){:/nomarkdown}, כאשר {::nomarkdown}\( \Phi\){:/nomarkdown} הוא או אופרטור {::nomarkdown}\( L\){:/nomarkdown}, או אופרטור {::nomarkdown}\( \forall\){:/nomarkdown}, או אופרטור {::nomarkdown}\( \exists\){:/nomarkdown}. כעת הפרוטוקול מתנהג בשלוש דרכים שונות, בהתאם לזהות האופרטור:

אם {::nomarkdown}\( \Phi=\forall_{X_{i}}\){:/nomarkdown} אז המוכיח שולח למוודא פולינום במשתנה יחיד {::nomarkdown}\( g\left(X_{i}\right)\){:/nomarkdown} שאמור להיות {::nomarkdown}\( f\left(a_{1},\dots,X_{i},\dots,a_{n}\right)\){:/nomarkdown}. המוודא בודק ש-{::nomarkdown}\( g\left(0\right)\cdot g\left(1\right)=K\){:/nomarkdown}. אם לא, הוא דוחה; אחרת, הוא מגריל ערך חדש של {::nomarkdown}\( a_{i}\){:/nomarkdown} ומבקש מהמוכיח להוכיח לו ש-{::nomarkdown}\( f\left(a_{1},\dots a_{i},\dots,a_{n}\right)=g\left(a_{i}\right)\){:/nomarkdown}.

אם {::nomarkdown}\( \Phi=\exists_{X_{i}}\){:/nomarkdown} קורה אותו הסיפור כמו במקרה של {::nomarkdown}\( \forall\){:/nomarkdown}, פרט לכך שהמוודא בודק ש-{::nomarkdown}\( g\left(0\right)+g\left(1\right)=K\){:/nomarkdown}.

אם {::nomarkdown}\( \Phi=L_{X_{i}}\){:/nomarkdown} אז שוב, קורה אותו הסיפור פרט לכך שהמוודא בודק ש-{::nomarkdown}\( a_{i}g\left(1\right)+\left(1-a_{i}\right)g\left(0\right)=K\){:/nomarkdown}.

זה סוף ההוכחה. כלומר, עוד נשאר לעשות את ניתוח הסיבוכיות וניתוח ההסתברויות המדויק, אבל אין הבדל מהותי בינו ובין מה שראינו בפוסט הקודם ומה שאמרנו עד כה. למוכיח יש הסתברות זניחה מאוד להצליח לעבוד על המוודא עם הפולינומים שהוא שולח מאותה סיבה שהייתה בפוסט הקודם - יש המון ערכים שהמוודא יכול לבחור באקראי מהשדה, ואם המוכיח רימה בפולינום {::nomarkdown}\( g\){:/nomarkdown} שהוא שלח, רוב הסיכויים שהמוודא יצליח להגריל ערך שעליו {::nomarkdown}\( g\){:/nomarkdown} לא מניב את התוצאה שהוא אמור להניב, והמוכיח יוותר עם טענה שקרית שעליו להוכיח, אבל סיבוב אחד פחות שבו יש לו הזדמנות לרמות.

ובכן, האם זו הוכחה קשה? מסובכת? מצד אחד, היא בהחלט אינה טריוויאלית - חשבו על כך שהיא מכילה גם את תעלול האריתמטיזציה, וגם את תעלול הלינאריזציה - אך מצד שני, אני סבור שניתן להבין את כל מה שהולך בה יחסית בקלות. זו עדיין לא תוצאה מתמטית מפלצתית שנדרשים חמישים עמודים כדי להוכיח. עם זאת, למי שסקרן לדעת איך נראות הוכחות "רציניות" בתורת הסיבוכיות, אני חושב שההוכחה הזו היא מבוא נאה ביותר לעניין.
