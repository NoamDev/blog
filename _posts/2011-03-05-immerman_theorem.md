---
id: 1046
title: "NL=coNL (\"משפט אימרמן\") - מי, מה, כמה ולמה"
date: 2011-03-05 18:39:14
layout: post
categories: 
  - תורת הסיבוכיות
tags: 
  - סיבוכיות זכרון
  - פרוייקט "תוצאות מפתיעות בסיבוכיות"
  - תוצאות לא אינטואיטיביות
  - תורת הסיבוכיות
---
בשעה טובה אנו עוברים לתיאור התוצאה השניה ב"<a href="http://www.gadial.net/?p=914">תוצאות מפתיעות בסיבוכיות</a>" - הטענה {::nomarkdown}\( \mbox{NL=coNL}\){:/nomarkdown}, או בשמה הקליט יותר, משפט אימרמן-סזלפסני (Immerman–Szelepcsényi - אין לי מושג איך לתעתק נכון), ומכאן ואילך - משפט אימרמן. אז על מה מדובר בכלל?

ראשית כל תזכורת כללית למה אנחנו עושים בתורת הסיבוכיות. המטרה היא לסווג בעיות לפי כמות המשאבים הנדרשת כדי לפתור אותן (כמות שנמדדת תמיד ביחס לגודל הקלט שאיתו מנסים להתמודד). לצורך פשטות, אנחנו אוהבים להתעסק במיוחד בבעיות "כן/לא" - בעיות שבהן מביאים לנו קלט מסויים ושואלים אותנו האם הוא מקיים תכונה מסויימת (תכונה שהיא חלק מהגדרת הבעיה). למשל - נתון לנו גרף (מהו גרף? זה ידע קודם שנדרש למי שרוצה לקרוא פוסטים על מדעי המחשב) ושני צמתים בו - {::nomarkdown}\( s,t\){:/nomarkdown} - ואנו רוצים לדעת אם קיים בגרף מסלול מ-{::nomarkdown}\( s\){:/nomarkdown} אל {::nomarkdown}\( t\){:/nomarkdown}. שימו לב לאופי ה"כן/לא"-י של הבעיה - לא ביקשנו לדעת <strong>מהו</strong> המסלול, אלא רק לדעת אם הוא קיים.

ייתכן שנראה לכם קצת מוזר שאפשר יהיה לגלות אם קיים מסלול בלי למצוא אותו במפורש, אבל יש בעיות שבהן זה קצת יותר ברור - למשל, בהינתן מספר {::nomarkdown}\( n\){:/nomarkdown}, לגלות שהוא אינו ראשוני, כלומר קיים מספר בין 1 ל-{::nomarkdown}\( n\){:/nomarkdown} שמחלק אותו - את זה אפשר לבצע ביעילות, בעוד שלא ברור איך אפשר למצוא ביעילות מספר שמחלק את {::nomarkdown}\( n\){:/nomarkdown} (איך? יש כמה שיטות ותיארתי בעבר אחת מהן; אם מוצאים {::nomarkdown}\( a\){:/nomarkdown} כך שבמהלך החישוב של {::nomarkdown}\( a^{n}\){:/nomarkdown} מודולו {::nomarkdown}\( n\){:/nomarkdown} מתגלה שורש יחידה לא טריוויאלי - זה אומר מייד ש-{::nomarkdown}\( n\){:/nomarkdown} אינו ראשוני אף שזה כלל לא רומז על האופן שבו ניתן לפרק אותו).

כפי שמראה הדוגמה שלמעלה, בשאלות "כן/לא" רבות אפשר לתת תשובה חיובית בקלות אם נותנים לכם "רמז" לכך שהתשובה אכן חיובית. למשל, בשאלת הגרף - אם ייתנו לכם את מסלול בין {::nomarkdown}\( s\){:/nomarkdown} ו-{::nomarkdown}\( t\){:/nomarkdown}, החיים יהיו קלים יותר - במקום לחפש מסלול בעצמכם רק תצטרכו לבדוק שהמסלול שנתנו לכם הוא בסדר. שימו לב שאם התשובה היא "לא", לא ממש ברור איזה רמז אפשר לתת שישכנע אתכם בכך שהתשובה היא אכן שלילית.

התופעה הזו, של בעיות שאפשר לתת "רמז" - או בשם היותר מקובל של המונח, "עד", Witness - לכך שהתשובה להן חיובית, כה חשובה עד שזכתה לסימון מיוחד: NP היא מחלקת הבעיות שניתן בזמן חישוב יעיל (יעיל במשמעות של פולינומי - זו הגדרה טכנית שלא אכנס אליה כעת) לבדוק עדים עבור תשובות "כן" שלהן. מה שאנחנו דורשים הוא שני דברים: שאם התשובה היא כן, אז יהיה קיים עד שניתן לבדוק בזמן יעיל ולענות בחיוב, ושאם התשובה היא לא אז אי אפשר לרמות אותנו - כל "עד" שיתנו לנו יוביל לכך שניתן תשובה שלילית, כלומר נצליח לזהות שהעד שנתנו לנו לא שווה כלום. אני אוהב לחשוב על עדים בתור "הוכחות" לנכונות של טענה. השימוש במילה הזו קצת מסוכן כי במתמטיקה אנחנו רגילים לחשוב על הוכחה בתור סדרה של טענות שכל אחת מהן נובעת לוגית מהשנייה; ה"הוכחות" שלי הן משהו יותר כללי - כלי שמאפשר לך לוודא בקלות בעצמך שטענה היא נכונה. הכלי הזה יכול להיות כתוב כמו הוכחה מתמטית רגילה, אבל זה יכול להיות גם מסלול בגרף.

שימו לב לחוסר הסימטריה שהיה בכל ההגדרה הזו של NP. דיברתי על בעיות שיש עדים עבור תשובות <strong>כן</strong> שלהן, אבל כפי שראינו עם דוגמת המסלול, זה לא אומר שלתשובות "לא" יהיה עד באותה קלות. מצד שני, הבה ונתבונן בבעיה הבאה: נתון גרף ושני צמתים {::nomarkdown}\( s,t\){:/nomarkdown} ואנו רוצים לדעת אם <strong>לא</strong> קיים מסלול מ-{::nomarkdown}\( s\){:/nomarkdown} אל {::nomarkdown}\( t\){:/nomarkdown}. כאן יש עד פשוט מאוד לכך שהטענה <strong>אינה</strong> נכונה עבור גרף נתון - פשוט מראים מסלול מ-{::nomarkdown}\( s\){:/nomarkdown} אל {::nomarkdown}\( t\){:/nomarkdown} וזה משכנע אותנו בודאות שהטענה "אין מסלול מ-{::nomarkdown}\( s\){:/nomarkdown} אל {::nomarkdown}\( t\){:/nomarkdown}" איננה נכונה. בוודאי תגידו שאני רמאי עלוב. בסך הכל לקחתי את הבעיה המקורית והפכתי קצת את הניסוח שלה. אבל זו לא באמת רמאות - כל בעיה שבה יש עד לתשובת "לא" אפשר להמיר לבעיה "משלימה" שבה יש עד לתשובת "כן" דווקא.

בואו נעבור לקצת טרמינולוגיה מדוייקת. במקום לדבר כל הזמן על "בעיות", מדעני מחשב מדברים על "שפות". שפה {::nomarkdown}\( L\){:/nomarkdown} היא קבוצה של מילים - מחרוזות סופיות של תווים שמייצגות מידע כלשהו (יכול להיות קידוד של גרף, מספר, קוד של תוכנית מחשב וכדומה - תלוי בהקשר). למשל, אפשר לדבר על השפה שמכילה את כל השלשות {::nomarkdown}\( \left(G,s,t\right)\){:/nomarkdown} של גרף {::nomarkdown}\( G\){:/nomarkdown} עם צמתים {::nomarkdown}\( s,t\){:/nomarkdown} שיש מסלול ביניהם. השפה המשלימה ל-{::nomarkdown}\( L\){:/nomarkdown} מסומנת ב-{::nomarkdown}\( \overline{L}\){:/nomarkdown} - זו שפת כל המחרוזות שאינן ב-{::nomarkdown}\( L\){:/nomarkdown} (מראש אנחנו מניחים שמדובר רק על מחרוזות בינאריות, נאמר, כך שהשאלה מהי "קבוצת כל המחרוזות" שלוקחים משלים ביחס אליה איננה בעייתית). למשל, אם {::nomarkdown}\( L\){:/nomarkdown} היא שפת השלשות {::nomarkdown}\( \left(G,s,t\right)\){:/nomarkdown} שתיארתי קודם, אז {::nomarkdown}\( \overline{L}\){:/nomarkdown} היא שפת השלשות {::nomarkdown}\( \left(G,s,t\right)\){:/nomarkdown} של גרף {::nomarkdown}\( G\){:/nomarkdown} עם צמתים {::nomarkdown}\( s,t\){:/nomarkdown} שאין ביניהם מסלול. אולי תגידו עכשיו שיש גם הרבה מחרוזות שבכלל לא מייצגות שלשה {::nomarkdown}\( \left(G,s,t\right)\){:/nomarkdown} וגם הן אמורות להיות ב-{::nomarkdown}\( \overline{L}\){:/nomarkdown}; כדי להיפרד מהמטרד הלא חשוב הזה נוח להניח שכל מחרוזת שמייצגת ג'יבריש תיחשב על ידינו ככזו שמייצגת איזה קלט טריוויאלי - למשל {::nomarkdown}\( \left(G,s,t\right)\){:/nomarkdown} כאשר {::nomarkdown}\( G\){:/nomarkdown} הוא גרף ששני הצמתים היחידים בו הם {::nomarkdown}\( s,t\){:/nomarkdown} ואין קשתות. הדברים הללו לא קריטייים ממילא ולא אחזור אליהם.

אומרים ש-{::nomarkdown}\( L\in\mbox{NP}\){:/nomarkdown} אם קיימת מכונת טיורינג {::nomarkdown}\( M\){:/nomarkdown} (ואם "מכונת טיורינג" לא אומר לכם כלום, תחשבו על "אלגוריתם" ותו לא; הסיבה שאומרים מכונת טיורינג במקום אלגוריתם היא אך ורק מכיוון שאין הגדרה מתמטית פורמלית ל"אלגוריתם") כך שאם {::nomarkdown}\( x\in L\){:/nomarkdown} אז קיים {::nomarkdown}\( y\){:/nomarkdown} כלשהו כך ש-{::nomarkdown}\( M\left(x,y\right)=\mbox{ACCEPT}\){:/nomarkdown}, כלומר {::nomarkdown}\( M\){:/nomarkdown}, כשהיא רצה על הקלטים {::nomarkdown}\( x,y\){:/nomarkdown} יחדיו, מסיימת את ריצה עם הפלט "Accept''; ואם {::nomarkdown}\( x\notin L\){:/nomarkdown} אז לכל {::nomarkdown}\( y\){:/nomarkdown} {::nomarkdown}\( M\left(x,y\right)=\mbox{REJECT}\){:/nomarkdown}, כלומר {::nomarkdown}\( M\){:/nomarkdown} דוחה כל "נסיון הוכחה" לכך ש-{::nomarkdown}\( x\in L\){:/nomarkdown} במקרה שבו {::nomarkdown}\( x\notin L\){:/nomarkdown}. יש על {::nomarkdown}\( M\){:/nomarkdown} דרישה אחת נוספת - שזמן הריצה שלה יהיה יעיל - פולינומי - ביחס לגודל של {::nomarkdown}\( x\){:/nomarkdown}. הדרישה הזו אוטומטית גם מגבילה את {::nomarkdown}\( y\){:/nomarkdown}; אם {::nomarkdown}\( y\){:/nomarkdown} הוא יותר מאשר פולינומי בגודל של {::nomarkdown}\( x\){:/nomarkdown}, אז {::nomarkdown}\( M\){:/nomarkdown} פשוט לא תספיק לקרוא את כולו. לכן לפעמים כדי לפשט את החיים דורשים מראש ש-{::nomarkdown}\( y\){:/nomarkdown} יהיה פולינומי ב-{::nomarkdown}\( x\){:/nomarkdown}.

כעת אפשר להציג את {::nomarkdown}\( \mbox{coNP}\){:/nomarkdown}: בפשטות, זו המחלקה של כל המשלימות של שפות ב-{::nomarkdown}\( \mbox{NP}\){:/nomarkdown}: {::nomarkdown}\( \mbox{coNP}=\left\{ \overline{L}\|L\in\mbox{NP}\right\} \){:/nomarkdown}. כפי שתיארתי לעיל, זו מחלקת השפות שיש עבורן תהליך-בדיקת-עדים כך שעבור תשובת "לא" קיים {::nomarkdown}\( y\){:/nomarkdown} שמוכיח זאת, ועבור תשובת "כן" אין אף {::nomarkdown}\( y\){:/nomarkdown} שיעבוד עלינו ויגרום לנו לחשוב שהתשובה היא "לא". וכעת לשאלת המחץ: האם {::nomarkdown}\( \mbox{NP}=\mbox{coNP}\){:/nomarkdown}?

האם העובדה שקל להוכיח שמשהו הוא "כן" גוררת שיהיה קל להוכיח אם הוא "לא", ולהפך? האם העולם סימטרי ונחמד? זו השאלה. נתון גרף ונשאלת השאלה אם אפשר לצבוע אותו בשלושה צבעים. אם מישהו יתן לי את הצביעה יהיה לי קל לבדוק שהגרף אכן ניתן לצביעה כזו; האם יש דרך פשוטה במידה דומה לשכנע אותי שהגרף לא ניתן ל<strong>שום</strong> צביעה? אםh תוכיחו את זה, הוכחתם כי {::nomarkdown}\( \mbox{NP=coNP}\){:/nomarkdown}. אני מקווה שאתם מרגישים את חוסר הסימטריה המשווע שיש כאן; הוא הסיבה לכך שהאמונה הרווחת היא ש-{::nomarkdown}\( \mbox{NP}\ne\mbox{coNP}\){:/nomarkdown}.

ייתכן שאתם תוהים מה הקשר של השאלה הזו לשאלה המפורסמת ביותר, האם {::nomarkdown}\( \mbox{P=NP}\){:/nomarkdown} ({::nomarkdown}\( \mbox{P}\){:/nomarkdown} היא מחלקת השפות שניתן להכריע עם אלגוריתם פולינומי שכלל לא נזקק לעדים). ובכן, אם {::nomarkdown}\( \mbox{P=NP}\){:/nomarkdown} אז {::nomarkdown}\( \mbox{NP=coNP=P}\){:/nomarkdown} (וזאת מכיוון ש-{::nomarkdown}\( \mbox{P}\){:/nomarkdown} סגורה למשלים), אבל אם {::nomarkdown}\( \mbox{P}\ne\mbox{NP}\){:/nomarkdown} (וכך סבורים כולם, כמעט) זה לא אומר ש-{::nomarkdown}\( \mbox{NP}\ne\mbox{coNP}\){:/nomarkdown}. כך שזו שאלה "עדינה" יותר מאשר {::nomarkdown}\( \mbox{P}\ne\mbox{NP}\){:/nomarkdown} והוכחה עבורה תהיה קשה יותר מאשר הוכחה ש-{::nomarkdown}\( \mbox{P}\ne\mbox{NP}\){:/nomarkdown} (שכן הוכחה ש-{::nomarkdown}\( \mbox{NP}\ne\mbox{coNP}\){:/nomarkdown} תוכיח בפרט ש-{::nomarkdown}\( \mbox{P}\ne\mbox{NP}\){:/nomarkdown}).

עכשיו בואו ונבצע שינוי מחשבתי כלשהו. במקום לדבר על יעילות בצריכת משאב ה<strong>זמן</strong>, נדבר על יעילות בצריכת משאב ה<strong>זכרון</strong>. זמן ריצה נמדד במספר הצעדים שנדרשו לחישוב במודל הסטנדרטי של מכונת טיורינג - איך אפשר למדוד צריכת זכרון? הגישה הנאיבית מדברת על מודל של מכונת טיורינג עם סרט בודד שבו ראשית כל נכתב הקלט, ואחריו אפשר לכתוב עוד דברים לפי הצורך. אפשר להגדיר את כמות הזכרון שהמכונה צורכת בתור האינדקס של התא הקיצוני ביותר שאליו המכונה מגיעה במהלך החישוב (במילים אחרות - אם הזכרון היה סופי, מה כמות הזכרון המינימלית שלא הייתה גורמת לתוכנית להתרסק על הקלט הנתון). הבעיה עם הגישה הזו היא שאם התוכנית רוצה <strong>לקרוא</strong> את כל הקלט . (אפילו אם אינה רוצה לכתוב שום דבר) היא צריכה ללכת עד לקצה הקלט וזה כבר יניב שסיבוכיות הזכרון שלה היא לפחות {::nomarkdown}\( \Omega\left(n\right)\){:/nomarkdown}. אלא שכאשר מדובר על סיבוכיות זכרון, סיבוכיות שנחשבת "יעילה" היא דווקא משהו מסדר גודל לוגריתמי ב-{::nomarkdown}\( n\){:/nomarkdown}, ואת זה בשיטה שלנו אי אפשר למדוד בכלל. אז מה עושים?

הפתרון הסטנדרטי הוא להפריד בין הקלט, שנמצא בסרט "לקריאה בלבד" שעליו לא ניתן לכתוב, ובין זכרון העבודה של המכונה שהוא ריק בתחילת ריצתה ובו ניתן לקרוא ולכתוב באופן חופשי. סיבוכיות הזכרון נמדדת רק ביחס לניצול זכרון העבודה הזה. הסיפור מסתבך עוד יותר כשרוצים להכניס לתמונה את האפשר לבדיקת עדים לנכונות טענות - גם העדים נכתבים על סרט משל עצמם שהוא לקריאה בלבד ויותר מכך - לקריאה חד פעמית, במובן זה שהראש הקורא יכול לנוע רק ימינה, אחרת המודל הופך לחזק מדי. למרות כל הברחש הפורמלי הזה, ניתוח סיבוכיות הזכרון של אלגוריתמים הוא בדרך כלל לא מסובך במיוחד.

כעת אפשר להכניס לתמונה סוף סוף את {::nomarkdown}\( \mbox{NL}\){:/nomarkdown}- זו מחלקת השפות שקיימת מכונה-בודקת-עדים עבורן שפועלת בסיבוכיות זכרון {::nomarkdown}\( O\left(\log n\right)\){:/nomarkdown}. את {::nomarkdown}\( \mbox{coNL}\){:/nomarkdown} מגדירים באותו אופן כמו {::nomarkdown}\( \mbox{coNP}\){:/nomarkdown}. לא מדויק עד הסוף לומר שאלו האנלוגים של {::nomarkdown}\( \mbox{NP}\){:/nomarkdown} ו-{::nomarkdown}\( \mbox{coNP}\){:/nomarkdown} כי גם סיבוכיות זכרון של {::nomarkdown}\( O\left(\log^{k}n\right)\){:/nomarkdown} ("פולי-לוגריתמית") נחשבת יעילה; אבל שתי המחלקות הללו הן הבסיס. ולכן זו הפתעה לא קטנה כשמתברר שהאנלוג לשאלת {::nomarkdown}\( \mbox{NP=coNP}\){:/nomarkdown} עבור סיבוכיות זכרון זוכה לתשובה, ותשובה חיובית דווקא - {::nomarkdown}\( \mbox{NL=coNL}\){:/nomarkdown}, ויותר מכך - לכל מחלקה דומה של סיבוכיות זכרון עבור חסם סיבוכיות גדול יותר, השוויון עדיין מתקיים (פורמלית, {::nomarkdown}\( \mbox{NSPACE}\left(f\left(n\right)\right)=\mbox{coNSPACE}\left(f\left(n\right)\right)\){:/nomarkdown} לכל {::nomarkdown}\( f\left(n\right)\ge\log n\){:/nomarkdown} שהיא מה שנקרא Space Constructible, כלומר ניתן לחשב את {::nomarkdown}\( f\left(n\right)\){:/nomarkdown} מתוך {::nomarkdown}\( 1^{n}\){:/nomarkdown} תוך שימוש ב-{::nomarkdown}\( f\left(n\right)\){:/nomarkdown} זכרון - זו דרישה טכנית שלא ניכנס כעת אליה). הטענה הוכחה בנפרד בידי אימרמן ובידי סזלפסני, ואין לי מושג מי מהם המציא את ההוכחה שאציג כעת (או אפילו אם מישהו מהם המציא אותה ולא שמדובר על המצאה מאוחרת יותר).

ראשית כל צריך להבין שכמו ש-{::nomarkdown}\( \mbox{NP}\){:/nomarkdown} קמה ונופלת על הפתרון של בעיות ספציפיות - הבעיות ה-{::nomarkdown}\( \mbox{NP}\){:/nomarkdown}-שלמות - גם כאן המשפט מסתכם בפתרון מוצלח עבור בעיה ספציפית - בעיית הישיגות בגרף שהזכרתי קודם. בעיית הישיגות היא טריוויאלית לפתרון בזמן יעיל - אלגוריתם DFS פותר אותה חיש קל, בזמן לינארי - אבל פתרון ב<strong>זכרון</strong> לוגריתמי זה סיפור שונה לגמרי - לא מוכר כיום פתרון שכזה עבור גרפים מכוונים (אבל, וזו תוצאה מפתיעה מאוד בפני עצמה וגם חדשה למדי - עבור גרפים <strong>לא מכוונים</strong> יש פתרון).

הסיבה לכך שהבעיה הזו כל כך חשובה היא שניתן לתאר חישובים של מכונות (ובפרט מכונות לבדיקת עדים) על קלט כלשהו באמצעות גרף - <strong>גרף הקונפיגורציות</strong> של המכונה, שכל צומת בו מתאר את המצב הנוכחי של המכונה - תוכן סרט הזכרון, מצב הבקרה הנוכחי, מיקום הראשים הקוראים בכל הסרטים - כל זה מידע שניתן לייצג בזכרון לוגריתמי, כך שניתן לשמור צומת בודד של הגרף בזכרון בכל עת. בגרף יש קשת מצומת א' לצומת ב' אם אפשר להגיע בצעד בודד מהקונפיגורציה א' לקונפיגורציה ב' (השאלה אם זה באמת קורא תלויה בשאלה מה רואים הראשים הקוראים בסרטי הקלט והעד). בפועל בהינתן הקידוד של צומת בגרף, אפשר לחשב בזכרון לוגריתמי את הצמתים שאליהם ניתן לעבור ממנו. לכן השאלה האם המכונה מקבלת קלט כלשהו מצטמצמת לשאלה אם קיים מסלול בגרף הקונפיגורציות שלה מהקונפיגורציה ההתחלתית לאיזו שהיא קונפיגורציה שבה המכונה עוצרת ומקבלת. אפשר להנדס את המכונה כך שתהיה רק קונפיגורציה אחת כזו (למשל, כזו שבה כל סרט העבודה מחוק והראשים הקוראים בתחילת כל הסרטים) ולכן אנחנו מצטמצמים לשאלה האם קיים מסלול בגרף בין שני צמתים - בדיוק בעיית הישיגות, {::nomarkdown}\( \mbox{CON}\){:/nomarkdown}.

כפי שאמרתי, הדרך הסטנדרטית לבדוק אם בגרף יש מסלול בין שני צמתים היא אלגוריתם כמו DFS, שפשוט מטייל לו בגרף ומסמן צמתים שהוא כבר ביקר בהם, נמנע מלהיכנס שוב לצמתים שהוא ביקר בהם, וחוזר אחורה אם הוא נתקע. לרוע המזל, סיבוכיות הזכרון של האלגוריתם הזה היא לינארית בגודל הגרף - בגלל עניין סימון הצמתים. לכן כל הרעיון הזה לא רלוונטי לנו.

לבדוק שיש מסלול מ-{::nomarkdown}\( s\){:/nomarkdown} אל {::nomarkdown}\( t\){:/nomarkdown} בסיבוכיות זכרון יעילה, <strong>בהינתן עד לכך</strong>, את זה קל לעשות. העד יהיה תיאור המסלול עצמו, ולכן כל המידע שצריך לזכור בכל שלב הוא מה הצומת הנוכחי שלנו, לקרוא את הצומת הבא בתור מהעד, ולבדוק אם אכן יש קשת מהצומת הנוכחי שלנו אל הצומת הבא בתור שהעד מדבר עליו. מכיוון שלייצג צומת או שניים בודדים דורש רק כמות לוגריתמית של זכרון, זה מראה ש-{::nomarkdown}\( \mbox{CON}\in\mbox{NL}\){:/nomarkdown}. האתגר הוא להראות ש-{::nomarkdown}\( \mbox{CON}\in\mbox{coNL}\){:/nomarkdown} - שיש עד לכך ש<strong>לא קיים</strong> מסלול מ-{::nomarkdown}\( s\){:/nomarkdown} אל {::nomarkdown}\( t\){:/nomarkdown}. איך עושים דבר כזה? התשובה פשוטה - אומרים את האמת, רק האמת, ו<strong>כל האמת</strong>.

נניח שידוע לנו שיש <strong>בדיוק</strong> {::nomarkdown}\( k\){:/nomarkdown} צמתים שאליהם אפשר להגיע מ-{::nomarkdown}\( s\){:/nomarkdown} תוך לכל היותר {::nomarkdown}\( n\){:/nomarkdown} צעדים. אנחנו לא יודעים מיהם הצמתים הללו, אבל כוח משמיים הבטיח לנו כי יש בדיוק {::nomarkdown}\( k\){:/nomarkdown} כאלו. אז קל מאוד יהיה לשכנע אותנו שמ-{::nomarkdown}\( s\){:/nomarkdown} אי אפשר להגיע אל {::nomarkdown}\( t\){:/nomarkdown} תוך {::nomarkdown}\( n\){:/nomarkdown} צעדים באופן הבא: יתנו לנו כעדים {::nomarkdown}\( k\){:/nomarkdown} מסלולים, שכל אחד מוביל לצומת כלשהו שאינו {::nomarkdown}\( t\){:/nomarkdown}, וכל הצמתים שונים אלו מאלו. זה יבטיח שלא ניתן להגיע מ-{::nomarkdown}\( s\){:/nomarkdown} אל {::nomarkdown}\( t\){:/nomarkdown} תוך {::nomarkdown}\( n\){:/nomarkdown} צעדים לכל היותר, כי יש בדיוק {::nomarkdown}\( k\){:/nomarkdown} צמתים שאפשר להגיע אליהם, ו"כיסינו" את כולם. כמה זכרון זה דורש? ובכן, כבר אמרנו שלבדוק מסלול דורש רק כמות לוגריתמית של זכרון. אבל, בעיה: איך נדע שכל {::nomarkdown}\( k\){:/nomarkdown} הצמתים שהביאו אותנו אליהם <strong>שונים</strong> זה מזה? בשביל זה צריך יהיה לזכור את כולם, וייתכן ש-{::nomarkdown}\( k\){:/nomarkdown} כבר יהיה גדול מדי מכדי להיות לוגריתמי (נניח, חצי מהצמתים בגרף). מה עושים?

הפתרון פשוט: העד יורכב מסדרה של טענות מהצורה "הצומת {::nomarkdown}\( v\){:/nomarkdown} ישיג מהצומת {::nomarkdown}\( s\){:/nomarkdown} לכל היותר ב-{::nomarkdown}\( n\){:/nomarkdown} צעדים, והרי הוכחה לכך...", כאשר הסדר שבו מופיעות הטענות בתוך העד מתאים לסדר לקסיקוגרפי כלשהו שנקבע על הצמתים {::nomarkdown}\( v\){:/nomarkdown} (בסופו של דבר, צמתים, כמו כל מידע אחר, מיוצגים בידי מחרוזות בינאריות, ועל מחרוזות כאלו יש סדר באופן טבעי). בכל שלב נצטרך לזכור מה הצומת האחרון שעליו כבר הוכיחו שהוא ישיג מ-{::nomarkdown}\( s\){:/nomarkdown} ולבדוק אם החדש אכן גדול ממנו. אם הוא אכן גדול יותר, אפשר לשכוח את הקודם ולזכור רק את הנוכחי; אם הוא לא גדול יותר, אפשר להפסיק את בדיקת העד ולהכריז שמרמים אותנו. זה מבטיח שלא נספור אף צומת פעמיים, ולכן כל מה שצריך לשמור בנוסף הוא את <strong>מספר</strong> הצמתים שכבר שוכנענו שהם ישיגים מ-{::nomarkdown}\( s\){:/nomarkdown}, וכדי לאחסן מספר שהוא לכל היותר מספר הצמתים הכולל בגרף דרוש רק זכרון לוגריתמי.

אז מה ראינו? שבזכרון לוגריתמי אפשר לבדוק הוכחה לטענה מהצורה "<strong>לפחות</strong> {::nomarkdown}\( k\){:/nomarkdown} הצמתים הללו ישיגים מ-{::nomarkdown}\( s\){:/nomarkdown} ב-{::nomarkdown}\( n\){:/nomarkdown} צעדים", ושאם זה משולב בטענה מהצורה "<strong>בדיוק</strong> {::nomarkdown}\( k\){:/nomarkdown} צמתים ישיגים מ-{::nomarkdown}\( s\){:/nomarkdown} ב-{::nomarkdown}\( n\){:/nomarkdown} צעדים" אפשר להוכיח שמשהו לא ישיג מ-{::nomarkdown}\( s\){:/nomarkdown} ב-{::nomarkdown}\( n\){:/nomarkdown} צעדים. אבל איך אפשר להראות ש<strong>בדיוק</strong> {::nomarkdown}\( k\){:/nomarkdown} צמתים ישיגים מ-{::nomarkdown}\( s\){:/nomarkdown} ב-{::nomarkdown}\( n\){:/nomarkdown} צעדים? ובכן, באינדוקציה על {::nomarkdown}\( n\){:/nomarkdown}.

בואו נסמן ב-{::nomarkdown}\( C_{n}\){:/nomarkdown} את מספר הצמתים שישיגים מ-{::nomarkdown}\( s\){:/nomarkdown} לכל היותר ב-{::nomarkdown}\( n\){:/nomarkdown} צעדים. ראשית, ברור ש-{::nomarkdown}\( C_{1}\){:/nomarkdown} ניתן לחישוב באופן עצמאי לגמרי ובלי שום עזרה - פשוט עוברים איכשהו על רשימת הקשתות של הגרף וסופרים כמה מחוברות ל-{::nomarkdown}\( s\){:/nomarkdown}. האתגר הוא להראות שאפשר לתת כעד את {::nomarkdown}\( C_{n+1}\){:/nomarkdown} באופן כזה שאם {::nomarkdown}\( C_{n}\){:/nomarkdown} כבר נתון, אפשר לבדוק שהעד נכון. איך עושים את זה?

בואו נעצור לרגע כדי לקחת אוויר ולסכם את מה שראינו עד כה. ראינו כי ניתן להוכיח (באופן שיהיה ניתן לבדיקה בזכרון לוגריתמי) שצומת כלשהו ישיג מ-{::nomarkdown}\( s\){:/nomarkdown} ב-{::nomarkdown}\( n\){:/nomarkdown} צעדים. כמו כן, ראינו כי אם {::nomarkdown}\( C_{n}\){:/nomarkdown} נתון, אז אפשר להוכיח שצומת כלשהו <strong>אינו</strong> ישיג מ-{::nomarkdown}\( s\){:/nomarkdown} ב-{::nomarkdown}\( n\){:/nomarkdown} צעדים. למעשה, אפשר גם להוכיח באופן דומה מאוד שצומת {::nomarkdown}\( v\){:/nomarkdown} אינו ישיג מ-{::nomarkdown}\( s\){:/nomarkdown} ב-{::nomarkdown}\( n+1\){:/nomarkdown} צעדים - פשוט מוכיחים שאף שכן של {::nomarkdown}\( v\){:/nomarkdown} אינו ישיג מ-{::nomarkdown}\( s\){:/nomarkdown} ב-{::nomarkdown}\( n\){:/nomarkdown} צעדים (ולמי שנזקק לפירוט - ההוכחה כוללת את רשימת כל {::nomarkdown}\( C_{n}\){:/nomarkdown} השכנים שכן ישיגים ואת המסלול שמוביל להם; בזמן שבודקים שההוכחה נכונה גם בודקים שכל אחד מהשכנים הללו אינו שכן של {::nomarkdown}\( v\){:/nomarkdown}).

עכשיו בואו נעצור לרגע ונחשוב - איך כל המרכיבים הללו פותרים לנו את הבעיה של חישוב {::nomarkdown}\( C_{n+1}\){:/nomarkdown}? תנסו לחשוב על זה בעצמכם לרגע. תזכרו שאנחנו כלל לא צריכים להיות חסכוניים בזמן ריצה, רק בזכרון.

התשובה פשוטה: ההוכחה לערך החדש של {::nomarkdown}\( C_{n+1}\){:/nomarkdown} תהיה מורכבת מרשימת <strong>כל</strong> הצמתים בגרף לפני הסדר, כשאחרי כל צומת ההוכחה או טוענת שהוא ישיג מ-{::nomarkdown}\( s\){:/nomarkdown} ב-{::nomarkdown}\( n+1\){:/nomarkdown} צעדים ומספקת תת-הוכחה שמראה זאת, או טוענת שהוא אינו ישיג מ-{::nomarkdown}\( s\){:/nomarkdown} ב-{::nomarkdown}\( n+1\){:/nomarkdown} צעדים, ומספקת תת-הוכחה שמראה זאת. הגאונות כאן היא בכך שאחרי שאנחנו גומרים עם צומת, אנחנו לא צריכים לזכור אם הוא היה ישיג או לא היה ישיג (זה ידרוש מאיתנו הרבה יותר מדי זכרון לתחזק רשימה כזו) אלא רק להוסיף או לא להוסיף 1 למונה של {::nomarkdown}\( C_{n+1}\){:/nomarkdown} שאנחנו מתחזקים. אחרי שנסיים לקרוא את ההוכחה (שכאמור, אומרת פרטנית מה קורה לכל אחד מהצמתים בגרף), יהיה ברשותנו הערך הנכון של {::nomarkdown}\( C_{n+1}\){:/nomarkdown}.

מכאן הפתרון לבעיה טריוויאלי. ההוכחה לכך ש-{::nomarkdown}\( t\){:/nomarkdown} לא ישיג מ-{::nomarkdown}\( s\){:/nomarkdown} ראשית כוללת הוכחות לסדרת הערכים {::nomarkdown}\( C_{1},C_{2},\dots,C_{\left\|V\right\|}\){:/nomarkdown}, ולבסוף היא כוללת הוכחה לכך ש-{::nomarkdown}\( t\){:/nomarkdown} אינו ישיג מ-{::nomarkdown}\( s\){:/nomarkdown} ב-{::nomarkdown}\( \left\|V\right\|\){:/nomarkdown} צעדים, שמסתמכת על {::nomarkdown}\( C_{\left\|V\right\|}\){:/nomarkdown}. אם {::nomarkdown}\( t\){:/nomarkdown} לא ישיג מ-{::nomarkdown}\( s\){:/nomarkdown} ב-{::nomarkdown}\( \left\|V\right\|\){:/nomarkdown} צעדים, הוא לא ישיג בכלל (למה?).

מה שיפה בהוכחה הזו היא השימוש האינטנסיבי משהו שהיא עושה ב"הוכחות". אנחנו לא סתם מספקים מסלול וזהו, אלא לכל שלב של חישוב {::nomarkdown}\( C_{i}\){:/nomarkdown}, אנחנו מספקים (שוב ושוב ושוב) את ההוכחה שצומת מסויים ישיג או לא ישיג מ-{::nomarkdown}\( s\){:/nomarkdown}, לכל צומת בגרף. האינטנסיביות הזו מצליחה להניב בסיום פתרון שהוא מאוד חסכוני בזכרון (על משקל בזבוז אדיר של זמן הריצה, כמובן), וזה נראה מפתיע - ויותר מכך, מעלה את השאלה איך לעזאזל בכלל חשבו על פתרון כמו זה (אם כי אני חייב להודות - ביחס למשפט ברינגטון, משפט אימרמן עוד נראה מתבקש איכשהו). פרט לכך, המשפט הוא המחשה יפה מאוד לטעמי של האופן הכל כך שונה שבו סיבוכיות זכרון מתנהגת ביחס לסיבוכיות זמן.
