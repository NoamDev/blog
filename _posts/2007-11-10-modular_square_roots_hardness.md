---
id: 88
title: "אוף, כל הקטע עם השורש הריבועי באמת יוצא מסובך"
date: 2007-11-10 16:31:34
layout: post
categories: 
  - תורת המספרים
  - תורת הסיבוכיות
---
סיימתי את <a href="http://www.gadial.net/?p=87">הפוסט הקודם</a> עם "סגירת" הבעיה של הוצאת שורש מודולו מספר ראשוני. בקצרה - הבעיה הזו אינה קשה יותר, מבחינה עקרונית, מאשר הוצאת שורש "רגילה", במספרים הממשיים. אם כן, מה כן קשה בהוצאת שורש מודולרית? התשובה פשוטה - הוצאת שורש מודולו מספר שאינו ראשוני. בפרט, מספיק לדבר על n שהוא מכפלה של שני ראשוניים, p,q. הטענה שלי היא שבעיית הוצאת שורש מודולו n הזה היא קשה "בדיוק כמו" הבעיה של פירוק n לגורמיו הראשוניים.

לפני שאמשיך, כדאי לסקור קצת את עניין ה"קשה" הזה. בצורה פשטנית למדי, אפשר לומר שב<a href="http://he.wikipedia.org/wiki/%D7%A1%D7%99%D7%91%D7%95%D7%9B%D7%99%D7%95%D7%AA">תורת הסיבוכיות</a> מבדילים בין ארבע מחלקות שונות של בעיות. בעיות ש"אפשר" לפתור בזמן סביר - מחלקה שמכונה <a href="http://he.wikipedia.org/wiki/P_%28%D7%9E%D7%93%D7%A2%D7%99_%D7%94%D7%9E%D7%97%D7%A9%D7%91%29">P</a>. בעיות ש"אולי אפשר" לפתור בזמן סביר, בעיות ש"כנראה אי אפשר" לפתור בזמן סביר, ובעיות שידוע בוודאות שאי אפשר לפתור בזמן סביר (או לפתור בכלל). המחלקה המעניינת ביותר היא זו של הבעיות ש"אולי אפשר" לפתור בזמן סביר. למחלקת הבעיות שכוללות את הבעיות הללו ואת הבעיות שכבר ידוע שאפשר לפתור בזמן סביר קוראים <a href="http://he.wikipedia.org/wiki/NP">NP</a>. אני מקווה בעתיד לפרט יותר על המחלקה החשובה הזו, אבל בינתיים אסתפק בתיאור לא מדוייק לחלוטין שלה: אפשר לחשוב עליה בתור אוסף כל הבעיות ש<strong>קל לבדוק פתרון עבורן</strong>. אחת מהשאלות המרכזיות במדעי המחשב היא האם התכונה הזו היא מספיקה כדי להקל על <strong>מציאת</strong> פתרון - זו שאלת P=NP, לאלו מכם שנתקלו בה כבר. נכון לעכשיו לא ידוע האם התשובה לשאלה הזו היא חיובית או שלילית, ולמיטב ידיעתי הקונצנזוס במדעי המחשב נוטה לאמונה שהתשובה שלילית.

בעיית הפירוק לגורמים שייכת ל-NP, מן הסתם: אולי לא קל לנו לפרק את n, אבל אם בא מישהו ונותן לנו שני ראשוניים p,q ואומר "אלו הגורמים של n", קל לבדוק אותו - מכפילים אותם, ורואים אם קיבלנו n. זה מספיק כדי לזכות את שאלת הפירוק לגורמים בתואר "אולי אפשר לפתור ביעילות, אבל לא יודעים איך". יתר על כן, ב-NP יש אוסף של בעיות שנחשבות "הקשות ביותר ב-NP", מהטעם הפשוט שפתרון יעיל שלהן ייספק דרך יעילה לפתור כל בעיה ב-NP (ולכן P=NP). לבעיות הללו קוראים "<a href="http://he.wikipedia.org/wiki/NP-%D7%A9%D7%9C%D7%9E%D7%94">בעיות NP-שלמות</a>". בעיית הפירוק לגורמים <strong>אינה</strong> מוכרת כבעיה NP שלמה; כלומר, גם אם נפתור אותה ביעילות, השמיים לא יפלו ושום בעיה מרכזית במדעי המחשב לא תוכרע באופן שנראה כרגע לא סביר.

כאילו שזה לא מספיק, מודל "<a href="http://he.wikipedia.org/wiki/%D7%9E%D7%97%D7%A9%D7%91_%D7%A7%D7%95%D7%95%D7%A0%D7%98%D7%99">המחשב הקוונטי</a>" המדובר כל כך יהיה מסוגל, אם ייבנה יום אחד, לפתור את בעיית הפירוק לגורמים בצורה יעילה (ועם זאת, יש בעיות ב-NP שלא ידוע איך הוא יוכל להתגבר עליהן בצורה יעילה - כלומר, גם במודל שלו כנראה שלא יתקיים P=NP). מכל זה נובע שה"קושי" של בעיית הפירוק לגורמים צריך להילקח בעירבון מוגבל. מצד שני, העובדות בשטח הן שלמרות שזו בעיה כל כך חשובה, ולמרות המחקר האדיר שנערך סביבה, ולמרות שפתרון יעיל שלה יזכה את הפותר בכבוד והדר עצומים - למרות כל זה היא טרם נפתרה באופן מעשי, ככל הידוע לנו. זה המדד האמפירי של "קשה" שבו אנו משתמשים כאן.

חזרה לענייננו. במה עוזר לי הפירוק לגורמים של מספר כדי להוציא שורש? כאן נכנס לתמונה <a href="http://he.wikipedia.org/wiki/%D7%9E%D7%A9%D7%A4%D7%98_%D7%94%D7%A9%D7%90%D7%A8%D7%99%D7%95%D7%AA_%D7%94%D7%A1%D7%99%D7%A0%D7%99"><strong>משפט השאריות הסיני</strong></a>. לפני שאציג אותו, אראה איך הוא עוזר לנו, ועוד לפני כן, אציג סימון חשוב.

הסימון הוא זה: {::nomarkdown}\( a\equiv b(mod n)\){:/nomarkdown} (קרי: "a שקול ל-b מודולו n"). הגדרתו המתמטית היא ש-n מחלק את a-b. הגדרתו הטיפה-פחות-מתמטית היא שגם a וגם b נותנים את אותה השארית כשמחלקים אותם ב-n. לכן, כשאני מחפש ל-x שורש מודולו n, אני בעצם מחפש איזה y שיקיים {::nomarkdown}\( y^2\equiv x(mod n)\){:/nomarkdown}

אז יש לי איזה שהוא x שאני רוצה להוציא לו שורש ריבועי מודולו n. לא בטוח בכלל שקיים לו שורש שכזה, אבל בואו נעסוק במקרה שבו קיים (אם יודעים את הפירוק של n קל לבדוק אם קיים ל-x שורש). נניח שפתרתי את הבעיות הקלות יותר של הוצאת שורש ל-x מודולו p ומודולו q, כלומר - מצאתי {::nomarkdown}\( y_p,y_q\){:/nomarkdown} כך שמתקיים:

{::nomarkdown}\( y_p^2\equiv x (mod p)\){:/nomarkdown}

{::nomarkdown}\( y_q^2\equiv x (mod q)\){:/nomarkdown}

עכשיו, נניח שבדרך קסם כלשהי אני מוצא y שמודולו p שקול ל-{::nomarkdown}\( y_p\){:/nomarkdown}, ומודולו q שקול ל-{::nomarkdown}\( y_q\){:/nomarkdown}. מה קורה? אני אקבל ש:

{::nomarkdown}\( y^2\equiv y_p^2\equiv x (mod p)\){:/nomarkdown}

{::nomarkdown}\( y^2\equiv y_q^2\equiv x (mod q)\){:/nomarkdown}

ומזה נובע ש:

{::nomarkdown}\( y^2\equiv x (mod n)\){:/nomarkdown}

המעבר האחרון בפירוש אינו מובן מאליו. כדי להבין אותו, צריך לשוב להגדרות הבסיסיות: {::nomarkdown}\( a\equiv b(mod p)\){:/nomarkdown} פירושו ש-p מחלק את {::nomarkdown}\( a-b\){:/nomarkdown}. באופן דומה, אם גם {::nomarkdown}\( a\equiv b(mod q)\){:/nomarkdown}, נובע מכך שגם q מחלק את {::nomarkdown}\( a-b\){:/nomarkdown}. כעת מגיעה טענה לא טריוויאלית (אך גם לא קשה מדי): אם שני מספרים שזרים זה לזה (אין להם מחלק משותף גדול מ-1) מחלקים שניהם גם יחד מספר כלשהו, אז גם <strong>מכפלתם</strong> מחלקת אותו.

כלומר, בהקשר שלנו, פירוש הדבר הוא ש-pq מחלק את {::nomarkdown}\( a-b\){:/nomarkdown}, אבל הרי pq=n. לכן, כמו שראינו, שורש של x שהוא אותו הדבר הן מודולו p והן מודולו q נותן לנו שורש מודולו n של x.

נשאר רק להבין איך מתרחש ה"קסם"; איך לוקחים שני שורשים <strong>שונים</strong> של x מודולו מספרים שונים, ומאחדים אותם לפתרון בודד.

משפט השאריות הסיני הוא זה שעושה את הקסם הזה. מכיוון שיש למשפט הזה ניסוחים רבים ושונים, אסתפק באחד מהפשוטים והפרטיים שבהם - בדיוק זה שאני זקוק לו כעת. הרעיון הבסיסי הוא זה. נניח שנתונים לנו שני מספרים שלמים, {::nomarkdown}\( a,n\){:/nomarkdown} ואנחנו רוצים לפתור את המשוואה {::nomarkdown}\( x\equiv a(mod n)\){:/nomarkdown}. האם אפשר לעשות זאת? כמובן, די בקלות; למשל, {::nomarkdown}\( x=a\){:/nomarkdown} הוא פתרון. אם כן, מה הלאה? מה אם יהיו לנו <strong>שתי</strong> משוואות, שאת שתיהן נרצה לפתור <strong>בו זמנית</strong>? כלומר, אם יש לנו {::nomarkdown}\( n,m\){:/nomarkdown} שלמים, ו-{::nomarkdown}\( a,b\){:/nomarkdown} שלמים, האם אפשר למצוא פתרון לשתי המשוואות הבאות:

{::nomarkdown}\( x\equiv a(mod n)\){:/nomarkdown}

{::nomarkdown}\( x\equiv b(mod m)\){:/nomarkdown}

התשובה היא שכלל לא בטוח שאפשר. נניח ש-{::nomarkdown}\( n=2,m=4, a=1, b=0\){:/nomarkdown}, אז פתרון לשתי המשוואות הוא מספר שמצד אחד מתחלק ללא שארית ב-4, ומצד שני משאיר שארית 1 בחלוקה ב-2, כלומר הוא אי זוגי - והרי כל מספר שמתחלק ב-4 הוא בפרט זוגי. לכן אין כאן פתרון למערכת.

משפט השאריות הסיני אומר במקרה הזה את הדבר הבא: <strong>אם</strong> שני המספרים {::nomarkdown}\( m,n\){:/nomarkdown} זרים זה לזה (אף מספר גדול מ-1 לא מחלק את שניהם גם יחד), אז קיים פתרון למשוואה (והוא יחיד מודולו {::nomarkdown}\( mn\){:/nomarkdown}, אבל זה פחות קריטי). ההוכחה של המשפט היא קונסטרוקטיבית ומראה בדיוק כיצד ניתן לחשב (ביעילות) את הפתרון הזה. אסביר כאן את ההוכחה, אך ייתכן מאוד שההסבר לא יהיה ברור למי שלא עסקו מעולם בנושאים הללו קודם.

הרעיון המרכזי בהוכחה הוא למצוא מספר {::nomarkdown}\( x_n\){:/nomarkdown} בעל שתי התכונות הנאות הבאות:

{::nomarkdown}\( x_n\equiv a(mod n)\){:/nomarkdown}

{::nomarkdown}\( x_n\equiv 0(mod m)\){:/nomarkdown}

ולמצוא {::nomarkdown}\( x_m\){:/nomarkdown} דומה, רק הפוך (שקול ל-{::nomarkdown}\( b\){:/nomarkdown} מודולו {::nomarkdown}\( m\){:/nomarkdown} ושקול לאפס מודולו {::nomarkdown}\( n\){:/nomarkdown}). אם מצאנו כאלו, הפתרון הסימולטני למשוואות הוא {::nomarkdown}\( x_n+x_m\){:/nomarkdown} (למה?)

איך מוצאים {::nomarkdown}\( x_n\){:/nomarkdown} שכזה? כאן נכנס החלק החישובי לסיפור. מכיוון ש-{::nomarkdown}\( m,n\){:/nomarkdown} זרים, אפשר להשתמש ב<a href="http://en.wikipedia.org/wiki/Euclidean_algorithm">אלגוריתם האוקלידי המורחב</a> (שראוי לפוסט משל עצמו) כדי למצוא מספרים שלמים {::nomarkdown}\( \alpha,\beta\){:/nomarkdown} כך ש- {::nomarkdown}\( \alpha n+\beta m=1\){:/nomarkdown} (אם המחלק הגדול ביותר של {::nomarkdown}\( m,n\){:/nomarkdown} היה גדול מ-1, אפשר היה עדיין לכתוב סכום דומה כשבאגף ימין של השוויון יש את המחלק הזה; נסו לחשוב איזו הכללה של המשפט נובעת בשל כך למקרה שבו {::nomarkdown}\( m,n\){:/nomarkdown} לא זרים).

כעת, על ידי כפל שני האגפים ב-{::nomarkdown}\( a\){:/nomarkdown} והעברת אגף, מקבלים את המשוואה {::nomarkdown}\( a\beta m=a-a\alpha n\){:/nomarkdown}. אם לוקחים את כל זה מודולו {::nomarkdown}\( m\){:/nomarkdown} ברור שמקבלים אפס (בגלל אגף שמאל), ואם לוקחים אותו מודולו {::nomarkdown}\( n\){:/nomarkdown} ברור שמקבלים {::nomarkdown}\( a\){:/nomarkdown} (בגלל אגף ימין), ולכן זה ה-{::nomarkdown}\( x_n\){:/nomarkdown} המבוקש.

זה סוגר את ההוכחה מלבד החור של האלגוריתם האוקלידי המורחב.

מה נשאר? הכיוון השני של השקילות בין הוצאת שורש ופירוק לגורמים - כלומר, נותר לשכנע למה אם אני יודע להוציא שורשים מודולו מספר כלשהו, אני יכול גם לפרק אותו לגורמים (ולכן פירוק לגורמים אינו "יותר קשה" מאשר הוצאת שורשים).

אז שוב, בואו נניח שיש לנו איזה {::nomarkdown}\( n=pq\){:/nomarkdown} ואנחנו יודעים באופן קסום להוציא שורשים. האבחנה הראשונית החשובה היא שאם יש למספר (שונה מאפס) שורש מודולו {::nomarkdown}\( n\){:/nomarkdown}, אז יש לו <strong>ארבעה</strong> שורשים. הסיבה לכך היא שלמספר שיש לו שורש מודולו {::nomarkdown}\( p\){:/nomarkdown} יש בדיוק שני שורשים כאלו (השורש המקורי, ומינוס השורש המקורי), וכך גם עבור {::nomarkdown}\( q\){:/nomarkdown}, כך שיש לנו ארבעה זוגות אפשריים של "מספר שהוא שורש מודולו {::nomarkdown}\( p\){:/nomarkdown} ומספר שהוא שורש מודולו {::nomarkdown}\( q\){:/nomarkdown}", וכל זוג שכזה נותן, באמצעות משפט השאריות הסיני, שורש אחר מודולו {::nomarkdown}\( n\){:/nomarkdown}.

לב האלגוריתם נעוץ בכך שאם ניקח שני שורשים שהתקבלו <strong>מאותו שורש</strong> מודולו {::nomarkdown}\( p\){:/nomarkdown} ונחסר אותם, נקבל מספר ששקול לאפס מודולו {::nomarkdown}\( p\){:/nomarkdown} - כלומר, {::nomarkdown}\( p\){:/nomarkdown} מחלק אותו. את הטענה הזו אשאיר גם כן כתרגיל, כדי לחסוך עוד כתיבה מסורבלת (אם יש צורך, אנסה לפרט בתגובות). מכיוון שההפרש הזה לא שווה ל-{::nomarkdown}\( n\){:/nomarkdown} (למה?), הרי שקיבלנו מספר ששונה מ-{::nomarkdown}\( n\){:/nomarkdown} אבל מתחלק ב-{::nomarkdown}\( p\){:/nomarkdown}, כלומר המחלק המשותף הגדול ביותר שלו ושל {::nomarkdown}\( n\){:/nomarkdown} הוא בדיוק {::nomarkdown}\( p\){:/nomarkdown}. מחלק משותף קל למצוא בעזרת האלגוריתם האוקלידי, ולכן זה סוף הסיפור - מפעילים אותו, ומקבלים את {::nomarkdown}\( p\){:/nomarkdown} (ולכן גם את {::nomarkdown}\( q\){:/nomarkdown} - פשוט מחלקים את {::nomarkdown}\( n\){:/nomarkdown} ב-{::nomarkdown}\( p\){:/nomarkdown}).

בקיצור, מה שאנחנו רוצים הוא למצוא  עבור מספר כלשהו את <strong>כל</strong> השורשים שלו מודולו {::nomarkdown}\( n\){:/nomarkdown}. מכיוון שלא מניחים שהאלגוריתם שלנו יודע לעשות את זה (מניחים רק שהוא יודע למצוא שורש אחד), מסתפקים בגישה הסתברותית: מגרילים מספר, מעלים אותו בריבוע מודולו {::nomarkdown}\( n\){:/nomarkdown} (כדי להבטיח שנקבל מספר שיש לו שורשים), ומוציאים לו שורש. אם קיבלנו משהו ששונה בערכו המוחלט מהמספר שהגרלנו, נהדר - מצאנו שני שורשים שונים וההפרש שלהם יתחלק ב-{::nomarkdown}\( p\){:/nomarkdown} או ב-{::nomarkdown}\( q\){:/nomarkdown}. אחרת, מנסים שוב. ושוב, ושוב. בסוף זה עובד.

רק חוב אחד נשאר לי: הדבר שבשבילו בכלל עושים את כל המהומה הזו - השימוש שלה בקריפטוגרפיה.
