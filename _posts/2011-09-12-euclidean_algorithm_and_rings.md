---
id: 1318
title: "האלגוריתם האוקלידי וחוגים אוקלידיים"
date: 2011-09-12 15:51:18
layout: post
categories: 
  - אלגברה מופשטת
  - תורת המספרים
tags: 
  - אלגברה קומוטטיבית
  - האלגוריתם האוקלידי
  - חוג אוקלידי
  - תורת המספרים האלגברית
---
האלגוריתם האוקלידי הוא אחד מאותם דברים שכל מי שמתעניין ולו קצת במתמטיקה צריך לדעת. הוא גם אחת מהדוגמאות העתיקות ביותר לאלגוריתם לא טריוויאלי, גם אחד מאבני היסוד של תורת המספרים האלגוריתמית, וגם רעיון בסיסי בעל הכללות חשובות בתורת החוגים. למרות ש<a href="http://www.gadial.net/?p=514">הזכרתי אותו</a> קצת בעבר בבלוג הגיע הזמן לתת לו (ולהכללה הרעיונית שלו) פוסט משל עצמו.

"אלגוריתם" הוא פשוט תהליך בעל תיאור מדויק ופשוט (טוב, לא בהכרח פשוט, אבל סופי). הרעיון באלגוריתם הוא לפשט חישובים מסובכים על ידי תיאור שלהם כסדרה של חישובים פשוטים, וזה גם בדיוק מה שהאלגוריתם האוקלידי עושה. המטרה שלו לא נשמעת גרנדיוזית כל כך ממבט ראשון - בהינתן שני מספרים טבעיים {% equation %}a,b{% endequation %}, אנחנו רוצים למצוא את המחלק המשותף המקסימלי של שניהם, שמסומן {% equation %}\mbox{gcd}\left(a,b\right){% endequation %} ובקיצור {% equation %}\left(a,b\right){% endequation %}. המחלק המשותף המקסימלי הוא בדיוק מה שהוא נשמע שהוא - המספר הגדול ביותר שמחלק גם את {% equation %}a{% endequation %} וגם את {% equation %}b{% endequation %}. כך למשל {% equation %}\left(30,20\right)=10{% endequation %} ו-{% equation %}\left(7,22\right)=1{% endequation %}.

לרוב רוצים משהו קצת יותר מחוכם מחישוב של המחלק המשותף המקסימלי. המשפט הרלוונטי הוא זה: אם {% equation %}d=\left(a,b\right){% endequation %} אז קיימים {% equation %}x,y{% endequation %} שלמים (שיכולים להיות גם שליליים) כך ש-{% equation %}d=ax+by{% endequation %}, כלומר המחלק המשותף המקסימלי ניתן לכתיבה כ<strong>צירוף לינארי בשלמים</strong> של {% equation %}a,b{% endequation %} והאלגוריתם האוקלידי מוצא את מקדמי הצירוף הזה.

בשביל מה זה טוב? הדוגמה הקלאסית ביותר, ש<a href="http://www.gadial.net/?p=1226">כבר הוזכרה בבלוג</a>, היא זו של אריתמטיקה מודולרית. באריתמטיקה מודולו {% equation %}n{% endequation %} אנחנו מבצעים פעולות חשבון רגילות על מספרים טבעיים אבל אחרי כל פעולה אנחנו מחלקים ב-{% equation %}n{% endequation %} ולוקחים את השארית. למה? טוב, זה סיפור שלם, אבל די אם נאמר שמערכת ההצפנה RSA פועלת בעולם שאלו חוקי החשבון שלו. בעולם הזה צריך גם לחלק, ולחלק ב-{% equation %}a{% endequation %} פירושו בעצם לכפול במספר אחר, {% equation %}a^{-1}{% endequation %}, שמקיים את התכונה ש-{% equation %}aa^{-1}=1{% endequation %} (עם כלל הכפל-ואז-חילוק-ב-{% equation %}n{% endequation %}-ולקיחת-שארית). כדי למצוא את {% equation %}a^{-1}{% endequation %} מפעילים את האלגוריתם האוקלידי על {% equation %}a,n{% endequation %} כדי למצוא {% equation %}ax+ny=1{% endequation %} ואז {% equation %}x{% endequation %} הוא {% equation %}a^{-1}{% endequation %} המבוקש (זה דורש שיתקיים {% equation %}\left(a,n\right)=1{% endequation %} אחרת כלל לא ניתן לחלק ב-{% equation %}a{% endequation %} מודולו {% equation %}n{% endequation %}).

בקיצור, סמכו עלי, זה טוב.

שתי דרכים קופצות לראש מייד כשחושבים על איך למצוא את המחלק המשותף המקסימלי של {% equation %}a,b{% endequation %}. הראשונה היא פשוט לעבור אחד אחד על כל המספרים שקטנים מ-{% equation %}a,b{% endequation %} ולבדוק מי מחלק את שניהם (לצורך אופטימיזציה עדיף להתחיל מהקטן שבין {% equation %}a,b{% endequation %} ולרדת עוד ועוד). האלגוריתם הזה איטי מדי ולכן חסר ערך. באופן כללי בתורת המספרים, אלגוריתם על מספר שזמן הריצה שלו הוא בערך כגודל המספר הוא בעייתי מאוד עד חסר ערך (זה אומר שעל מספרים בני מאות ספרות - מה שקורה ב-RSA למשל - המחשב שעליו האלגוריתם רץ יפסיק לעבוד הרבה לפני שהאלגוריתם יסיים לרוץ).

הדרך השניה היא לפרק את {% equation %}a,b{% endequation %} לגורמים ראשוניים. הגורמים הראשוניים של {% equation %}\left(a,b\right){% endequation %} יהיו בדיוק הגורמים של {% equation %}a,b{% endequation %} כשכל גורם מופיע בחזקה הנמוכה יותר מבין אלו שבה הוא מופיע בשני המספרים. נשמע מבלבל? טוב מאוד - אני רוצה שתבינו בעצמכם מה אמרתי פה. אין טעם להרחיב על השיטה הזו כי פירוק לגורמים הוא בעייתי; אנחנו לא מכירים אלגוריתם יעיל לפירוק לגורמים גם כיום, והאלגוריתם האוקלידי קיים עוד מימי היוונים (ואולי עוד לפני כן?) כך שודאי יש דרך אחרת.

אם כן, איך האלגוריתם פועל? כפי שאמרתי, אלגוריתם פירושו פירוק פעולת חישוב מסובכת לפעולות יותר פשוטות. כאן הפעולה הפשוטה יותר היא כזו שלומדים בבית הספר היסודי - חילוק עם שארית. לא אכנס הפעם לדיון על איך עושים את זה בפועל (למרות שזו שאלה מרתקת בפני עצמה - כשהיינו ילדים ולמדנו את זה לא ממש עצרנו - לפחות לא אני - ושאלנו את עצמנו למה זה עובד) אלא רק אגיד מה נובע מזה: בהינתן מספרים טבעיים {% equation %}a,b{% endequation %} אנחנו יודעים למצוא מספרים טבעיים {% equation %}q,r{% endequation %} כך ש-{% equation %}a=bq+r{% endequation %}. ל-{% equation %}q{% endequation %} קוראים <strong>המנה</strong> של {% equation %}a{% endequation %} חלקי {% equation %}b{% endequation %} ול-{% equation %}r{% endequation %} קוראים <strong>השארית</strong>. התכונה הכי הכי הכי הכי חשובה כאן, שלפעמים אנחנו בקושי נותנים עליה את הדעת, היא ה<strong>גודל</strong> של השארית: מובטח לנו שיתקיים {% equation %}0\le r&lt;b{% endequation %}, כלומר השארית תמיד קטנה מהמספר שבו מחלקים. על הפרט הזה קם ונופל הפוסט כולו.

עכשיו אפשר להציג את האלגוריתם האוקלידי. האבחנה המרכזית היא שאם {% equation %}a=bq+r{% endequation %} אז {% equation %}\left(a,b\right)=\left(b,r\right){% endequation %}. למה? כי אם מישהו מחלק את {% equation %}a,b{% endequation %} הוא יחלק גם את {% equation %}a-bq{% endequation %}, כלומר את {% equation %}r{% endequation %}; ואם מישהו מחלק את {% equation %}b,r{% endequation %} אז הוא מחלק גם את {% equation %}bq+r{% endequation %}, כלומר את {% equation %}a{% endequation %}. בפרט, {% equation %}\left(a,b\right){% endequation %} מחלק גם את {% equation %}r{% endequation %} ולכן {% equation %}\left(a,b\right)\le\left(b,r\right){% endequation %} (כי {% equation %}\left(a,b\right){% endequation %} מחלק את {% equation %}b,r{% endequation %} ולכן קטן או שווה מהמקסימלי שמחלק אותם שהוא {% equation %}\left(b,r\right){% endequation %}) ובאופן דומה {% equation %}\left(b,r\right)\le\left(a,b\right){% endequation %}.

זה מעניק לנו את האלגוריתם האוקלידי הפשוט, על המספרים {% equation %}a\ge b{% endequation %}:
<ol>
	<li> אם {% equation %}b=0{% endequation %} החזר את {% equation %}a{% endequation %}.</li>
	<li> חשב את {% equation %}a=bq+r{% endequation %}.</li>
	<li> הצב {% equation %}a\leftarrow b,b\leftarrow r{% endequation %}.</li>
	<li> חזור אל 1.</li>
</ol>
אני אישית חושב שלראות קוד אמיתי אפילו יותר ברור כאן, אז הנה קוד בשפת רובי, שמשתמש ברקורסיה:
<div class="code-block">
{% highlight ruby %}
def gcd(a,b)
  return a if b == 0
  return gcd(b, a % b)
end
{% endhighlight %}
</div>

בעולם האמיתי רצוי לשפר את הקוד כך שיטפל גם במקרים שבהם {% equation %}a&lt;b{% endequation %} או שהמספרים לא בהכרח חיוביים, אבל נעזוב את זה.

קצת פחות ברור הוא איך מרחיבים את האלגוריתם הזה כדי למצוא את אותם {% equation %}x,y{% endequation %} שמקיימים {% equation %}ax+by=\left(a,b\right){% endequation %}. כאן חשיבה רקורסיבית היא מאוד מועילה.

נניח שקיבלנו {% equation %}a,b{% endequation %} ואנחנו רוצים למצוא {% equation %}x,y{% endequation %} כך ש-{% equation %}\left(a,b\right)=ax+by{% endequation %}. מה עושים? ראשית, מחשבים את {% equation %}a=qb+r{% endequation %} כרגיל. כעת החשיבה הרקורסיבית תבוא לידי ביטוי בגישה הבאה: אני אראה איך מוצאים את {% equation %}x,y{% endequation %} עבור {% equation %}a,b{% endequation %} תוך שאני מניח שאני <strong>כבר יודע</strong> איך מוצאים אותם עבור {% equation %}b,r{% endequation %}. אם כן, נניח שמצאתי {% equation %}x,y{% endequation %} כך ש-{% equation %}\left(b,r\right)=bx+ry{% endequation %}. זכרו כעת ש-{% equation %}\left(a,b\right)=\left(b,r\right){% endequation %}, ולכן בעצם מצאתי {% equation %}x,y{% endequation %} כך ש-{% equation %}\left(a,b\right)=bx+ry{% endequation %}. זה כמעט מה שאני רוצה: רק צריך להיפטר איכשהו מ-{% equation %}r{% endequation %} ולהכניס למשחק את {% equation %}a{% endequation %}. אז נשים לב לכך ש-{% equation %}r=a-qb{% endequation %} ולכן אפשר לכתוב:

{% equation %}\left(a,b\right)=\left(b,r\right)=bx+\left(a-qb\right)y=ay+\left(x-qy\right)b{% endequation %}

וכאן אני מקווה שהעיקרון כבר אמור להיות ברור - אני <strong>מאוד</strong> ממליץ לכם להפסיק לקרוא לרגע ולכתוב בעצמכם את האלגוריתם שמבצע את החישוב הכללי. למי שמתעצל, הנה הקוד שאני כתבתי:
<div class="code-block">
{% highlight ruby %}
def extended_gcd(a,b)
  return [a,1,0] if b == 0
  q = a / b
  r = a % b
  gcd, x, y = extended_gcd(b,r)
  return [gcd, y, x-q*y]
end
{% endhighlight %}
</div>
אם כן, בסופו של דבר גם האלגוריתם האוקלידי המורחב הוא פשוט מאוד למימוש. בספרים בדרך כלל לא נכנסים לפירוט הזה אלא מסתפקים בלהראות איזו דוגמה ולהגיד שאפשר למצוא את {% equation %}x,y{% endequation %} על ידי "חזרה לאחור" בחישוב של האלגוריתם האוקלידי הרגיל, וחבל.

זה מסיים את נושא האלגוריתם האוקלידי. לטעמי הוא דוגמה קלאסית לנושא שפשוט חייבים ללמד בבית הספר ופשוט לא עושים את זה, וחבל. כעת אעבור לדבר על נושא שלא מלמדים בבית הספר, ומזל, כי זה כבר כנראה קצת יותר מדי - מה קורה כשרוצים להכליל את האלגוריתם האוקלידי גם לדברים שאינם המספרים השלמים.

כדי שלא נרחיק לכת יותר מדי, אנחנו מגבילים מראש את הדיון לדברים ש"בבסיסם הם כמו המספרים השלמים". מה זה אומר? פורמלית, חוגים קומוטטיביים עם יחידה שהם תחומי שלמות; לא פורמלית, קבוצות של "איברים" (עוד מעט יהיו דוגמאות) שמוגדרות עליהן פעולות חיבור וכפל שמתנהגות כמו במספרים השלמים (כללי הקיבוץ, החילוף והפילוג). קבוצות כאלו נקראות "חוגים". בנוסף, דורשים שבחוג שלנו יהיה קיים איבר נייטרלי לכפל (כמו 1 במספרים הטבעיים) ועוד תכונה חשובה וכבר לא מובנת מאליה - אי אפשר לכפול שני איברים שונים מאפס ולקבל אפס. זה נכון במספרים השלמים, אבל בחוג השלמים מודולו 6 זה כבר לא כך: 3 כפול 2 שווה 0 (כי השארית שמתקבלת כשמחלקים את 3 כפול 2 ב-6 היא 0). לאיבר שונה מאפס שאפשר לכפול אותו במישהו אחר ששונה מאפס ולקבל אפס קוראים "מחלק אפס". פורמלית כל מספר מחלק את אפס, כי {% equation %}a\cdot0=0{% endequation %} תמיד; זה נהיה מעניין רק כשיש {% equation %}b\ne0{% endequation %} כך ש-{% equation %}a\cdot b=0{% endequation %} התופעה הזו גורמת לדברים מוזרים: אנחנו רגילים לכך שאם {% equation %}ax=ay{% endequation %} עבור {% equation %}a\ne0{% endequation %} אז {% equation %}x=y{% endequation %}; אבל אם {% equation %}a{% endequation %} הוא מחלק אפס אז זה כבר לא יהיה נכון. למשל, אנחנו יודעים שאם {% equation %}a{% endequation %} הוא מחלק אפס אז {% equation %}a\cdot b=a\cdot0=0{% endequation %} עבור {% equation %}b\ne0{% endequation %} כלשהו. ואם נחזור לדוגמה של השלמים מודולו 6, הרי ש-{% equation %}2\cdot4=2\cdot1{% endequation %}, למשל.

לעומת זאת, אם אנחנו דורשים במפורש שלא יהיו מחלקי אפס בחוג שלנו נובע מכך שאכן אם {% equation %}ax=ay{% endequation %} אז {% equation %}x=y{% endequation %} לכל {% equation %}a\ne0{% endequation %}, כי על ידי העברת אגפים וחוק הפילוג מקבלים {% equation %}a\left(x-y\right)=0{% endequation %} ומכיוון ש-{% equation %}a\ne0{% endequation %} בהכרח {% equation %}x-y=0{% endequation %}, כלומר {% equation %}x=y{% endequation %}. כלומר, החשבון מתנהג פחות או יותר כפי שאנחנו מצפים שיתנהג. לחוגים שבהם מתקיימת התכונה הזו קוראים "תחומי שלמות" (לרוב דורשים במפורש שהם גם יהיו קומוטטיביים ועם יחידה אבל נעזוב את זה). אם כן, ההכללה שאציג תניח מראש שבחוגים שאנחנו מדברים עליהם מתקיימות התכונות הללו.

שתי הדוגמאות המרכזיות שאני רוצה לעבוד איתן הן חוג השלמים הגאוסיים, {% equation %}\mathbb{Z}\left[i\right]{% endequation %}, שהוא אוסף המספרים מהצורה {% equation %}a+bi{% endequation %} כאשר {% equation %}a,b{% endequation %} הם שלמים ו-{% equation %}i{% endequation %} הוא מספר מדומה שמקיים {% equation %}i^{2}=-1{% endequation %}; וחוג הפולינומים עם מקדמים ממשיים {% equation %}\mathbb{R}\left[x\right]{% endequation %} (למעשה מה שאגיד יהיה תקף לחוג הפולינומים מעל כל שדה, אבל יותר קל לחשוב על מקרה קונקרטי כמו הממשיים). תרגיל טוב לקוראים הוא לוודא שהחוגים הללו הם אכן תחומי שלמות - בפרט עבור השלמים הגאוסיים זה לא מובן מאליו כי מינוסים יכולים לצוץ במקומות שלא ציפינו להם.

המרכיב הנוסף שחסר לנו כדי להתחיל להריץ את האלגוריתם האוקלידי גם על החוגים הללו הוא חילוק עם שארית. אם {% equation %}\alpha,\beta{% endequation %} הם שלמים גאוסיים, היינו רוצים לומר שאפשר לכתוב {% equation %}\alpha=\beta\cdot\gamma+\rho{% endequation %} (האותיות היווניות מטרתן להבהיר שמדובר על שלמים גאוסיים ולא על מספרים "רגילים") כך ש-{% equation %}\rho{% endequation %} "קטן מ-{% equation %}\beta{% endequation %}". אבל זה מעלה את השאלה - קטן באיזה מובן? איך מודדים?

התשובה היא פשוטה - אפשר למדוד באיזו דרך שבא לנו כל עוד המטרה שלנו - האלגוריתם האוקלידי - עדיין תעבוד. דבר אחד שהוא קריטי לאלגוריתם האוקלידי הוא שעניין הגדלים מבטיח שהוא יסתיים מתישהו, כי כל שארית קטנה מקודמתה ולכן מתישהו נגיע לשארית עם גודל אפס, שאומר שהשארית גם היא אפס. בשורה המסכנה הזו יש הנחות מכאן ועד להודעה חדשה. בואו נפרק אותן לגורמים:

ראשית, אם ה"גודל" יכול להיות מספר רציונלי כלשהו, לא קשה לראות שאפשר לבנות סדרה יורדת אינסופית של גדלים שאף פעם לא מגיעה לאפס: {% equation %}1,\frac{1}{2},\frac{1}{4},\frac{1}{8},\dots{% endequation %}. כדי למנוע עיוותים כאלו אנחנו רוצים שהגדלים שלנו יהיו בעלי <strong>סדר טוב</strong>, או כדי לחסוך כאב ראש - אנחנו רוצים ש"גודל" יהיה תמיד מספר טבעי (חיובי או אפס).

שנית, אנחנו רוצים לדרוש במפורש שהגודל של 0 יהיה 0. עניין הגדרתי שכזה (למעשה, כפי שנראה בקרוב, ה"גודל" של 0 פשוט לא מעניין אותנו לרוב).

שלישית, יש לנו התחבטות האם להתיר לאיברים אחרים להיות בעלי "גודל 0" או רק לאפס. כפי שנראה בקרוב, מאוד נוח לפעמים להתיר לעוד איברים להיות בעלי "גודל 0"; זה ידרוש מאיתנו לשנות טיפה את ההגדרה של חלוקה עם שארית.

השם המפורש במתמטיקה ל"גודל" המדובר הוא <strong>נורמה</strong>. זה שם מבלבל כי המילה "נורמה" מופיעה בהרבה הקשרים במתמטיקה, אבל בפוסט הזה אדבר רק על ההקשר הזה כך שלא יהיה חשש לבלבול. בהגדרה הפשוטה שלנו, אנו דורשים רק שהנורמה של איבר {% equation %}a{% endequation %} של החוג, שאסמן כ-{% equation %}N\left(a\right){% endequation %}, תהיה מספר שלם אי שלילי ותו לא; הדרישה הנוספת היחידה שיש לי היא זו של חילוק עם שארית:

אם {% equation %}a,b{% endequation %} איברים של החוג כך ש-{% equation %}b\ne0{% endequation %} אז קיימים {% equation %}q,r{% endequation %} בחוג כך ש-{% equation %}a=bq+r{% endequation %} ובנוסף, או ש-{% equation %}r=0{% endequation %}, או ש-{% equation %}N\left(r\right)&lt;N\left(b\right){% endequation %}.

ההגדרה הזו עוקפת את ה"בעיה" בכך שיש איברים בעלי נורמה 0. אנחנו מרשים להם להתקיים, אבל אם הם מחלקים מישהו, מובטח שהשארית באותה חלוקה תהיה אפס. למה? כי אם {% equation %}N\left(b\right)=0{% endequation %} ו-{% equation %}a=bq+r{% endequation %} ו-{% equation %}N\left(r\right)&lt;N\left(b\right){% endequation %} או ש-{% equation %}r=0{% endequation %}, בהכרח האופציה השניה חייבת להתקיים כי לא ייתכן ש-{% equation %}N\left(r\right)&lt;0{% endequation %} שהרי הנורמה היא מספר אי שלילי. זה מבטיח לנו שהאלגוריתם האוקלידי ניתן להפעלה בחוג ושהוא מסתיים אחרי מספר צעדים סופי (כשצצה השארית 0).

לחוגים שבהם קיימת נורמה שעונה על הדרישות שהצגתי קוראים <strong>חוגים אוקלידיים</strong>. אם כן, {% equation %}\mathbb{Z}{% endequation %} הוא חוג אוקלידי עם הנורמה {% equation %}N\left(a\right)=\left|a\right|{% endequation %} - הערך המוחלט. אולי אתם שואלים את עצמכם איך <strong>מוכיחים פורמלית</strong> את העובדה הזו שידענו עוד מאז שהיינו ילדים - איך מוכיחים שיש חילוק עם שארית ב-{% equation %}\mathbb{Z}{% endequation %}? ובכן, הנה הוכחה פשוטה באינדוקציה. נ

ניח שאנחנו רוצים לחלק את {% equation %}n{% endequation %} ב-{% equation %}b{% endequation %}. נניח ש-{% equation %}b{% endequation %} קבוע ונבצע אינדוקציה על {% equation %}n{% endequation %}. ראשית, עבור {% equation %}n=0,1,\dots,b-1{% endequation %} הטענה נובעת מייד: {% equation %}n=b\cdot0+n{% endequation %}, וזה חוקי כי {% equation %}0\le n&lt;b{% endequation %}. אם כן, זה הבסיס שלנו. צעד האינדוקציה הוא כדלהלן: בהינתן {% equation %}n{% endequation %}, ניתן להפעיל את הנחת האינדוקציה על {% equation %}n-b{% endequation %} ולקבל ש-{% equation %}n-b=qb+r{% endequation %}, כך ש-{% equation %}0\le r&lt;b{% endequation %}; מכאן נובע ש-{% equation %}n=\left(q+1\right)b+r{% endequation %}. פשוט, לא?

נעבור כעת לחוגים {% equation %}\mathbb{Z}\left[i\right]{% endequation %} ו-{% equation %}\mathbb{R}\left[x\right]{% endequation %}. שניהם אוקלידיים, אבל עם אילו נורמות? הנורמה ב-{% equation %}\mathbb{Z}\left[i\right]{% endequation %} היא ההכללה הטבעית של הערך המוחלט עבור מספרים מרוכבים: {% equation %}N\left(a+bi\right)=a^{2}+b^{2}{% endequation %}. כאן עלול להתקבל הרושם השגוי לפיו הנורמה הזו מראה שכל חוג שלמים הוא אוקלידי עם הנורמה הזו, או שכל חוג שלמים אוקלידי, אוקלידי עם הנורמה הזו. <strong>זה לא נכון</strong>! זה עובד ב-{% equation %}\mathbb{Z}\left[i\right]{% endequation %} כי יש לנו מזל וכי זה חוג נחמד במיוחד, לא כחלק מאיזה עקרון גורף.

עבור פולינומים, הנורמה פשוטה עוד יותר. {% equation %}N\left(p\left(x\right)\right){% endequation %} היא פשוט הדרגה של {% equation %}p\left(x\right){% endequation %}, כלומר החזקה הגבוהה ביותר של {% equation %}x{% endequation %} שמופיעה בו. כאן באופן טבעי צצים איברים מנורמה 0: כל פולינום קבוע (כלומר, מספר ממשי). למעשה, הדרגה של פולינום האפס לרוב אינה מוגדרת, או מוגדרת להיות אינסוף, או מינוס אינסוף, או אלף ואחד דברים הזויים שאינם אפס, כך שזו דוגמה טובה לחוג שבו אנחנו ממש רוצים להימנע מלדבר על "הנורמה של אפס" (למרות שאפשר גם להגדיר אותה להיות אפס וזה לא ישנה כלום).

כמובן, סתם להגיד את הנורמה זה לא רציני. צריך גם להוכיח שקיים חילוק עם שארית בחוגים שתיארתי, עם הנורמה שתיארתי. אין כאן ארוחות חינם - כל הוכחה שכזו היא אתגר בפני עצמו עם טריקים משל עצמה. עם נורמות מתאימות גם {% equation %}\mathbb{Z}\left[\sqrt{-2}\right],\mathbb{Z}\left[\sqrt{-3}\right],\mathbb{Z}\left[\sqrt{-7}\right],\mathbb{Z}\left[\sqrt{-11}\right]{% endequation %} הם חוגים אוקלידיים, אבל למשל החוג {% equation %}\mathbb{Z}\left[\sqrt{-5}\right]{% endequation %} אינו חוג אוקלידי! למעשה, יש רק מספר סופי של חוגים אוקלידיים מהצורה {% equation %}\mathbb{Z}\left[\sqrt{D}\right]{% endequation %} עבור {% equation %}D{% endequation %} שלם. אני אסיים את הפוסט עם הצגת ההוכחות ש-{% equation %}\mathbb{Z}\left[i\right]{% endequation %} ו-{% equation %}\mathbb{R}\left[x\right]{% endequation %} הם חוגים אוקלידיים, אבל לפני כן אני רוצה לדבר קצת על מה שנובע מכך.

<a href="http://www.gadial.net/?p=1281">בפוסט קודם</a> דיברתי על פריקות יחידה לגורמים בחוגי שלמים וכמה היא חשובה. בהקשר הזה הצגתי את המושג של אידאלים של חוג - תת-קבוצות של החוג שסגורות לחיבור ו"בולעות" בכפל (כלומר, סכום שני איברים מהאידאל גם הוא באידאל, וכפל איבר מהאידאל באיבר כלשהו מהחוג גם הוא שייך לאידאל). אידאלים הובאו בתור מעין אבסטרקטיזציה של מחלקים - אידאל היה קבוצת כל האיברים שמתחלקים על ידי "מישהו" (כשבמהלך מחשבתי שאני מאוד מחבב, ה"מישהו" הזה הוא פשוט האידאל עצמו). כמו כן ראינו שב-{% equation %}\mathbb{Z}{% endequation %} כל אידאל היה ניתן לזיהוי בצורה פשוטה עם מספר: לכל מספר {% equation %}a{% endequation %} הותאם האידאל ש-{% equation %}a{% endequation %} יוצר - אוסף כל הכפולות של {% equation %}a{% endequation %} באיבר כלשהו של {% equation %}\mathbb{Z}{% endequation %} - וראינו שכל אידאל הוא בהכרח מהצורה הזו (ואז האיברים באידאל הם אכן בדיוק האיברים ש-{% equation %}a{% endequation %} מחלק). לחוג שבו כל אידאל נוצר כך בידי איבר מסויים קוראים <strong>תחום ראשי</strong>, ותוצאה מרכזית שלא הוכחתי (עדיין, לפחות) היא שכל תחום ראשי הוא גם בעל פריקות יחידה לראשוניים.

מה שאני רוצה להראות עכשיו הוא שכל חוג אוקלידי הוא בפרט תחום ראשי. ההוכחה קלילה עד להפתיע. יהא {% equation %}I\subseteq R{% endequation %} אידאל ({% equation %}I{% endequation %} הוא האידאל, {% equation %}R{% endequation %} הוא חוג אוקלידי כלשהו). אז קיים ב-{% equation %}I{% endequation %} איבר בעל נורמה מינימלית, {% equation %}d{% endequation %}. למה קיים כזה? כי הנורמות הן מספרים שלמים אי שליליים ולכן קיים להן מינימום. כמובן, ייתכן שיש באידאל הרבה איברים מנורמה מינימלית, אז נבחר אחד באופן שרירותי. אני טוען שאותו {% equation %}d{% endequation %} יוצר את האידאל. כיוון אחד הוא מובן מאליו: בשל תכונת הבליעה, {% equation %}dr\in I{% endequation %} לכל {% equation %}r\in R{% endequation %}, כך שהאידאל ש-{% equation %}d{% endequation %} יוצר מוכל ב-{% equation %}I{% endequation %}. אבל למה כל איבר ב-{% equation %}I{% endequation %} מתחלק ב-{% equation %}d{% endequation %}? ובכן, יש לנו חילוק עם שארית כי {% equation %}R{% endequation %} אוקלידי - הבה ונשתמש בו: אם {% equation %}a\in I{% endequation %} הוא איבר כלשהו של האידאל, אז {% equation %}a=qd+r{% endequation %}, כך ש-{% equation %}r=0{% endequation %} או ש-{% equation %}N\left(r\right)&lt;N\left(d\right){% endequation %}. כעת, {% equation %}a\in I{% endequation %} וגם {% equation %}qd\in I{% endequation %} (מבליעה) ולכן {% equation %}r=a-qd\in I{% endequation %}. אבל בחרנו את {% equation %}d{% endequation %} להיות איבר מנורמה מינימלית ב-{% equation %}I{% endequation %}, אז לא ייתכן ש-{% equation %}r{% endequation %} (שראינו ששיך ל-{% equation %}I{% endequation %}) הוא בעל נורמה קטנה מ-{% equation %}d{% endequation %}; מכאן ש-{% equation %}r=0{% endequation %} ולכן {% equation %}d{% endequation %} מחלק את {% equation %}a{% endequation %}.

אם ההוכחה נשמעת לכם מוכרת (ולא למדתם אותה אף פעם), זה כנראה לא במקרה: ב<a href="http://www.gadial.net/?p=1289">פוסט</a> שבו הצגתי אידאלים הצגתי גם את ההוכחה הזו, עבור {% equation %}\mathbb{Z}{% endequation %}. עד כדי שינויי ניסוח קלים, זו אותה ההוכחה בדיוק.

כעת אני רוצה לדבר טיפה על פולינומים. מה שמעניין בכך שהפולינומים (במקדמים ממשיים, או באופן כללי יותר מעל שדה כלשהו; זה לא נכון לפולינומים מעל קבוצה שאיננה שדה) הם חוג אוקלידי הוא שזה מצביע על דמיון לא מבוטל שלהם למספרים השלמים, ודמיון שכזה עשוי להיות מפתיע למדי במבט ראשון. זה אומר שאפשר לחלק פולינומים כמו שמחלקים שלמים (ואפילו יש אלגוריתם חילוק ארוך בדיוק כמו עם שלמים), ואפשר למצוא מחלק משותף מקסימלי לפולינומים (אותו קוד שכתבתי למעלה עובד באותה מידה גם לפולינומים; רק צריך לשנות את המימוש של פעולת החילוק ופעולת המודולו) ואפשר גם לפרק פולינומים לגורמים. באופן מפתיע למדי, פירוק של פולינומים לגורמים הוא <strong>קל יותר</strong> מבחינה חישובית מאשר פירוק של מספרים שלמים (לא ידוע כיום אלגוריתם יעיל לפירוק שלמים, אבל לפירוק של פולינומים יש אלגוריתמים לא רעים). כדי לקבל אינטואיציה כלשהי לגבי הסיבה לכך, בואו נבין איך נראה פירוק שכזה.

ראשית כל, פולינום הוא יצור שחי חיים כפולים: {% equation %}p\left(x\right)=x^{3}+2x+17{% endequation %} הוא מצד אחד ביטוי פורמלי עם איקס וחזקות וסכומים; ומצד שני הוא פונקציה - אפשר "להציב" בו ערכים ולראות מה מקבלים. אם {% equation %}p\left(a\right)=0{% endequation %} עבור {% equation %}a{% endequation %} כלשהו, {% equation %}a{% endequation %} נקרא "שורש" של הפולינום (לא במשמעות של {% equation %}\sqrt{p\left(x\right)}{% endequation %}, חלילה; זה עוד שימוש כפול מבלבל באותה מילה). השורשים של הפולינום הם המפתח לפירוק לגורמים שלו: אם {% equation %}p\left(x\right){% endequation %} הוא פולינום ו-{% equation %}a{% endequation %} שורש שלו, אז {% equation %}\left(x-a\right){% endequation %} מחלק את {% equation %}p\left(x\right){% endequation %}. בואו נראה איך מוכיחים את הטענה הזו, שנובעת ישירות מכך שהפולינומים הם חוג אוקלידי.

חוג אוקלידי אומר שניתן לחלק עם שארית, אז בואו נעשה את זה: {% equation %}p\left(x\right)=\left(x-a\right)\cdot q\left(x\right)+r\left(x\right){% endequation %}. כעת, {% equation %}r\left(x\right){% endequation %} הוא אפס או פולינום מדרגה נמוכה יותר מ-{% equation %}x-a{% endequation %} ומכיוון ש-{% equation %}x-a{% endequation %} הוא פולינום מדרגה 1, אז {% equation %}r\left(x\right){% endequation %} הוא פולינום קבוע ולכן הוא בעצם מספר ממשי {% equation %}r{% endequation %}. כעת, אם נציב {% equation %}x=a{% endequation %} במשוואה שקיבלנו, נקבל: {% equation %}0=p\left(a\right)=\left(a-a\right)q\left(a\right)+r=r{% endequation %}, כלומר השארית חייבת להיות אפס, וזה מסיים בזריזות את ההוכחה.

התוצאה הזו מלמדת אותנו שכל פולינום {% equation %}p\left(x\right){% endequation %} ניתן לפירוק יחיד מהצורה {% equation %}p\left(x\right)=a\left(x-a_{1}\right)\left(x-a_{2}\right)\cdots\left(x-a_{n}\right){% endequation %} (ה-{% equation %}a{% endequation %} שמחוץ לסוגריים הוא מספר ממשי ששווה למקדם של החזקה הגבוהה ביותר ב-{% equation %}p\left(x\right){% endequation %}; מנקודת מבט אלגברית זה איבר הפיך ולכן "לא רלוונטי" כמו שכפל ב-1 ובמינוס 1 לא רלוונטי בפירוק לגורמים ראשוניים ב-{% equation %}\mathbb{Z}{% endequation %}). לרוע המזל, החיים לא בהכרח פשוטים עד כדי כך - אני מסתמך כאן במובלע על ההנחה שלכל פולינום קיים שורש (ואז אפשר לחלק באיקס פחות השורש, לקבל פולינום מנה {% equation %}q\left(x\right){% endequation %} קטן יותר, גם לו למצוא שורש וכן הלאה) אבל זה תלוי ב"עולם" שבו אנו חיים. כך למשל לפולינום {% equation %}x^{2}+1{% endequation %} אין שורשים ממשיים ולכן כאיבר של {% equation %}\mathbb{R}\left[x\right]{% endequation %}, הוא עצמו ראשוני וזהו הפירוק שלו לגורמים. לעומת זאת, מעל {% equation %}\mathbb{C}\left[x\right]{% endequation %} הפירוק שלו לגורמים ראשוניים יהיה {% equation %}\left(x+i\right)\left(x-i\right){% endequation %}. אחת התוצאות החשובות באלגברה היא שלכל פולינום קיים שדה שבו הוא מתפרק לגורמים ממעלה 1 - <strong>שדה הפיצול</strong> של הפולינום; אבל לא אכנס לכך כעת.

לסיום, בואו נבין למה פולינומים ושלמים גאוסיים הם חוגים אוקלידיים. נתחיל מפולינומים. יש לנו שני פולינומים {% equation %}a\left(x\right),b\left(x\right){% endequation %}; אנחנו רוצים למצוא שני פולינומים {% equation %}q\left(x\right),r\left(x\right){% endequation %} כך ש-{% equation %}a\left(x\right)=b\left(x\right)q\left(x\right)+r\left(x\right){% endequation %} ודרגת {% equation %}r\left(x\right){% endequation %} קטנה מדרגת {% equation %}b\left(x\right){% endequation %} (או ש-{% equation %}r\left(x\right)=0{% endequation %}). מה עושים?

ובכן, ההוכחה מאוד דומה למה שהראיתי קודם עבור שלמים: "מקפיאים" את {% equation %}b\left(x\right){% endequation %} ומוכיחים לכל {% equation %}a\left(x\right){% endequation %} באינדוקציה על דרגת {% equation %}a\left(x\right){% endequation %}. הבסיס הוא דרגה שקטנה מדרגת {% equation %}b\left(x\right){% endequation %}: עבורה {% equation %}a\left(x\right)=b\left(x\right)\cdot0+a\left(x\right){% endequation %} (כי {% equation %}a\left(x\right){% endequation %} הוא שארית לגיטימית). הצעד הוא קצת יותר מחוכם מאשר בשלמים: אם דרגת {% equation %}a\left(x\right){% endequation %} גדולה או שווה לדרגת {% equation %}b\left(x\right){% endequation %}, אז על ידי כפל של {% equation %}b\left(x\right){% endequation %} בפולינום כלשהו {% equation %}t\left(x\right){% endequation %} אפשר לקבל פולינום {% equation %}b\left(x\right)t\left(x\right){% endequation %} שדרגתו שווה לדרגת {% equation %}a\left(x\right){% endequation %} והמקדם המוביל של שניהם זהה. מכך עולה ש-{% equation %}a\left(x\right)-b\left(x\right)t\left(x\right){% endequation %} הוא פולינום מדרגה קטנה מדרגת {% equation %}a\left(x\right){% endequation %} ולכן אפשר להשתמש עליו בהנחת האינדוקציה. מקבלים: {% equation %}a\left(x\right)-b\left(x\right)t\left(x\right)=b\left(x\right)q\left(x\right)+r\left(x\right){% endequation %}, ולכן {% equation %}a\left(x\right)=b\left(x\right)\left[t\left(x\right)+q\left(x\right)\right]+r\left(x\right){% endequation %}. כלומר, השלב היחיד כאן שבו היה עלינו לפעול בצורה שונה מבהוכחה עבור {% equation %}\mathbb{Z}{% endequation %} היה האופן שבו "הקטנו" את {% equation %}a\left(x\right){% endequation %}.

עבור שלמים גאוסיים זה כבר לא עובד ככה. הרבה פחות ברור איך לבצע "הקטנה" שכזו. לכן ההוכחה גם יותר מסובכת.

אם כן, יהיו {% equation %}\alpha=a+bi{% endequation %} ו-{% equation %}\beta=c+di{% endequation %} שני שלמים גאוסיים כך ש-{% equation %}\beta\ne0{% endequation %}. מה שנעשה יהיה לחלק אותם בכוח, ואז לאסוף את השברים מהרצפה. כשאני אומר לחלק בכוח, הכוונה היא לכך שנחשב את {% equation %}\frac{\alpha}{\beta}{% endequation %} באופן ישיר:

{% equation %}\frac{\alpha}{\beta}=\frac{a+bi}{c+di}=\frac{a+bi}{c+di}\frac{c-di}{c-di}=\frac{ac+bd}{c^{2}+d^{2}}+\frac{bc-ad}{c^{2}+d^{2}}i=t+si{% endequation %}

כלומר, קיבלנו ש-{% equation %}\frac{\alpha}{\beta}{% endequation %} הוא מהצורה {% equation %}t+si{% endequation %} כאשר {% equation %}t,s{% endequation %} הם מספרים רציונליים (לא בהכרח שלמים, אחרת היינו יכולים לסיים כאן). למרבה המזל, לכל רציונלי יש מספר שלם שקרוב אליו - לכל היותר במרחק {% equation %}\frac{1}{2}{% endequation %} ממנו. אז בואו וניקח את {% equation %}p,q{% endequation %} להיות השלמים המתאימים: {% equation %}\left|t-p\right|\le\frac{1}{2}{% endequation %} ו-{% equation %}\left|s-q\right|\le\frac{1}{2}{% endequation %}. אם כן, השלם הגאוסי {% equation %}p+qi{% endequation %} נראה כמו הימור טוב להיות המנה של {% equation %}\alpha{% endequation %} ו-{% equation %}\beta{% endequation %} שתותיר את השארית הכי קטנה שאפשר (מבחינת הנורמה). אם כן, נכתוב {% equation %}\alpha=\left(p+qi\right)\beta+\gamma{% endequation %} ומה שעלינו לברר הוא ש-{% equation %}N\left(\gamma\right)&lt;N\left(\beta\right){% endequation %}.

למקרה שזה לא ברור - {% equation %}\gamma{% endequation %} <strong>מוגדר</strong> על ידי הנוסחה {% equation %}\gamma=\alpha-\left(p+qi\right)\beta{% endequation %}, ולכן גם מובטח לנו שהוא שלם גאוסי. מה שלא ברור הוא איך לחשב את הנורמה שלו. כדי להקל על החישוב הזה נמצא {% equation %}\theta{% endequation %} מרוכב (לא בהכרח שלם גאוסי בעצמו) כך שיתקיים {% equation %}\gamma=\theta\beta{% endequation %}. זה יקל עלינו שכן הנורמה שבה אנו משתמשים בשלמים הגאוסים וניתנת להגדרה עבור כל מספר מרוכב מקיימת תכונה נחמדה (שבאופן כללי לא נהוג במיוחד לדרוש, למרות שלפעמים עושים זאת) - היא <strong>כפלית</strong>. כלומר בפרט {% equation %}N\left(\gamma\right)=N\left(\theta\right)N\left(\beta\right){% endequation %} (הכפליות ניתנת להוכחה בקלות יחסית אם שמים לב לכך שהנורמה הזו מקיימת {% equation %}N\left(\alpha\right)=\alpha\cdot\overline{\alpha}{% endequation %} - כפל בצמוד המרוכב).

טוב, אז מהו אותו {% equation %}\theta{% endequation %} מסתורי? לא קשה למצוא אותו אם שמים לב לכך ש-{% equation %}\alpha=\left(t+si\right)\beta{% endequation %}, כלומר {% equation %}\gamma=\left(t+si\right)\beta-\left(p+qi\right)\beta=\left[\left(t-p\right)+\left(s-q\right)i\right]\beta{% endequation %}, כלומר {% equation %}\theta=\left(t-p\right)+\left(s-q\right)i{% endequation %}. נותר רק לחסום את גודל הנורמה של {% equation %}\theta{% endequation %} ולהראות שהוא קטן מ-1: {% equation %}N\left(\theta\right)=\left(t-p\right)^{2}+\left(s-q\right)^{2}\le\left|\frac{1}{2}\right|^{2}+\left|\frac{1}{2}\right|^{2}\le\frac{1}{2}&lt;1{% endequation %}. זה מסיים את ההוכחה (וגם מסביר למה עניין ה"קרוב עד כדי חצי" היה חשוב לנו).

לטעמי ההוכחה הזו <strong>מגעילה</strong>. אמנם, אין בה קסמים וכל הצעדים בה ברורים יחסית, אבל היא מאוד מותאמת לנורמה הספציפית הזו ולשלמים הגאוסיים. זו גם בדיוק הסיבה שהבאתי אותה - רק כך מקבלים תחושה כלשהי של הקושי בהוכחה שחוגים מסויימים הם אוקלידיים ומבינים מדוע זה לא עובד לכל חוג שלמים, ולכן גם למה חוגים אוקלידיים זו תופעה נדירה ונפלאה יותר משנדמה במבט ראשון.
