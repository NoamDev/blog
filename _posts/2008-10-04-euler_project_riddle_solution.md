---
id: 166
title: "חידת אוילר - הפתרון"
date: 2008-10-04 11:48:33
layout: post
categories: 
  - משחקים וחידות מתמטיות
  - תורת המספרים
---
מכיוון ש<a href="http://www.gadial.net/?p=165">החידה שהצגתי בפוסט הקודם</a> עוסקת ב<a href="http://he.wikipedia.org/wiki/%D7%A4%D7%95%D7%A0%D7%A7%D7%A6%D7%99%D7%99%D7%AA_%D7%90%D7%95%D7%99%D7%9C%D7%A8">פונקצית אוילר</a>, כדאי להבין את הפונקציה יותר טוב על מנת שניתן יהיה להבין את הפתרון. כפי שכתבתי שם, הפונקציה מחזירה לכל מספר טבעי את מספרם של המספרים הטבעיים הקטנים ממנו וזרים לו, כלומר שאין מספר גדול מ-1 שמחלק את שניהם גם יחד. למשל, עבור 8 הפונקציה תחזיר 4, בשל המספרים 1,3,5,7 (שימו לב - 6 אמנם אינו מחלק את 8 אך גם אינו זר לו, שכן 2 מחלק את שניהם). חישוב של הפונקציה על בסיס ההגדרה הזו בלבד יהיה לא יעיל במיוחד - לעבור על כל המספרים שקטנים מ-{::nomarkdown}\( n\){:/nomarkdown}, לבדוק לכל אחד אם הוא זר ל-{::nomarkdown}\( n\){:/nomarkdown} (בעזרת <a href="http://he.wikipedia.org/wiki/%D7%94%D7%90%D7%9C%D7%92%D7%95%D7%A8%D7%99%D7%AA%D7%9D_%D7%94%D7%90%D7%95%D7%A7%D7%9C%D7%99%D7%93%D7%99">האלגוריתם האוקלידי</a> למציאת המחלק המשותף המקסימלי - אלגוריתם שבפני עצמו הוא יעיל למדי), ואם כן - להוסיף אותו לסכום. זה לא פתרון טוב במיוחד, כי זמן הריצה הוא פרופורציוני לגודל המספר, מה שנחשב איטי למדי (אלגוריתמים יעילים על מספרים הם כאלו שזמן הריצה שלהם הוא <a href="http://en.wikipedia.org/wiki/Polylogarithmic">פולינום בלוגריתם של המספר</a>, או בצורה פשוטה יותר - פולינומי במספר הספרות שלו).

לכן אנו מחפשים נוסחה יותר פשוטה לפונקצית אוילר, מתוך תקווה שהיא תפשט את החידה. קיימת נוסחה שכזו ואציג אותה בפוסט הזה; את החידה שהצגתי קודם היא תהפוך לטריוויאלית, ואדגים גם כיצד ניתן להשתמש בה כדי לחשב את הערכים של פונקצית אוילר, כשצריך לחשב אותה לתחום גדול של מספרים רציפים, בצורה יותר יעילה מהצורה הנאיבית שלעיל. לרוע המזל, כפי שיתבהר בהמשך, הנוסחה עדיין לא הופכת את החישוב של נוסחת אוילר ליעיל; הקושי של החישוב שלה יתגלה כקשור בצורה הדוקה לקושי של פירוק מספרים לגורמים (בפרט, <a href="http://www.gadial.net/?p=90">שיטת ההצפנה RSA</a> מתבססת <a href="http://www.gadial.net/?p=92">בצורה חזקה מאוד</a> על כך שקשה לחשב את פונקצית אוילר למספרים מסויימים בלי ידע על הפירוק לגורמים שלהם).

את הנוסחה אפשר להסיק באמצעות שתי תכונות פשוטות של הפונקציה:
<ol>
	<li>אם {::nomarkdown}\( a,b\){:/nomarkdown} זרים, אז {::nomarkdown}\( \varphi(ab)=\varphi(a)\cdot\varphi(b)\){:/nomarkdown}. כלומר, פונקצית אוילר של מכפלת שני מספרים זרים, שווה למכפלות פונקצית אוילר שלהם.</li>
	<li>אם {::nomarkdown}\( p\){:/nomarkdown} הוא ראשוני, אז {::nomarkdown}\( \varphi(p^k)=p^k-p^{k-1}\){:/nomarkdown}</li>
</ol>
בעזרת שתי התכונות הללו קל לתת נוסחה עבור פונקצית אוילר לכל מספר, שכן כל מספר ניתן להציג בתור מכפלה של חזקות של ראשוניים (זה נקרא "המשפט היסודי של האריתמטיקה") ויש רק הצגה אחת כזו, וכל שתי חזקות של ראשוניים שונים זרות זו לזו (כי חזקה של ראשוני מתחלקת אך ורק באותו ראשוני ובחזקות שלו, לא בראשוניים אחרים).

כלומר, אם {::nomarkdown}\( n=p_1^{k_1}\cdots p_t^{k_t}\){:/nomarkdown} אז

{::nomarkdown}\( \varphi\left(n\right)=\varphi\left(p_{1}^{k_{1}}\cdots p_{t}^{k_{t}}\right)=\varphi\left(p_{1}^{k_{1}}\right)\cdots\varphi\left(p_{t}^{k_{t}}\right)=\left(p_{1}^{k_{1}}-p_{1}^{k_{1}-1}\right)\cdots\left(p_{t}^{k_{t}}-p_{t}^{k_{t}-1}\right)\){:/nomarkdown}

זה בפני עצמו לא נראה מרשים כל כך, אבל הנה טוויסט קטן שעושה את הכל הרבה יותר נחמד. אפשר לכתוב את {::nomarkdown}\( p^k-p^{k-1}\){:/nomarkdown} גם בצורה שונה, אם מחלקים את שני האיברים ב-{::nomarkdown}\( p^k\){:/nomarkdown}. מקבלים: {::nomarkdown}\( p^k(1-\frac{1}{p})\){:/nomarkdown}.

"יופי", אתם אומרים, "אז עכשיו גם הכנסת שברים לעניין. ממש פשוט." אבל שימו לב מה קורה כשמכניסים את הטוויסט הזה לנוסחה:

{::nomarkdown}\( \varphi\left(n\right)=\left(p_{1}^{k_{1}}-p_{1}^{k_{1}-1}\right)\cdots\left(p_{t}^{k_{t}}-p_{t}^{k_{t}-1}\right)=p_{1}^{k_{1}}\cdots p_{t}^{k_{t}}\left(1-\frac{1}{p_{1}}\right)\cdots\left(1-\frac{1}{p_{t}}\right)=n\cdot\left(1-\frac{1}{p_{1}}\right)\cdots\left(1-\frac{1}{p_{t}}\right)\){:/nomarkdown}

אם נשתמש בקיצור הסטנדרטי במתמטיקה לתיאור כפל בהרבה איברים, סימן גדול של האות פאי, אפשר לכתוב את כל העסק ככה:

{::nomarkdown}\( \varphi\left(n\right)=n\cdot\prod_{p\|n}\left(1-\frac{1}{p}\right)\){:/nomarkdown}

במילים: פונקצית אוילר של מספר שווה ל<strong>עצמו</strong> כפול "תיקון" כלשהו, שנבנה מתוך הראשוניים שמחלקים אותו. אחד הדברים היפים כאן הוא שהחזקה שבה הראשוניים מופיעים בפירוק של המספר לגורמים איננה חשובה; צריך רק לדעת מי הראשוניים שמחלקים את המספר, ולא "כמה פעמים" הם מחלקים. כל ראשוני שמחלק את המספר מופיע בנוסחה פעם אחת בלבד.

כדאי לשים לב שה"תיקון" תמיד יהיה מספר רציונלי קטן מ-1, שכן הוא מכפלה של איברים מהצורה "אחד פחות משהו", כשהמשהו הוא קטן יותר ככל שהראשוני שיוצר את האיבר גדול יותר. מכאן גם מגיעים בזריזות לפתרון החידה מהפוסט הקודם. מהו היחס {::nomarkdown}\( \frac{n}{\varphi(n)}\){:/nomarkdown}? אם משתמשים בנוסחה, רואים שהוא {::nomarkdown}\( \frac{1}{\prod_{p\|n}\left(1-\frac{1}{p}\right)}\){:/nomarkdown}. אנחנו רוצים לדעת מתי הערך הזה הוא מקסימלי, כלומר מתי {::nomarkdown}\( \prod_{p\|n}\left(1-\frac{1}{p}\right)\){:/nomarkdown} הוא מינימלי.

ה"מינימליות" היא די בעייתית כאן. הרי אם ניקח קבוצה של ראשוניים ונכניס אותם למכפלה הזו, התוצאה שנקבל אף פעם לא תהיה מינימלית כי תמיד ניתן יהיה לכפול אותה בעוד גורם שהתקבל מראשוני שלא היה בקבוצה (הרי יש אינסוף ראשוניים) ולקבל משהו שהוא עוד טיפ-טיפה יותר קטן. לכן נדרשת הגבלה על גודל {::nomarkdown}\( n\){:/nomarkdown}. בחידה הגבילו אותו שרירותית למיליון, אבל העיקר פה הוא העיקרון. אם כן, איך נבנה את המספר שערכו הוא מינימלי?

ראשית, ברור שבפירוק לגורמים של המספר, כל ראשוני צריך להופיע פעם אחת (כלומר, המעריך שלו בחזקה יהיה 1; לכן מספר כמו 9 או 18 הוא פסול מראש כי 3 מופיע בפירוק שלו בחזקת 2). למה? כי זו חזקה "מבוזבזת"; היא לא מקטינה עוד יותר את המכפלה, כי הראשוני כבר מופיע בה; לכן, בהינתן מספר שעבורו היחס הוא כך וכך ויש לו ראשוני עם חזקה גבוהה מ-1 בפירוק לגורמים, אפשר להחליף אותו במספר אחר, שבו החזקה של אותו ראשוני היא 1, ונותן בדיוק את אותו היחס. נסו כמה דוגמאות - למשל, 18 חלקי פונקצית אוילר של 18 ייתן בדיוק אותה תוצאה כמו 6 חלקי פונקצית אוילר של 6: 3 בשני המקרים.

אם כן, המספר שלנו יהיה מכפלה של ראשוניים שונים זה מזה. אילו ראשוניים נבחר? הדעת נותנת שאת הקטנים ביותר שרק אפשר, שכן ככל שהראשוני גדול יותר, כך {::nomarkdown}\( 1-\frac{1}{p}\){:/nomarkdown} גדול יותר, ואנחנו רוצים שיהיה דווקא קטן. מכאן שהמספר שלנו הוא בהכרח המספר הגדול ביותר שקטן ממיליון ומהווה מכפלה של ראשוניים עוקבים, החל מ-2. לחשב את זה במספרים גבוהים זה כאב ראש, אבל במספרים נמוכים זה לא נורא. אפשר לגלות די בקלות, על ידי בדיקה ממצה אפילו, שהראשוניים הראשונים הם 2,3,5,7,11,13,17; חישוב קצר (לא כיפי בכלל, אבל ניתן לביצוע אפילו עם נייר ועיפרון) יראה כי מכפלתם היא 510,510; ואם נכפול את העסק הזה בראשוני הבא בתור, 19, נקבל מפלצת שעוברת את מיליון בקלות. לכן 510510 הוא המספר המבוקש - זהו פתרון החידה.

הבטחתי שהנוסחה תסייע לנו גם בחישוב פונקצית אוילר עבור תחומים רציפים גדולים. הרעיון הוא להשתמש באלגוריתם דומה ל<a href="http://he.wikipedia.org/wiki/%D7%94%D7%A0%D7%A4%D7%94_%D7%A9%D7%9C_%D7%90%D7%A8%D7%98%D7%95%D7%A1%D7%AA%D7%A0%D7%A1">כברה של ארטוסתנס</a>: בונים מערך גדול מאוד של כל המספרים מ-2 ועד למקסימום שעבורו אנחנו רוצים לחשב, כשבתא ה-{::nomarkdown}\( n\){:/nomarkdown} שמים את הערך {::nomarkdown}\( n\){:/nomarkdown}. כעת מתחילים לעבור על כל הראשוניים שבתחום שלנו (איך מוצאים אותם? זה כבר סיפור אחר ויסופר בפעם אחרת, אבל זה לא קשה עד כדי כך). לכל ראשוני {::nomarkdown}\( p\){:/nomarkdown}, מתחילים לעבור על כל התאים שמספרם הוא כפולה של {::nomarkdown}\( p\){:/nomarkdown}, וכופלים כל אחד מהם ב"תיקון" שנובע ממנו: {::nomarkdown}\( 1-\frac{1}{p}\){:/nomarkdown}. זה כל מה שצריך לעשות כדי להבטיח שבסיום האלגוריתם, בכל תא תהיה התוצאה הנכונה (מדוע?). בהתחלה זה ייקח זמן רב (עבור 2 "נתקן" חצי מהתאים שלו) אבל מהר מאוד מגיעים לראשוניים גדולים, והעסק יתחיל לרוץ. נסו לתכנת את השיטה הזו ואת השיטה הנאיבית (לעבור תא-תא ולכל תא בנפרד לחשב את פונקצית אוילר) ותיווכחו במהירות שמבחינה פרקטית, השיטה הראשונה עדיפה פי כמה וכמה (מבחינה תיאורטית, היא עדיין אינה מעשית כשמגיעים לערכים גדולים מדי).

נותר לי רק להסביר איך מוכיחים את שתי התכונות של פונקצית אוילר שעליהן התבססתי בבניית הנוסחה. נתחיל דווקא מהשנייה:  {::nomarkdown}\( \varphi(p^k)=p^k-p^{k-1}\){:/nomarkdown}. הוכחת הנוסחה הזו מתבססת על קומבינטוריקה פשוטה. אנו רוצים לדעת כמה מספרים זרים ל-{::nomarkdown}\( p^k\){:/nomarkdown} יש בתחום {::nomarkdown}\( 1,\dots\,p^k\){:/nomarkdown}. התחום כולו מכיל {::nomarkdown}\( p^k\){:/nomarkdown} מספרים, ולכן טכניקת ספירה הגיונית היא לספור כמה מספרים בתחום דווקא <strong>לא</strong> זרים ל-{::nomarkdown}\( p^k\){:/nomarkdown} ולחסר מסך כל המספרים שבתחום. אם כן, כל מה שנשאר לנו להראות הוא שיש בתחום הזה {::nomarkdown}\( p^{k-1}\){:/nomarkdown} מספרים שאינם זרים ל-{::nomarkdown}\( p^k\){:/nomarkdown}.

כאן אנחנו נעזרים בכך ש-{::nomarkdown}\( p\){:/nomarkdown} הוא ראשוני, ולכן המספרים היחידים שמחלקים את {::nomarkdown}\( p^k\){:/nomarkdown} יהיו חזקות של {::nomarkdown}\( p\){:/nomarkdown} עצמו (הטענה הזו אולי נשמעת אינטואיטיבית אבל לא טריוויאלי לגמרי להוכיח אותה - נסו, ושימו לב לאיזה משפט אתם מזדקקים). מכאן שאם יש מספר שאינו זר ל-{::nomarkdown}\( p^k\){:/nomarkdown} (דהיינו, יש לו מחלק משותף עם {::nomarkdown}\( p^k\){:/nomarkdown} שגדול מ-1), אז בפרט הוא מתחלק ב-{::nomarkdown}\( p\){:/nomarkdown}. ברור שגם ההפך נכון - שכל מספר שמתחלק ב-{::nomarkdown}\( p\){:/nomarkdown} אינו זרק ל-{::nomarkdown}\( p^k\){:/nomarkdown}. לכן יש לנו <strong>התאמה חד חד ערכית ועל</strong> בין "קבוצת המספרים שמתחלקים ב-{::nomarkdown}\( p\){:/nomarkdown} בתחום {::nomarkdown}\( 1,\dots\,p^k\){:/nomarkdown}" ובין "קבוצת המספרים שאינם זרים ל-{::nomarkdown}\( p^k\){:/nomarkdown} באותו התחום". זו התאמה פשוטה במיוחד - כל איבר מותאם לעצמו - אבל היא אומרת הרבה - שמספיק לנו לספור כמה איברים שמתחלקים ב-{::nomarkdown}\( p\){:/nomarkdown} יש בתחום הזה.

גם את הספירה הזו קל לבצע עם התאמה חח"ע ועל - במקרה הזה, בין התחום {::nomarkdown}\( 1,\dots,p^{k-1}\){:/nomarkdown} <strong>כולו</strong> ובין המספרים שמתחלקים ב-{::nomarkdown}\( p\){:/nomarkdown} בתחום הגדול. ההתאמה פשוטה: בהינתן איבר מתוך {::nomarkdown}\( 1,\dots,p^{k-1}\){:/nomarkdown} נכפול אותו ב-{::nomarkdown}\( p\){:/nomarkdown}, ונקבל איבר ששייך לתחום הגדול ומתחלק ב-{::nomarkdown}\( p\){:/nomarkdown}. קל להראות שההתאמה היא חד חד ערכית - אם כפלנו שני מספרים ב-{::nomarkdown}\( p\){:/nomarkdown} והגענו לאותה תוצאה, אלו היו אותם מספרים; זה צמצום פשוט. קל גם להראות שההתאמה היא על, שכן אם יש לנו מספר בתחום הגדול שמתחלק ב-{::nomarkdown}\( p\){:/nomarkdown}, פשוט נחלק אותו ב-{::nomarkdown}\( p\){:/nomarkdown} ובהכרח נקבל איבר בתחום הקטן - כלומר מקור של האיבר בתחום הגדול.

אם כן, גודל התחום {::nomarkdown}\( 1,\dots,p^{k-1}\){:/nomarkdown} הוא כגודל קבוצת המספרים בתחום הגדול שמתחלקים ב-{::nomarkdown}\( p\){:/nomarkdown}, ולכן יש בדיוק {::nomarkdown}\( p^{k-1}\){:/nomarkdown} מספרים כאלו וגמרנו.

טענת הכפליות היא מורכבת קצת יותר. בהינתן {::nomarkdown}\( n,m\){:/nomarkdown} זרים, אנחנו רוצים להראות שלכל זוג מספרים {::nomarkdown}\( a,b\){:/nomarkdown} כך ש-{::nomarkdown}\( a\){:/nomarkdown} זר ל-{::nomarkdown}\( n\){:/nomarkdown} וקטן ממנו, ו-{::nomarkdown}\( b\){:/nomarkdown} זר ל-{::nomarkdown}\( m\){:/nomarkdown} וקטן ממנו, ניתן להתאים בצורה חד חד ערכית ועל מספר שזר למכפלה {::nomarkdown}\( nm\){:/nomarkdown} וקטן ממנה. טבעי לחשוב שהמספר הזה יהיה {::nomarkdown}\( ab\){:/nomarkdown}; אלא שהעתקה כזו אינה חד חד ערכית. למשל, אם {::nomarkdown}\( n=5\){:/nomarkdown} ואילו {::nomarkdown}\( m=7\){:/nomarkdown}, אז נקבל את המספר 2 גם עבור {::nomarkdown}\( a=2,b=1\){:/nomarkdown} וגם עבור {::nomarkdown}\( a=1,b=2\){:/nomarkdown}. יש מספרים אחרים שזרים למכפלה 35, כמו למשל 31, שאין סיכוי לקבל כמכפלה (הרי 31 הוא ראשוני). צריך אם כן התחכמות נוספת כאן. ההתחכמות מתבססת על משפט חשוב בתורת המספרים האלמנטרית - "<a href="http://he.wikipedia.org/wiki/%D7%9E%D7%A9%D7%A4%D7%98_%D7%94%D7%A9%D7%90%D7%A8%D7%99%D7%95%D7%AA_%D7%94%D7%A1%D7%99%D7%A0%D7%99">משפט השאריות הסיני</a>". אציג כאן גרסה פשוטה מאוד של המשפט, שהיא כל מה שצריך; אולי בהמשך אתאר את הגרסאות הכלליות יותר.

בגרסה הפשוטה, המשפט אומר כך: בהינתן {::nomarkdown}\( n,m\){:/nomarkdown} זרים זה לזה (הכרחי שהם יהיו זרים), ובהינתן {::nomarkdown}\( a,b\){:/nomarkdown} קטנים מהם בהתאמה, ניתן למצוא {::nomarkdown}\( x\){:/nomarkdown} בין 1 והמכפלה {::nomarkdown}\( nm\){:/nomarkdown}, כך שהשארית שהוא מותיר כאשר מחלקים אותו ב-{::nomarkdown}\( n\){:/nomarkdown} היא {::nomarkdown}\( a\){:/nomarkdown}, והשארית שהוא מותיר כאשר מחלקים אותו ב-{::nomarkdown}\( m\){:/nomarkdown} היא {::nomarkdown}\( b\){:/nomarkdown}, והמספר הזה הוא יחיד (אין עוד מספר בתחום הזה שמקיים את אותה תכונה). המספר הזה יהיה בדיוק מה שאנחנו רוצים להתאים לכל זוג. כדי שזה יסיים את ההוכחה רק צריך להיווכח בכך שאם {::nomarkdown}\( x\){:/nomarkdown} הוא מספר בתחום {::nomarkdown}\( 1,\dots,nm\){:/nomarkdown} שמקיים את תכונת השאריות הזו עבור {::nomarkdown}\( a,b\){:/nomarkdown} שזרים ל-{::nomarkdown}\( n,m\){:/nomarkdown}, אז הוא עצמו זר ל-{::nomarkdown}\( nm\){:/nomarkdown}, וההפך - אם הוא זר, גם השאריות זרות.

בואו נבין לרגע מה פירוש "השארית של חלוקת {::nomarkdown}\( x\){:/nomarkdown} ב-{::nomarkdown}\( n\){:/nomarkdown} היא {::nomarkdown}\( a\){:/nomarkdown}"; זה אומר שקיים {::nomarkdown}\( q\){:/nomarkdown} כך שמתקיים {::nomarkdown}\( x=qn+a\){:/nomarkdown}. במילים אחרות, {::nomarkdown}\( x-qn=a\){:/nomarkdown}, ולכן אם יש מספר גדול מ-1 שמחלק גם את {::nomarkdown}\( x\){:/nomarkdown} וגם את {::nomarkdown}\( n\){:/nomarkdown}, אז בפרט הוא מחלק את שני המספרים באגף שמאל ולכן גם את הפרשם, ולכן הוא מחלק את אגף שמאל כולו, ולכן גם את אגף ימין, ולכן גם את {::nomarkdown}\( a\){:/nomarkdown}. כלומר: אם {::nomarkdown}\( x\){:/nomarkdown} לא זר ל-{::nomarkdown}\( n\){:/nomarkdown}, גם {::nomarkdown}\( a\){:/nomarkdown} לא זר ל-{::nomarkdown}\( n\){:/nomarkdown}, וההפך - אם {::nomarkdown}\( a\){:/nomarkdown} לא זר ל-{::nomarkdown}\( n\){:/nomarkdown} אז כבר מהמשוואה  {::nomarkdown}\( x=qn+a\){:/nomarkdown} מקבלים שגם {::nomarkdown}\( x\){:/nomarkdown} לא זר ל-{::nomarkdown}\( n\){:/nomarkdown}. כלומר, הוכחנו בדיוק את מה שרצינו.

ההסבר הזה אינו קל להבנה, כמובן; הרבה יותר טבעי להבין אותו כשמדברים בשפת החבורות, ומשפט השאריות הסיני בא לידי ביטוי כטענת איזומורפיזם של חבורות מסויימות. כאמור, אולי אעסוק בכך בעתיד - לעת עתה מה שהיה חשוב לי הוא התוצאה - הנוסחה היפה עבור פונקצית אוילר.
