---
id: 218
title: "הפוסט שיודע להדפיס את עצמו"
date: 2009-11-27 17:07:25
layout: post
categories: 
  - חישוביות
  - תכנות
tags: 
  - הפניה עצמית
  - חישוביות
  - רובי
  - תכנות
---
הפניה עצמית היא אחד מהרעיונות שטבועים עמוק בלב <a href="http://he.wikipedia.org/wiki/%D7%97%D7%99%D7%A9%D7%95%D7%91%D7%99%D7%95%D7%AA">תורת החישוביות</a> ו<a href="http://he.wikipedia.org/wiki/%D7%9C%D7%95%D7%92%D7%99%D7%A7%D7%94_%D7%9E%D7%AA%D7%9E%D7%98%D7%99%D7%AA">הלוגיקה המתמטית</a>. היא מה שעומד בבסיס <a href="http://he.wikipedia.org/wiki/%D7%9E%D7%A9%D7%A4%D7%98%D7%99_%D7%94%D7%90%D7%99_%D7%A9%D7%9C%D7%9E%D7%95%D7%AA_%D7%A9%D7%9C_%D7%92%D7%93%D7%9C">משפטי אי השלמות של גדל</a> והוכחת אי כריעות <a href="http://he.wikipedia.org/wiki/%D7%91%D7%A2%D7%99%D7%99%D7%AA_%D7%94%D7%A2%D7%A6%D7%99%D7%A8%D7%94">בעיית העצירה</a>. זה מעלה את השאלה עד כמה ניתן להכליל את השיטה הזו. האם מודל חישובי - לצורך העניין מכונת טיורינג, אבל אפשר גם תוכנית מחשב - מסוגל להשתמש בייצוג של עצמו באופן ישיר? האם תוכנית יכולה להשתמש ישירות בקוד שלה? ואם נפשט, האם תוכנית מחשב יכולה לעשות דבר מה פשוט כמו הדפסת הקוד שלה עצמה?כיום השאלה הזו נראית די טיפשית. יש <a href="http://en.wikipedia.org/wiki/RepRap_Project">מדפסות תלת ממדיות</a> שיודעות לייצר עותק מושלם של עצמן, אז מהי תוכנית מחשב בהשוואה לכך? אך בזמן שתורת החישוביות הייתה עוד צעירה והתוצאה הזו הוכחה לראשונה, עוד לא היו דברים כאלו. הבה ננסה לשכוח שניה ממה שאנחנו יודעים ולחשוב מה הבעיה העקרונית כאן. איך גורמים לתוכנית מחשב להדפיס את הקוד של עצמה? כמובן, אפשר לבחור בגישה ה"רמאית" ולהגיד "התוכנית תפתח את הקובץ שבו שמור הקוד שלה ותדפיס אותו", אלא שאנחנו לא רוצים להסתמך על עזרים חיצוניים שכאלו, ולכן אנחנו מתמקדים בשאלה הקונקרטית על <a href="http://he.wikipedia.org/wiki/%D7%9E%D7%9B%D7%95%D7%A0%D7%AA_%D7%98%D7%99%D7%95%D7%A8%D7%99%D7%A0%D7%92">מכונת טיורינג</a>, שלא מסוגלת לעשות תעלולים שכאלו. אבל באותה מידה ניתן לשאול האם ניתן לכתוב תוכנית מחשב שאיכשהו מסוגלת להדפיס את הקוד שלה עצמה בלי גישה לקבצים ובלי שום דבר דומה (כשה"קופסה השחורה" היחידה שבה היא פונקצית ההדפסה). תוכניות מחשב שכאלו, שמדפיסות את עצמן, נקראות באופן כללי <a href="http://en.wikipedia.org/wiki/Quine_%28computing%29">quine</a> (על שם לוגיקאי אמריקאי שחיבב מאוד הפניות עצמיות).

אם תנסו לכתוב תוכנית שכזו תגלו שזו משימה מעט טריקית. אתמקד בכתיבה בשפת התכנות <a href="http://he.wikipedia.org/wiki/Ruby">רובי</a>, שבה הכל יוצא "נקי" יחסית; פונקצית ההדפסה הסטנדרטית בשפה זו היא print. אם כן, נניח שאני רוצה לכתוב תוכנית שמדפיסה את עצמה ואני נוקט בגישה נאיבית, אז התוכנית שלי תהיה מהצורה "..." print, כאשר שלוש הנקודות בתוך המרכאות מייצגות את מה שאני רוצה להדפיס - במקרה זה, קוד התוכנית עצמה. הקוד של התוכנית מתחיל ב-print ולכן התוכנית תהיה חייבת להיות מהצורה ""..." print "print, אלא שכעת <strong>שיניתי</strong> את קוד התוכנית, ולכן מה שמקבלת פקודת ה-print חייב לגדול שוב, ושוב, ושוב - ולעולם לא אצא מזה. כלומר, הגישה הנאיבית נכשלת כשלון חרוץ. למי שעדיין לא הבין מה לעזאזל השתבש - פשוט נסו לכתוב את התוכנית בעצמם, זה ייתן מייד את התחושה (אין צורך לדעת לתכנת - מספיק להכיר את פקודת print ותו לא).

מכונות טיורינג סובלות מאותה הבעיה. כל מכונת טיורינג ניתן לקודד בתור מחרוזת, אבל אם ננסה לגרום למכונה לכתוב את המחרוזת הזו על הסרט שלה, הדרך הנאיבית לעשות זאת תכלול הרחבה מהותית של הקידוד של המכונה - ולכן גם שינוי של המחרוזת שמייצגת אותה. אנחנו חייבים לנקוט פה בגישה עקיפה לפני שיהיה לנו את קוד התוכנית "ביד". התעלול שבו נשתמש הוא פשוט ומקסים, וגם כללי מאוד באופיו - ניתן להשתמש באותו רעיון כדי לכתוב בקלות תוכנית מחשב פרקטית שמדפיסה את הקוד של עצמה.

תזכורת קצרצרה למהי מכונת טיורינג - תחשבו עליה כעל מחשב פרימיטיבי שבמקום זכרון יש לו "סרט" שניתן לכתיבה וקריאה. זה בערך כל מה שצריך לדעת עליהן בהקשר הנוכחי. בתוכניות "אמיתיות" את הסרט הזה מחליפים משתנים.

הרעיון הוא לבנות מכונה שמורכבת משתי "תת מכונות", {::nomarkdown}\( A,B\){:/nomarkdown}, כך ש-{::nomarkdown}\( A\){:/nomarkdown} עושה משהו ואז עוצרת, והשליטה עוברת ל-{::nomarkdown}\( B\){:/nomarkdown} שגם כן עושה משהו ועוצרת, ואחרי שהיא עוצרת על הסרט יהיה כתוב הקידוד של {::nomarkdown}\( A\){:/nomarkdown} ולאחר מכן הקידוד של {::nomarkdown}\( B\){:/nomarkdown}, מה שאסמן בתור {::nomarkdown}\( \left\langle AB\right\rangle \){:/nomarkdown}. על פניו אני קצת מרמה כאן טכנית - בהגדרות מקובלות של קידודי מכונות טיורינג לא מרשים "פירוק" כזה של מכונה לשתי תת מכונות. אלא שאין בעיה עם הגדרה שכן מרשה "פירוק" שכזה; וכפי שנראה בהמשך, ההנחה אפילו לא הכרחית, רק מפשטת את ההבנה של הבניה.

אם כן, מה {::nomarkdown}\( A\){:/nomarkdown} תעשה? פשוט מאוד - תכתוב את הקידוד של {::nomarkdown}\( B\){:/nomarkdown} (כלומר, {::nomarkdown}\( \left\langle B\right\rangle \){:/nomarkdown}) על הסרט ואז תעצור. אבל רגע, מאיפה {::nomarkdown}\( A\){:/nomarkdown} יודעת מה הקידוד של {::nomarkdown}\( B\){:/nomarkdown}? עדיין לא אמרנו מהי {::nomarkdown}\( B\){:/nomarkdown} בכלל! אם כן, עלינו להגדיר את {::nomarkdown}\( B\){:/nomarkdown} במדוייק, אבל להיות מאוד זהירים כשנעשה זאת; אם {::nomarkdown}\( B\){:/nomarkdown} תהיה תלויה באופן כלשהו ב-{::nomarkdown}\( A\){:/nomarkdown}, תהיה לנו כאן תלות מעגלית (הקוד של {::nomarkdown}\( B\){:/nomarkdown} תלוי ב-{::nomarkdown}\( A\){:/nomarkdown}, אבל מכיוון ש-{::nomarkdown}\( A\){:/nomarkdown} מדפיסה את הקוד של {::nomarkdown}\( B\){:/nomarkdown}, בוודאי שהקוד של {::nomarkdown}\( A\){:/nomarkdown} תלוי ב-{::nomarkdown}\( B\){:/nomarkdown}!). לכן נגדיר את {::nomarkdown}\( B\){:/nomarkdown} בלי לדבר בכלל על {::nomarkdown}\( A\){:/nomarkdown}.

כש-{::nomarkdown}\( B\){:/nomarkdown} "מתעוררת" כתוב קלט כלשהו על הסרט. נקרא לו {::nomarkdown}\( w\){:/nomarkdown}. מה שב-{::nomarkdown}\( B\){:/nomarkdown} תעשה יהיה לבנות קידוד של מכונה שכל ייעודה בחיים הוא לכתוב את {::nomarkdown}\( w\){:/nomarkdown} על הסרט ולעצור. זה רעיון מעט מחוכם, אבל לא קשה במיוחד. נסו לחשוב האם אתם יכולים, בהינתן קלט {::nomarkdown}\( w\){:/nomarkdown} כלשהו, לכתוב תוכנית מחשב שכל מה שהיא עושה הוא לכתוב {::nomarkdown}\( w\){:/nomarkdown} ולעצור; ואם כן, האם אתם מסוגלים לכתוב פונקציה שמקבלת {::nomarkdown}\( w\){:/nomarkdown} כקלט ומוציאה כפלט קוד של תוכנית מחשב שמדפיסה את {::nomarkdown}\( w\){:/nomarkdown}?

אם כן, נסמן ב-{::nomarkdown}\( M_{w}\){:/nomarkdown} מכונת טיורינג שמה שהיא עושה הוא לכתוב {::nomarkdown}\( w\){:/nomarkdown} על הסרט ולעצור. אז מה ש-{::nomarkdown}\( B\){:/nomarkdown} עושה הוא לבנות את {::nomarkdown}\( \left\langle M_{w}\right\rangle \){:/nomarkdown} ולכתוב אותו ליד הקלט {::nomarkdown}\( w\){:/nomarkdown} הקיים, כלומר בסופה של ריצת {::nomarkdown}\( B\){:/nomarkdown} יהיה כתוב על הסרט {::nomarkdown}\( \left\langle M_{w}\right\rangle w\){:/nomarkdown}. כדי להיות עוד יותר מדוייקים נדבר ממש על פונקציה, {::nomarkdown}\( q\){:/nomarkdown}, שמקבלת כקלט {::nomarkdown}\( w\){:/nomarkdown} ומוציאה כפלט קידוד של {::nomarkdown}\( M_{w}\){:/nomarkdown} ספציפית (שהרי יש הרבה מכונות שונות שכותבות {::nomarkdown}\( w\){:/nomarkdown} על הסרט ועוצרות).

תיארנו את {::nomarkdown}\( B\){:/nomarkdown} בלי להזדקק ל-{::nomarkdown}\( A\){:/nomarkdown}, ולכן אין בעיה לכתוב מכונה {::nomarkdown}\( A\){:/nomarkdown} שכל מה שהיא עושה בחיים הוא לכתוב {::nomarkdown}\( \left\langle B\right\rangle \){:/nomarkdown} על הסרט ולעצור. כאן מגיע הפאנץ': אפשר בתור {::nomarkdown}\( A\){:/nomarkdown} לבחור את המכונה שהקידוד שלה הוא {::nomarkdown}\( q\left(\left\langle B\right\rangle \right)=\left\langle M_{\left\langle B\right\rangle }\right\rangle\){:/nomarkdown}! כלומר, את המכונה שאת הקידוד שלה הפונקציה {::nomarkdown}\( q\){:/nomarkdown} מחזירה. האם אתם כבר רואים לאן הולכים מכאן?

אז מה ש-{::nomarkdown}\( A\){:/nomarkdown} עושה הוא לכתוב {::nomarkdown}\( \left\langle B\right\rangle \){:/nomarkdown} על הסרט ולעצור. אז {::nomarkdown}\( B\){:/nomarkdown} "מתעוררת", רואה קלט {::nomarkdown}\( w=\left\langle B\right\rangle \){:/nomarkdown} ({::nomarkdown}\( w\){:/nomarkdown} הוא הקידוד של {::nomarkdown}\( B\){:/nomarkdown}, אך {::nomarkdown}\( B\){:/nomarkdown} לא "יודעת" זאת), ומחשבת את {::nomarkdown}\( q\left(\left\langle B\right\rangle \right)=M_{\left\langle B\right\rangle }=\left\langle A\right\rangle \){:/nomarkdown}. לסיום היא כותבת את הפלט הזה משמאל ל-{::nomarkdown}\( w\){:/nomarkdown} שהיא קיבלה, כלומר בסיום ריצת {::nomarkdown}\( B\){:/nomarkdown} כתוב על הסרט {::nomarkdown}\( \left\langle AB\right\rangle \){:/nomarkdown}, בדיוק כפי שרצינו. תעלול פשוט, אך מבריק.

כעת אפשר להסביר מדוע ההנחה שהקידוד של המכונה מורכב קודם כל מהקידוד של {::nomarkdown}\( A\){:/nomarkdown} ולאחר מכן מהקידוד של {::nomarkdown}\( B\){:/nomarkdown} היא לגיטימית - כי מה שקורה ל-{::nomarkdown}\( B\){:/nomarkdown} בסופו של דבר היא שהיא מחזיקה אצלה הן את הקידוד של {::nomarkdown}\( A\){:/nomarkdown} (בתור ה-{::nomarkdown}\( q\left(w\right)\){:/nomarkdown} והן את הקידוד של {::nomarkdown}\( B\){:/nomarkdown} (בתור ה-{::nomarkdown}\( w\){:/nomarkdown}) והיא יכולה לעשות איתם מה שמתחשק לה. אנחנו ביקשנו ממנה לרשום אותם האחד אחרי השני, אבל אם היה צורך להשתמש בהם באופן מחוכם יותר, {::nomarkdown}\( B\){:/nomarkdown} הייתה יכולה לעשות גם את זה. בעצם כל מה שאנחנו מניחים הוא שאם יש לנו מכונה שמורכבת משתי תת-מכונות {::nomarkdown}\( A,B\){:/nomarkdown} ויש לנו את הקוד של אותן שתי תתי-מכונות, אז אפשר לבנות את הקוד של המכונה ה"מורכבת" - וזה דבר שאני מניח שתסכימו איתי שהוא אפשרי.

עכשיו אפשר לקחת את הבניה הזו צעד אחד קדימה ולבנות מכונה שיודעת להשתמש בקוד של עצמה כמה שתרצה. לצורך העניין, נחשוב על מכונה {::nomarkdown}\( T\){:/nomarkdown} שמקבלת שני פרמטרים, {::nomarkdown}\( \left\langle M\right\rangle ,w\){:/nomarkdown}, כאשר {::nomarkdown}\( w\){:/nomarkdown} הוא הקלט ה"רגיל" של המכונה ואילו {::nomarkdown}\( \left\langle M\right\rangle \){:/nomarkdown} הוא קידוד של מכונה כלשהי, ו-{::nomarkdown}\( T\){:/nomarkdown} פועלת כפונקציה של שני הקלטים הללו. מה שאנחנו רוצים להראות הוא קיום של מכונה {::nomarkdown}\( R\){:/nomarkdown} כך ש-{::nomarkdown}\( R\left(w\right)=T\left(\left\langle R\right\rangle ,w\right)\){:/nomarkdown}. כלומר, {::nomarkdown}\( R\){:/nomarkdown} מתנהגת כמו {::nomarkdown}\( T\){:/nomarkdown} בכל הנוגע לקלט {::nomarkdown}\( w\){:/nomarkdown}, ועבור הקוד {::nomarkdown}\( \left\langle M\right\rangle \){:/nomarkdown} שלה עצמה. מבלבל? אז חשבו על תוכנית מחשב שמקבלת קלט מהמשתמש ועוד משתנה של "הקוד שלי"; אנחנו רוצים לגרום לתוכנית לרוץ כך שהמשתנה "הקוד שלי" יכיל את הערך הנכון.

אין כאן שום גאונות חדשה, אלא רק הרחבה פשוטה של הבניה שכבר ראינו. נוסיף את הקוד של המכונה {::nomarkdown}\( T\){:/nomarkdown} למשחק, כך שהיא תתחיל לפעול אחרי {::nomarkdown}\( B\){:/nomarkdown}, ולכן הקוד של המכונה ה"משולשת" יהיה {::nomarkdown}\( \left\langle ABT\right\rangle \){:/nomarkdown}. מה ש-{::nomarkdown}\( A\){:/nomarkdown} יעשה הפעם יהיה לכתוב {::nomarkdown}\( \left\langle BT\right\rangle \){:/nomarkdown} על הסרט, ואילו {::nomarkdown}\( B\){:/nomarkdown} יעשה בדיוק את אותו הדבר כמו קודם ויחשב את {::nomarkdown}\( \left\langle A\right\rangle \){:/nomarkdown}. כש-{::nomarkdown}\( B\){:/nomarkdown} יסיים את ריצתו על הסרט יהיה כתוב {::nomarkdown}\( \left\langle ABT\right\rangle \){:/nomarkdown} וזה בדיוק מה ש-{::nomarkdown}\( T\){:/nomarkdown} תראה כאשר היא תתחיל את ריצתה (ואיפה הקלט של {::nomarkdown}\( T\){:/nomarkdown} נמצא? אפשר להניח שכבר {::nomarkdown}\( A\){:/nomarkdown} שמרה אותו בצד - זה לא גורר שינוי משמעותי בהגדרות שלנו).

ועכשיו - לקוד בפועל, בשפת רובי, שמשתמש בדיוק ברעיונות שתיארתי כאן:
<pre dir="ltr">b = "\n\ndef q(w)\n\t\"b = \#{w.inspect}\"\nend\n\nprint q(b) + b"

def q(w)
    "b = #{w.inspect}"
end

print q(b) + b
</pre>
<p dir="rtl">לא צריך לדעת יותר מדי רובי כדי להבין מה קורה כאן. הדבר המחוכם ביותר הוא האופן שבו אני מתאר מחרוזת: בתוך מחרוזת אני יכול לכתוב ביטויים כמו n\ ו-t\ שמתפרשים בתור התווים המתאימים לירידת שורה או לטאבים. מה שכתוב בתוך השורה הראשונה בקובץ הוא פשוט כל יתר השורות בקובץ. כל זה מושם בתוך המשתנה b; חשבו על זה בתור הריצה של {::nomarkdown}\( A\){:/nomarkdown}, שכותבת את המחרוזת שמתארת את {::nomarkdown}\( B\){:/nomarkdown} לא על ה"סרט" (כי אין סרט) אלא לתוך המשתנה b.</p>
החל מהשורה השניה מגיע התיאור של {::nomarkdown}\( B\){:/nomarkdown}. ראשית, הפונקציה {::nomarkdown}\( q\){:/nomarkdown} שמקבלת {::nomarkdown}\( w\){:/nomarkdown} ופולטת תוכנית שמה שהיא עושה בחיים הוא להדפיס את {::nomarkdown}\( w\){:/nomarkdown}. האופן שבו היא עושה את זה הוא המקום העיקרי שבו צריך להבין טיפה רובי. ראשית, ברובי לא חייבים לכתוב במפורש return כדי להחזיר ערך מפונקציה; הערך האחרון שמחושב בתוך פונקציה הוא אוטומטית ערך ההחזרה שלה. לכן הפונקציה בת השורה הבודדת הזו כוללת רק מחרוזת, והמחרוזת הזו אוטומטית תהיה הפלט של הפונקציה.

שנית, כשאני כותב מחרוזת בשפת רובי אני יכול "להשתיל" בתוך המחרוזת ערכים של ביטויים. התחביר עבור "השתלה" כזו הוא כתיבה של סולמית (#) ואז את הביטוי שאני רוצה להשתיל במחרוזת כשהוא בתוך סוגריים מסולסלים. במקרה שלנו אני משתיל את הערך של w, אבל לא לפני שאני מבצע שינוי כלשהו לערך הזה באמצעות הפעלת הפונקציה inspect עליו. הפונקציה הזו, כשהיא מופעלת על מחרוזת, מחזירה גרסה חדשה של המחרוזת שכתובה בצורה יותר מפורשת. למשל, אם במחרוזת המקורית היה תו של ירידת שורה (ולכן כשהמחרוזת הייתה מודפסת על המסך הייתה מופיעה ירידת שורה) הרי ש-inspect החליפה את התו הזה בזוג תווים, n\; זה מתאים לאופן שבו תיארתי את ירידת השורה בתוך המחרוזת b מלכתחילה. במהלך ריצת התוכנית מה שקורה הוא שראשית המשתנה b מאותחל על ידי לקיחת המחרוזת ששמים לתוכו וביצוע כל מני המרות בה שהופכות זוג רצוף של תווים כמו n\ לתו ירידת שורה; inspect פשוט מבצעת את התהליך הזה בכיוון ההפוך.

לאחר הגדרת {::nomarkdown}\( q\){:/nomarkdown} מגיע יתר הקוד של {::nomarkdown}\( B\){:/nomarkdown}; ראשית היא מחשבת את {::nomarkdown}\( q\){:/nomarkdown} על "תוכן הסרט" הנוכחי (כלומר, על המשתנה b) ומקבלת תוצאה שהיא {::nomarkdown}\( \left\langle A\right\rangle \){:/nomarkdown}; וכעת היא פולטת את השרשור של הפלט הזה עם התוכן של b, בדיוק כמו ש-{::nomarkdown}\( B\){:/nomarkdown} התיאורטית שלי עבדה.

בשביל מה כל זה טוב? ראשית, האפשרות של מכונה לדעת את הקידוד של עצמה מקלה על פתרון בעיות מסויימות בחישוביות (למשל, להראות שבעיה בסגנון "יש לבדוק האם המכונה הבאה היא המכונה בעלת הקידוד המינימלי מבין כל המכונות ששקולות לה" היא בלתי פתירה). שנית, כי זה מגניב. שלישית, כדי לנטרל טענות מגוחכות שלפעמים צצות בדיונים לפיהן מחשבים אינם מסוגלים "להבין" את עצמם עד הסוף, או שאינם מסוגלים "לשכפל את עצמם" (להבדיל מבני אדם שיש להם מנגנון טבעי לכך). מעתה אמרו: מחשבים, בני אדם ומטאטאים - כולנו מסוגלים לשכפל את עצמנו (בכל הנוגע ל"הבנה", זה כבר עניין לדיון אחר בזמן אחר).
