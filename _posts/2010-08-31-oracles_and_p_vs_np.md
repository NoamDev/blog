---
id: 721
title: "כיצד אורקלים מנבאים שקשה להוכיח ש-P שונה מ-NP"
date: 2010-08-31 17:49:12
layout: post
categories: 
  - תורת הסיבוכיות
tags: 
  - אורקלים
  - בעיית P=NP
  - הוכחות יפות
  - טכני
  - לכסון
---
<a href="http://www.gadial.net/2010/08/16/p_vs_np_hard_to_diagonalize/">בפוסט הקודם</a> נפנפתי קצת ידיים על אחת מהסיבות הנפוצות לקושי שבהוכחה ש-{% equation %}\mbox{P}\ne\mbox{NP}{% endequation %}; העובדה שאחד מרעיונות ההוכחה החזקים והיפים שבמתמטיקה ומדעי המחשב, הלכסון שגורם להפניה עצמית, מה שמככב במשפט אי השלמות של גדל ובהוכחת אי כריעותה של בעית העצירה - רעיון זה פשוט לא יכול לעבוד כאשר עוסקים ב-{% equation %}\mbox{P}{% endequation %} וב-{% equation %}\mbox{NP}{% endequation %}. בפוסט הזה אני רוצה להיות יותר טכני ולפרט גם את האופן שבו עושים זאת, אף שאני משער שחלק מהקוראים לא יצליחו לעקוב אחרי ההוכחה עד סופה. אני מניח כאן ידע מוקדם כלשהו בתורת הסיבוכיות - ספציפית, למה אנחנו מתכוונים ב"<a href="http://www.gadial.net/2007/09/23/turing_machine/">מכונת טיורינג</a>", ב"<a href="http://www.gadial.net/2007/12/23/nondeterminism/">מכונת טיורינג אי דטרמיניסטית</a>" וב"שפה" (אוסף של מחרוזת סופיות) - מי שאינו מכיר מושגים אלו כנראה יתקשה לעקוב אחרי ההמשך.

ראשית, תזכורת לגבי שיטת הפעולה שלנו: אנחנו משתמשים במודל החישובי של מכונת טיורינג עם אורקל, שאולי יותר פשוט לחשוב עליה במונחים מעשיים כ"תוכנית מחשב עם פונקצית ספריה חזקה במיוחד". אותה פונקצית ספריה מקבלת כקלט מחרוזת ואומרת עליה "כן"או "לא" בהתאם לשאלה מסויימת וקבועה מראש. למשל, "האם למשוואה הזו יש פתרון בשלמים" על קלט שהוא בעצמו משוואה פולינומית עם מקדמים שלמים. זו נשמעת כמו פונקצית ספריה נחמדה ופשוטה יחסית במבט ראשון; אך למעשה, אפשר להוכיח ש<strong>לא קיימת</strong> פונקציה שכזו בעולם האמיתי. עם זאת, אין מניעה מלשחק ב"נדמה לי" - נניח שפונקציה שכזו עומדת לרשותנו; אילו תוכניות מחשב נוכל לכתוב באמצעותה?

מכיוון שאנחנו עוסקים בענייני יעילות, עוד הנחה שלנו לגבי האורקל היא שהוא פועל באופן מיידי. כך אפשר לקצר את פרק הזמן שדורשים חישובים, על ידי כך ששואלים את האורקל שאלות שחישוב התשובה להן באופן ידני הוא תובעני, והאורקל עונה עליהן תכף ומייד. למשל, אם נתון לנו גרף ואנו מתבקשים למצוא כיסוי בצמתים שלו מגודל מסויים (כיסוי בצמתים הוא אוסף צמתים שכל קשת בגרף נוגעת באחד מהם לפחות) ויש לנו פונקצית ספריה שאומרת תכף ומייד, בהינתן גרף ומספר, האם קיים בגרף כיסוי קודקודים בגודל הדרוש, אז קל מאוד למצוא את הכיסוי: בוחרים צומת, מסלקים אותה ואת כל הקשתות המחוברות אליה מהגרף, ושואלים את הפונקציה האם קיים כעת כיסוי מהגודל שאנו רוצים פחות 1. אם כן, אז משאירים את הצומת שבחרנו בכיסוי, ואחרת "מתקנים" את הגרף ובודקים את הצומת הבא. הסיבה לכך שהאלגוריתם הוא כעת יעיל היא שהחלק ה"כבד" בו הוא הבדיקה האם בגרפים שמתקבלים במהלך ההרצה יש כיסוי קודקודים.

לא הבנתם כלום? מצויין, ההמשך עוד יותר מבלבל.

הטענה {% equation %}\mbox{P}\ne\mbox{NP}{% endequation %} היא בעצם הטענה "מכונות אי-דטרמיניסטיות פולינומיות יכולות לעשות משהו שמכונות דטרמיניסטיות פולינומיות לא יכולות לעשות". מה שאנו רוצים להראות הוא שאם מחזקים את שני המודלים הללו עם אורקל, אז עבור אורקל אחד המכונות כן ישתוו בכוחן, אבל עבור אורקל אחר אפשר יהיה להראות שהן לא שוות בכוחן (כלומר, להוכיח טענה דמויית {% equation %}\mbox{P}\ne\mbox{NP}{% endequation %} אבל על מחלקה אחרת של מכונות). החלק הקל יותר הוא להרחיב את שני המודלים כך שהם כן יהיו שווים בכוחם - פשוט צריך לתת להם אורקל למשהו שהוא <strong>כל כך חזק</strong> עד שההבדלים בכוח של שתי המכונות (אם קיימים כאלו) מתפוגגים ונעלמים. דוגמה לאורקל כזה היא אורקל שבהינתן שלשה {% equation %}\left(M,x,1^{n}\right){% endequation %} של מכונה {% equation %}M{% endequation %}, קלט {% equation %}x{% endequation %} ומספר {% equation %}n{% endequation %} שנתון בבסיס אונרי (למה? מסיבת טכניות - יעילות של אלגוריתמים נמדדת ביחס ל<strong>גודל הייצוג</strong> של קלט, ואם מייצגים מספר שלא בבסיס אונרי אז גודל הייצוג שלו הוא לוגריתמי בגודל של המספר עצמו), אומר האם {% equation %}M{% endequation %} עונה "כן"על {% equation %}x{% endequation %} תוך {% equation %}2^{n}{% endequation %} צעדים.

אורקל לשפה הזו מאפשר למכונה דטרמיניסטית לקבל כל שפה שמכונה אי דטרמיניסטית פולינומית יכולה לקבל: אם {% equation %}M{% endequation %} היא מכונה אי דטרמיניסטית פולינומית ואנו רוצים לדעת אם היא מקבלת את {% equation %}x{% endequation %}, אז נבקש מהאורקל תשובה עבור {% equation %}\left(M^{\prime},x,1^{n}\right){% endequation %} כאשר {% equation %}M^{\prime}{% endequation %} היא מכונה דטרמיניסטית שמבצעת חיפוש ממצה על כל אפשרויות הריצה של {% equation %}M{% endequation %} על {% equation %}x{% endequation %}; חיפוש ממצה שכזה לוקח זמן שהוא אקספוננציאלי באורך של {% equation %}x{% endequation %}, ולכן בהתאם בוחרים את {% equation %}n{% endequation %} להיות בערך הגודל של {% equation %}x{% endequation %} (מסיבות טכניות אולי יהיה צורך בקצת יותר).

אלא מה? כל מה שזה מראה הוא ש-{% equation %}\mbox{NP}\subseteq\mbox{P}^{L}{% endequation %} (כש-{% equation %}L{% endequation %} היא השפה של האורקל שלנו). אנחנו רוצים להראות ש-{% equation %}\mbox{NP}^{L}\subseteq\mbox{P}^{L}{% endequation %} - כלומר, שגם אחרי שמחזקים את המכונות האי-דטרמיניסטיות עם האורקל של {% equation %}L{% endequation %}, עדיין מכונות דטרמיניסטיות מצליחות לעשות את אותם הדברים. אלא שזו לא בעיה אמיתית, כי אותה מכונה {% equation %}M^{\prime}{% endequation %} שמסמלצת את המכונה האי דטרמיניסטית {% equation %}M{% endequation %} יכולה לסמלץ גם קריאות לאורקל - כלומר, לבצע בעצמה את החישוב שהאורקל מבצע, על איזה קלט שלא יהיה ש-{% equation %}M{% endequation %} תזרוק עליו, ולענות במקום האורקל. זה לא יגדיל את זמן הריצה של {% equation %}M^{\prime}{% endequation %} בצורה משמעותית (כאן צריך לבוא נימוק טכני מפורט יותר, אך אמנע ממנו - זה תרגיל טוב לחשוב מה בדיוק צריך לומר ואיזה עוד סיבוכים עשויים לצוץ; למשל, האם {% equation %}M{% endequation %} יכולה לקרוא לאורקל עם קלטים שבהם {% equation %}1^{n}{% endequation %} הוא "גדול מדי"?).

יפה. אם כן, עבור האורקל החזק הזה, מכונת דטרמיניסטיות ואי דטרמיניסטיות משתוות. החלק הקשה יותר הוא לחשוב על אורקל שעבורו לא רק שהן לא משתוות, אלא שאפילו ניתן להוכיח זאת. במילים אחרות, אנחנו רוצים להוכיח משפט ש<strong>דומה</strong> למשפט {% equation %}\mbox{P}\ne\mbox{NP}{% endequation %}, וצריכים לחפש את ההקלה המתאימה שתאפשר לנו להוכיח משפט שכזה.

בואו ניקח שפה {% equation %}L{% endequation %} כלשהי. לשפה הזו ניתן להתאים שפה אחרת, {% equation %}U_{L}{% endequation %}, של אורכי המילים ב-{% equation %}L{% endequation %} (שוב, בייצוג אונרי). במילים אחרות, בהינתן מספר {% equation %}1^{n}{% endequation %} השאלה היא האם קיימת מילה מאורך {% equation %}n{% endequation %} בשפה {% equation %}L{% endequation %}. זו שאלה שקל מאוד להכריע אם אנחנו מכונה אי דטרמיניסטית עם אורקל לשפה {% equation %}L{% endequation %}: בהינתן {% equation %}n{% endequation %} פשוט מנחשים מילה מאורך {% equation %}n{% endequation %}, שואלים את האורקל האם היא שייכת ל-{% equation %}L{% endequation %} ואם כן - מקבלים. אם כן, לכל שפה {% equation %}L{% endequation %} מתקיים ש-{% equation %}U_{L}\in\mbox{NP}^{L}{% endequation %}. מצד שני, מכונה דטרמיניסטית פולינומית לא יכולה לנקוט בגישה הזו - אם נותנים לה {% equation %}n{% endequation %}, לבדוק את כל המילים מאורך {% equation %}n{% endequation %} ייקח לה יותר מדי זמן כי יש {% equation %}2^{n}{% endequation %} כאלו. זה נותן פתח לתקווה לכך שיתקיים {% equation %}U_{L}\notin\mbox{P}^{L}{% endequation %} עבור שפה {% equation %}L{% endequation %} שתהונדס בצורה מתאימה. כמו שכל מי שמכיר קצת את תורת הסיבוכיות יודע, להוכיח שמשהו הוא קשה זה עניין קשה, והבניה של {% equation %}L{% endequation %} היא יצירתית למדי ומסתמכת - איך לא - על לכסון.

הבה ונמספר את כל מכונות הטיורינג הדטרמיניסטיות עם אורקל הקיימות - {% equation %}M_{1},M_{2},M_{3},\dots{% endequation %}. מה שנעשה יהיה לבנות את {% equation %}L{% endequation %} בשלבים, כשבשלב ה-{% equation %}i{% endequation %} ננסה לגרום למכונה {% equation %}M_{i}{% endequation %} לטעות בתשובה שהיא אמורה לתת על מילה כלשהי מ-{% equation %}L{% endequation %}.

נתחיל מכך ש-{% equation %}L{% endequation %} ריקה. כפי שניתן יהיה לראות מהבניה, בכל שלב תישמר התכונה שב-{% equation %}L{% endequation %} רק מספר סופי של מילים. בסיבוב ה-{% equation %}i{% endequation %} בבניה, ניקח מספר {% equation %}n{% endequation %} שגדול ממספר הסיבוב הנוכחי {% equation %}i{% endequation %} ומאורך כל המילים שעד כה הוכנסו ל-{% equation %}n{% endequation %}. המטרה שלנו - לגרום ל-{% equation %}M_{i}{% endequation %} "לטעות"בתשובה שהיא מחזירה על {% equation %}1^{n}{% endequation %}. בדרך כלל מה שהיינו עושים הוא לומר "נריץ את {% equation %}M_{i}{% endequation %} על {% equation %}1^{n}{% endequation %}; אם {% equation %}M_{i}{% endequation %} דחתה, נוסיף את {% equation %}1^{n}{% endequation %} ל-{% equation %}L{% endequation %}; ואם היא קיבלה לא נוסיף אותו". זה גם הרעיון כאן אבל יש לנו סיבוך - {% equation %}M_{i}{% endequation %} היא מכונה עם גישה לאורקל. ולא סתם אורקל - אורקל לשפה {% equation %}L{% endequation %} שאותה אנו בונים. כלומר, {% equation %}M_{i}{% endequation %}, במהלך ריצתה על {% equation %}1^{n}{% endequation %}, עשויה לשאול את האורקל על מילים שבכלל עוד לא החלטנו אם הן כן או לא ב-{% equation %}L{% endequation %}. עם זאת, זו לא בעיה של ממש - מה שנעשה הוא להריץ את {% equation %}M_{i}{% endequation %} על {% equation %}1^{n}{% endequation %}, בכל פעם שבה {% equation %}M_{i}{% endequation %} תשאל את האורקל על מילה שכבר החלטנו אם היא שייכת ל-{% equation %}L{% endequation %} או לא נענה בהתאם לבחירה שביצענו; ואם {% equation %}M_{i}{% endequation %} שואלת על מילה שאיננה מהמילים שכבר החלטנו עליהן, נענה (בתור האורקל) שהמילה איננה ב-{% equation %}L{% endequation %} ונסמן לנו את זה בצד, למקרה שגם בעתיד ישאלו על המילה הזו.

ה"סכנה" שבדרך הפעולה שלנו היא ש-{% equation %}M_{i}{% endequation %} עלולה לשאול את האורקל שאלה על <strong>כל</strong> המילים מאורך {% equation %}n{% endequation %}. זה אולי נשמע מוזר קצת בהתחלה - לא אמרנו שנדרש זמן אקספוננציאלי כדי לעשות זאת? אבל זו הנקודה העדינה המרכזית בהוכחות מהסוג הזה - אנחנו תוקפים את {% equation %}M_{i}{% endequation %} עבור {% equation %}n{% endequation %} <strong>ספציפי</strong>, בעוד שדיבורים על זמן ריצה אקספוננציאלי הם רלוונטיים רק כשמדברים על ההתנהגות <strong>האסימפטוטית</strong> של {% equation %}M_{i}{% endequation %}, כלומר על האופן שבו {% equation %}M_{i}{% endequation %} מתנהגת על אינסוף קלטים. ייתכן שעל כל הקלטים עד גודל זיליארד {% equation %}M_{i}{% endequation %} דורשת פרק זמן גדול עד להדהים, ורק לאחר מכן היא "נרגעת" ורצה זמן פולינומי - גם אז היא עדיין תיחשב פולינומית. מכאן שהסכנה ש-{% equation %}M_{i}{% endequation %} תבדוק את כל המילים מאורך {% equation %}n{% endequation %} היא מוחשית מאוד, ונדרשים פיתולים טכניים כדי להתגבר עליה. במקרה שלנו, פשוט נגביל את זמן הריצה של {% equation %}M_{i}{% endequation %} - אם היא רצה יותר מ-{% equation %}\frac{2^{n}}{10}{% endequation %} צעדים, פשוט נשכח ממנה ונעבור למכונה הבאה. עוד מעט אסביר איך אפשר להבטיח שזה לא יגרום נזק להוכחה שלנו.

אם {% equation %}M_{i}{% endequation %} עצרה על {% equation %}1^{n}{% endequation %} תוך לכל היותר {% equation %}\frac{2^{n}}{10}{% endequation %} צעדים, אז <strong>בהכרח</strong> היא לא הספיקה לשאול את האורקל על כל הקלטים מאורך {% equation %}n{% endequation %}. אם {% equation %}M_{i}{% endequation %} קיבלה, הרי שהיא טוענת שב-{% equation %}L{% endequation %} יש מילה מאורך {% equation %}n{% endequation %}, אולם כרגע בבניה שלנו אין מילה כזו. זכרו - {% equation %}n{% endequation %} היה מספר שגדול מאורך כל המילים שהחלטנו אם הן ב-{% equation %}L{% endequation %} או לא בתחילת הסיבוב {% equation %}i{% endequation %}, ובמהלך הסיבוב עצמו לא הוספנו אף מילה ל-{% equation %}L{% endequation %} - בכל פעם ש-{% equation %}M_{i}{% endequation %} שאלה את האורקל על מילה חדשה, אמרנו לה שאותה מילה אינה ב-{% equation %}L{% endequation %}. מכאן ש-{% equation %}M{% endequation %} טועה. אם לעומת זאת {% equation %}M{% endequation %} דחתה את {% equation %}1^{n}{% endequation %}, כלומר טענה שאין ב-{% equation %}L{% endequation %} מילה מאורך {% equation %}n{% endequation %}, פשוט נוסיף ל-{% equation %}L{% endequation %} מילה כלשהי ש-{% equation %}M_{i}{% endequation %} לא הספיקה לשאול את האורקל עליה (כאמור, יש כזו). ושוב, {% equation %}M{% endequation %} טועה, והגדלנו את {% equation %}L{% endequation %} במילה אחת בסך הכל, כך ש-{% equation %}L{% endequation %} עדיין סופית.

{% equation %}L{% endequation %} "האמיתית" היא התוצר הסופי של כל שלבי הבניה הללו. פורמלית, אם {% equation %}L_{i}{% endequation %} מסמנת את השפה שהתקבלה אחרי השלב ה-{% equation %}i{% endequation %}, אז {% equation %}L=\bigcup L_{i}{% endequation %}. מבחינה מתמטית זו בניה חוקית לחלוטין והשפה מוגדרת היטב, אבל היא עשויה להיות מבלבלת למדי למי שלא רגיל לדברים כאלו. עכשיו צריך להשתכנע ש-{% equation %}U_{L}{% endequation %} אכן אינה מתקבלת על ידי אף מכונה דטרמיניסטית פולינומית.

ובכן, נניח ש-{% equation %}M{% endequation %} היא מכונה דטרמיניסטית פולינומית שכזו, ושזמן הריצה שלה חסום על ידי הפולינום {% equation %}p\left(n\right){% endequation %}. אז קיים {% equation %}n{% endequation %} גדול מספיק כך ש-{% equation %}\frac{2^{n}}{10}&gt;p\left(n\right){% endequation %}. במילים אחרות, אם ננסה "לתקוף" את {% equation %}M{% endequation %} עבור המילה {% equation %}1^{n}{% endequation %} או מילים ארוכות יותר, ננצח. איך אפשר להבטיח שאכן נתקוף את {% equation %}M{% endequation %} מתישהו עם מילה ארוכה שכזו? תעלול פשוט - במקום לתקוף את {% equation %}M{% endequation %} פעם אחת, נתקוף אותה <strong>אינסוף</strong> פעמים. כלומר, המניה {% equation %}M_{1},M_{2},M_{3},\dots{% endequation %} לא תכיל כל מכונה רק פעם אחת, אלא מספר אינסופי של פעמים. קל להנדס מניה שכזו - למשל, הביטו בסדרה {% equation %}1,1,2,1,2,3,1,2,3,4,\dots{% endequation %} שבה מובטח שכל מספר טבעי יופיע מספר אינסופי של פעמים. מכאן שאנו נתקלים ב-{% equation %}M{% endequation %} בתור {% equation %}M_{i}{% endequation %} עבור אינסוף ערכים שונים של {% equation %}i{% endequation %}, ומכיוון שדרשנו שה-{% equation %}n{% endequation %} שאותו בוחרים בסיבוב ה-{% equation %}i{% endequation %} יהיה בפרט גדול מ-{% equation %}i{% endequation %}, מובטח לנו שהחל מסיבוב מסויים ה-{% equation %}n{% endequation %} שאיתו נתקוף את {% equation %}M{% endequation %} אכן יביס אותה.

אחרי שמבינים את כל הפרטים הללו, ההוכחה הזו אינה כה מסובכת - ואכן, רוב הרעיונות בה הם סטנדרטיים לגמרי בתורת הסיבוכיות. עיקר היופי בה הוא בבניה ההדרגתית, הכמו-אלגוריתמית של {% equation %}L{% endequation %} ובאופן המחוכם שבו היא מצליחה להתגבר על סכנת ההפניה העצמית שנוצרת משאלות האורקל של {% equation %}M_{i}{% endequation %}. אבל הדבר היפה באמת בהוכחה הזו הוא בכך שההוכחה לכך שלכסון <strong>לא</strong> מסוגל לעשות דבר מה היא עצמה הוכחה בלכסון!
