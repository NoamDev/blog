---
id: 1002
title: "משפט ברינגטון - ההוכחה"
date: 2011-01-24 20:17:33
layout: post
categories: 
  - תורת הסיבוכיות
tags: 
  - גם טכני זה כיף!
  - הוכחות יפות
  - מאיפה זה הגיע?
  - משפט ברינגטון
  - פרוייקט "תוצאות מפתיעות בסיבוכיות"
  - תורת הסיבוכיות
---
<a href="http://www.gadial.net/?p=995">בפוסטים הקודמים</a> הסברתי מה אומר משפט ברינגטון, וכעת אפשר להגיע לחלק היפה ביותר בכל העניין - ההוכחה שלו. האתגר הוא להראות שכל פונקציה שנמצאת ב-{::nomarkdown}\( \mbox{NC}^{1}\){:/nomarkdown}, כלומר ניתנת לחישוב על ידי מעגל בוליאני מגודל פולינומי ועומק לוגריתמי, ניתנת לחישוב על ידי תוכנית מתפצלת מאורך פולינומי וגודל קבוע, ואפילו קבוע "מאוד" - 5, תמיד. הכיוון ההפוך גם נכון - אם פונקציה ניתנת לחישוב על ידי תוכנית מתפצלת שכזו, אז היא ב-{::nomarkdown}\( \mbox{NC}^{1}\){:/nomarkdown}, ולכן אנחנו משיגים תוצאה סגורה ויפה - מחלקת הפונקציות שניתנות לחישוב על ידי תוכניות מתפצלות מרוחב קבוע היא בדיוק {::nomarkdown}\( \mbox{NC}^{1}\){:/nomarkdown} - מחלקה גדולה בהרבה ממה שניתן היה לצפות. ההוכחה היא יפה מאוד לטעמי, אבל לא טריוויאלית, ומי שאינו משופשף קצת בהוכחות כאלו בהחלט עלול לאבד אותי.

בתור חימום בואו נראה את הכיוון הקל. הוא אמנם קל, אבל גם כאן בוודאי אאבד קוראים - מי שיישבר, אני מציע לו לפחות לקפוץ לתחילת ההוכחה של הכיוון השני כדי לראות את "הרעיון הגדול" של ההוכחה.

אם כן, אם יש לנו תוכנית מתפצלת מרוחב {::nomarkdown}\( d\){:/nomarkdown} כלשהו ומאורך {::nomarkdown}\( t\){:/nomarkdown}, איך בונים מעגל בוליאני שמסמלץ אותה? הרעיון הוא לבנות נוסחה שאומרת "בגרף הזה והזה יש מסלול מהצומת {::nomarkdown}\( a\){:/nomarkdown} לצומת {::nomarkdown}\( b\){:/nomarkdown}" - נסמן נוסחה כזו ב-{::nomarkdown}\( R\left(a,b\right)\){:/nomarkdown}. הגרף שעליו מדובר יהיה תמיד הגרף שמתקבל מהתוכנית המתפצלת אחרי שמציבים במשתנים ערכים - אנחנו נראה תכף איך זה בא לידי ביטוי.

את {::nomarkdown}\( R\left(a,b\right)\){:/nomarkdown} קל לבנות במקרה שבו {::nomarkdown}\( a,b\){:/nomarkdown} הם צמתים משכבות סמוכות (הגרף של התוכנית המתפצלת הוא גרף שכבות, זוכרים?). במקרה כזה יש מסלול מ-{::nomarkdown}\( a\){:/nomarkdown} אל {::nomarkdown}\( b\){:/nomarkdown} אם ורק אם יש קשת מ-{::nomarkdown}\( a\){:/nomarkdown} ל-{::nomarkdown}\( b\){:/nomarkdown}, מה שמצריך שני דברים: ראשית, שבתוכנית המתפצלת המקורית הייתה קשת מ-{::nomarkdown}\( a\){:/nomarkdown} אל {::nomarkdown}\( b\){:/nomarkdown} (שמסומנת או ב-0 או ב-1) ושנית, שהיא "שרדה" את ההשמה. אם הצומת {::nomarkdown}\( a\){:/nomarkdown} מסומן במשתנה {::nomarkdown}\( x_{i}\){:/nomarkdown}, אז נגדיר את הנוסחה באופן הבא: {::nomarkdown}\( R\left(a,b\right)=x_{i}\){:/nomarkdown} אם הקשת {::nomarkdown}\( a\to b\){:/nomarkdown} מסומנת ב-1, {::nomarkdown}\( R\left(a,b\right)=\neg x_{i}\){:/nomarkdown} אם הקשת {::nomarkdown}\( a\to b\){:/nomarkdown} מסומנת ב-0, ו-{::nomarkdown}\( R\left(a,b\right)=0\){:/nomarkdown} אם אין קשת.

נוסחה כללית עבור {::nomarkdown}\( a,b\){:/nomarkdown} שיכולים להיות מרוחקים זה מזה יותר מאשר שכבה אחת נבנית ברקורסיה. הטיעון הבסיסי הוא זה: אם המרחק בין {::nomarkdown}\( a\){:/nomarkdown} ל-{::nomarkdown}\( b\){:/nomarkdown} גדול מ-1 אבל יש מסלול ביניהם, אז יש צומת {::nomarkdown}\( c\){:/nomarkdown} שנמצא "באמצע הדרך" ביניהם. במילים אחרות, יש מסלול מ-{::nomarkdown}\( a\){:/nomarkdown} אל {::nomarkdown}\( b\){:/nomarkdown} אם ורק אם <strong>קיים</strong> צומת {::nomarkdown}\( c\){:/nomarkdown} בשכבה שהיא באמצע הדרך בין {::nomarkdown}\( a\){:/nomarkdown} ל-{::nomarkdown}\( b\){:/nomarkdown}, כך ש-{::nomarkdown}\( R\left(a,c\right)\){:/nomarkdown} וגם {::nomarkdown}\( R\left(c,b\right)\){:/nomarkdown}. לאלו מכם שמכירים קצת סיבוכיות כל זה ודאי מזכיר את ההוכחה של משפט סביץ', שמשתמש בתעלול דומה.

מה לכאורה הבעיה? שבשכבת הביניים בין {::nomarkdown}\( a\){:/nomarkdown} ל-{::nomarkdown}\( b\){:/nomarkdown} יכולים להיות המון {::nomarkdown}\( c\){:/nomarkdown}-ים ואז הנוסחה שלנו, שצריכה לקחת בחשבון את כולם, תהיה ענקית. אלא שאנחנו מתעסקים כאן עם תוכניות שהרוחב שלהם <strong>חסום</strong>, ולכן יש רק {::nomarkdown}\( d\){:/nomarkdown} צמתים {::nomarkdown}\( c\){:/nomarkdown} אפשריים לכל היותר, מה שאומר שהנוסחה שלנו לא תהיה עד כדי כך גדולה. נכתוב אותה במפורש: {::nomarkdown}\( R\left(a,b\right)=\bigvee_{c}\left(R\left(a,c\right)\wedge R\left(c,b\right)\right)\){:/nomarkdown}.

נותר להבין מהו גודל הנוסחה. נניח שהמרחק בין {::nomarkdown}\( a\){:/nomarkdown} ו-{::nomarkdown}\( b\){:/nomarkdown} הוא {::nomarkdown}\( k\){:/nomarkdown}. נסמן ב-{::nomarkdown}\( S\left(k\right)\){:/nomarkdown} את הגודל המקסימלי של נוסחה שנבנית בשיטה שלנו עבור צמתים במרחק {::nomarkdown}\( k\){:/nomarkdown}. אז ראינו כי {::nomarkdown}\( S\left(1\right)\){:/nomarkdown} הוא קבוע קטן, וכי {::nomarkdown}\( S\left(k\right)\le2d\cdot S\left(\frac{k}{2}\right)\){:/nomarkdown} (כי בנוסחה עבור {::nomarkdown}\( R\left(a,b\right)\){:/nomarkdown} שכתבנו, כל {::nomarkdown}\( R\left(a,c\right)\){:/nomarkdown} ו-{::nomarkdown}\( R\left(c,b\right)\){:/nomarkdown} שמופיעים שם עוסקים בזוג צמתים שהמרחק ביניהם הוא בערך {::nomarkdown}\( \frac{k}{2}\){:/nomarkdown} - זאת מכיוון שבחרנו את {::nomarkdown}\( c\){:/nomarkdown} להיות באמצע הדרך). פתרון נוסחת הנסיגה שלעיל מניב ש-{::nomarkdown}\( S\left(k\right)=O\left(\left(2d\right)^{\lg k}\right)=O\left(k^{\lg\left(2d\right)}\right)\){:/nomarkdown}, ולכן נקבל שגודל הנוסחה {::nomarkdown}\( R\left(s,t\right)\){:/nomarkdown} עבור התוכנית המתפצלת כולה, גודל המעגל המתאים יהיה {::nomarkdown}\( O\left(t^{\lg\left(2d\right)}\right)\){:/nomarkdown} - זהו פולינום ב-{::nomarkdown}\( t\){:/nomarkdown}, שכן {::nomarkdown}\( d\){:/nomarkdown} קבוע. זה סוף הכיוון הזה - עד כה לא ראינו רעיונות מעניינים חריגים.

נעבור להוכחת הכיוון השני, המעניין. הרעיון המרכזי בחלק הזה של ההוכחה הוא להגביל <strong>עוד יותר</strong> את מה שלתוכנית המתפצלת מותר לעשות: בכל שכבה שלה, כל הצמתים יסומנו באותו משתנה (זה לא משהו שנדרש בהגדרה המקורית), והקשתות יהיו כאלו כך שכל הקשתות המסומנות ב-0 יהוו <strong>פרמוטציה</strong>, וגם כל הקשתות שמסומנות ב-1 יהוו פרמוטציה. מה? מי? מאיפה זה בא? הפרמוטציות הן מה שנותן לפתרון את הכוח שלו. הן האופן שבו ברינגטון מכניס כוח וגמישות לתוך מודל שנראה פרימיטיבי ומוגבל - בזכות העובדה שפרמוטציות הן מצד אחד יצורים פשוטים למדי מעצמם, ומצד שני הם יצורים מורכבים ביותר.

בואו נעשה קצת סדר בעניינים. אצל ברינגטון, כל שכבה בתוכנית המתפצלת כוללת חמישה צמתים <strong>בדיוק</strong>. נמספר אותם {::nomarkdown}\( 1,2,3,4,5\){:/nomarkdown}. עכשיו, מהצומת {::nomarkdown}\( 1\){:/nomarkdown} יוצאות שתי קשתות - אחת שמסומנת ב-0 ואחת שמסומנת ב-1. הקשת שמסומנת ב-0 נכנסת לאחד מהצמתים בשכבה הבאה, שגם בה כל הצמתים מסומנים ב-1 עד 5. נניח שהקשת נכנסת ל-3, אז אנחנו אומרים ש-"1 עובר ל-3 עם הקשת 0". באותו אופן כל אחד מחמשת המספרים עובר למספר בשכבה הבאה עם קשת ה-0 שלו. ברינגטון מוודא שלא יהיו שני מספרים שעוברים לאותו צומת בשכבה הבאה, ולכן אכן מתקבלת כאן פרמוטציה. באותו אופן, אם שוכחים מהקשתות שמסומנות ב-0 ומסתכלים רק על אלו שמסומנות ב-1, מקבלים פרמוטציה אחרת, אולי שונה מהראשונה.

על כן, אומר ברינגטון, אפשר לאפיין כל שכבה בגרף באמצעות השלשה הבאה: {::nomarkdown}\( \left(k,\pi^{0},\pi^{1}\right)\){:/nomarkdown}. {::nomarkdown}\( k\){:/nomarkdown} הוא מספרו של המשתנה {::nomarkdown}\( x_{k}\){:/nomarkdown} אשר מופיע על כל צומת בשכבה הזו. {::nomarkdown}\( \pi^{1}\){:/nomarkdown} היא הפרמוטציה שמתאימה לקשתות שמסומנות ב-0, ו-{::nomarkdown}\( \pi^{1}\){:/nomarkdown} היא הפרמוטציה שמתאימה לקשתות שמסומנות ב-1. בצורה הזו אפשר לבנות את כל התוכנית, ולקבל סדרה של שלשות: {::nomarkdown}\( \left(k_{1},\pi_{1}^{0},\pi_{1}^{1}\right),\left(k_{2},\pi_{2}^{0},\pi_{2}^{1}\right),\dots,\left(k_{t},\pi_{t}^{0},\pi_{t}^{1}\right)\){:/nomarkdown}. זוהי תוכנית מאורך {::nomarkdown}\( t\){:/nomarkdown}.

כעת, השמה של ערכים למשתנים כמוה בעצם כבחירה של פרמוטציה אחת מכל זוג, והכפלת כל הפרמוטציות שנבחרו כדי לקבל פרמוטציה שמייצגת את הגרף כולו. אם {::nomarkdown}\( \pi\){:/nomarkdown} היא מה שהתקבל מהכפל הזה, אז {::nomarkdown}\( \pi\left(1\right)\){:/nomarkdown} הוא מספרו של הצומת שאליו מגיעים בשכבה האחרונה אם מתחילים את הטיול מצומת 1 בשכבה הראשונה והולכים עם הקשתות שההשמה הותירה בחיים עד שמגיעים לשכבה האחרונה. בדומה {::nomarkdown}\( \pi\left(2\right)\){:/nomarkdown} זה אותו הדבר אם מתחילים מצומת 2 בשכבה הראשונה, וכן הלאה. פורמלית זה מוגדר כך: {::nomarkdown}\( \pi=\prod_{i=1}^{t}\pi_{i}^{x_{k_{i}}}\){:/nomarkdown}.

אם כן, אפשר לחשוב על תוכנית מתפצלת {::nomarkdown}\( P\){:/nomarkdown} כעל פונקציה שמקבלת קלט {::nomarkdown}\( \overline{x}\){:/nomarkdown} של ביטים ופולטת פרמוטציה ב-{::nomarkdown}\( S_{5}\){:/nomarkdown}: {::nomarkdown}\( P\left(\overline{x}\right)=\pi\){:/nomarkdown}. אבל איך כל זה קשור לפלט של 0 או 1? פשוט מאוד: נבחר מראש פרמוטציה ספציפית {::nomarkdown}\( \sigma\in S_{5}\){:/nomarkdown} ששונה מפרמוטציית הזהות, שאותה אסמן ב-{::nomarkdown}\( e\){:/nomarkdown} (הפרמוטציה שמעבירה כל איבר לעצמו). אז נגדיר ש-{::nomarkdown}\( P\){:/nomarkdown} מחזירה 1 על קלט {::nomarkdown}\( \overline{x}\){:/nomarkdown} אם {::nomarkdown}\( P\left(\overline{x}\right)=\sigma\){:/nomarkdown}, ושהיא מחזירה 0 אם {::nomarkdown}\( P\left(\overline{x}\right)=e\){:/nomarkdown}. בניסוח שיהיה נוח בהמשך - {::nomarkdown}\( P\){:/nomarkdown} {::nomarkdown}\( \sigma\){:/nomarkdown}-מחשבת את {::nomarkdown}\( f\){:/nomarkdown} אם מתקיים הדבר הבא: עבור ערכים של {::nomarkdown}\( \overline{x}\){:/nomarkdown} שעבורם מתקיים {::nomarkdown}\( f\left(\overline{x}\right)=1\){:/nomarkdown}, {::nomarkdown}\( P\){:/nomarkdown} מקיימת ש-{::nomarkdown}\( P\left(\overline{x}\right)=\sigma\){:/nomarkdown}, ואילו עבור ערכים שעבורם מתקיים {::nomarkdown}\( f\left(\overline{x}\right)=0\){:/nomarkdown}, {::nomarkdown}\( P\){:/nomarkdown} מקיימת ש-{::nomarkdown}\( P\left(\overline{x}\right)=e\){:/nomarkdown}.

זה שהגדרנו את זה כך זה טוב ויפה אבל לא מתאים להגדרה המקורית של תוכנית מתפצלת - כזכור, תוכנית מתפצלת מחזירה 1 אם יש מסלול מ-{::nomarkdown}\( s\){:/nomarkdown} ל-{::nomarkdown}\( t\){:/nomarkdown} אחרי ההשמה למשתנים, ו-0 אם אין מסלול כזה. אצלנו טרם בחרנו את {::nomarkdown}\( s\){:/nomarkdown} ו-{::nomarkdown}\( t\){:/nomarkdown}, והרעיון הוא לבחור אותם באופן שמתאים ל-{::nomarkdown}\( \sigma\){:/nomarkdown}. מכיוון ש-{::nomarkdown}\( \sigma\ne e\){:/nomarkdown} קיים {::nomarkdown}\( i\){:/nomarkdown} כך ש-{::nomarkdown}\( \sigma\left(i\right)\ne i\){:/nomarkdown}; אם כן, נגדיר את {::nomarkdown}\( s\){:/nomarkdown} להיות הצומת מס' {::nomarkdown}\( i\){:/nomarkdown} בשכבה הראשונה, ואת {::nomarkdown}\( t\){:/nomarkdown} להיות הצומת מס' {::nomarkdown}\( \sigma\left(i\right)\){:/nomarkdown} בשכבה האחרונה, וסיימנו: אם {::nomarkdown}\( P\left(\overline{x}\right)=\sigma\){:/nomarkdown} אז אכן יש מסלול מ-{::nomarkdown}\( i\){:/nomarkdown} אל {::nomarkdown}\( \sigma\left(i\right)\){:/nomarkdown}, ואם {::nomarkdown}\( P\left(\overline{x}\right)=e\){:/nomarkdown} אז המסלול היחיד מ-{::nomarkdown}\( i\){:/nomarkdown} הוא אל {::nomarkdown}\( e\left(i\right)=i\ne\sigma\left(i\right)\){:/nomarkdown}, כלומר אין מסלול מ-{::nomarkdown}\( s\){:/nomarkdown} אל {::nomarkdown}\( t\){:/nomarkdown}.

מסקנת ביניים, למי שאיבד אותי: אנחנו יכולים לשכוח מתוכניות מתפצלות ולעבור לדבר על "תוכניות פרמוטציה" - תוכניות שמתוארת על ידי שלשות של משתנה וזוג פרמוטציות כפי שתיארתי לעיל. מספיק להראות ש<strong>הן</strong> מסוגלות לסמלץ כל מעגל {::nomarkdown}\( \mbox{NC}^{1}\){:/nomarkdown} ולעשות זאת תוך שמירה על אורך לא גדול במיוחד (כלומר, {::nomarkdown}\( t\){:/nomarkdown} קטן).

אולי קצת יותר ברור כעת המספר 5 - הוא אומר שהפרמוטציות שמשתתפות במשחק כולן מ-{::nomarkdown}\( S_{5}\){:/nomarkdown}. אבל למה דווקא {::nomarkdown}\( S_{5}\){:/nomarkdown} ולא {::nomarkdown}\( S_{4}\){:/nomarkdown} או {::nomarkdown}\( S_{6}\){:/nomarkdown}? ובכן, עוד מעט נראה.

אמרתי שהסיבה שפרמוטציות מועילות לנו היא כי הן מצד אחד יצורים פשוטים ומצד שני מורכבים - בואו ננסה להבין איך זה מתבטא. ראשית, כמו שכבר ראינו, קיימת פעולת "כפל" של פרמוטציות שפירושה הוא פשוט להפעיל אותן בזו אחר זו: {::nomarkdown}\( \sigma\tau\){:/nomarkdown} זו הפרמוטציה שבה מפעילים את {::nomarkdown}\( \tau\){:/nomarkdown} ואחר כך את {::nomarkdown}\( \sigma\){:/nomarkdown}. באופן כללי זה לא חייב להיות שווה ל-{::nomarkdown}\( \tau\sigma\){:/nomarkdown} - נסו למצוא דוגמה שבה אכן {::nomarkdown}\( \tau\sigma\ne\sigma\tau\){:/nomarkdown}. כמו כן לכל פרמוטציה קיימת {::nomarkdown}\( \sigma^{-1}\){:/nomarkdown} פרמוטציה הפוכה שעבורה {::nomarkdown}\( \sigma\sigma^{-1}=\sigma^{-1}\sigma=e\){:/nomarkdown}. לא קשה לראות שהפרמוטציות מהוות מה שנקרא <strong>חבורה</strong> עם פעולת הכפל המדוברת, אבל זה לא יהיה קריטי יותר מדי עבורנו כאן.

פרמוטציות פשוטות במיוחד הן <strong>מעגלים</strong>: אם למשל {::nomarkdown}\( \sigma\left(1\right)=3\){:/nomarkdown} ו-{::nomarkdown}\( \sigma\left(3\right)=5\){:/nomarkdown} ו-{::nomarkdown}\( \sigma\left(5\right)=1\){:/nomarkdown} אז {::nomarkdown}\( \sigma\){:/nomarkdown} כוללת בתוכה את המעגל {::nomarkdown}\( \left(1\ 3\ 5\right)\){:/nomarkdown} ("1 עובר ל-3 שעובר ל-5 שעובר ל-1"). לא קשה להוכיח שכל פרמוטציה אפשר לכתוב כמכפלה של מעגלים זרים, כלומר כאלו שכל מספר מופיע רק באחד מהם. למשל, {::nomarkdown}\( \left(1\ 4\right)\left(2\ 5\right)\left(3\right)\){:/nomarkdown} היא הפרמוטציה שמעבירה את 1 ל-4, את 4 ל-1, את 2 ל-5, את 5 ל-2, ואת 3 לעצמו. אנחנו מדברים על פרמוטציות על חמישה איברים, אז לפרמוטציה שהיא מעגל על כל חמשת האיברים הללו אקרא "5-מעגל" (צריך לא להתבלבל עם המושג השני של מעגל שעליו אנחנו מדברים פה - מעגל בוליאני, שהוא יצור שונה לגמרי - אבל אני בטוח שיהיה בסדר).

פעולה בסיסית בחבורות, ולכן גם בפרמוטציות, היא <strong>הצמדה</strong>. אם {::nomarkdown}\( \sigma,\tau\){:/nomarkdown} הן שתי פרמוטציות, אז הצמדה של {::nomarkdown}\( \sigma\){:/nomarkdown} על ידי {::nomarkdown}\( \tau\){:/nomarkdown} היא הפרמוטציה {::nomarkdown}\( \tau\sigma\tau^{-1}\){:/nomarkdown}. אפשר לחשוב על זה כעל "מה שקורה כשמפעילים את {::nomarkdown}\( \sigma\){:/nomarkdown}, אבל לא על הדבר המקורי שעליו רצינו להפעיל אותה אלא עליו אחרי שהוא "מוזז" ובסוף מתקנים את ה"הזזה" הזו" (באלגברה לינארית, למשל, הצמדה של מטריצות היא בעלת המשמעות של <strong>שינוי מערכת הקוארדינטות</strong>, הפעלת הטרנספורמציה הלינארית שהמטריצה האמצעית מייצגת בתוך מערכת הקוארדינטות החדשה, ואז חזרה למערכת הקוארדינטות הישנה - מי שכל זה נשמע לו כמו ג'יבריש, לא נורא; אני מקווה שהפלתי למישהו אסימון כרגע).

להצמדת פרמוטציות יש פירוש קל ונחמד. בואו נניח לשניה ש-{::nomarkdown}\( \sigma\){:/nomarkdown} היא מעגל: {::nomarkdown}\( \sigma=\left(a_{1}\ a_{2}\ \dots a_{k}\right)\){:/nomarkdown}. אז {::nomarkdown}\( \tau\sigma\tau^{-1}=\left(\tau\left(a_{1}\right)\ \tau\left(a_{2}\right)\ \dots\tau\left(a_{k}\right)\right)\){:/nomarkdown}. כלומר, עדיין קיבלנו מעגל, רק שבמקום המספרים המקוריים של {::nomarkdown}\( \sigma\){:/nomarkdown} אנחנו מקבלים את המספרים הללו אחרי שערבבנו אותם באופן ש-{::nomarkdown}\( \tau\){:/nomarkdown} מתאר. אם למשל {::nomarkdown}\( \sigma=\left(1\ 4\ 2\right)\){:/nomarkdown} ו-{::nomarkdown}\( \tau=\left(1\ 3\right)\left(2\ 5\right)\){:/nomarkdown} אז {::nomarkdown}\( \tau\sigma\tau^{-1}=\left(3\ 4\ 5\right)\){:/nomarkdown}. נסו והיווכחו בעצמכם. לא אוכיח את הטענה הזו כעת למרות שהיא אינה מסובכת במיוחד (האינטואיציה גם כאן היא לחשוב על {::nomarkdown}\( \tau\){:/nomarkdown} כמעין "שינוי קוארדינטות").

המסקנה שמעניינת אותנו כאן היא זו: אם {::nomarkdown}\( \sigma_{1},\sigma_{2}\){:/nomarkdown} הן שתי פרמוטציות ששתיהן 5-מעגל, אז יש {::nomarkdown}\( \tau\){:/nomarkdown} כך ש-{::nomarkdown}\( \tau\sigma_{1}\tau^{-1}=\sigma_{2}\){:/nomarkdown} (למה? האם אתם יכולים להגיד איך מוצאים את {::nomarkdown}\( \tau\){:/nomarkdown}?). בהתבסס על המסקנה הזו, אפשר סוף סוף להתחיל ולראות את הכוח והגמישות שהשימוש בפרמוטציות נותן לנו. נניח ש-{::nomarkdown}\( P\){:/nomarkdown} היא תוכנית פרמוטציות אשר {::nomarkdown}\( \sigma\){:/nomarkdown}-מחשבת איזו פונקציה {::nomarkdown}\( f\){:/nomarkdown}, כאשר {::nomarkdown}\( \sigma\){:/nomarkdown} היא 5-מעגל, אז קיימת תוכנית פרמוטציות {::nomarkdown}\( P^{\prime}\){:/nomarkdown} <strong>מאותו אורך כמו</strong> {::nomarkdown}\( P\){:/nomarkdown} אשר {::nomarkdown}\( \sigma^{\prime}\){:/nomarkdown}-מחשבת את {::nomarkdown}\( f\){:/nomarkdown} <strong>לכל</strong> {::nomarkdown}\( \sigma^{\prime}\){:/nomarkdown} שהיא 5-מעגל. זה מפחית מאוד את התלות שלנו ב-{::nomarkdown}\( \sigma\){:/nomarkdown}הספציפית שאיתה אנחנו מחשבים את {::nomarkdown}\( f\){:/nomarkdown}, וכפי שנראה בקרוב, זה מאוד מועיל.

ההוכחה של הטענה הזו היא פשוט מקסימה. אז נניח ש-{::nomarkdown}\( \sigma^{\prime}=\tau\sigma\tau^{-1}\){:/nomarkdown}. בואו נכתוב במפורש את התוכנית {::nomarkdown}\( P\){:/nomarkdown}: {::nomarkdown}\( P=\left(k_{1},\pi_{1}^{0},\pi_{1}^{1}\right),\left(k_{2},\pi_{2}^{0},\pi_{2}^{1}\right),\dots,\left(k_{t},\pi_{t}^{0},\pi_{t}^{1}\right)\){:/nomarkdown}. מה שנעשה יהיה "לתקן" את {::nomarkdown}\( P\){:/nomarkdown} באופן הבא: {::nomarkdown}\( P^{\prime}=\left(k_{1},\tau\pi_{1}^{0},\tau\pi_{1}^{1}\right),\left(k_{2},\pi_{2}^{0},\pi_{2}^{1}\right),\dots,\left(k_{t},\pi_{t}^{0}\tau^{-1},\pi_{t}^{1}\tau^{-1}\right)\){:/nomarkdown} - כלומר, השינוי הוא רק בפרמוטציות הראשונות והאחרונות. בפרט לא שינינו את אורך התוכנית.

כעת, מה קורה? אם {::nomarkdown}\( f\left(\overline{x}\right)=1\){:/nomarkdown} אז {::nomarkdown}\( P\left(\overline{x}\right)=\prod_{i=1}^{t}\pi_{i}^{x_{k_{i}}}=\sigma\){:/nomarkdown}. ומהו {::nomarkdown}\( P^{\prime}\left(\overline{x}\right)\){:/nomarkdown}? ובכן, על פי ההגדרה, זהו {::nomarkdown}\( P^{\prime}\left(\overline{x}\right)=\tau\left(\prod_{i=1}^{t}\pi_{i}^{x_{k_{i}}}\right)\tau^{-1}=\tau\sigma\tau^{-1}=\sigma^{\prime}\){:/nomarkdown}.

ואם {::nomarkdown}\( f\left(x\right)=0\){:/nomarkdown}, מה אז? ובכן, {::nomarkdown}\( P^{\prime}\left(\overline{x}\right)=\tau\left(\prod_{i=1}^{t}\pi_{i}^{x_{k_{i}}}\right)\tau^{-1}=\tau e\tau^{-1}=\tau\tau^{-1}=e\){:/nomarkdown}, שכן כאשר מצמידים את {::nomarkdown}\( e\){:/nomarkdown} תמיד מקבלים את {::nomarkdown}\( e\){:/nomarkdown}. קיבלנו בדיוק את מה שרצינו.

הטענה הזו תעזור לנו עוד מעט בהמשך, אבל עכשיו אפשר סוף סוף לגשת להוכחה עצמה. המטרה שלנו היא לבצע סימולציה של מעגל {::nomarkdown}\( \mbox{NC}^{1}\){:/nomarkdown} באמצעות תוכנית פרמוטציות. הרעיון יהיה לתקוף את המעגל באופן אינדוקטיבי - נראה כיצד ניתן להמיר צומת כניסה למעגל לתוכנית פרמוטציות, וכיצד ניתן להמיר את צמתי השערים הלוגיים בתוכניות פרמוטציות. בכל אחד מהמקרים העיקרון יהיה שעל קלטים שעבורם השער פולט {::nomarkdown}\( 1\){:/nomarkdown}, תוכנית הפרמוטציות תפלוט {::nomarkdown}\( \sigma\){:/nomarkdown} עבור פרמוטציה כלשהי שהיא 5-מעגל, ועל קלטים שעבורם הוא פולט {::nomarkdown}\( 0\){:/nomarkdown}, תוכנית הפרמוטציות תפלוט {::nomarkdown}\( e\){:/nomarkdown}.

כדי לפשוט לנו את החיים, נניח שבמעגל הבוליאני יש רק שני סוגי שערים: שער {::nomarkdown}\( \neg\){:/nomarkdown} ושער {::nomarkdown}\( \wedge\){:/nomarkdown}. שער {::nomarkdown}\( \vee\){:/nomarkdown} ניתן לסימולציה בעזרת כללי דה-מורגן: {::nomarkdown}\( x\vee y=\neg\left(\neg x\wedge\neg y\right)\){:/nomarkdown}. אמנם, זה יגדיל קצת את עומק המעגל, אבל לא באופן משמעותי - רק פי 2, כלומר הכפלה בקבוע.

נתחיל, אם כן, משער קלט של המעגל. שער כזה תמיד מסומן במשתנה {::nomarkdown}\( x_{i}\){:/nomarkdown} ומקבל 1 או 0 בהתאם לערך ש-{::nomarkdown}\( x_{i}\){:/nomarkdown} מקבל בהשמה. תוכנית פרמוטציות עבור שער כזה היא פשוטה מאוד - מאורך 1: {::nomarkdown}\( P=\left(i,e,\sigma\right)\){:/nomarkdown}. נסו להבהיר לעצמכם למה זה עובד.

שער {::nomarkdown}\( \neg\){:/nomarkdown} מסובך מעט יותר ויש בו תעלול נחמד. זכרו שלשער {::nomarkdown}\( \neg\){:/nomarkdown} יש כניסה אחת בלבד, ולכן אפשר לתאר את הסיטואציה כך: יש לנו שער שמחשב פונקציה {::nomarkdown}\( f\){:/nomarkdown} כלשהי וכבר בנינו עבורו תוכנית פרמוטציות {::nomarkdown}\( P\){:/nomarkdown} אשר {::nomarkdown}\( \sigma\){:/nomarkdown}-מחשבת את {::nomarkdown}\( f\){:/nomarkdown} עבור {::nomarkdown}\( \sigma\){:/nomarkdown} שהיא 5-מעגל כלשהו. כעת אנו רוצים לבנות תוכנית פרמוטציות {::nomarkdown}\( \neg P\){:/nomarkdown} אשר {::nomarkdown}\( \tau\){:/nomarkdown}-מחשבת את {::nomarkdown}\( \neg f\){:/nomarkdown} עבור {::nomarkdown}\( \tau\){:/nomarkdown} שגם היא 5-מעגל (לא בהכרח שווה ל-{::nomarkdown}\( \sigma\){:/nomarkdown}). הרעיון הוא זה: אם {::nomarkdown}\( P=\left(k_{1},\pi_{1}^{0},\pi_{1}^{1}\right),\dots,\left(k_{t},\pi_{t}^{0},\pi_{t}^{1}\right)\){:/nomarkdown} אז {::nomarkdown}\( \neg P=\left(k_{1},\pi_{1}^{0},\pi_{1}^{1}\right),\dots,\left(k_{t},\pi_{t}^{0}\sigma^{-1},\pi_{t}^{1}\sigma^{-1}\right)\){:/nomarkdown}. כלומר, שינינו במעט את השלב האחרון בתוכנית - שימו לב כי לא שינינו את <strong>אורך</strong> התוכנית כלל. למה זה עובד? כי אם {::nomarkdown}\( f\left(\overline{x}\right)=1\){:/nomarkdown} אז {::nomarkdown}\( P\left(\overline{x}\right)=\sigma\){:/nomarkdown} ולכן {::nomarkdown}\( \neg P\left(\overline{x}\right)=\sigma\cdot\sigma^{-1}=e\){:/nomarkdown}, בהתאם לכך ש-{::nomarkdown}\( \neg f\left(\overline{x}\right)=0\){:/nomarkdown}; ואילו אם {::nomarkdown}\( f\left(\overline{x}\right)=0\){:/nomarkdown} אז {::nomarkdown}\( P\left(\overline{x}\right)=e\){:/nomarkdown} ולכן {::nomarkdown}\( \neg P\left(\overline{x}\right)=e\cdot\sigma^{-1}=\sigma^{-1}\){:/nomarkdown}. כלומר, {::nomarkdown}\( \neg P\){:/nomarkdown} {::nomarkdown}\( \sigma^{-1}\){:/nomarkdown}-מקבלת את {::nomarkdown}\( \neg f\){:/nomarkdown}, וזה מצויין כי אם {::nomarkdown}\( \sigma\){:/nomarkdown} היא 5-מעגל, כך גם {::nomarkdown}\( \sigma^{-1}\){:/nomarkdown} (כלומר, {::nomarkdown}\( \sigma^{-1}\){:/nomarkdown} היא ה-{::nomarkdown}\( \tau\){:/nomarkdown} שלנו).

עכשיו הגענו לקליימקס - שער {::nomarkdown}\( \wedge\){:/nomarkdown}. נניח שיש לנו את {::nomarkdown}\( f_{1},f_{2}\){:/nomarkdown} אשר {::nomarkdown}\( \sigma_{1},\sigma_{2}\){:/nomarkdown}-מחושבות בידי {::nomarkdown}\( P_{1},P_{2}\){:/nomarkdown} בהתאמה - ושוב, {::nomarkdown}\( \sigma_{1},\sigma_{2}\){:/nomarkdown} שתיהן 5-מעגלים. אנחנו רוצים לבנות {::nomarkdown}\( P\){:/nomarkdown} אשר {::nomarkdown}\( \sigma\){:/nomarkdown}-תחשב את {::nomarkdown}\( f_{1}\wedge f_{2}\){:/nomarkdown}. מה עושים?

כאן נשלף תעלול נוסף: ב-{::nomarkdown}\( S_{5}\){:/nomarkdown} יש שתי פרמוטציות {::nomarkdown}\( \sigma_{1},\sigma_{2}\){:/nomarkdown} שהן 5-מעגלים וגם {::nomarkdown}\( \sigma=\sigma_{1}\sigma_{2}\sigma_{1}^{-1}\sigma_{2}^{-1}\){:/nomarkdown} - מה שנקרא <strong>הקומוטטור</strong> של {::nomarkdown}\( \sigma_{1},\sigma_{2}\){:/nomarkdown} - הוא 5-מעגל. לעובדה הזו יש חשיבות קריטית, והיא הסיבה שבגללה מתעסקים עם {::nomarkdown}\( S_{5}\){:/nomarkdown} דווקא - עבור {::nomarkdown}\( S_{n}\){:/nomarkdown} עם {::nomarkdown}\( n\le4\){:/nomarkdown} פשוט לא קיימות שתי פרמוטציות שהן מעגלים וגם הקומוטטור שלהן הוא מעגל מאותו האורך.

מיהן אותן תמורות שמקיימות את התכונה המדוברת? ובכן, למשל: {::nomarkdown}\( \left(1\ 2\ 3\ 4\ 5\right)\){:/nomarkdown} ו-{::nomarkdown}\( \left(1\ 3\ 5\ 4\ 2\right)\){:/nomarkdown} שהקומוטטור שלהן הוא {::nomarkdown}\( \left(1\ 3\ 2\ 5\ 4\right)\){:/nomarkdown}. לא צריך יותר מזה.

אנחנו יכולים להניח כי {::nomarkdown}\( P_{1},P_{2}\){:/nomarkdown} אכן מחשבות את הפונקציות שלהן בעזרת אותן {::nomarkdown}\( \sigma_{1},\sigma_{2}\){:/nomarkdown} המדוברות בזכות הטיעון שהראינו קודם - שאפשר להחליף בחופשיות את ה-{::nomarkdown}\( \sigma\){:/nomarkdown} של התוכנית כל עוד ממשיכים לדבר על 5-מעגלים. יותר מזה: אנחנו גם יכולים לבנות מ-{::nomarkdown}\( P_{1}\){:/nomarkdown} תוכנית חדשה, {::nomarkdown}\( P_{1}^{-1}\){:/nomarkdown}, שאורכה זהה לזה של {::nomarkdown}\( P_{1}\){:/nomarkdown} אבל היא {::nomarkdown}\( \sigma_{1}^{-1}\){:/nomarkdown}-מקבלת את {::nomarkdown}\( f_{1}\){:/nomarkdown}. כנ"ל עבור {::nomarkdown}\( P_{2}\){:/nomarkdown}. וכעת אפשר להציג את התוכנית עבור {::nomarkdown}\( f_{1}\wedge f_{2}\){:/nomarkdown}: היא תהיה פשוט {::nomarkdown}\( P=P_{1}P_{2}P_{1}^{-1}P_{2}^{-1}\){:/nomarkdown}. כלומר, שרשור של הסדרות של כל ארבע התוכניות הללו. כאן, סוף כל סוף, אורך התוכנית שאנו בונים גדל.

מדוע זה עובד? ובכן, אם {::nomarkdown}\( f_{1}\left(\overline{x}\right)=f_{2}\left(\overline{x}\right)=1\){:/nomarkdown} אז {::nomarkdown}\( P\left(\overline{x}\right)=\sigma_{1}\sigma_{2}\sigma_{1}^{-1}\sigma_{2}^{-1}=\sigma\){:/nomarkdown}, כפי שרצינו. אבל אם למשל {::nomarkdown}\( f_{1}\left(\overline{x}\right)=0\){:/nomarkdown} ו-{::nomarkdown}\( f_{2}\left(\overline{x}\right)=1\){:/nomarkdown} אז {::nomarkdown}\( P_{1}\left(\overline{x}\right)=P_{1}^{-1}\left(\overline{x}\right)=e\){:/nomarkdown} ולכן {::nomarkdown}\( P\left(\overline{x}\right)=e\cdot\sigma_{2}\cdot e\cdot\sigma_{2}^{-1}=e\){:/nomarkdown}. באופן דומה מקבלים {::nomarkdown}\( e\){:/nomarkdown} גם עבור הסיטואציות שבהן {::nomarkdown}\( f_{2}\left(\overline{x}\right)=0\){:/nomarkdown}. זה הסוף. אני לא יודע מה איתכם, אבל לדעתי הטריק הזה ממש מקסים, ואלוהים יודע מאיפה הוא הגיע.

טוב, מכאן נגמר רעיון הבניה וכל מה שנשאר הוא חשבון מכולת. אם נפעיל את הטרנספורמציות שתיארתי כאן על כל שער במעגל ה-{::nomarkdown}\( \mbox{NC}^{1}\){:/nomarkdown} בסופו של דבר נגיע גם לשער הפלט, והתוכנית שמתאימה לשער הפלט היא התוכנית שמתאימה לפונקציה שאותה המעגל כולו מחשב. השאלה היא רק מה אורך התוכנית הזו.

כפי שכבר ראינו, אורך תוכנית שמתאימה לשער קלט היא 1, ושער שלילה לא משנה כלל את אורך התוכנית. רק שער {::nomarkdown}\( \wedge\){:/nomarkdown} מאריך אותה. בואו נסמן ב-{::nomarkdown}\( S\left(d\right)\){:/nomarkdown} את האורך המקסימלי של תוכנית עבור מעגל מעומק {::nomarkdown}\( d\){:/nomarkdown}.

אם יש לנו בתוכנית שער {::nomarkdown}\( \wedge\){:/nomarkdown} בעומק {::nomarkdown}\( d\){:/nomarkdown}, אז שני הצמתים שנכנסים אליו מהווים כל אחד מעגל בעומק {::nomarkdown}\( d-1\){:/nomarkdown}. לכן גודל התוכניות {::nomarkdown}\( P_{1},P_{2}\){:/nomarkdown} עבורם הוא לכל היותר {::nomarkdown}\( S\left(d-1\right)\){:/nomarkdown} לכל אחד מהם. מכיוון שאנו משרשרים את {::nomarkdown}\( P_{1},P_{2}\){:/nomarkdown} ואז גם את שתי התוכניות עם הפרמוטציה ההופכית, אנחנו בסך הכל מגדילים פי 4 את האורך לכל היותר, כלומר {::nomarkdown}\( S\left(d\right)=4\cdot S\left(d-1\right)\){:/nomarkdown}. אם נפתור את נוסחת הנסיגה הזו נקבל {::nomarkdown}\( S\left(d\right)=4^{d}\){:/nomarkdown}. שזה, חייבים להודות, לא נראה מרשים במבט ראשון - זה נראה אקספוננציאלי.

אלא מה, צריך לזכור שאנו מדברים כאן על מעגל {::nomarkdown}\( \mbox{NC}^{1}\){:/nomarkdown} - מעגל שהעומק שלו הוא לוגריתמי ב-{::nomarkdown}\( n\){:/nomarkdown}, כלומר במספר הביטים שעליהם פועלת הפונקציה שמחשבים. לכן {::nomarkdown}\( 4^{d}\){:/nomarkdown} הוא בעצם {::nomarkdown}\( O\left(4^{\log n}\right)=O\left(n^{\log4}\right)\){:/nomarkdown} - פולינומי לגמרי (אבל, אם ניקח מעגל {::nomarkdown}\( \mbox{NC}^{2}\){:/nomarkdown}, שבו העומק הוא {::nomarkdown}\( O\left(\log^{2}n\right)\){:/nomarkdown}, כבר לא נקבל אורך פולינומי). זה מסיים את ההוכחה.

אני מקווה שהצלחתם לשרוד את כל ההוכחה. היא אינה קשה במיוחד וגם אינה עמוסה ביותר מדי פרטים, אך קצת נסיון בתחום בהחלט עוזר להבין אותה. מה שקשה להבין, ואני עדיין לא מבין בעצמי, הוא מאיפה הגיע הרעיון להוכחה הזו בכלל ולמה זה עובד (שאלה שכמובן, גם לראות הוכחה פורמלית לא עוזר לענות עליה לחלוטין). אבל לדעתי, גם בלי להבין, התוצאה הזו מהנה מאוד - כמו לשבת במופע של קוסם וליהנות מהשפן שנשלף מהשרוול. לשמחתי, תורת הסיבוכיות עשירה בקסמים שכאלו.
