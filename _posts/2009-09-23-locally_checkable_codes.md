---
id: 209
title: "קודים לתיקון שגיאות (שניתנים לבדיקה מקומית)"
date: 2009-09-23 19:21:09
layout: post
categories: 
  - מבני נתונים ואלגוריתמים
  - תורת הסיבוכיות
tags: 
  - קוד הדמר
  - קודים הניתנים לבדיקה מקומית
  - קודים לתיקון שגיאות
---
אוהבים ללעוג למתמטיקאים על כך שהמתמטיקה הנקייה והאידאלית שלהם לא מסתדרת טוב עם העולם האמיתי המלוכלך. גם מדעי המחשב סובלים מבעיה דומה, והראיתי את זה לא מזמן, ב<a href="http://www.gadial.net/?p=201">פוסט</a> שעסק במאמר שלעג ל"חשיבה המתמטית" שמונעת את ראיית הדרך ה"פשוטה" לפצח את RSA; טענתי אז שגם התאורטיקנים הגדולים ביותר יודעים לטפל - בואפן מתמטי ומדוייק - בבעיות שקשורות לעולם האמיתי. דוגמה מעניינת נוספת לכך היא <a href="http://gadial.blogli.co.il/wp-admin/%D7%A7%D7%95%D7%93%D7%99%D7%9D%20%D7%9C%D7%AA%D7%99%D7%A7%D7%95%D7%9F%20%D7%A9%D7%92%D7%99%D7%90%D7%95%D7%AAhttp://he.wikipedia.org/wiki/%D7%A7%D7%95%D7%93_%D7%AA%D7%99%D7%A7%D7%95%D7%9F_%D7%A9%D7%92%D7%99%D7%90%D7%95%D7%AA">קודים לתיקון שגיאות</a> - הם באים לטפל בבעיה אמיתית מאוד, ומשתמשים בהם כל הזמן בעולם האמיתי, ומצד שני התורה שלהם יכולה להיות תאורטית מאוד, מתבססת בחלקה הגדול על אלגברה לינארית ומופשטת, והחשוב מכל - יש לה שימושים מפתיעים גם בהוכחת תוצאות תיאורטיות לחלוטין בתחומים אחרים של מדעי המחשב, ובפרט את משפט ה-PCP ש<a href="http://www.gadial.net/?p=208">הזכרתי בפוסט הקודם</a>.

נחזור לבסיס. במדעי המחשב, אפשר לחשוב על כל אינפורמציה כאילו היא מיוצגת כרצף של סיביות - אפסים ואחדים. גם כשמאחסנים מידע במחשב ועל מדיות שונות ומשונות (כגון דיסקים) וגם כששולחים אותו בקו תקשורת, זה מה שנשלח - אפסים ואחדים. כמובן שבפועל מה שקורה הוא מסובך יותר, אבל זוהי הפשטה שאפשר לבצע ועדיין לקבל תיאור די מדוייק של המציאות; לא ארחיב בנושא מעבר לכך כעת.

אלא שהעולם האמיתי הוא מקום מלוכלך - לקווי תקשורת יש "רעש", דיסקים יכולים להישרט, וכן הלאה. בפועל המשמעות של זה מבחינתנו היא שחלק מהמידע שאנחנו שולחים (מכאן ואילך "לשלוח" פירושו גם "לשים מידע על דיסק"; תחשבו על זה כאילו אנחנו שולחים כך מידע אל גרסה עתידית שלנו שתנסה לקרוא את הדיסק) ייהרס. מה זה "ייהרס" מבחינתנו אם כל מה שיש הוא אפסים ואחדים? שבמקום לקרוא 0 נקרא 1, ולהפך. למשל, נשלח את המילה 0010 ובצעד השני תתקבל המילה 0110. כאן הביט השני "התקלקל". זה יכול לגרום לשינוי עצום במשמעות של המידע שנשלח ולהיות בעל תוצאות הרסניות - בקיצור, אסור להתיר לדברים כאלו לקרות. הבעיה היא שבעולם האמיתי הם קורים כל הזמן. לא סביר לבנות ערוץ ממשי שבו תקלות כאלו לא יתרחשו כל הזמן. בקצרה - אנו נזקקים לפתרון לבעיה שאינו תלוי ערוץ; אנחנו צריכים לקבל את הקלקולים בתור חלק מהחיים ולמצוא דרך לטפל בהם בכל זאת.

גישה נאיבית לבעיה היא זו - במקום לשדר את המידע סיבית-סיבית, נשכפל כל סיבית מספר פעמים כלשהו - נאמר, שלוש - ונשלח את השכפולים ברצף. כך למשל במקום לשלוח את המידע 0010, נשלח 000000111000. מי שמקבל את המידע בצד השני יפרק את הקלט שקיבל לשלשות, ויחליט מה הסיבית שכל שלשה מייצגת על פי "הכרעת רוב". למשל, אם קיבלנו 111, אפשר להניח שהשלשה הזו מייצגת את הסיבית 1; ואם קיבלנו 100, אפשר להניח שהשלשה מייצגת את הסיבית 0. כמובן, ייתכן שנשלח את 000 ובדרך כל שלוש הסיביות יתפקששו, בצד השני יתקבל 111 והמפענח יחשוב שניסיתי לשדר לו 1; אבל הסיכוי לכך שזה יקרה הוא נמוך יחסית. כמובן שכדי לבצע חישוב מדוייק צריך לדעת מהי ההסתברות לכך שסיבית תתפקשש, ובהתאם אפשר לשלוח 5 עותקים של הספרה שרוצים להעביר, או 7, וכו' - איני רוצה להיכנס לניתוחים הללו כעת.

הנה עוד דוגמה לדבר מה שניתן לעשות - אם אני רוצה לשלוח רצף של סיביות, נניח 01010, אני אוסיף לסוף הרצף עוד סיבית אחת, שתתקבל מ"חיבור" כל הסיביות (עם הכלל לפיו {::nomarkdown}\( 1+1=0\){:/nomarkdown}). הסיבית הזו נקראת "סיבית הזוגיות", שכן היא 0 אם יש מספר זוגי של 1 ברצף שאני שולח (למשל, ברצף שנתתי בדוגמה) והיא 1 אם יש מספר אי זוגי שלהן (למשל, ברצף 11100). בשביל מה זה טוב? אם בצד השני יקבלו 110001, יבינו שמשהו השתבש, כי סיבית הסימן היא 1 ועם זאת בין שאר חמש הסיביות (שאמורות לייצג את המידע האמיתי) יש רק שתיים שהן מגודל 1. זה טוב לזיהוי השגיאה, אבל לא ממש עוזר לתקן אותה במקרה הזה (כמובן שזיהוי שגיאה הוא חשוב מספיק לכשעצמו - אם שגיאות הן נדירות, אז כשמזוהה שגיאה אפשר לבקש מהשולח שישלח את פיסת המידע שוב).

באופן כללי אפשר לתאר קוד באמצעות שלושה פרמטרים - ראשית, מספר הסיביות שיש בכל מילת קוד; שנית, קבוצת המילים בקוד; שלישית, המרחק המינימלי שבין המילים בקוד. בואו נחזור לרגע לקוד השלשות שתיארתי קודם - זה קוד שהכיל בדיוק שתי מילות קוד, 111 ו-000; כל מילה אחרת הייתה "לא חוקית". אם כן, זה קוד שבו המילים הן מאורך 3 ויש בדיוק שתי מילים. הקוד הזה מאפשר לנו, אם כן, לשלוח שני "סוגי מידע שונים"; אני הגדרתי שרירותית ש-000 ייצג את 0 וש-111 ייצג את 1 אבל זה לא הכרחי; הייתי יכול גם לקבוע ש-000 מייצג את 1 ו-111 מייצג את 0, או שהם מייצגים בכלל את 012 ואת 4325, או כל זוג מוזר אחר. נותר להסביר מהו עניין ה"מרחק".

המילה 000 נראית לנו שונה מהמילה 111 הרבה יותר מאשר 110 שונה מ-111. ההבדל ברור -<strong> מספר המקומות השונים</strong> בין 000 ו-111 הוא 3, בעוד שמספר המקומות השונים בין 110 ו-111 הוא 1 בלבד. זה מוביל להגדרה של מרחק המינג בין שתי מחרוזות מאורך זהה - מספר המקומות השונים זה מזה במחרוזת, או אם תרצו: מספר <strong>השגיאות</strong> שצריכות להתרחש כדי שבמקום המחרוזת א' תתקבל המחרוזת ב'.

הסיבה שקוראים להגדרה הזו "<a href="http://he.wikipedia.org/wiki/%D7%9E%D7%98%D7%A8%D7%99%D7%A7%D7%94">מרחק</a>" היא שהתכונות הקלאסיות של מרחק מתקיימות עבורה. המרחק של כל מילה מעצמה הוא 0, ואם יש מרחק 0 בין שתי מילים, זוהי אותה המילה; המרחק של א' מב' זהה למרחק של ב' מא'; והמרחק של א' מג' קטן מסכום המרחקים של א' מב' ומב' לג', לכל מילה ב'. לתכונה האחרונה קוראים "אי שוויון המשולש" בגלל שהיא ניסוח פורמלי של התכונה המוכרת לפיה במשולש סכום אורכי שתי צלעות תמיד גדול או שווה לאורך הצלע השלישית. אם חושבים על צלעות המשולש בתור מסלולים שיש ללכת בהם, אי שוויון המשולש הוא פורמליזציה של האבחנה הפשוטה לפיה עדיף ללכת בקו ישר ולא להתעכב בנקודות ביניים בדרך.

אם כן, המרחק המינימלי בין שתי מילים בקוד הוא מספר השגיאות שצריכות ליפול במהלך השידור כדי שנטעה לחשוב ששום דבר לא השתבש, ונקבל מילת קוד לא נכונה. יותר מזה - <strong>חצי</strong> מהמרחק המינימלי הוא מספר השגיאות המקסימלי שיכולות ליפול בקוד כך שעדיין נוכל לשחזר את מילת הקוד הנכונה המקורית (למעשה, מספר השגיאות חייב להיות קטן <strong>ממש</strong> מחצי) - נסו לחשוב מדוע.

כעת אני רוצה לעזוב את הנושא הכללי הזה, שלא התחלתי אפילו לדגדג את קצה-קצהו, ולדבר על קוד מאוד ספציפי, עם תכונה מאוד ספציפית - <a href="http://en.wikipedia.org/wiki/Hadamard_code">קוד הדמר</a> (Hadamard), עם תכונה מאוד ספציפית - הוא <a href="http://en.wikipedia.org/wiki/Locally_testable_code">ניתן לבדיקה מקומית </a>(Locally Testable). הכוונה ב"בדיקה מקומית" היא שבאמצעות דגימה של מספר קטן מאוד - סופי - של ביטים ממילת הקוד ניתן יהיה לזהות בהסתברות טובה האם היא חוקית או לא. ליתר דיוק - אם היא חוקית, תמיד נזהה זאת; אם היא לא חוקית, אז ככל שהיא רחוקה מלהיות מילת קוד חוקית ההסתברות שלנו לזהות זאת תגדל משמעותית (מובן מאליו שאם נפלה שגיאה בביט בודד במילת הקוד אין סיכוי לזהות זאת בהסתברות גדולה על ידי בדיקה של מספר סופי של ביטים - הרי חייבים לקלוע "בול" לביט שהתקלקל כדי שיהיה בכלל סיכוי להבין שמשהו השתבש).

קוד הדמר, כמו רוב הקודים לתיקון שגיאות, הוא קוד לינארי - מילות הקוד מהוות <a href="http://he.wikipedia.org/wiki/%D7%9E%D7%A8%D7%97%D7%91_%D7%95%D7%A7%D7%98%D7%95%D7%A8%D7%99">מרחב לינארי</a> מעל <a href="http://he.wikipedia.org/wiki/%D7%A9%D7%93%D7%94_%D7%A1%D7%95%D7%A4%D7%99">שדה סופי</a> כלשהו. אני לא סתם נכנס לעובדה הטכנית הזו - כדי להבין את הרעיון בקוד אין כמעט מנוס מלהכניס לתמונה <a href="http://he.wikipedia.org/wiki/%D7%90%D7%9C%D7%92%D7%91%D7%A8%D7%94_%D7%9C%D7%99%D7%A0%D7%90%D7%A8%D7%99%D7%AA">אלגברה לינארית</a>.

שדה המשחק שלנו הוא מרחבים וקטוריים מעל {::nomarkdown}\( \mathbb{F}_{2}\){:/nomarkdown} - השדה הסופי בן שני איברים (0 ו-1, עם כללי החיבור והכפל הרגילים, כשב"רגילים" הכוונה לכך ש-{::nomarkdown}\( 1+1=0\){:/nomarkdown}). "מרחב וקטורי מעל השדה הזה" הוא בסך הכל אוסף של סדרות מאורך נתון כלשהו של איברים מ-{::nomarkdown}\( \mathbb{F}_{2}\){:/nomarkdown}; למשל, אם המרחב הוקטורי הוא ממימד 3, אז אברי המרחב הם {::nomarkdown}\( \left(0,0,0\right),\left(0,1,0\right)\){:/nomarkdown} וכן הלאה. בקיצור, טרם חידשנו משהו. כעת יש להכניס לתמונה את שאר התכונות של מרחב וקטורי: אם {::nomarkdown}\( v_{1},v_{2}\){:/nomarkdown} הם איברים של המרחב הוקטורי, כך גם {::nomarkdown}\( v_{1}+v_{2}\){:/nomarkdown} (כשחיבור הוא "רכיב-רכיב", כלומר {::nomarkdown}\( \left(1,0,1\right)+\left(1,1,0\right)=\left(0,1,1\right)\){:/nomarkdown} ). מי שמכיר אלגברה לינארית יודע שיש גם דרישה של כפל בסקלר, אבל במקרה הזה היא לא מעניינת במיוחד (למה?)

בואו נחשוב לרגע שוב על קודים באופן כללי. קוד פשוט יכול להיות קוד שלוקח מילה {::nomarkdown}\( w\){:/nomarkdown} וממיר אותה במילת הקוד {::nomarkdown}\( \left(w,f\left(w\right)\right)\){:/nomarkdown} כש-{::nomarkdown}\( f\){:/nomarkdown} היא פונקציה שמקבלת את {::nomarkdown}\( w\){:/nomarkdown} ופולטת ביט בודד. אם נרצה שהקוד יהיה לינארי (ואנחנו רוצים, שכן קודים לינאריים הם קלים מאוד לניתוח), אז חיבור של שתי מילות קוד צריך לתת בעצמו מילת קוד, כלומר צריך שיתקיים ש-{::nomarkdown}\( \left(w,f\left(w\right)\right)+\left(v,f\left(v\right)\right)=\left(w+v,f\left(w\right)+f\left(v\right)\right)\){:/nomarkdown} יהיה בעצמו מילת קוד חוקית, כלומר שיתקיים {::nomarkdown}\( f\left(w+v\right)=f\left(w\right)+f\left(v\right)\){:/nomarkdown}. התכונה הזו נקראת "לינאריות של {::nomarkdown}\( f\){:/nomarkdown}". נסכם - אם אנחנו רוצים לבנות את הקוד שלנו על ידי כך שנוסיף ל-{::nomarkdown}\( w\){:/nomarkdown} עוד ביטים לאחריו, שמחושבים באופן מסויים מ-{::nomarkdown}\( w\){:/nomarkdown}, אז כל ביט שכזה חייב להיות מחושב באמצעות פונקציה לינארית.

קוד הדמר לוקח את הגישה הזו עד הסוף - הוא אומר "בואו נוסיף אחרי {::nomarkdown}\( w\){:/nomarkdown} את <strong>כל</strong> הביטים האפשריים שיכולים להתקבל מחישוב של פונקציה לינארית כלשהי". זה מייד מעלה את השאלה איך בכלל אפשר למצוא ולייצג את כל הפונקציות הלינאריות הללו. זה שוב עניין לסטודנטים לאלגברה לינארית; אבל אפשר להראות שאם {::nomarkdown}\( v=\left(v_{1},v_{2},\dots,v_{n}\right)\){:/nomarkdown} הוא וקטור, אז כל פונקציה לינארית היא מהצורה {::nomarkdown}\( f\left(v\right)=\sum_{i=1}^{n}a_{i}v_{i}\){:/nomarkdown}, כשכל {::nomarkdown}\( a_{i}\){:/nomarkdown} הוא או 0 או 1. זו הפשטה נוראית של מה שקורה במקרה הכללי יותר, של מרחב מעל שדה גדול יותר - אבל אני רוצה לא לגלוש לדיון הכללי כרגע.

כעת, הנה אבחנה מעניינת נוספת - {::nomarkdown}\( a=\left(a_{1},a_{2},\dots,a_{n}\right)\){:/nomarkdown} הוא בעצמו איבר המרחב הוקטורי ממימד {::nomarkdown}\( n\){:/nomarkdown} מעל {::nomarkdown}\( \mathbb{F}_{2}\){:/nomarkdown}, כלומר אפשר לייצג כל פונקציה לינארית מהמרחב הוקטורי הזה באמצעות <strong>איבר</strong> מהמרחב הוקטורי הזה! (גם זו תוצאה כללית בהרבה מכפי שאני מציג אותה כאן). כדי לפשט את הסימונים, מגדירים {::nomarkdown}\( a\cdot v=\sum_{i=1}^{n}a_{i}v_{i}\){:/nomarkdown} - לדבר הזה קוראים "מכפלה סקלרית". מכפלה סקלרית דומה למדי לכפל "רגיל", למשל {::nomarkdown}\( a\left(v_{1}+v_{2}\right)=av_{1}+av_{2}\){:/nomarkdown} (התכונה הזו תהיה חשובה בקרוב). נסו להוכיח את התכונה הזו - זה קל למדי, ומסתמך באופן חזק על התכונה הדומה עבור כפל "רגיל".

כעת, אם יש לנו מילה {::nomarkdown}\( w\in\mathbb{F}_{2}^{n}\){:/nomarkdown} (כלומר, רצף של {::nomarkdown}\( n\){:/nomarkdown} ספרות שהן אפס או אחד), אפשר להתעלל קצת בסימונים ולהגיד שנשתמש ב-{::nomarkdown}\( w\){:/nomarkdown} גם כדי לתאר את המילה המקודדת, ולסמן בתור {::nomarkdown}\( w_{a}\){:/nomarkdown} את הביט המתאים במילה המקודדת שמתקבל על ידי חישוב {::nomarkdown}\( a\cdot w\){:/nomarkdown} (ובפירוט יתר: הביט שמתאים להפעלה של הפונקציה הלינארית שמיוצגת על ידי {::nomarkdown}\( a\){:/nomarkdown} על המילה {::nomarkdown}\( w\){:/nomarkdown}). עכשיו אפשר לשים לב לכך שההפרדה המקורית שלנו את מילת הקוד ל"קודם כל המילה המקורית, ואז התוצאה של הפעלת כמה פונקציות לינאריות עליה" היא מלאכותית למדי; גם הביטים של מילת הקוד עצמה יכולים להתקבל מהפעלה של פונקציות לינאריות. למשל, הביט הראשון של {::nomarkdown}\( w\){:/nomarkdown} מתקבל על ידי כפל עם המילה {::nomarkdown}\( e_{1}=\left(1,0,0,\dots,0\right)\){:/nomarkdown}, הביט השני על ידי כפל עם {::nomarkdown}\( e_{2}=\left(0,1,0,0,\dots,0\right)\){:/nomarkdown} וכן הלאה. מעתה אמרו - הקידוד של {::nomarkdown}\( w\){:/nomarkdown} הוא פשוט אוסף ההפעלות של כל הפונקציות הלינאריות האפשריות על {::nomarkdown}\( w\){:/nomarkdown}. לקידוד הזה יש מחיר - אנחנו מקודדים {::nomarkdown}\( n\){:/nomarkdown} ביטים באמצעות {::nomarkdown}\( 2^{n}\){:/nomarkdown} ביטים (כי יש {::nomarkdown}\( 2^{n}\){:/nomarkdown} פונקציות לינאריות אפשריות - למה?) - ניפוח אקספוננציאלי של המידע המקורי.

למה זה מועיל? כי במובן מסויים, זה לוקח את המילה {::nomarkdown}\( w\){:/nomarkdown} ו"מורח" את הביטים שלה טוב-טוב. כל קומבינציה אפשרית של ביטים של {::nomarkdown}\( w\){:/nomarkdown} באה לידי ביטוי איפה שהוא במילת הקוד. לכן לדגום באקראי ביט מתוך מילת הקוד בעצם שקול לדגימה אקראית של<strong> מספר כלשהו</strong> של ביטים מתוך {::nomarkdown}\( w\){:/nomarkdown}; יותר במדוייק, אם אני בוחר ביט במילת קוד באקראי, אני בעצם מגריל אינדקס {::nomarkdown}\( a\){:/nomarkdown} באקראי וקורא את {::nomarkdown}\( w_{a}\){:/nomarkdown}; והגרלה של {::nomarkdown}\( a\){:/nomarkdown} באופן אקראי (בהתפלגות אחידה) פירושו שכל קוארדינטה של {::nomarkdown}\( a\){:/nomarkdown} מוגרלת בהסתברות {::nomarkdown}\( \frac{1}{2}\){:/nomarkdown} ל-0 ו-{::nomarkdown}\( \frac{1}{2}\){:/nomarkdown} ל-1. כלומר, בדגימה אקראית של ביט ממילת הקוד אנחנו מגרילים כל ביט מ-{::nomarkdown}\( w\){:/nomarkdown} בהסתברות חצי. האבחנה הזו היא המפתח לכך שקוד הדמר ניתן לבדיקה מקומית.

בואו ננסח במדוייק כעת מה מטרתו של בודק מקומי עבור הקוד. הדרישה היא שבהינתן מילת קוד חוקית, הבודק יגיד "כן", ובהינתן מילה שאינה מילת קוד, הבודק יגיד "לא" בהסתברות סבירה, שתלויה במרחק המילה ממילת קוד חוקית. נאמר שהמילה {::nomarkdown}\( w\){:/nomarkdown} רחוקה עד כדי {::nomarkdown}\( \delta\){:/nomarkdown} ממילת קוד חוקית, כש-{::nomarkdown}\( 0&lt;\delta\le1\){:/nomarkdown}, אם צריך לשנות {::nomarkdown}\( \delta\){:/nomarkdown} מהכניסות של {::nomarkdown}\( w\){:/nomarkdown} כדי לקבל מילת קוד חוקית (למשל, אם {::nomarkdown}\( \delta=\frac{1}{4}\){:/nomarkdown} זה אומר שצריך לשנות רבע מהכניסות של {::nomarkdown}\( w\){:/nomarkdown}). לאלו מכם שרוצים פורמליזם, ההגדרה המדוייקת היא {::nomarkdown}\( \delta=\min_{w^{\prime}\in C}\frac{d\left(w,w^{\prime}\right)}{\left\|w\right\|}\){:/nomarkdown}. זהו בעצם המרחק במשמעותו המקורית כשהוא מנורמל באופן שמתחשב באורך המילים - "המרחק היחסי" שבין המילים. מכניסים אותו לתמונה כי הוא מפשט את הניסוחים הטכניים.

אם כן, מה שאראה הוא בודק מקומי שעל מילה שאיננה מילת קוד חוקית, מזהה זאת בהסתברות של {::nomarkdown}\( \frac{\delta}{2}\){:/nomarkdown} לפחות, אך לא יותר מ-{::nomarkdown}\( \frac{2}{9}\){:/nomarkdown}. זאת אומרת שאם {::nomarkdown}\( \delta&lt;\frac{4}{9}\){:/nomarkdown}, אז ההסתברות שתתגלה שגיאה היא {::nomarkdown}\( \frac{\delta}{2}\){:/nomarkdown} (ולכן עבור {::nomarkdown}\( \delta\){:/nomarkdown} קטן היא לא גדולה; אבל היא לינארית ב-{::nomarkdown}\( \delta\){:/nomarkdown}, וזה טוב), ועבור ערכים גדולים יותר יש הסתברות קבועה של {::nomarkdown}\( \frac{2}{9}\){:/nomarkdown} לגלות שגיאה ולכן על ידי הפעלות נשנות של הבודק אפשר "לנפח" את ההסתברות לגילוי שגיאה עד שתתקרב כרצוננו ל-1. ה"מחיר" יהיה קריאה של בדיוק שלושה ביטים מהקלט; כמובן שה"ניפוח" מצריך קריאה של עוד ביטים, אבל עדיין מספר קבוע שאינו תלוי ב-{::nomarkdown}\( n\){:/nomarkdown}. כאן אנחנו מתחילים להרגיש את ה-PCP שהזכרתי בפוסט הקודם; גם שם הרעיון הוא קריאה של מספר קבוע של ביטים.

ואיך הבודק עובד? באופן כמעט מגוחך. הוא בוחר באקראי וקטורים {::nomarkdown}\( a,b\){:/nomarkdown} וקורא את {::nomarkdown}\( w_{a},w_{b}\){:/nomarkdown}. כזכור, הערכים הללו הם {::nomarkdown}\( a\cdot w,b\cdot w\){:/nomarkdown}, ועל פי כללי הכפל נובע ש-{::nomarkdown}\( aw+bw=\left(a+b\right)w\){:/nomarkdown}, מה שמוביל אותנו בקלות לביט הנוסף שיש לדגום - הוא קורא את {::nomarkdown}\( w_{a+b}\){:/nomarkdown} ובודק האם {::nomarkdown}\( w_{a+b}=w_{a}+w_{b}\){:/nomarkdown}. אם כן - הוא מקבל (או מתחיל סיבוב בדיקה חדש); אם לא, הוא דוחה. כל כך פשוט.

טוב, אבל למה זה עובד? התשובה הקצרה היא "זה טכני". התשובה הארוכה היא "זה טכני, אבל אראה את זה בכל זאת ובתקווה לא אאבד יותר מדי אנשים, כי זו אחת מההוכחות האהובות עלי". אני מקווה שברור מדוע אם {::nomarkdown}\( w\){:/nomarkdown} היא מילת קוד חוקית הבדיקה עובדת - נימקתי זאת לעיל. השאלה היא מה קורה אם {::nomarkdown}\( w\){:/nomarkdown} אינה מילת קוד חוקית.

הבה ונסמן את ההסתברות שהבודק ידחה את המילה {::nomarkdown}\( w\){:/nomarkdown} ב-{::nomarkdown}\( \varepsilon\){:/nomarkdown}. אם {::nomarkdown}\( \varepsilon\ge\frac{2}{9}\){:/nomarkdown}, "ניצחנו" - הראנו שהבודק עובד טוב על {::nomarkdown}\( w\){:/nomarkdown}. לכן ההנחה היא ש-{::nomarkdown}\( \varepsilon&lt;\frac{2}{9}\){:/nomarkdown}. מה שרוצים להראות הוא שמכך נובע שהמרחק היחסי של {::nomarkdown}\( w\){:/nomarkdown} ממילת הקוד החוקית הקרובה ביותר (שהוא, כזכור, {::nomarkdown}\( \delta\){:/nomarkdown}) לא עולה על {::nomarkdown}\( 2\varepsilon\){:/nomarkdown} (כלומר - {::nomarkdown}\( \delta\le2\varepsilon\){:/nomarkdown}, או {::nomarkdown}\( \varepsilon\ge\frac{\delta}{2}\){:/nomarkdown}). בקיצור - רוצים למצוא איכשהו מילת קוד חוקית שקרובה יחסית ל-{::nomarkdown}\( w\){:/nomarkdown}. אה, אבל זה בדיוק מה שקודים לתיקון שגיאות עושים - בהינתן מילה "מקולקלת", מראים כיצד לתקן אותה.

כאן מגיע הרעיון המרכזי בהוכחה, שהוא מקסים. כיצד תיבנה אותה מילת קוד, שאסמן בתור {::nomarkdown}\( v\){:/nomarkdown}? באופן הבא. הכניסה {::nomarkdown}\( v_{a}\){:/nomarkdown} במילה תוגדר בתור "הצבעת הרוב" של {::nomarkdown}\( w\){:/nomarkdown}. למה הכוונה? אנחנו יודעים ש<strong>אם</strong> {::nomarkdown}\( w\){:/nomarkdown} הייתה מילה חוקית, אז היה מתקיים {::nomarkdown}\( w_{a}+w_{b}=w_{a+b}\){:/nomarkdown} לכל {::nomarkdown}\( b\){:/nomarkdown} אפשרי, או בניסוח אחר - {::nomarkdown}\( w_{a}=w_{a+b}-w_{b}\){:/nomarkdown}. לרוע המזל {::nomarkdown}\( w\){:/nomarkdown} איננה מילת קוד חוקית ולכן זה לא מתקיים עבורה תמיד - כלומר, ייתכן ש-{::nomarkdown}\( w_{a+b}-w_{b}\){:/nomarkdown} לא תמיד מחזיר את אותו ערך, כאשר משנים את הערכים ש-{::nomarkdown}\( b\){:/nomarkdown} מקבל. עם זאת, הערך שמופיע מספר רב יותר של פעמים הוא כנראה הערך ה"נכון" עבור {::nomarkdown}\( w\){:/nomarkdown}. אם כן, התיקון של {::nomarkdown}\( w\){:/nomarkdown} יהיה {::nomarkdown}\( v\){:/nomarkdown} כך ש-{::nomarkdown}\( v_{a}=\mbox{majority}_{b}\left\{ w_{a+b}-w_{b}\right\} \){:/nomarkdown}, כאשר {::nomarkdown}\( \mbox{majority}\){:/nomarkdown} היא פונקציה שמחזירה את האיבר השכיח יותר ב"קבוצה" שהיא מקבלת ("קבוצה" במרכאות כי בדרך כלל בקבוצות כל איבר נספר פעם אחת, וכאן למספר המופעים יש חשיבות מכרעת).

צריך כעת להראות שני דברים: ראשית ש-{::nomarkdown}\( v\){:/nomarkdown} היא בכלל מילת קוד חוקית; שנית, שהיא קרובה ל-{::nomarkdown}\( w\){:/nomarkdown} עד כדי {::nomarkdown}\( 2\varepsilon\){:/nomarkdown} - פורמלית נסמן זאת {::nomarkdown}\( d\left(w,v\right)&lt;\varepsilon\){:/nomarkdown}. נתחיל דווקא מהתוצאה השניה. האינטואיציה כאן אינה קשה - אם {::nomarkdown}\( w_{a}\ne v_{a}\){:/nomarkdown}, אז אם הבודק המקומי יבחר את {::nomarkdown}\( a\){:/nomarkdown} כאחת משתי הקוארדינטות שהוא בודק, יהיה לו סיכוי של לפחות חצי לעלות על שגיאה, שהרי {::nomarkdown}\( w_{a}\){:/nomarkdown} <strong>אינו</strong> מתאים לכלל הצבעת הרוב, ולכן עבור רוב הערכים של {::nomarkdown}\( b\){:/nomarkdown} שהבודק יגריל, יתקיים ש-{::nomarkdown}\( w_{a}\ne w_{a+b}-w_{b}\){:/nomarkdown} (כלומר, {::nomarkdown}\( w_{a}+w_{b}\ne w_{a+b}\){:/nomarkdown}). כעת, שימו לב שהסיכוי של הבודק ליפול על {::nomarkdown}\( a\){:/nomarkdown} שמקיים {::nomarkdown}\( w_{a}\ne v_{a}\){:/nomarkdown} הוא בדיוק המרחק היחסי שלהם; ואם הבודק כבר נפל על {::nomarkdown}\( a\){:/nomarkdown} שכזה, ההסתברות שלו ליפול על {::nomarkdown}\( b\){:/nomarkdown} שיכשיל את {::nomarkdown}\( w\){:/nomarkdown} היא לפחות חצי; ולכן ההסתברות של הבודק לדחות את {::nomarkdown}\( w\){:/nomarkdown} היא לפחות {::nomarkdown}\( \frac{1}{2}d\left(w,v\right)\){:/nomarkdown}; אבל סימנו ב-{::nomarkdown}\( \varepsilon\){:/nomarkdown} את ההסתברות של הבודק לדחות את {::nomarkdown}\( w\){:/nomarkdown}, כלומר {::nomarkdown}\( \frac{1}{2}d\left(w,v\right)\le\varepsilon\){:/nomarkdown}, כלומר {::nomarkdown}\( \delta\le d\left(w,v\right)\le2\varepsilon\){:/nomarkdown}.

אם כן, נותר אתגר בודד - להראות ש-{::nomarkdown}\( v\){:/nomarkdown} היא מילת קוד חוקית. כפי שניתן לנחש, זה המקום שבו {::nomarkdown}\( \frac{2}{9}\){:/nomarkdown} המסתורי יבוא לידי ביטוי. ברשותכם, ארשה לעצמי להמשיך להיות טכני ולהציג את ההוכחה במלואה. ראשית כל צריך להבהיר לעצמנו כיצד ניתן להוכיח שמילה כלשהי {::nomarkdown}\( v\){:/nomarkdown} היא מילת קוד חוקית. דרך אחת היא להראות איך מילה בת {::nomarkdown}\( n\){:/nomarkdown} ביטים ממופה ל-{::nomarkdown}\( v\){:/nomarkdown} על ידי הקוד; אבל זה די מסורבל. הרבה יותר נחמד להשתמש בקריטריון הבדיקה שכבר הצגנו, ומסתבר שזה אכן מספיק: אם {::nomarkdown}\( v_{a}+v_{b}=v_{a+b}\){:/nomarkdown} לכל {::nomarkdown}\( a,b\){:/nomarkdown}, אז {::nomarkdown}\( v\){:/nomarkdown} היא מילת קוד חוקית. האבחנה הזו טבעית למדי - הרי כפי שראינו, גם הביטים של "המילה המקורית" שממנה התקבל הקוד מקודדים בתוך {::nomarkdown}\( v\){:/nomarkdown} (הביט ה-{::nomarkdown}\( i\){:/nomarkdown} מקודד כ-{::nomarkdown}\( v_{e_{i}}\){:/nomarkdown}) ומתכונת החיבוריות הזו נובע שלכל {::nomarkdown}\( a=\sum\alpha_{i}e_{i}\){:/nomarkdown} מתקיים {::nomarkdown}\( v_{a}=v_{\sum\alpha_{i}e_{i}}=\sum\alpha_{i}v_{e_{i}}\){:/nomarkdown}, כנדרש.

אם כן, מספיק לקחת {::nomarkdown}\( a,b\){:/nomarkdown} שרירותיים ולהראות שעבורם מתקיים {::nomarkdown}\( v_{a}+v_{b}=v_{a+b}\){:/nomarkdown}. באופן די מפתיע, ההוכחה היא כמעט מיידית אם רק נראה עוד משהו אחד - ש"הכרעת הרוב" שמגדירה את {::nomarkdown}\( v_{a}\){:/nomarkdown} היא לא סתם הכרעת רוב, אלא הכרעת רוב מוחץ: שלפחות {::nomarkdown}\( \frac{2}{3}\){:/nomarkdown} מה"הצבעות" {::nomarkdown}\( w_{a+b}-w_{a}\){:/nomarkdown} נתנו את הערך של {::nomarkdown}\( v_{a}\){:/nomarkdown} ולא את הערך השני האפשרי. קודם כל אסביר מדוע זה מסיים את העניין ואז אוכיח זאת.

הטריק הוא להשתמש בשיטה ההסתברותית - להוכיח שמשהו קיים על ידי כך שמראים שההסתברות למציאתו במרחב החיפוש שלנו גדולה מאפס. מה שאנו מחפשים הוא מילה {::nomarkdown}\( c\){:/nomarkdown} שתקיים את שלוש התכונות הבאות <strong>בו זמנית</strong>:
<ol>
	<li> {::nomarkdown}\( v_{a}=w_{c}-w_{a+c}\){:/nomarkdown}</li>
	<li> {::nomarkdown}\( v_{b}=w_{b+c}-w_{c}\){:/nomarkdown}</li>
	<li> {::nomarkdown}\( v_{a+b}=w_{b+c}-w_{a+c}\){:/nomarkdown}</li>
</ol>
אם מצאנו {::nomarkdown}\( c\){:/nomarkdown} כזה, סיימנו. למה? שכן אז {::nomarkdown}\( v_{a}+v_{b} = \left(w_{c}-w_{a+c}\right)+\left(w_{b+c}-w_{c}\right)=w_{b+c}-w_{a+c}=v_{a+b}\){:/nomarkdown} כנדרש. אז למה קיים {::nomarkdown}\( c\){:/nomarkdown} כזה? ובכן, בואו נביט לרגע על המשוואה הראשונה, {::nomarkdown}\( v_{a}=w_{c}-w_{a+c}\){:/nomarkdown}. מכיוון שפעולת החיבור מתבצעת מעל {::nomarkdown}\( \mathbb{F}_{2}\){:/nomarkdown} (כלומר, {::nomarkdown}\( 1+1=0\){:/nomarkdown}, או במילים אחרות {::nomarkdown}\( 1=-1\){:/nomarkdown}), זו בדיוק אותה משוואה כמו {::nomarkdown}\( v_{a}=w_{a+c}-w_{c}\){:/nomarkdown}

מה ההסתברות, אם מגרילים {::nomarkdown}\( c\){:/nomarkdown}, שהיא לא מתקיימת? בדיוק ההסתברות ש-{::nomarkdown}\( c\){:/nomarkdown} יהיה אחד מקולות המיעוט בהצבעה שקבעה את {::nomarkdown}\( v_{a}\){:/nomarkdown}. מכיוון שאמרנו שהרוב בהצבעה היה לפחות {::nomarkdown}\( \frac{2}{3}\){:/nomarkdown}, נובע מכך שההסתברות ש-{::nomarkdown}\( c\){:/nomarkdown} יהיה "מקלקל" שכזה היא לכל היותר {::nomarkdown}\( \frac{1}{3}\){:/nomarkdown}. באופן דומה גם עבור שני התנאים האחרים אפשר להראות שההסתברות לכך ש-{::nomarkdown}\( c\){:/nomarkdown} לא יקיים אותם היא לכל היותר {::nomarkdown}\( \frac{1}{3}\){:/nomarkdown}. כעת, <a href="http://en.wikipedia.org/wiki/Boole%27s_inequality">חסם טריוויאלי</a> בהסתברות (שמכונה Union bound) אומר כי אם יש לנו קבוצת מאורעות, אז ההסתברות שלפחות אחד מהם יתרחש היא לכל היותר סכום ההסתברויות של כולם. כאן יש לנו שלושה מאורעות שההסתברות של כל אחד מהם קטנה מ-{::nomarkdown}\( \frac{1}{3}\){:/nomarkdown}, ולכן ההסתברות שלפחות אחד מהם יקרה קטנה מ-{::nomarkdown}\( 1\){:/nomarkdown} - כלומר, קיים {::nomarkdown}\( c\){:/nomarkdown} שלא מקיים אף אחד מהמאורעות. מכיוון שהמאורעות היו "1 מתקלקל", "2 מתקלקל" ו-"3 מתקלקל", קיבלנו שיש {::nomarkdown}\( c\){:/nomarkdown} שעבורו אף אחד משלושת התנאים אינו מתקלקל - כלומר, סיימנו.

נותר רק להראות שאכן מתקיימת "הכרעת רוב מוחץ", כלומר שעבור לפחות {::nomarkdown}\( \frac{2}{3}\){:/nomarkdown} מה-{::nomarkdown}\( b\){:/nomarkdown}-ים האפשריים מתקיים {::nomarkdown}\( v_{a}=w_{a+b}-w_{b}\){:/nomarkdown}.

הבה ונסמן את גודל הרוב ב-{::nomarkdown}\( p\){:/nomarkdown}, כלומר {::nomarkdown}\( \mbox{Pr}\left[v_{a}=w_{a+b}-w_{b}\right]=p\){:/nomarkdown} ({::nomarkdown}\( \mbox{Pr}\){:/nomarkdown} הוא סימון סטנדרטי להסתברות של המאורע שבסוגריים; ההסתברות נלקחת על פני הבחירות האקראיות של {::nomarkdown}\( b\){:/nomarkdown}). כעת נשדרג את המשחק - נניח שאנחנו בוחרים באקראי <strong>שני</strong> "מצביעים", {::nomarkdown}\( b,c\){:/nomarkdown} ושואלים אותם לדעתם; מה ההסתברות שהם יגידו את אותו הדבר? כלומר, מהו {::nomarkdown}\( \mbox{Pr}\left[w_{a+b}-w_{b}=w_{a+c}-w_{c}\right]\){:/nomarkdown}? ובכן, אחד משניים: או ששניהם הצביעו לערך שהרוב בחרו, בהסתברות {::nomarkdown}\( p\){:/nomarkdown} כל אחד ולכן {::nomarkdown}\( p^{2}\){:/nomarkdown} לשניהם יחד; או ששניהם הצביעו עבור הערך השני, בהסתברות {::nomarkdown}\( \left(1-p\right)\){:/nomarkdown} כל אחד ולכן {::nomarkdown}\( \left(1-p\right)^{2}\){:/nomarkdown} לשניהם יחד. סה"כ ההסתברות שהם מסכימים היא {::nomarkdown}\( p^{2}+\left(1-p\right)^{2}\){:/nomarkdown}. אם נצליח למצוא חסם תחתון כלשהו על ההסתברות הזו, נוכל לחלץ מהמשוואה (ומכך ש-{::nomarkdown}\( p\ge\frac{1}{2}\){:/nomarkdown}) חסם תחתון על {::nomarkdown}\( p\){:/nomarkdown}. כאן גם מתחילה ה"הנדסה לאחור" שלבסוף תניב את ה-{::nomarkdown}\( \frac{2}{9}\){:/nomarkdown} הידוע לשמצה - אנחנו מחפשים חסם תחתון על {::nomarkdown}\( p^{2}+\left(1-p\right)^{2}\){:/nomarkdown} שיגרור {::nomarkdown}\( p&gt;\frac{2}{3}\){:/nomarkdown}; קצת משחק בפרמטרים ופתרון משוואה ריבועית יראה כי החסם התחתון הזה הוא {::nomarkdown}\( \frac{5}{9}\){:/nomarkdown} (נסו זאת בבית!).

נסכם: עלינו להראות כי {::nomarkdown}\( \mbox{Pr}\left[w_{a+b}-w_{b}=w_{a+c}-w_{c}\right]&gt;\frac{5}{9}\){:/nomarkdown}. הטכניקה דומה לטכניקה שכבר השתמשתי בה. ראשית נשים לב לכך ש-{::nomarkdown}\( \mbox{Pr}\left[w_{a+b}-w_{b}=w_{a+c}-w_{c}\right] = \mbox{Pr}\left[w_{a+b}+w_{c}=w_{a+c}+w_{b}\right]\){:/nomarkdown}

כעת שני האגפים הם "מאוזנים" במידת מה - בכולם מופיעים גם {::nomarkdown}\( a\){:/nomarkdown}, גם {::nomarkdown}\( b\){:/nomarkdown} וגם {::nomarkdown}\( c\){:/nomarkdown}. יותר מכך - אם {::nomarkdown}\( w\){:/nomarkdown} הייתה מילת קוד חוקית, שני האגפים היו שווים ל-{::nomarkdown}\( w_{a+b+c}\){:/nomarkdown}. לכן ההסתברות של המאורע שלמטה היא בעצם ההסתברות שלא חל "קלקול" בחישוב של {::nomarkdown}\( w_{a+b+c}\){:/nomarkdown} לא באמצעות {::nomarkdown}\( w_{a+b}+w_{c}\){:/nomarkdown}, וגם לא באמצעות {::nomarkdown}\( w_{a+c}+w_{b}\){:/nomarkdown}. לכן שוב נשאל את עצמנו - מה ההסתברות שכן חל קלקול באחד משני המקרים הללו?

אם כן, מה ההסתברות ש-{::nomarkdown}\( w_{a+b}+w_{c}\ne w_{a+b+c}\){:/nomarkdown}? זה טיפה מבלבל מכיוון שהן {::nomarkdown}\( b\){:/nomarkdown} והן {::nomarkdown}\( c\){:/nomarkdown} נבחרו באקראי ואילו {::nomarkdown}\( a\){:/nomarkdown} נקבע מראש, אבל אפשר לפשט קצת את העניינים: אם {::nomarkdown}\( b\){:/nomarkdown} נבחר באקראי ובהתפלגות אחידה מבין כל הערכים האפשריים, ו-{::nomarkdown}\( a\){:/nomarkdown} קבוע, אז גם {::nomarkdown}\( a+b\){:/nomarkdown} מוגרל בהתפלגות אחידה מבין כל הערכים האפשריים (למה?). לכן אפשר לסמן לצורך פשטות {::nomarkdown}\( a^{\prime}=a+b\){:/nomarkdown} ולשאול את עצמנו את השאלה הפשוטה יותר: מהי ההסתברות ש-{::nomarkdown}\( w_{a^{\prime}}+w_{c}\ne w_{a^{\prime}+c}\){:/nomarkdown} כאשר הן {::nomarkdown}\( a^{\prime}\){:/nomarkdown} והן {::nomarkdown}\( c\){:/nomarkdown} נבחרים באקראי? ואת התשובה לשאלה הזו אנחנו יודעים: ההסתברות הזו חסומה על ידי ההסתברות שהבודק ידחה את {::nomarkdown}\( w\){:/nomarkdown} - שהרי זה בדיוק מה שהבודק עושה - מגריל שני אינדקסים ומבצע את בדיקת השוויון שלעיל.

כזכור, בתחילת הדיון הזה הנחנו שהסתברות הדחייה של הבודק היא נמוכה יחסית - נמוכה מ-{::nomarkdown}\( \frac{2}{9}\){:/nomarkdown} (כי במקרה שהיא גבוהה יותר אין מה להראות). מכאן שההסתברות ש-{::nomarkdown}\( w_{a+b}+w_{c}\ne w_{a+b+c}\){:/nomarkdown} קטנה מ-{::nomarkdown}\( \frac{2}{9}\){:/nomarkdown}, וגם ההסתברות ש-{::nomarkdown}\( w_{a+c}+w_{b}\ne w_{a+b+c}\){:/nomarkdown} קטנה מ-{::nomarkdown}\( \frac{2}{9}\){:/nomarkdown}, ולכן על פי ה-Union bound נקבל שההסתברות שאף אחד משני מאורעות אלו אינו מתרחש, ולכן {::nomarkdown}\( w_{a+b}+w_{c}=w_{a+c}+w_{b}\){:/nomarkdown}, היא לפחות {::nomarkdown}\( \frac{5}{9}\){:/nomarkdown}, כמו שרצינו. זה מסיים, סוף כל סוף, את ההוכחה כולה.

תרגיל בית למי שרוצה לוודא שהוא אכן הבין את כל החישובים הקטנים והקטנוניים האחרונים, ושה-{::nomarkdown}\( \frac{2}{9}\){:/nomarkdown} שהופיע בהתחלה לא נפל משמיים אלא אפשר להגיע אליו בדרך טבעית: נניח שהיינו רוצים להראות ש-{::nomarkdown}\( p&gt;\frac{3}{4}\){:/nomarkdown} ולא סתם {::nomarkdown}\( p&gt;\frac{2}{3}\){:/nomarkdown}; מהו החסם החדש על {::nomarkdown}\( \varepsilon\){:/nomarkdown} שהיה עלינו לדרוש?
