---
id: 3330
title: "החלפת משתנים בחשבון דיפרנציאלי ואינטגרלי - המשפט הכללי"
date: 2016-04-12 16:29:22
layout: post
categories: 
  - אנליזה מתמטית
tags: 
  - חלוקת יחידה
  - משפט החלפת המשתנים
---
אחרי <a href="http://www.gadial.net/2015/12/31/calculus_change_of_variables/">פוסט המבוא </a>בנושא, אנחנו רוצים להוכיח את משפט החלפת המשתנים הכללי בחדו"א, עבור אינטגרלים {::nomarkdown}\( n\){:/nomarkdown}-ממדיים. לפני הכל נתחיל בלהזכיר מה המשפט אומר: אם {::nomarkdown}\( g:A\to B\){:/nomarkdown} היא דיפאומורפיזם של קבוצות פתוחות ב-{::nomarkdown}\( \mathbb{R}^{n}\){:/nomarkdown} ו-{::nomarkdown}\( f:B\to\mathbb{R}\){:/nomarkdown} רציפה, אז {::nomarkdown}\( f\){:/nomarkdown} אינטגרבילית מעל {::nomarkdown}\( B\){:/nomarkdown} אם ורק אם {::nomarkdown}\( \left(f\circ g\right)\left\|\det Dg\right\|\){:/nomarkdown} אינטגרבילית מעל {::nomarkdown}\( A\){:/nomarkdown} ובמקרה זה מתקיים:

{::nomarkdown}\( \int_{B}f=\int_{A}\left(f\circ g\right)\left\|\det Dg\right\|\){:/nomarkdown}

מכיוון שטרם עשיתי זאת, הגיע הזמן להסביר מה זה דיפאומורפיזם. כמו כל שאר שלל ה"מורפיזמים" במתמטיקה, זה שם לפונקציה ש<strong>משמרת מבנה</strong> מסויים, רק שטרם הסברתי בשום שלב מה המבנה וגם עכשיו אני עדיין דוחה את זה; רק אומר למי שתוהה שזה מבנה של <strong>יריעה חלקה</strong> שיש ל-{::nomarkdown}\( A,B\){:/nomarkdown}, אבל לא אסביר מה זו יריעה חלקה. פורמלית, {::nomarkdown}\( g:A\to B\){:/nomarkdown} היא דיפאומורפיזם מסדר {::nomarkdown}\( r\){:/nomarkdown} אם היא חד-חד-ערכית ועל, כלומר הפיכה, ואם גם {::nomarkdown}\( g\){:/nomarkdown} וגם {::nomarkdown}\( g^{-1}\){:/nomarkdown} הן ב-{::nomarkdown}\( C^{r}\){:/nomarkdown}, כלומר גזירות ברציפות {::nomarkdown}\( r\){:/nomarkdown} פעמים. למי שמכיר את ההגדרה של <strong>הומיאומורפיזם</strong> בטופולוגיה, זו נראית מעין הרחבה של ההגדרה (בהומיאומורפיזם דורשים את הדרישה החלשה יותר ש-{::nomarkdown}\( g\){:/nomarkdown} ו-{::nomarkdown}\( g^{-1}\){:/nomarkdown} יהיו רציפות, ואז {::nomarkdown}\( g\){:/nomarkdown} משמרת את המבנה הטופולוגי של המרחב שהיא פועלת עליו). האינטואיציה למשפט, אם כן, היא זו: האינטגרל של {::nomarkdown}\( f\){:/nomarkdown} בקבוצה {::nomarkdown}\( B\){:/nomarkdown} ניתן לחישוב גם מעל הקבוצה {::nomarkdown}\( A\){:/nomarkdown} שהיא "פחות או יותר {::nomarkdown}\( B\){:/nomarkdown}", אבל עדיין נדרש תיקון מסויים - התיקון הזה הוא ההכפלה ב-{::nomarkdown}\( \left\|\det Dg\right\|\){:/nomarkdown}, שמתאר במובן מסויים עד כמה {::nomarkdown}\( g\){:/nomarkdown} "מעוותת" את המרחב (למשל, אם היא מנפחת את המרחב פי 2, כפי שעושה הפונקציה {::nomarkdown}\( g\left(x\right)=2x\){:/nomarkdown}, ברור שנצטרך לכפול ב-2). שימו לב שהתיקון הזה הוא לא איזה קבוע שבו כופלים את הערך הכולל של האינטגרל וזהו - זה תיקון <strong>נקודתי</strong>. בכל נקודה {::nomarkdown}\( a\in A\){:/nomarkdown} אנחנו בודקים מהי הנגזרת של {::nomarkdown}\( g\){:/nomarkdown} בנקודה הזו, לוקחים את הערך המוחלט של הדטרמיננטה של המטריצה של הנגזרת בנקודה הזו, וזה ה"תיקון" שאנחנו מצמידים לערך ש-{::nomarkdown}\( f\){:/nomarkdown} מחזירה על {::nomarkdown}\( g\left(a\right)\){:/nomarkdown}. זה שינוי של הפונקציה שעליה אנחנו מבצעים אינטגרציה, מ-{::nomarkdown}\( f\){:/nomarkdown}-מופעלת-על-התמונה-של-{::nomarkdown}\( g\){:/nomarkdown} למשהו קצת יותר מסובך.

עכשיו, משאנחנו מבינים את המשפט, אפשר לגשת להוכחה שלו. ההוכחה כבדה למדי, אבל זה לא אומר שהיא לא יפה או מעניינת. כמו כן, אני אנצל את העובדה שאני כותב פוסט לבלוג כדי להציג אותה בגישת Top-down, דהיינו קודם נציג את ההוכחה בלי להיכנס בהכרח לכל הפרטים ולהוכחה של טענות ספציפיות, שאותן נדחה להמשך או נוותר עליהן בכלל. בספרים בדרך כלל קודם כל מבצעים עבודת הכנה לא קטנה עד שניגשים להוכחת המשפט, וזה יכול להיות מעייף למדי (אם כי זו הדרך הנכונה לנקוט בה בספרי לימוד, לטעמי).

ראשית כל נשים לב לכך שהמשפט מנוסח בתור "אם ורק אם", ולכן צריך להוכיח שני כיוונים: גם להוכיח שאם {::nomarkdown}\( f\){:/nomarkdown} אינטגרבילית מעל {::nomarkdown}\( B\){:/nomarkdown} אז {::nomarkdown}\( \left(f\circ g\right)\left\|\det Dg\right\|\){:/nomarkdown} אינטגרבילית מעל {::nomarkdown}\( A\){:/nomarkdown}, וגם להוכיח שאם {::nomarkdown}\( \left(f\circ g\right)\left\|\det Dg\right\|\){:/nomarkdown} אינטגרבילית מעל {::nomarkdown}\( A\){:/nomarkdown} אז {::nomarkdown}\( f\){:/nomarkdown} אינטגרבילית מעל {::nomarkdown}\( B\){:/nomarkdown}, וזאת לכל {::nomarkdown}\( g\){:/nomarkdown} שהיא דיפאומורפיזם. אלא שאם נוכיח את הכיוון הראשון, הכיוון השני מאוד קל כי אפשר לחשוב עליו בתור "המקרה הראשון" עבור {::nomarkdown}\( g^{-1}\){:/nomarkdown}. פורמלית: {::nomarkdown}\( g^{-1}:B\to A\){:/nomarkdown} היא דיפאומורפיזם של קבוצות פתוחות, ונתונה לנו פונקציה {::nomarkdown}\( F:B\to\mathbb{R}\){:/nomarkdown} שהיא אינטגרבילית; זה אומר שגם {::nomarkdown}\( \left(F\circ g^{-1}\right)\left\|\det Dg^{-1}\right\|\){:/nomarkdown} אינטגרבילית מעל {::nomarkdown}\( A\){:/nomarkdown}. אבל מהי {::nomarkdown}\( F\){:/nomarkdown} הזו? כמובן, {::nomarkdown}\( F=\left(f\circ g\right)\left\|\det Dg\right\|\){:/nomarkdown} - זו פונקציה רציפה מעל {::nomarkdown}\( B\){:/nomarkdown} ש<strong>נתון</strong> לי שהיא אינטגרבילית (כי אני בכיוון השני של המשפט, שזה הנתון בו). עכשיו יש לנו סתם חשבון פשוט כדי לראות ש-{::nomarkdown}\( \left(F\circ g^{-1}\right)\left\|\det Dg^{-1}\right\|\){:/nomarkdown} זו דרך מפוצצת לכתוב {::nomarkdown}\( f\){:/nomarkdown}:

{::nomarkdown}\( \left(F\circ g^{-1}\right)\left\|\det Dg^{-1}\right\|\left(y\right)=F\left(g^{-1}\left(y\right)\right)\left\|\det Dg^{-1}\left(y\right)\right\|=\){:/nomarkdown}

{::nomarkdown}\( =f\left(g\left(g^{-1}\left(y\right)\right)\right)\cdot\left\|\det Dg\left(g^{-1}\left(y\right)\right)\right\|\cdot\left\|\det Dg^{-1}\left(y\right)\right\|\){:/nomarkdown}

{::nomarkdown}\( =f\left(y\right)\left\|\det Dg^{-1}\left(y\right)\right\|^{-1}\left\|\det Dg^{-1}\left(y\right)\right\|=f\left(y\right)\){:/nomarkdown}

שימו לב למעבר {::nomarkdown}\( \left\|\det Dg\left(g^{-1}\left(y\right)\right)\right\|=\left\|\det Dg^{-1}\left(y\right)\right\|^{-1}\){:/nomarkdown} שעשוי לבלבל - זו תוצאה ישירה של הפעלת כלל השרשרת על פונקציות הפיכות; הראיתי את זה <a href="http://www.gadial.net/2015/08/19/multivariable_derivative_properties/">כאן</a>.

סיימנו את הכיוון הזה. נשאר לנו רק העיקר - להראות שאם {::nomarkdown}\( f\){:/nomarkdown} אינטגרבילית, כך גם {::nomarkdown}\( \left(f\circ g\right)\left\|\det Dg\right\|\){:/nomarkdown}, ושהאינטגרלים שווים. כדי לעשות לעצמנו את החיים קלים, משתמשים ב<strong>שלוש </strong>טכניקות פישוט סטנדרטיות: ראשית, משתמשים באינדוקציה על המימד {::nomarkdown}\( n\){:/nomarkdown} של המרחב. מקרה הבסיס, כש-{::nomarkdown}\( n=1\){:/nomarkdown}, כבר טופל חלקית <a href="http://www.gadial.net/2015/12/31/calculus_change_of_variables/">בפוסט על שיטת ההצבה</a>; עוד מעט אסביר למה המקרה הזה בכל זאת כללי קצת יותר, ואראה איך מוכיחים אותו.

שנית, אנחנו מניחים ש-{::nomarkdown}\( g\){:/nomarkdown} היא <strong>מאוד</strong> נחמדה, במובן זה שהיא <strong>קבועה</strong> על הקואורדינטה ה-{::nomarkdown}\( n\){:/nomarkdown}-ית במרחב. דהיינו, {::nomarkdown}\( g\left(x_{1},\dots,x_{n}\right)=\left(y_{1},\dots,y_{n-1},x_{n}\right)\){:/nomarkdown}. העובדה ש-{::nomarkdown}\( g\){:/nomarkdown} טריוויאלית לגמרי על הקואורדינטה ה-{::nomarkdown}\( n\){:/nomarkdown}-ית מאפשרת לנו להשתמש יחסית בקלות בהנחת האינדוקציה כדי להוכיח את הנדרש. לדיפאומורפיזם כזה שהוא קבוע על אחת מהקואורדינטות קוראים <strong>דיפאומורפיזם פרימיטיבי</strong>. אבל למה שאוכל להניח ש-{::nomarkdown}\( g\){:/nomarkdown} היא כזו? נדרשת לא מעט עבודה כדי להוכיח שכל דיפאומורפיזם ניתן להיבנות כהרכבה של של דיפאומורפיזמים פרימיטיביים (מכאן המילה "פרימיטיבי"), ושהרכבה כזו משמרת את נכונות המשפט על החלפת המשתנים. אבל נשמור את זה לאחר כך.

הדבר האחרון שאני מניח הוא שכדי להוכיח שהמשפט מתקיים עבור {::nomarkdown}\( g:A\to B\){:/nomarkdown} מספיק להוכיח שהוא מתקיים <strong>מקומית</strong> עבור {::nomarkdown}\( g\){:/nomarkdown} ועבור פונקציות {::nomarkdown}\( f\){:/nomarkdown} עם <strong>תומך קומפקטי</strong>, כאשר "תומך" כאן הוא הסגור הטופולוגי של קבוצת הנקודות עליהן {::nomarkdown}\( f\){:/nomarkdown} אינה מתאפסת (כלומר, קבוצת הנקודות הזו ועוד כל נקודות השפה שלה). המשמעות הפורמלית היא זו: אם לכל {::nomarkdown}\( x\in A\){:/nomarkdown} קיימת סביבה {::nomarkdown}\( U\){:/nomarkdown} של {::nomarkdown}\( x\){:/nomarkdown} (כלומר, קבוצה פתוחה {::nomarkdown}\( U\subseteq A\){:/nomarkdown} כך ש-{::nomarkdown}\( x\in U\){:/nomarkdown}) שנסמן את תמונתה בתור {::nomarkdown}\( V=g\left(U\right)\){:/nomarkdown}, כך שלכל פונקציה {::nomarkdown}\( f:V\to\mathbb{R}\){:/nomarkdown} עם תומך קומפקטי המשפט מתקיים - אז המשפט מתקיים עבור {::nomarkdown}\( f:B\to\mathbb{R}\){:/nomarkdown} כלשהי. כאן המשמעות של "תומך קומפקטי" היא שקבוצת הערכים ב-{::nomarkdown}\( V\){:/nomarkdown} שעליהם {::nomarkdown}\( f\){:/nomarkdown} לא מתאפסת היא חסומה (קבוצה קומפקטית ב-{::nomarkdown}\( \mathbb{R}^{n}\){:/nomarkdown} אם ורק אם היא סגורה וחסומה, וכאן אנחנו לוקחים מראש את התומך להיות קבוצה סגורה). זה בעצם מחזיר אותנו למושג האינטגרל שממנו התחלנו - כזה של פונקציה שמוגדרת על קבוצה סגורה וחסומה, לפני שעברתי לדבר על אינטגרלים מוכללים.

הנה סיכום זריז של השלבים:
<ol>
	<li>נראה את נכונות המשפט עבור {::nomarkdown}\( n=1\){:/nomarkdown} תוך שימוש בהנחה שמספיק להוכיח את המשפט <strong>מקומית</strong>.</li>
	<li>נראה איך נובעת מכך נכונות המשפט עבור {::nomarkdown}\( n\){:/nomarkdown} כלשהו תוך שימוש בהנחה שמספיק להוכיח את המשפט עבור {::nomarkdown}\( g\){:/nomarkdown} <strong>פרימיטיבית</strong>.</li>
	<li>נראה למה אם המשפט נכון עבור שני דיפאומורפיזמים הוא נכון גם להרכבה שלהם ונסביר למה כל דיפאומורפיזם ניתן לתיאור כהרכבת דיפאומורפיזמים פרימיטיביים, מה שיצדיק את ההנחה שלנו בשלב 2.</li>
	<li>נראה שמספיק להוכיח את המשפט מקומית, מה שיצדיק את ההנחה שלנו בשלב 1.</li>
</ol>
חלקים 1-2 מן הסתם כוללים את הלב הרעיוני של ההוכחה, בעוד שחלקים 3-4 הם יותר טכניים באופיים ולכן אני דוחה אותם לסוף, למרות שהסדר התקין יותר להצגה שלהם הוא בהתחלה.

אם תבקשו ממני לתת אינטואיציה <strong>כלשהי</strong> לאיך ההוכחה עובדת, אני חושש שגם עכשיו אין לי משהו טוב יותר מנפנוף הידיים המופרע הבא: "אם חותכים את המרחב כולו לפיסות קטנות קטנות קטנות קטנות קטנטנות ממש ממש ממש ממש אז בכל פיסה כזו נראה ש-{::nomarkdown}\( g\){:/nomarkdown} רק טיפה מכווצת או מותחת את המרחב בציר אחד ואז פשוט צריך לכפול בקבוע המתאים שמתקן את אפקט העיוות הזה".

אני חושב שהפוסט הזה הוא דוגמה נפלאה לאופן שבו המתמטיקה מפרמלת את הצורה לטיעון מנופנף ידיים כזה.
<h1>שלב 1: בסיס האינדוקציה: n=1</h1>
השלב הזה הוא בבסיסו פשוט שיטת ההצבה שכבר הצגתי והוכחתי <a href="http://www.gadial.net/2015/12/31/calculus_change_of_variables/">בפוסט קודם</a>. שם ההוכחה התבססה על תותח כבד יחסית - המשפט היסודי של החדו"א - אבל כל זה הוא חומר של חדו"א בסיסי ולא של אנליזה וקטורית. עם זאת, בגלל האופן שבו ניסחתי את שיטת ההצבה הכללית עבור אינטגרלים מוכללים, ההוכחה ההיא לא מספיקה, כי היא מתייחסת רק לאינטגרלים רגילים שמוגדרים על קטעים, לא על קבוצות פתוחות. לכן משתמשים בכך שמספיק להוכיח את המשפט באופן מקומי. דהיינו, ניקח {::nomarkdown}\( x\in A\){:/nomarkdown} וניקח קטע סגור כלשהו {::nomarkdown}\( I\subseteq A\){:/nomarkdown} כך ש-{::nomarkdown}\( x\in I\){:/nomarkdown}. התמונה של קטע סגור על ידי פונקציה ממשית רציפה גם היא קטע סגור (זה נובע מ<strong>משפט ערך הביניים </strong>עם עוד קצת עבודה) ולכן {::nomarkdown}\( J=g\left(I\right)\){:/nomarkdown} הוא קטע סגור ב-{::nomarkdown}\( B\){:/nomarkdown}, ואז אפשר להשתמש במשפט החלפת המשתנים כדי לקבל ש-{::nomarkdown}\( \int_{J}f=\int_{I}f\circ g\left\|g^{\prime}\right\|\){:/nomarkdown}, וזה בדיוק מה שאנחנו רוצים.
<h1>שלב 2: צעד האינדוקציה</h1>
גם כאן מתחילים מלפשט את מה שבכלל צריך להוכיח.מכיוון שמספיק להוכיח את המשפט מקומית, אז לוקחים נקודה {::nomarkdown}\( x\in A\){:/nomarkdown} ומחפשים סביבה "נחמדה" שלה: לוקחים תיבה {::nomarkdown}\( Q\subseteq B\){:/nomarkdown} שמכילה את {::nomarkdown}\( g\left(x\right)\){:/nomarkdown} ומסמנים ב-{::nomarkdown}\( U=g^{-1}\left(Q\right)\){:/nomarkdown} את המקור שלה, וזו תהיה הקבוצה הפתוחה שלנו; אם כן, די להוכיח את המשפט עבור {::nomarkdown}\( f\){:/nomarkdown} רציפה שמוגדרת על התיבה {::nomarkdown}\( Q\){:/nomarkdown} ויש לה תומך קומפקטי בתיבה הזו. מכיוון ש-{::nomarkdown}\( f\){:/nomarkdown} רציפה ויש לה תומך קומפקטי, היא אינטגרבילית על {::nomarkdown}\( Q\){:/nomarkdown}, כלומר אפשר לדבר על {::nomarkdown}\( \int_{Q}f\){:/nomarkdown}; ובאופן דומה גם {::nomarkdown}\( g\circ f\left\|\det Dg\right\|\){:/nomarkdown} היא פונקציה רציפה (כי הרכבה וכפל של פונקציות רציפות הם רציפים, ודטרמיננטה של הנגזרת היא פונקציה רציפה, וערך מוחלט הוא רציף) וגם לה יש תומך קומפקטי מעל {::nomarkdown}\( U\){:/nomarkdown} (המקור של התומך הקומפקטי של {::nomarkdown}\( f\){:/nomarkdown} על פי {::nomarkdown}\( g\){:/nomarkdown}), ולכן היא אינטגרבילית שם, כלומר {::nomarkdown}\( \int_{U}\left(f\circ g\right)\left\|\det Dg\right\|\){:/nomarkdown}. האתגר הוא להוכיח ש-{::nomarkdown}\( \int_{U}\left(f\circ g\right)\left\|\det Dg\right\|=\int_{Q}f\){:/nomarkdown}.

הרעיון עכשיו הוא מתבקש למדי: אנחנו לא באמת יודעים לחשב אינטגרלים על קבוצות במספר גדול של ממדים "בבת אחת"; אנחנו משתמשים במשפט פוביני כדי לחלק את האינטגרל ה"גדול" לאינטגרל חד-ממדי שמופעל על אינטגרל על קבוצה פחות במימד אחד פחות, שעליה אפשר להשתמש בהנחת האינדוקציה. פורמלית, בואו נסמן {::nomarkdown}\( F=\left(f\circ g\right)\left\|\det Dg\right\|\){:/nomarkdown}, כלומר אנחנו רוצים להוכיח {::nomarkdown}\( \int_{U}F=\int_{Q}f\){:/nomarkdown}, ונפרק את התיבה {::nomarkdown}\( Q\){:/nomarkdown} לתת-תיבה ממימד קטן ב-1 כפול קטע חד ממדי: {::nomarkdown}\( Q=D\times I\){:/nomarkdown}. איך זה משפיע על {::nomarkdown}\( U\){:/nomarkdown}? כאן נכנסת לתמונה ההנחה שלנו ש-{::nomarkdown}\( g\){:/nomarkdown} היא <strong>פרימיטיבית</strong>, כלומר לא משנה את הקואורדינטה האחרונה; זה אומר ש-{::nomarkdown}\( U\subseteq E\times I\){:/nomarkdown} כאשר {::nomarkdown}\( E\){:/nomarkdown} היא תיבה ו-{::nomarkdown}\( I\){:/nomarkdown} הוא אותו קטע כמו ב-{::nomarkdown}\( D\times I\){:/nomarkdown}.

המשוואה שאנחנו רוצים להוכיח כעת היא {::nomarkdown}\( \int_{E\times I}F=\int_{D\times I}f\){:/nomarkdown}. את זה נפתח על פי משפט פוביני:

{::nomarkdown}\( \int_{t\in I}\int_{y\in D}F\left(y,t\right)=\int_{t\in I}\int_{x\in E}f\left(x,t\right)\){:/nomarkdown}

שני האינטגרלים הפנימיים הולכים לתת לנו פונקציה של {::nomarkdown}\( t\){:/nomarkdown}. מכיוון שהאינטגרציה החיצונית היא על אותו קטע בדיוק, מספיק להראות ששני האינטגרלים הפנימיים שווים:

{::nomarkdown}\( \int_{y\in D}F\left(x,t\right)=\int_{x\in E}f\left(y,t\right)\){:/nomarkdown}

וזאת לכל {::nomarkdown}\( t\){:/nomarkdown}, כשחושבים על {::nomarkdown}\( t\){:/nomarkdown} בתור פרמטר. כמובן, צריך להיות טיפה זהירים לפני שצועקים פה "הנחת האינדוקציה!" - ההנחה הזו תקפה עבור פונקציות במימד נמוך ב-1, ועדיין לא הצגנו אותן במפורש. אני יכול להגדיר {::nomarkdown}\( h_{t}\left(x\right)=f\left(x,t\right)\){:/nomarkdown} כדי לטפל באגף ימין, אבל מה בדיוק קורה באגף שמאל? שם יש לנו את {::nomarkdown}\( g\left(x,t\right)\){:/nomarkdown} שגם התחום שלה וגם התמונה שלה צריכים לרדת במימד שלהם. אז אני אגיד שמכיוון ש-{::nomarkdown}\( g\){:/nomarkdown} פרימיטיבית, ניתן לכתוב את התמונה שלה כך: {::nomarkdown}\( g\left(x,t\right)=\left(r\left(x,t\right),t\right)\){:/nomarkdown}, ולכן אני יכול להגדיר {::nomarkdown}\( k_{t}\left(x\right)=r\left(x,t\right)\){:/nomarkdown}. צריך להוכיח שזה דיפאומורפיזם, כמובן.

עכשיו, מהו {::nomarkdown}\( Dk_{t}\){:/nomarkdown}? זו פשוט תת-המטריצה של {::nomarkdown}\( Dh\){:/nomarkdown} שמתקבלת כשמעיפים את השורה והעמודה האחרונות. אני אסמן את זה בתור {::nomarkdown}\( \frac{\partial r}{\partial x}\){:/nomarkdown}. עם הסימונים הללו אנחנו מגיעים סוף סוף לשימוש בהנחת האינדוקציה:

{::nomarkdown}\( \int h_{t}\left(y\right)=\int h_{t}\left(k_{t}\left(x\right)\right)\left\|\det\frac{\partial r}{\partial x}\right\|\){:/nomarkdown}

וכאן {::nomarkdown}\( f\left(y,t\right)=h_{t}\left(y\right)\){:/nomarkdown} ו-{::nomarkdown}\( F\left(x,t\right)=h_{t}\left(k_{t}\left(x\right)\right)\){:/nomarkdown}, אז רק נשאר להבין למה {::nomarkdown}\( \left\|\det Dg\right\|=\left\|\det\frac{\partial r}{\partial x}\right\|\){:/nomarkdown}. בשביל זה, בואו נכתוב במפורש את המטריצה של {::nomarkdown}\( Dg\){:/nomarkdown} בתור מטריצת בלוקים:

{::nomarkdown}\( Dg=\left[\begin{array}{cc}\partial r/\partial x &amp; \partial r/\partial t\\0\dots0 &amp; 1\end{array}\right]\){:/nomarkdown}

למי שזוכר איך מחשבים דטרמיננטות ברור שהדטרמיננטה של המטריצה הזו היא {::nomarkdown}\( \det\frac{\partial r}{\partial x}\){:/nomarkdown}. אבל למה השורה האחרונה נראית כפי שהיא נראית? ובכן, בדיוק בגלל ש-{::nomarkdown}\( g\){:/nomarkdown} פרימיטיבית ולכן לינארית במשתנה האחרון (והנגזרת שלה היא 1 בו) וקבועה ביתר המשתנים (ולכן הנגזרת שלה היא 0 בהם).

אז סיימנו את השלב הזה, אבל כפי שאנחנו רואים, ההנחה ש-{::nomarkdown}\( g\){:/nomarkdown} פרימיטיבית היא חזקה מאוד ופחות או יותר חוסכת לנו את כל העבודה. לכן זה הדבר הבא שחייבים לדבר עליו.
<h1>שלב 3: מדיפאומורפיזמים פרימיטיביים לכלליים</h1>
הרעיון הכללי כאן הוא זה: ניקח דיפאומורפיזם כללי {::nomarkdown}\( g\){:/nomarkdown}. נראה שאפשר לכתוב אותו בתור <strong>הרכבה</strong> של דיפאומורפיזמים {::nomarkdown}\( g_{1},g_{2},\dots,g_{k}\){:/nomarkdown} שהם כולם <strong>פרימיטיביים</strong> (פועלים כמו הזהות על קואורדינטה אחת), ונשתמש בכך שאם משפט החלפת המשתנים נכון עבור שני דיפאומורפיזמים, הוא נכון עבור ההרכבה שלהם. את הטענה האחרונה הזו על הההרכבה די קל לראות. נניח ש-{::nomarkdown}\( g,h\){:/nomarkdown} הם דיפאומורפיזמים שמקיימים את המשפט, אז זה אומר ש:

{::nomarkdown}\( \int f=\int\left(f\circ g\right)\left\|\det Dg\right\|=\int\left(\left(f\circ g\right)\circ h\right)\left\|\left(\det Dg\right)\circ h\right\|\left\|\det Dh\right\|\){:/nomarkdown}

כלומר, אני משתמש פה במשפט החלפת המשתנים פעמיים. פעם אחת עבור הדיפאומורפיזם {::nomarkdown}\( g\){:/nomarkdown} והפונקציה הרציפה {::nomarkdown}\( f\){:/nomarkdown}, ובפעם השניה עבור הדיפאומורפיזם {::nomarkdown}\( h\){:/nomarkdown} והפונקציה הרציפה המסובכת יותר {::nomarkdown}\( \left(f\circ g\right)\left\|\det Dg\right\|\){:/nomarkdown}. אם זה מבלבל, צריך לזכור מה {::nomarkdown}\( \left(f\circ g\right)\left\|\det Dg\right\|\){:/nomarkdown} אומר בכלל. זו פונקציה שלוקחת קלט {::nomarkdown}\( x\in\mathbb{R}^{n}\){:/nomarkdown} ועושה איתו שני דברים: ראשית, מחשבת את {::nomarkdown}\( f\left(g\left(x\right)\right)\){:/nomarkdown} ושומרת בצד את התוצאה; ושנית, מחשבת <strong>טרנספורמציה לינארית </strong>שהיא הדיפרנציאל של {::nomarkdown}\( g\){:/nomarkdown} בנקודה {::nomarkdown}\( x\){:/nomarkdown}, ואז היא מחשבת את הערך המוחלט של הדטרמיננטה של הטרנספורמציה הלינארית הזו, וכופלת את התוצאה ב-{::nomarkdown}\( f\left(g\left(x\right)\right)\){:/nomarkdown} שחושב קודם.

אם אני לוקח את כל הפונקציה הזו ומרכיב אותה על {::nomarkdown}\( h\){:/nomarkdown}, זה אומר שצריך להחליף את {::nomarkdown}\( x\){:/nomarkdown} בתיאור הקודם ב-{::nomarkdown}\( h\left(x\right)\){:/nomarkdown}. כלומר, אני לוקח את הפונקציה שמחשבת ערך-מוחלט-של-דטרמיננטה-של-הדיפרנציאל של {::nomarkdown}\( g\){:/nomarkdown} ומרכיב אותה על {::nomarkdown}\( h\){:/nomarkdown}. זה נראה קצת מבלבל בגלל האופן שבו אנחנו כותבים ערך מוחלט לא כפונקציה אלא בתור שני קווים, אבל זה בסדר גמור - העובדה ש-{::nomarkdown}\( h\){:/nomarkdown} נמצאת בתוך הקווים של הערך המוחלט מעידה על כך שהערך המוחלט פועל אחרון בפונקציה המורכבת שמקבלים.

מה אנחנו <strong>רוצים</strong> להראות? ש-{::nomarkdown}\( \int f=\int f\circ\left(g\circ h\right)\left\|\det D\left(g\circ h\right)\right\|\){:/nomarkdown}. האסוציאטיביות של הרכבת פונקציות נותנת לנו מייד ש-{::nomarkdown}\( f\circ\left(g\circ h\right)=\left(f\circ g\right)\circ h\){:/nomarkdown}; מה שחסר כאן הוא רק שוויון עבור קבוע ה"תיקון", כלומר חסר להראות ש-

{::nomarkdown}\( \left\|\det D\left(g\circ h\right)\right\|=\left\|\left(\det Dg\right)\circ h\right\|\left\|\det Dh\right\|\){:/nomarkdown}

וזה כנראה מזכיר לכם כבר את כלל השרשרת שממנו התוצאה הזו נובעת מייד (יחד עם תכונת ה<strong>כפליות</strong> של הדטרמיננטה, כמובן).

אם כן, האתגר האמיתי בשלב הזה הוא להראות שדיפאומורפיזם {::nomarkdown}\( g\){:/nomarkdown} כללי ניתן לכתיבה כהרבה של דיפאומורפיזמים פרימיטיביים. נתחיל מכך שזה כנראה <strong>לא אפשרי</strong> ואנחנו לא ננסה לעשות את זה: מה שנעשה הוא להראות שזה ניתן לביצוע <strong>באופן מקומי</strong>. כלומר, נקבע נקודה כלשהי {::nomarkdown}\( a\){:/nomarkdown} ונראה שקיימת סביבה {::nomarkdown}\( U\){:/nomarkdown} של {::nomarkdown}\( a\){:/nomarkdown} שבה {::nomarkdown}\( g\){:/nomarkdown} מתפרקת כך להרכבה של דיפאומורפיזמים פרימיטיביים (שתלויים ב-{::nomarkdown}\( a\){:/nomarkdown}). כזכור, אנחנו הולכים בהמשך לדבר על למה מספיק להוכיח את משפט החלפת המשתנים מקומית כדי שהוא יהיה נכון באופן כללי, ולכן אנחנו יכולים לעשות זאת. עדיין, גם באופן מקומי, איך מפרקים כך את {::nomarkdown}\( g\){:/nomarkdown}?

האינסטינקט הראשוני שלי הוא לכתוב את {::nomarkdown}\( g\){:/nomarkdown} בתור הרכבה של פונקציות שכל אחת מהן פועלת על רכיב בודד ולכן משמרת את כל היתר: למשל, אם {::nomarkdown}\( g\left(x,y\right)=\left(2x+y,2y+x\right)\){:/nomarkdown} אז נגדיר {::nomarkdown}\( g_{1}\left(x,y\right)=\left(x,2y+x\right)\){:/nomarkdown} ו-{::nomarkdown}\( g_{2}\left(x,y\right)=\left(2x+\left(\frac{y-x}{2}\right),y\right)\){:/nomarkdown}. אבל שימו לב שזה היה קצת אד-הוקי - נאלצתי איכשהו "לשחזר" את {::nomarkdown}\( y\){:/nomarkdown} המקורי ב-{::nomarkdown}\( g_{2}\){:/nomarkdown}. מי אומר שתמיד אפשר לעשות את זה? ואיך אפשר לוודא שהפירוקים שלנו יהיו דיפאומורפיזמים?

אז עושים את זה בשלבים. מתחילים מהמקרה הפרטי שבו {::nomarkdown}\( g\){:/nomarkdown} היא טרנספורמציה לינארית. זה זמן טוב עבורכם לעצור ולנסות להוכיח את הטענה בעצמכם עבור טרנספורמציות לינאריות כדי להרגיש מה בעצם אנחנו מנסים לעשות פה ולמה זה טיפה מאתגר. כאשר {::nomarkdown}\( g\){:/nomarkdown} היא טרנספורמציה לינארית שהיא דיפאומורפיזם המידע הנוסף שיש לנו עליה הוא שהיא הפיכה (כי דיפאומורפיזם חייב להיות הפיך) - הגזירות של {::nomarkdown}\( g\){:/nomarkdown} ושל ההופכית שלה נובעת מכך שכל טרנספורמציה לינארית היא גזירה. עכשיו, אחד הדברים הראשונים שרואים באלגברה לינארית הוא שכל טרנספורמציה לינארית אפשר להציג בתור הרכבה של טרנספורמציות לינאריות <strong>אלמנטריות</strong> - בשלב הזה עוד קוראים לטרנספורמציה לינארית "מטריצה" ומדברים על כך שכל מטריצה היא מכפלה של מטריצות אלמנטריות.

טרנספורמציה אלמנטרית שפועלת על וקטור {::nomarkdown}\( \left(x_{1},\dots,x_{n}\right)\){:/nomarkdown} עושה אחד משלושה דברים: או כופלת כניסה אחת (נאמר, את הראשונה, אבל באותה מידה אפשר גם את היתר) בסקלר, כלומר מקבלים את הוקטור {::nomarkdown}\( \left(\lambda x_{1},x_{2}\dots,x_{n}\right)\){:/nomarkdown}; זו בבירור טרנספורמציה פרימיטיבית כי לא שינינו את שאר הכניסות. או שמוסיפים לאחת הכניסות את המכפלה של אחרת בסקלר, כלומר מקבלים את הוקטור {::nomarkdown}\( \left(x_{1},x_{2}+\lambda x_{1},\dots,x_{n}\right)\){:/nomarkdown}, וגם פה לא שינינו את שאר הכניסות; או שמחליפים שתי כניסות, למשל מקבלים {::nomarkdown}\( \left(x_{2},x_{1},\dots,x_{n}\right)\){:/nomarkdown}. כאן יכולה להיות בעיה אם {::nomarkdown}\( n=2\){:/nomarkdown}, אבל הנה תעלול נחמד! אפשר "לסמלץ" החלפה של שתי שורות גם בעזרת טרנספורמציות משני הסוגים הראשונים! בואו תראו את זה כך:

{::nomarkdown}\( \left(a,b\right)\mapsto\left(a,b-a\right)\mapsto\left(b,b-a\right)\mapsto\left(b,-a\right)\mapsto\left(b,a\right)\){:/nomarkdown}

אני מניח שתוכלו לנחש בעצמכם מה ביצעתי בכל שלב.

עכשיו, משאנחנו חמושים בנכונות של הטענה על הפירוק עבור טרנספורמציות לינאריות, בואו נוכיח אותן עבור איזומטריה פשוטה ש<strong>אינה</strong> טרנספורמציה לינארית - הזזה. {::nomarkdown}\( g\left(x\right)=x+c\){:/nomarkdown} עם {::nomarkdown}\( c\){:/nomarkdown} קבוע; זו כנראה הפונקציה הפשוטה ביותר שאיננה טרנספורמציה לינארית שיש טעם לדבר עליה. וכמובן, די בבירור אפשר לפרק אותה כי פשוט נזיז לא בכל {::nomarkdown}\( c\){:/nomarkdown} בבת אחת אלא נחכה קצת עם אחד הצירים. דהיינו, אם {::nomarkdown}\( c=\left(c_{1},\dots,c_{n}\right)\){:/nomarkdown} בואו נגדיר {::nomarkdown}\( g_{1}\left(x_{1},\dots,x_{n}\right)=\left(x_{1}+c_{1},x_{2}+c_{2},\dots,x_{n-1}+c_{n-1},x_{n}\right)\){:/nomarkdown} ו-{::nomarkdown}\( g_{2}\left(x_{1},\dots,x_{n}\right)=\left(x_{1},x_{2},\dots,x_{n-1},x_{n}+c_{n}\right)\){:/nomarkdown}, וקיבלנו ש-{::nomarkdown}\( g\){:/nomarkdown} היא הרכבה של שני דיפאומורפיזמים פרימיטיביים.

בשני המקרים הללו הפירוק היה <strong>גלובלי</strong> - לא הייתי צריך להתייחס לכך שאני מפרק בסביבה של נקודה {::nomarkdown}\( a\){:/nomarkdown} מסויימת ונעזר במה שאני יודע עליה. הסיבה שטרחתי להתעסק במפורש עם שני המקרים הללו היא שאני הולך להיעזר בהם כדי לקחת דיפאומורפיזם <strong>כללי</strong> ולהעביר אותו לצורה פשוטה יחסית, שבה אני יכול לטפל באופן מפורש. בואו נראה עכשיו את הצורה הזו: אני מניח ש-{::nomarkdown}\( a=0\){:/nomarkdown} פשוט כדי שהסימונים יהיו פשוטים ככל הניתן, וש-{::nomarkdown}\( g\left(0\right)=0\){:/nomarkdown} וש-{::nomarkdown}\( Dg\left(0\right)=I\){:/nomarkdown}. תחת ההנחות הללו הרעיון האינטואיטיבי שנתתי קודם - שאפשר יהיה "לשחזר" קואורדינטות מתוך הפלט החלקי של {::nomarkdown}\( g\){:/nomarkdown} ולכן לבצע את {::nomarkdown}\( g\){:/nomarkdown} בשלבים - באמת עובד. בואו ונראה במפורש איך.

אני אתאר את {::nomarkdown}\( g\left(x_{1},\dots,x_{n}\right)\){:/nomarkdown} כאילו הוא מורכבת מ-{::nomarkdown}\( n\){:/nomarkdown} פונקציות ממשיות ב-{::nomarkdown}\( n\){:/nomarkdown} משתנים, כלומר {::nomarkdown}\( g\left(x_{1},\dots,x_{n}\right)=\left(g_{1}\left(x_{1},\dots,x_{n}\right),\dots,g_{n}\left(x_{1},\dots,x_{n}\right)\right)\){:/nomarkdown}, ואראה שאפשר לפרק את {::nomarkdown}\( g\){:/nomarkdown} להרכבה {::nomarkdown}\( g=k\circ h\){:/nomarkdown}. נתחיל עם {::nomarkdown}\( h\){:/nomarkdown}, שתהיה פשוט הפעלה של {::nomarkdown}\( g\){:/nomarkdown} לכל הקואורדינטות מלבד האחרונה, שאותה משמרים. כלומר, {::nomarkdown}\( h\left(x_{1},\dots,x_{n}\right)=\left(g_{1}\left(x_{1},\dots,x_{n}\right),\dots,g_{n-1}\left(x_{1},\dots,x_{n}\right),x_{n}\right)\){:/nomarkdown}. מכיוון שמשמרים את הקואורדינטה האחרונה הרי שאם {::nomarkdown}\( h\){:/nomarkdown} היא דיפאומורפיזם אז היא דיפאומורפיזם פרימיטיבי - אבל מאיפה לנו ש-{::nomarkdown}\( h\){:/nomarkdown} היא דיפאומורפיזם, כלומר גזירה, הפיכה ועם הופכית שגזירה כמו {::nomarkdown}\( h\){:/nomarkdown} עצמה?

גזירות זה קל - {::nomarkdown}\( h\){:/nomarkdown} גזירה אם ורק אם כל הקואורדינטות שלה גזירות, וכולן הן פונקציות מהצורה {::nomarkdown}\( g_{i}\){:/nomarkdown} שאנחנו יודעים שהן גזירות פרט לקואורדינטה האחרונה, שהיא פונקציית הזהות שהיא בוודאי גזירה. אם נגזור את {::nomarkdown}\( h\){:/nomarkdown} בנקודה כלשהי, נקבל מטריצה שכל השורות שלה פרט לאחרונה זהות לאלו של {::nomarkdown}\( Dg\){:/nomarkdown}, ואילו השורה האחרונה בה תהיה פשוט {::nomarkdown}\( \left[0,0,0,\dots,1\right]\){:/nomarkdown} בנקודה {::nomarkdown}\( a=0\){:/nomarkdown} אנחנו יודעים ש-{::nomarkdown}\( Dg\left(0\right)=I\){:/nomarkdown} ולכן נקבל גם ש-{::nomarkdown}\( Dh\left(0\right)=I\){:/nomarkdown}. זה אומר שאנחנו עומדים בתנאי <strong>משפט הפונקציה ההפוכה</strong>: הנגזרת של {::nomarkdown}\( h\){:/nomarkdown} בנקודה 0 היא הפיכה, מה שאומר שקיימת סביבה {::nomarkdown}\( U\){:/nomarkdown} של {::nomarkdown}\( 0\){:/nomarkdown} שבה קיים ל-{::nomarkdown}\( h\){:/nomarkdown} הופכי שהוא גזיר כמו {::nomarkdown}\( h\){:/nomarkdown}. קיבלנו שבסביבה {::nomarkdown}\( U\){:/nomarkdown} הזו, {::nomarkdown}\( h\){:/nomarkdown} היא אכן דיפאומורפיזם.

זה המקום שבו כל עניין ה"סביבה" נכנס לתמונה, באופן מהותי: משפט הפונקציה ההפוכה <strong>לא נכון</strong> באופן גלובלי - הוא תמיד מבטיח לנו הפיכות רק בסביבה של הנקודה שבה הנגזרת הפיכה. בשל המגבלה הזו, נצטרך לבלות את החלק האחרון של הפוסט עם "הדבקה" של כל התוצאות הגלובליות יחד. אבל צעד צעד.

עכשיו נשאלת השאלה - איך להגדיר את {::nomarkdown}\( k\){:/nomarkdown} כך שנקבל {::nomarkdown}\( g=h\circ k\){:/nomarkdown}? בבירור, על {::nomarkdown}\( n-1\){:/nomarkdown} הקואורדינטות הראשונות {::nomarkdown}\( k\){:/nomarkdown} לא תעשה כלום (ולכן תהיה בעצמה דיפאומורפיזם פרימיטיבי), אבל על האחרונה {::nomarkdown}\( k\){:/nomarkdown} צריכה להחזיר את {::nomarkdown}\( g_{n}\left(x_{1},\dots,x_{n}\right)\){:/nomarkdown}, כשה"בעיה" שלה היא שהיא לא מקבלת כקלט את {::nomarkdown}\( x_{1},\dots,x_{n}\){:/nomarkdown} אלא את {::nomarkdown}\( y=h\left(x_{1},\dots,x_{n}\right)\){:/nomarkdown}. לכן היא צריכה "לשחזר" את הקלט, ואת זה היא יכולה לעשות כי מקומית, {::nomarkdown}\( h\){:/nomarkdown} הפיכה. כלומר, {::nomarkdown}\( k\){:/nomarkdown} רוצה לחשב את {::nomarkdown}\( g_{n}\left(h^{-1}\left(y\right)\right)\){:/nomarkdown}, וזו תהיה ההגדרה שלה:

{::nomarkdown}\( k\left(y_{1},\dots,y_{n}\right)=\left(y_{1},\dots,y_{n-1},g_{n}\left(h^{-1}\left(y_{1},\dots,y_{n}\right)\right)\right)\){:/nomarkdown}

כמובן, {::nomarkdown}\( k\){:/nomarkdown} מוגדרת רק על הסביבה {::nomarkdown}\( U\){:/nomarkdown} של {::nomarkdown}\( a\){:/nomarkdown} שבה {::nomarkdown}\( h^{-1}\){:/nomarkdown} קיימת, אבל זה לא מפריע לנו. צריך עדיין להראות שגם היא דיפאומורפיזם, אז מחשבים את {::nomarkdown}\( Dk\left(0\right)\){:/nomarkdown} ומקבלים מטריצה ש-{::nomarkdown}\( n-1\){:/nomarkdown} השורות הראשונות בה יוצרות את מטריצת היחידה מסדר {::nomarkdown}\( n-1\){:/nomarkdown}, ואילו השורה האחרונה היא הנגזרת של {::nomarkdown}\( g_{n}\left(h^{-1}\left(y_{1},\dots,y_{n}\right)\right)\){:/nomarkdown}. כלל השרשרת יתן לנו את המכפלה של הנגזרת של {::nomarkdown}\( g_{n}\){:/nomarkdown} ב-{::nomarkdown}\( 0\){:/nomarkdown} עם הנגזרת של {::nomarkdown}\( h^{-1}\){:/nomarkdown} ב-{::nomarkdown}\( 0\){:/nomarkdown}; אבל הנגזרת של {::nomarkdown}\( h^{-1}\){:/nomarkdown} היא ההופכית של הנגזרת של {::nomarkdown}\( h\){:/nomarkdown}, כלומר היא מטריצת היחידה. נשארנו עם הנגזרת של {::nomarkdown}\( g_{n}\){:/nomarkdown}, שהיא פשוט הוקטור {::nomarkdown}\( \left[0,0,0,\dots,1\right]\){:/nomarkdown} כפי שאמרנו קודם (בזכות ההנחה שלנו שהנגזרת של {::nomarkdown}\( g\){:/nomarkdown} ב-{::nomarkdown}\( 0\){:/nomarkdown} היא מטריצת היחידה) ולכן סיימנו (אני מחפף פה עבודה טכנית של למצוא את הקבוצה הפתוחה המדוייקת שעליה {::nomarkdown}\( g\){:/nomarkdown} מתפרקת).

עכשיו בואו נסיים עם החלק הזה. ניקח דיפאומורפיזם כללי {::nomarkdown}\( g\){:/nomarkdown} ונקודה כללית {::nomarkdown}\( a\){:/nomarkdown}. עכשיו בואו נגדיר שלוש פונקציות כך:

{::nomarkdown}\( t_{1}\left(x\right)=x+a\){:/nomarkdown}

{::nomarkdown}\( t_{2}\left(x\right)=x-g\left(a\right)\){:/nomarkdown}

{::nomarkdown}\( T\left(x\right)=C^{-1}x\){:/nomarkdown} כאשר {::nomarkdown}\( Dg\left(a\right)=C\){:/nomarkdown}

ועכשיו בואו נגדיר דיפאומורפיזם חדש:

{::nomarkdown}\( h=T\circ t_{2}\circ g\circ t_{1}\){:/nomarkdown}

וכעת, מהו {::nomarkdown}\( h\left(0\right)\){:/nomarkdown}? קל לחשב: {::nomarkdown}\( h\left(0\right)=C^{-1}\left(g\left(a\right)-g\left(a\right)\right)=C^{-1}0=0\){:/nomarkdown}

וכמו כן, על פי כלל השרשרת, {::nomarkdown}\( Dh\){:/nomarkdown} היא המכפלה של הנגזרות של ארבע הפונקציות הללו; הנגזרות של ההזזות הן מטריצות היחידה, אז מקבלים {::nomarkdown}\( C^{-1}\cdot C=I\){:/nomarkdown}. כלומר, {::nomarkdown}\( h\){:/nomarkdown} עונה על התנאים שטיפלנו בהם לפני רגע. כל מה שנותר לעשות הוא לשים לב לכך ש-{::nomarkdown}\( g=t_{2}^{-1}\circ T^{-1}\circ h\circ t^{-1}\){:/nomarkdown} וסיימנו - זו הרכבה של דיפאומורפיזמים שכבר ראינו עבור כולם שניתן לפרק אותם להרכבה של דיפאומורפיזמים פרימיטיביים. זה מסייים את החלק הזה של ההוכחה.
<h1>שלב 4: ממקומי לגלובלי</h1>
טוב, אני מניח שבשלב הזה כבר ברור שקל העסק הזה לא יהיה, נכון? הסתמכנו כל כך חזק על הלוקליות שנדמה שיהיה צריך איזה שהוא נס כדי לעבור לטענה גלובלית - כדי "לתפור" את כל התעלולים המקומיים שאנחנו עושים למשהו שעובד בכל מקום. את ה"נס" הזה אני הולך לספק באמצעות כלי טכני שלא הזכרתי עד כה שנקרא <strong>חלוקת יחידה</strong> (Partition of Unity). בספרי הלימוד המושג הזה מוזכר ומוסבר לעומק הרבה לפני שמגיעים להוכחת משפט החלפת המשתנים, אבל זו בדיוק הבעיה המרכזית - לא ברור <strong>בשביל מה צריך את זה</strong> עד שלא מגיעים לשימוש כמו זה שלנו. ומכיוון שלהבין מה זו חלוקת יחידה, ולמה היא קיימת בכלל, זה לא הכי קל בעולם, מוטיבציה היא דבר מאוד חשוב כאן. אז אני הולך להציג את המושג הזה עכשיו ולהראות למה הוא מסיים לנו את ההוכחה, ואז בתור בונוס אני גם אוכיח שהוא בכלל קיים.

אז מה זו חלוקת יחידה? בואו נניח ש-{::nomarkdown}\( A\){:/nomarkdown} היא קבוצה פתוחה. חלוקת יחידה היא אוסף פונקציות רציפות {::nomarkdown}\( \phi_{1},\phi_{2},\dots\){:/nomarkdown} שכולן מ-{::nomarkdown}\( A\){:/nomarkdown} לממשיים בין אפס ואחד, {::nomarkdown}\( \phi:A\to\left[0,1\right]\){:/nomarkdown}, וכמו כן מתקיימים התנאים הבאים:
<ol>
	<li>{::nomarkdown}\( \sum\phi\left(x\right)=1\){:/nomarkdown} לכל {::nomarkdown}\( x\in A\){:/nomarkdown}, כשהסכום נלקח על כל ה-{::nomarkdown}\( \phi\){:/nomarkdown} באוסף. זה מבהיר איפה פה ה"חלוקה" של היחידה.</li>
	<li>לכל נקודה של {::nomarkdown}\( A\){:/nomarkdown} קיימת סביבה שחותכת רק מספר סופי של תומכים של {::nomarkdown}\( \phi\){:/nomarkdown} מתוך החלוקה (כלומר, עבור כל ה-{::nomarkdown}\( \phi\){:/nomarkdown} בקבוצה פרט למספר סופי, הן מתאפסות על הנקודה הזו וכל הסביבה שלה).</li>
</ol>
מהכתיב שלי עשוי להתקבל הרושם שחלוקת יחידה חייבת להיות סדרה <strong>בת מניה</strong> של פונקציות. כך אמנם יהיה במקרה הנוכחי, אבל באופן כללי אפשר גם לדבר על קבוצות לא בנות מניה. זה עשוי להיראות מוזר במבט ראשון כי תנאי 1 עוסק בסכום שנלקח, לכאורה, על כל הפונקציות; אבל תנאי 2 מבטיח שכל האיברים בסכום הזה יהיו 0 פרט למספר סופי, כך שאין פה שום בעיה - אפילו אין צורך לדבר על התכנסות טורים של מספר בן מניה אינסופי של איברים.

בינתיים אין בהגדרה הזו שום דבר מרגש - אפילו הפונקציה {::nomarkdown}\( \phi\left(x\right)=1\){:/nomarkdown} מקיימת את התכונה הזו לבדה. לכן בדרך כלל מוסיפים דרישות נוספות על חלוקת היחידה. בפרט, מגבילים את ה<strong>תומך</strong> של כל פונקציה {::nomarkdown}\( \phi\){:/nomarkdown}, שהוא כזכור הסגור של אוסף הנקודות ש-{::nomarkdown}\( \phi\){:/nomarkdown} שונה מאפס עליהן. דרישה אפשרית אחת היא שהתומך יהיה <strong>קומפקטי</strong> (בהקשר שלנו, סגור וחסום), מה שלא מתקיים עבור {::nomarkdown}\( \phi\left(x\right)=1\){:/nomarkdown} אם {::nomarkdown}\( A\){:/nomarkdown} אינה קבוצה קומפקטית; דרישה אפשרית נוספת צצה אם יש לנו הצגה של {::nomarkdown}\( A\){:/nomarkdown} כאיחוד של קבוצות פתוחות, והדרישה מחלוקת היחידה היא שהתומך של כל {::nomarkdown}\( \phi\){:/nomarkdown} יהיה מוכל כולו באחת מהקבוצות הפתוחות - על זה אומרים שהחלוקה <strong>נשלטת</strong> על ידי אוסף הקבוצות הפתוחות. אנחנו נדרוש את שתי הדרישות הללו, ובנוסף - כי אנחנו מתעסקים פה באנליזה - נדרוש גם שכל ה-{::nomarkdown}\( \phi\){:/nomarkdown} יהיו גזירות אינסוף פעמים.

השימושיות של חלוקת יחידה עבורנו כאן נובעת מכך שהיא מאפשרת לנו לפרק אינטגרל של פונקציה מורכבת לסכום אינטגרלים של פונקציות פשוטות יותר, באופן הבא: אם יש לנו חלוקת יחידה מעל {::nomarkdown}\( A\){:/nomarkdown} עם תומכים קומפקטיים, ואם {::nomarkdown}\( f\){:/nomarkdown} היא פונקציה ממשית רציפה מעל {::nomarkdown}\( A\){:/nomarkdown}, אז האינטגרל של {::nomarkdown}\( f\){:/nomarkdown} קיים אם ורק אם האינטגרל {::nomarkdown}\( \sum_{i=1}^{\infty}\int_{A}\phi_{i}\left\|f\right\|\){:/nomarkdown} קיים, ובמקרה הזה מתקיים

{::nomarkdown}\( \int_{A}f=\sum_{i=1}^{\infty}\int_{A}\phi_{i}f\){:/nomarkdown}

כאשר הסכום נלקח על כל ה-{::nomarkdown}\( \phi\){:/nomarkdown}-ים בחלוקת היחידה - כאן כן הכרחי שהחלוקה תכיל רק מספר בן מניה של פונקציות או שלא היינו יכולים לבצע סכימה כזו.

נו, מה תגידו, הנה <strong>עוד</strong> טענה כבדת משקל שאני אדחה את ההוכחה שלה להמשך. קודם כל נראה איך היא עוזרת לנו.

כזכור, מה שאנחנו צריכים להוכיח כאן הוא את הדבר הבא: נתון לנו דיפאומורפיזם {::nomarkdown}\( g:A\to B\){:/nomarkdown}. אנחנו יודעים שלכל נקודה {::nomarkdown}\( x\in A\){:/nomarkdown} קיימת סביבה {::nomarkdown}\( U_{x}\){:/nomarkdown}, כך שמשפט החלפת המשתנים תקף עליה עבור כל פונקציה רציפה עם תומך קומפקטי. דהיינו, נסמן {::nomarkdown}\( V_{x}=g\left(U_{x}\right)\){:/nomarkdown}, ניקח פונקציה {::nomarkdown}\( f:V_{x}\to\mathbb{R}\){:/nomarkdown} רציפה עם תומך קומפקטי, אז {::nomarkdown}\( \int_{V_{x}}f=\int_{U_{x}}\left(f\circ g\right)\left\|\det Dg\right\|\){:/nomarkdown}.

זה הנתון, ומה שאנחנו רוצים להוכיח הוא שלכל {::nomarkdown}\( f:B\to\mathbb{R}\){:/nomarkdown} רציפה מתקיים {::nomarkdown}\( \int_{B}f=\int_{A}\left(f\circ g\right)\left\|\det Dg\right\|\){:/nomarkdown}. הרעיון יהיה לחלק את {::nomarkdown}\( f\){:/nomarkdown} הזו בעזרת חלוקת היחידה להרבה תת-פונקציות פשוטות שעבור כל אחת מהן אפשר להשתמש במשפט החלפת המשתנים. כמובן, השלב הראשון הוא לומר איזו חלוקת יחידה אנחנו לוקחים בכלל; ניקח אחת עם תומכים קומפקטיים שנשלטת על ידי קבוצת ה-{::nomarkdown}\( V_{x}\){:/nomarkdown}-ים, כלומר שלכל פונקציה {::nomarkdown}\( \phi\){:/nomarkdown} בחלוקה, התומך שלה הוא תת-קבוצה של {::nomarkdown}\( V_{x}\){:/nomarkdown} עבור {::nomarkdown}\( x\in A\){:/nomarkdown} כלשהו.

בהינתן החלוקה הזו, וההנחה ש-{::nomarkdown}\( f\){:/nomarkdown} אינטגרבילית מעל {::nomarkdown}\( B\){:/nomarkdown}, אפשר לכתוב

{::nomarkdown}\( \int_{B}f=\sum_{i=1}^{\infty}\int_{B}\phi_{i}f\){:/nomarkdown}

עכשיו, מכיוון ש-{::nomarkdown}\( \phi_{i}\){:/nomarkdown} היא בעלת תומך קומפקטי שמוכל ב-{::nomarkdown}\( V_{x}\){:/nomarkdown}, כל מה שבאינטגרנד מתאפס לכל נקודה מחוץ ל-{::nomarkdown}\( V_{x}\){:/nomarkdown}, ומכאן ש-{::nomarkdown}\( \int_{B}\phi_{i}f=\int_{V_{x}}\phi_{i}f\){:/nomarkdown}. מכיוון ש-{::nomarkdown}\( \phi_{i}f\){:/nomarkdown} היא פונקציה רציפה אפשר להשתמש במשפט החלפת המשתנים (שימו לב! כאן זה השימוש ב<strong>כל</strong> מה שעשינו עד כה!) ולקבל

{::nomarkdown}\( \int_{V_{x}}\phi_{i}f=\int_{U_{x}}\left(\phi_{i}f\right)\circ g\left\|\det Dg\right\|\){:/nomarkdown}

את אגף ימין יותר נוח לכתוב בתור

{::nomarkdown}\( \int_{U_{x}}\left(\phi_{i}\circ g\right)\left(f\circ g\right)\left\|\det Dg\right\|\){:/nomarkdown}

עכשיו, אני רוצה לטעון שהתומך של {::nomarkdown}\( \phi_{i}\circ g\){:/nomarkdown} מוכל כולו ב-{::nomarkdown}\( U_{x}\){:/nomarkdown}. אם לא הייתי מניח כלום על {::nomarkdown}\( g\){:/nomarkdown} זה לא היה נכון, כי אמנם אני יודע שהתומך של {::nomarkdown}\( \phi_{i}\){:/nomarkdown} מוכל כולו ב-{::nomarkdown}\( V_{x}=g\left(U_{x}\right)\){:/nomarkdown} אבל זה <strong>לא אומר</strong> שאין נקודות מחוץ ל-{::nomarkdown}\( U_{x}\){:/nomarkdown} שהתמונה של {::nomarkdown}\( g\){:/nomarkdown} עליהן שייכת ל-{::nomarkdown}\( V_{x}\){:/nomarkdown}. במקרה שלנו זה כן נכון, כי {::nomarkdown}\( g\){:/nomarkdown} היא דיפאומורפיזם ולכן בפרט חח"ע ועל - אין נקודות מחוץ ל-{::nomarkdown}\( U_{x}\){:/nomarkdown} שמחזירות נקודות בתוך {::nomarkdown}\( V_{x}\){:/nomarkdown}.

מכיוון שהתומך של {::nomarkdown}\( \phi_{i}\circ g\){:/nomarkdown} מוכל כולו ב-{::nomarkdown}\( U_{x}\){:/nomarkdown} אפשר להרחיב את האינטגרל לכל {::nomarkdown}\( A\){:/nomarkdown}:

{::nomarkdown}\( \int_{A}\left(\phi_{i}\circ g\right)\left(f\circ g\right)\left\|\det Dg\right\|\){:/nomarkdown}

ועכשיו תראו מה קיבלנו!

{::nomarkdown}\( \int_{B}\phi_{i}f=\int_{A}\left(\phi_{i}\circ g\right)\left(f\circ g\right)\left\|\det Dg\right\|\){:/nomarkdown}

התחלנו עם חתיכות של {::nomarkdown}\( f\){:/nomarkdown} שפזורות על חתיכות של {::nomarkdown}\( B\){:/nomarkdown}; עכשיו אנחנו עדיין מדברים על חתיכות של {::nomarkdown}\( f\){:/nomarkdown} אבל הן מוגדרות על <strong>כל</strong> {::nomarkdown}\( B\){:/nomarkdown}. כדי לחזור אל {::nomarkdown}\( f\){:/nomarkdown} המקורית, בואו נחבר את כל החתיכות:

{::nomarkdown}\( \int_{B}f=\sum_{i=1}^{\infty}\int_{B}\phi_{i}f=\sum_{i=1}^{\infty}\int_{A}\left(\phi_{i}\circ g\right)\left(f\circ g\right)\left\|\det Dg\right\|\){:/nomarkdown}

חסר לנו רק הצעד האחרון:

{::nomarkdown}\( \sum_{i=1}^{\infty}\int_{A}\left(\phi_{i}\circ g\right)\left(f\circ g\right)\left\|\det Dg\right\|=\int_{A}\left(f\circ g\right)\left\|\det Dg\right\|\){:/nomarkdown}

רגע, מה ההבדל בין זה ובין {::nomarkdown}\( \int_{B}f=\sum_{i=1}^{\infty}\int_{B}\phi_{i}f\){:/nomarkdown}? ובכן, שאנחנו עובדים עכשיו מעל {::nomarkdown}\( A\){:/nomarkdown} וה"חלוקה" שלנו היא לא הפונקציות {::nomarkdown}\( \phi_{i}\){:/nomarkdown} אלא הפונקציות {::nomarkdown}\( \phi_{i}\circ g\){:/nomarkdown}. צריך להוכיח שהן מהוות חלוקת יחידה עבור {::nomarkdown}\( A\){:/nomarkdown}, אבל זו הוכחה ישירה ופשוטה למדי למדי - החלק היחיד שאינו מיידי לחלוטין הוא ההוכחה שהתומכים של הפונקציות הללו הם קומפקטיים, וזה נובע מכך שהם המקורות של קבוצות קומפקטיות (התומכים של ה-{::nomarkdown}\( \phi_{i}\){:/nomarkdown}-ים המקוריים) על ידי הפונקציה הרציפה {::nomarkdown}\( g\){:/nomarkdown}.

זה מסיים את משפט החלפת המשתנים, ומשאיר לנו רק לדבר עוד קצת על חלוקות יחידה.
<h1>שלב 5 (בונוס!): לדבר עוד קצת על חלוקות יחידה</h1>
נשארו שני דברים: להוכיח שקיימת חלוקת יחידה מהסוג שבה השתמשנו קודם, ולהוכיח שבאמת אפשר לפרק אינטגרלים איתה לסכומים, כפי שעשינו קודם.
<h2>עוד</h2>
נתחיל עם קיום, ועם בעיה פשוטה קצת יותר. נניח שמביאים לנו תיבה {::nomarkdown}\( Q\){:/nomarkdown} ב-{::nomarkdown}\( \mathbb{R}^{n}\){:/nomarkdown}. האם אנחנו יודעים לבנות פונקציה אי-שלילית גזירה אינסוף פעמים שמתאפסת מחוץ ל-{::nomarkdown}\( Q\){:/nomarkdown} וגדולה מאפס בתוך {::nomarkdown}\( Q\){:/nomarkdown} למעט על השפה של {::nomarkdown}\( Q\){:/nomarkdown}? אם נצליח לבנות פונקציה כזו, יהיה קל לראות איך מקבלים מפונקציות כאלו את חלוקת היחידה שאנחנו רוצים - אחרי שנעשה עוד להטוט שבכלל לא מערב פונקציות.

בואו נתחיל אפילו יותר פשוט: פונקציה ב-{::nomarkdown}\( \mathbb{R}\){:/nomarkdown} שמתאפסת מחוץ לקבוצה קומפקטית כלשהי, והיא עדיין רציפה וגזירה כמה פעמים שנרצה. אם סתם ניקח פונקציה כמו {::nomarkdown}\( f\left(x\right)=9-x^{2}\){:/nomarkdown} שהיא אי שלילית בקבוצה {::nomarkdown}\( \left[-3,3\right]\){:/nomarkdown} ונגדיר אותה להיות 0 מחוץ לקבוצה הזו אמנם נקבל פונקציה רציפה אבל היא לא תהיה גזירה בקצוות - צריך משהו "חלק" יותר. אבל אין כאן רעיון גאוני במיוחד - מה שבדרך כלל עובד בסיטוציות כאלו הוא וריאציה כלשהי על אקספוננט. זה מה שנעשה כאן. נגדיר {::nomarkdown}\( f\left(x\right)=\begin{cases}e^{-\frac{1}{x}} &amp; x&gt;0\\0 &amp; x\le0\end{cases}\){:/nomarkdown} ונקבל פונקציה אי שלילית שרציפה וגזירה בכל מקום והיא מתאפסת מחוץ לקטע {::nomarkdown}\( \left(0,\infty\right)\){:/nomarkdown}. זה לא קטע קומפקטי, אז נגדיר {::nomarkdown}\( g\left(x\right)=f\left(x\right)f\left(1-x\right)\){:/nomarkdown} והופס - הפונקציה הזו עדיין נחמדה כמו {::nomarkdown}\( f\){:/nomarkdown}, אבל מתאפסת בכל מקום מלבד הקטע {::nomarkdown}\( \left(0,1\right)\){:/nomarkdown} (ולכן היא אפס בכל מקום מלבד בתוך הקבוצה הקומפטית {::nomarkdown}\( \left[0,1\right]\){:/nomarkdown}).

עכשיו, זו פונקציה במשתנה יחיד. אנחנו רוצים משהו ב-{::nomarkdown}\( \mathbb{R}^{n}\){:/nomarkdown} שמתאפס מחוץ לתיבה {::nomarkdown}\( Q=\left[a_{1},b_{1}\right]\times\dots\times\left[a_{n},b_{n}\right]\){:/nomarkdown}. זה ממש פשוט: בואו נגדיר {::nomarkdown}\( \varphi\left(x\right)=g\left(\frac{x_{1}-a_{1}}{b_{1}-a_{n}}\right)\cdots g\left(\frac{x_{n}-a_{n}}{b_{n}-a_{n}}\right)\){:/nomarkdown}. מה הולך פה? כל גורם מהצורה {::nomarkdown}\( \frac{x-a_{k}}{b_{k}-a_{k}}\){:/nomarkdown} נע בין 0 ל-1 כאשר {::nomarkdown}\( x_{k}\){:/nomarkdown} נע מ-{::nomarkdown}\( a_{k}\){:/nomarkdown} אל {::nomarkdown}\( b_{k}\){:/nomarkdown}, לכן אם {::nomarkdown}\( x_{k}\notin\left[a_{k},b_{k}\right]\){:/nomarkdown} אז ה-{::nomarkdown}\( g\){:/nomarkdown} של הגורם הזה יתאפס ולכן הפונקציה כולה. כלומר, {::nomarkdown}\( \varphi\left(x\right)\){:/nomarkdown} מתאפסת מחוץ ל-{::nomarkdown}\( Q\){:/nomarkdown}. גזירות קל לבדוק והיא נובעת מהגזירות של {::nomarkdown}\( g\){:/nomarkdown}, וכך גם אי-שליליות.

כל הפונקציות בחלוקת היחידה שלנו יוגדרו באמצעות {::nomarkdown}\( \varphi\){:/nomarkdown} כזו, פשוט על תיבות שונות ומשונות, ועם עוד נורמליזציה שנתייחס אליה בסוף שתבטיח שסכום הערכים של כולן יהיה 1 בכל מקום. לעת עתה השאלה שלנו היא בכלל אילו תיבות אני רוצה לבחור. הסיטואציה היא ש-{::nomarkdown}\( A\){:/nomarkdown} נתונה לנו כאיחוד של קבוצות פתוחות, {::nomarkdown}\( A=\bigcup U_{\alpha}\){:/nomarkdown} - זה אוסף קבוצות פתוחות שיכול גם להיות לא בן מניה בכלל. אנחנו רוצים למצוא מספר בן מניה של תיבות, {::nomarkdown}\( Q_{1},Q_{2},\dots\){:/nomarkdown} שאיחודן יכסה את כל {::nomarkdown}\( A\){:/nomarkdown}, שכל אחת מהן תהיה מוכלת באחת מה-{::nomarkdown}\( U_{\alpha}\){:/nomarkdown} הללו, ושכל נקודה ב-{::nomarkdown}\( A\){:/nomarkdown} תהיה בעלת סביבה שחותכת רק מספר סופי של {::nomarkdown}\( Q\){:/nomarkdown}-ים מתוך הסדרה.

מה שהולך לקרות עכשיו יהיה גלישה זריזה לטופולוגיה פשוטה יחסית. נתחיל מכך שקל למצוא סדרה {::nomarkdown}\( D_{1},D_{2},\dots\){:/nomarkdown} של קבוצות קומפקטיות שהאיחוד שלהן נותן בדיוק את {::nomarkdown}\( A\){:/nomarkdown} וכל קבוצה מוכלת בפנים של הבאה אחריה - נבחר למשל את {::nomarkdown}\( D_{n}\){:/nomarkdown} להיות החיתוך בין הכדור הסגור (והחסום) ברדיוס {::nomarkdown}\( n\){:/nomarkdown} סביב הראשית, ובין אוסף הנקודות ב-{::nomarkdown}\( A\){:/nomarkdown}שמרחקן משפת {::nomarkdown}\( A\){:/nomarkdown} הוא לכל הפחות {::nomarkdown}\( \frac{1}{n}\){:/nomarkdown}. זה חיתוך בין שתי קבוצות סגורות שאחת מהן חסומה, כך שזו קבוצה קומפקטית. פורמלית:

{::nomarkdown}\( D_{n}=\left\{ x\in A\ \|\ \left\|x\right\|\le n\wedge d\left(x,\mathbb{R}^{n}\backslash A\right)\ge\frac{1}{n}\right\} \){:/nomarkdown}

דבר כזה נקרא Exhaustion by compact sets. עכשיו ניקח את ה-{::nomarkdown}\( D\){:/nomarkdown}-ים הללו ונתעלל בהן קצת עד שנקבל את התיבות שאנחנו רוצים. ראשית נקבל מהן קבוצות שמתארות רק את "הדברים החדשים שקיבלנו":

{::nomarkdown}\( B_{n}=D_{n}\backslash\mbox{Int}D_{n-1}\){:/nomarkdown} (אני מסמן ב-{::nomarkdown}\( D\){:/nomarkdown} עם אינדקס שלילי את הקבוצה הריקה). שימו לב שזו בעצמה קבוצה קומפקטית. עכשיו, לא מובטח לנו שהיא זרה ל-{::nomarkdown}\( D_{n-1}\){:/nomarkdown} כי העפנו רק את הפנים של {::nomarkdown}\( D_{n-1}\){:/nomarkdown}, אבל מובטח לנו שהיא <strong>כן</strong> זרה ל-{::nomarkdown}\( D_{n-2}\){:/nomarkdown}, כי {::nomarkdown}\( D_{n-2}\){:/nomarkdown} היה מוכל כולו בפנים של {::nomarkdown}\( D_{n-1}\){:/nomarkdown}. זה יהיה מספיק טוב עבורנו.

אפשר לדמיין את מה שהולך כאן כך: {::nomarkdown}\( D_{n}\){:/nomarkdown} הם עיגולים; {::nomarkdown}\( B_{n}\){:/nomarkdown} הן טבעות; ועכשיו נכסה כל טבעת על ידי אוסף סופי של תיבות קטנות. אז לכל {::nomarkdown}\( x\in B_{n}\){:/nomarkdown} ניקח תיבה כלשהי שמכילה את {::nomarkdown}\( x\){:/nomarkdown} בפנים שלה והיא קטנה מספיק כדי להיות מוכלת כולה ב-{::nomarkdown}\( A\){:/nomarkdown} (אפשרי, כי {::nomarkdown}\( A\){:/nomarkdown} קבוצה פתוחה) ולמעשה, היא קטנה מספיק כדי להיות מוכלת כולה באחת מהקבוצות {::nomarkdown}\( U_{\alpha}\){:/nomarkdown} שמכסות את {::nomarkdown}\( A\){:/nomarkdown} (שוב אפשרי, כי {::nomarkdown}\( x\){:/nomarkdown} שייך לפחות לאחת מהקבוצות הללו, ואלו קבוצות פתוחות) וכמו כן היא קטנה מספיק כדי להיות זרה ל-{::nomarkdown}\( D_{n-2}\){:/nomarkdown} (זה אפשרי כי {::nomarkdown}\( x\){:/nomarkdown} לא שייך ל-{::nomarkdown}\( D_{n-2}\){:/nomarkdown} ו-{::nomarkdown}\( D_{n-2}\){:/nomarkdown} היא קבוצה <strong>סגורה</strong>, כלומר המשלימה שלה פתוחה).

ועכשיו מגיע הקסם שבטופולוגיה. אמרנו שה-{::nomarkdown}\( B_{n}\){:/nomarkdown}-ים הללו הן קבוצות <strong>קומפקטיות</strong>. בשבילנו, המתעסקים ב-{::nomarkdown}\( \mathbb{R}^{n}\){:/nomarkdown}, קומפקטיות זה כינוי נרדף ל"סגור וחסום". אבל בעולם הטופולוגי הגדול, קומפקטיות פירושה "לכל כיסוי של הקבוצה באמצעות קבוצות פתוחות קיים תת-כיסוי <strong>סופי</strong> שעדיין מכסה את הקבוצה". ב-{::nomarkdown}\( \mathbb{R}^{n}\){:/nomarkdown} התכונה הזו שקולה לסגירות וחסימות - זה מה שנקרא "משפט היינה-בורל". אצלנו, הפנים של התיבות שלקחנו לכל {::nomarkdown}\( x\){:/nomarkdown} היווה כיסוי פתוח שכזה של {::nomarkdown}\( B_{n}\){:/nomarkdown} ולכן קיים לו תת-כיסוי סופי. לכן, אם ניקח את כל התיבות של כל תתי-הכיסויים הסופיים של כל ה-{::nomarkdown}\( B_{n}\){:/nomarkdown}-ים נקבל קבוצה בת מניה (איחוד בן מניה של קבוצות סופיות) של תיבות שהאיחוד של כולן מכסה את כל ה-{::nomarkdown}\( B_{n}\){:/nomarkdown}-ים ולכן את כל {::nomarkdown}\( A\){:/nomarkdown}, וכל תיבה בו מוכלת ב-{::nomarkdown}\( U_{\alpha}\){:/nomarkdown} כלשהו, ורק צריך להסביר עוד למה תכונת החיתוכים הסופיים מתקיימת.

אם כן, ניקח {::nomarkdown}\( x\in A\){:/nomarkdown} כלשהו ונחפש סביבה פתוחה שלו שחותכת רק מספר <strong>סופי</strong> של תיבות. אנחנו יודעים ש-{::nomarkdown}\( x\in B_{n}\){:/nomarkdown} עבור {::nomarkdown}\( n\){:/nomarkdown} כלשהו. ניקח אם כן סביבה של {::nomarkdown}\( x\){:/nomarkdown} שמוכלת בפנים של {::nomarkdown}\( B_{n}\){:/nomarkdown}. אנחנו גם יודעים שכל תיבה שמכסה את {::nomarkdown}\( B_{k}\){:/nomarkdown}, עבור {::nomarkdown}\( k\ge n+2\){:/nomarkdown}, <strong>לא</strong> חותכת את {::nomarkdown}\( B_{n}\){:/nomarkdown} ולכן לא חותכת את הסביבה של {::nomarkdown}\( x\){:/nomarkdown} שלקחנו. מי אם כן התיבות ה"בעייתיות" מבחינתנו? כל התיבות שמכסות את {::nomarkdown}\( B_{1},B_{2},\dots,B_{n},B_{n+1}\){:/nomarkdown}. אבל כפי שכבר אמרנו, לכל {::nomarkdown}\( B_{k}\){:/nomarkdown} שכזו לקחנו רק מספר <strong>סופי</strong> של תיבות, ויש לנו רק מספר <strong>סופי</strong> של {::nomarkdown}\( B_{k}\){:/nomarkdown}-ים בעייתיים, ולכן הסביבה של {::nomarkdown}\( x\){:/nomarkdown} חותכת רק מספר סופי של תיבות, וסיימנו.

רגע, מה סיימנו? איפה חלוקת היחידה? כבר שכחנו שהיה אמור להיות דבר כזה. כזכור, הראיתי קודם איך בהינתן תיבה {::nomarkdown}\( Q_{i}\){:/nomarkdown} אפשר להגדיר פונקציה {::nomarkdown}\( \varphi_{i}\){:/nomarkdown} שהיא חיובית על הפנים של {::nomarkdown}\( Q_{i}\){:/nomarkdown}, אפס בכל מקום אחר, וגזירה כמה פעמים שרק נרצה. עכשיו, נתונה לנו קבוצה {::nomarkdown}\( A\){:/nomarkdown} שאנחנו רוצים למצוא חלוקת יחידה עבורה, ו-{::nomarkdown}\( A\){:/nomarkdown} מכוסה על ידי קבוצות פתוחות {::nomarkdown}\( U_{\alpha}\){:/nomarkdown} שאנחנו רוצים שישלטו על חלוקת היחידה שלנו, אז ניקח את ה-{::nomarkdown}\( Q_{i}\){:/nomarkdown}-ים שלנו להיות כמו שהראיתי למעלה, וניקח את ה-{::nomarkdown}\( \varphi_{i}\){:/nomarkdown} המתאימים, והדבר הזה הוא כבר כמעט חלוקת יחידה: לכל {::nomarkdown}\( \varphi_{i}\){:/nomarkdown} התומך של {::nomarkdown}\( \varphi_{i}\){:/nomarkdown} הוא {::nomarkdown}\( Q_{i}\){:/nomarkdown} שמוכל באחת מהקבוצות {::nomarkdown}\( U_{\alpha}\){:/nomarkdown}, ולכל {::nomarkdown}\( x\in A\){:/nomarkdown} קיימת ל-{::nomarkdown}\( x\){:/nomarkdown} סביבה שחותכת רק מספר סופי של {::nomarkdown}\( Q_{i}\){:/nomarkdown}, כלומר רק מספר סופי של תומכים של פונקציות בחלוקת היחידה. הדבר היחיד שבינתיים לא עובד הוא שיתקיים {::nomarkdown}\( \sum_{i=1}^{\infty}\varphi_{i}\left(x\right)=1\){:/nomarkdown} לכל {::nomarkdown}\( x\in A\){:/nomarkdown}. הסכום הזה אמנם מוגדר היטב תמיד, כי תכונת החיתוך הסופי אומרת שהוא כולל רק מספר סופי של מחוברים ששונים מאפס, אבל הוא לאו דווקא שווה ל-1. אז מה עושים? מנרמלים. נגדיר פונקציה {::nomarkdown}\( \lambda\left(x\right)=\sum_{i=1}^{\infty}\varphi_{i}\left(x\right)\){:/nomarkdown}, וכעת נגדיר {::nomarkdown}\( \phi_{i}\left(x\right)\triangleq\frac{\varphi_{i}\left(x\right)}{\lambda\left(x\right)}\){:/nomarkdown}. כמובן, צריך להשתכנע ש-{::nomarkdown}\( \lambda\left(x\right)\ne0\){:/nomarkdown} לכל {::nomarkdown}\( x\){:/nomarkdown}; זה נובע מכך שאנחנו יודעים שהפנים של ה-{::nomarkdown}\( Q_{i}\){:/nomarkdown}-ים מכסים את {::nomarkdown}\( A\){:/nomarkdown} ולכן {::nomarkdown}\( x\){:/nomarkdown} שייך לפנים של לפחות {::nomarkdown}\( Q_{i}\){:/nomarkdown} אחד ומכאן ש-{::nomarkdown}\( \varphi_{i}\left(x\right)\ne0\){:/nomarkdown} (וכל ה-{::nomarkdown}\( \varphi_{i}\){:/nomarkdown} הן אי-שליליות ולכן לא יכולות לאפס זו את זו).
<h2>קצת</h2>
הגענו סוף סוף אל הדבר האחרון בפוסט: הראינו שחלוקת יחידה קיימות, ועכשיו נשאר להראות שאפשר להשתמש בהן לפירוק אינטגרלים לסכומים.

כזכור, מה שאנחנו רוצים להוכיח הוא זה: אם {::nomarkdown}\( \phi_{1}\phi_{2},\dots\){:/nomarkdown} היא חלוקת יחידה עם תומכים קומפקטיים של קבוצה פתוחה {::nomarkdown}\( A\){:/nomarkdown}, ויש לנו פונקציה {::nomarkdown}\( f:A\to\mathbb{R}\){:/nomarkdown} שהיא רציפה, אז היא אינטגרבילית מעל {::nomarkdown}\( A\){:/nomarkdown} אם ורק אם הטור {::nomarkdown}\( \sum_{i=1}^{\infty}\int_{A}\phi_{i}\left\|f\right\|\){:/nomarkdown} מתכנס, ובמקרה זה מתקיים ש-{::nomarkdown}\( \int_{A}f=\sum_{i=1}^{\infty}\int_{A}\phi_{i}f\){:/nomarkdown}.

כמו שקורה לפעמים באינטגרלים, ההוכחה תתחיל בלהתעסק בפונקציות {::nomarkdown}\( f\){:/nomarkdown} שהן אי-שליליות ואחר כך תתרחב בהתאם.

אם {::nomarkdown}\( f\){:/nomarkdown} היא אי-שלילית מעל {::nomarkdown}\( A\){:/nomarkdown}, אז {::nomarkdown}\( \left\|f\right\|=f\){:/nomarkdown} ולכן בעצם כל מה שצריך להראות הוא את השוויון {::nomarkdown}\( \int_{A}f=\sum_{i=1}^{\infty}\int_{A}\phi_{i}f\){:/nomarkdown} משני הכיוונים. נעשה את זה בצורה קצת מתחכמת. ראשית, נניח שהטור באגף ימין מתכנס, ונוכיח שהאינטגרל באגף שמאל מתכנס, ושערכו חסום מלמעלה על ידי אגף ימין. אחר כך נניח שאגף שמאל מתכנס ונוכיח שאגף ימין מתכנס ושערכו חסום מלמעלה על ידי אגף שמאל. שני אלו ביחד נותנים לנו את הטענה כולה.

נתחיל עם אגף ימין. כלומר, נניח שהטור {::nomarkdown}\( \sum_{i=1}^{\infty}\int_{A}\phi_{i}f\){:/nomarkdown} מתכנס (שימו לב לכך ש-{::nomarkdown}\( \int_{A}\phi_{i}f\){:/nomarkdown} <strong>תמיד</strong> קיים כי {::nomarkdown}\( \phi_{i}f\){:/nomarkdown} היא פונקציה רציפה בעלת תומך קומפקטי, וראינו שפונקציות כאלו הן תמיד אינטגרביליות, כך שהסכום תמיד מוגדר היטב והשאלה היחידה היא האם הוא מתכנס). נוכיח ש-{::nomarkdown}\( f\){:/nomarkdown} אינטגרבילית מעל {::nomarkdown}\( A\){:/nomarkdown} והאינטגרל שלה קטן או שווה לסכום הזה. לשם כך, בואו נזכור איך הוגדר אינטגרל מוכלל {::nomarkdown}\( \int_{A}f\){:/nomarkdown}: זה הסופרמום של {::nomarkdown}\( \int_{D}f\){:/nomarkdown} על כל הקבוצות {::nomarkdown}\( D\subseteq A\){:/nomarkdown} שהן קומפקטיות ומדידות ז'ורדן. תהא {::nomarkdown}\( D\){:/nomarkdown} קבוצה כזו. כעת נשתמש בקסם של חלוקת יחידה: לכל נקודה {::nomarkdown}\( x\in D\){:/nomarkdown} קיימת סביבה שבה מתאפסות כל ה-{::nomarkdown}\( \phi_{i}\){:/nomarkdown} פרט למספר סופי. איחוד כל הסביבות הללו מכסה את {::nomarkdown}\( D\){:/nomarkdown}, ומכיוון ש-{::nomarkdown}\( D\){:/nomarkdown} קומפקטית, אפשר לקחת <strong>מספר סופי</strong> שלהן שעדיין יכסה את {::nomarkdown}\( D\){:/nomarkdown}. קיבלנו אוסף סופי של סביבות כך שלכל סביבה רק מספר סופי של {::nomarkdown}\( \phi_{i}\){:/nomarkdown}-ים הוא לא זהותית אפס, ומכאן שעל כל {::nomarkdown}\( D\){:/nomarkdown} רק מספר סופי של {::nomarkdown}\( \phi_{i}\){:/nomarkdown}-ים אינו זהותית אפס. כלומר, קיים איזה שהוא {::nomarkdown}\( N\){:/nomarkdown} טבעי כך שלכל {::nomarkdown}\( i&gt;N\){:/nomarkdown} מתקיים {::nomarkdown}\( \phi_{i}\left(x\right)=0\){:/nomarkdown} לכל {::nomarkdown}\( x\in A\){:/nomarkdown}. דהיינו, {::nomarkdown}\( \sum_{i=1}^{N}\phi_{i}\left(x\right)=1\){:/nomarkdown} ולכן {::nomarkdown}\( f\left(x\right)=\sum_{i=1}^{N}f\left(x\right)\phi_{i}\left(x\right)\){:/nomarkdown}. הסופיות של הסכום הזה מאפשרת לנו להשתמש בתכונה נחמדה מאוד של אינטגרלים - <strong>לינאריות</strong>. לא הוכחתי את זה בפוסטים הללו, אבל לא קשה לראות ש-{::nomarkdown}\( \int_{A}\left(\alpha f+\beta g\right)=\alpha\int_{A}f+\beta\int_{A}g\){:/nomarkdown} עבור {::nomarkdown}\( f,g\){:/nomarkdown} פונקציות ו-{::nomarkdown}\( \alpha,\beta\in\mathbb{R}\){:/nomarkdown} סקלרים - זה נובע ישירות מההגדרות. כמובן, אם זה עובד עבור שני מחוברים, זה עובד עבור כל מספר <strong>סופי</strong> של מחוברים, ולכן:

{::nomarkdown}\( \int_{D}f=\int_{D}\sum_{i=1}^{N}\phi_{i}f=\sum_{i=1}^{N}\int_{D}\phi_{i}f\){:/nomarkdown}

עכשיו, לא קשה לראות ש-{::nomarkdown}\( \int_{D}\phi_{i}f\le\int_{A}\phi_{i}f\){:/nomarkdown}, פשוט כי אנחנו מרחיבים את התחום שעליו אנחנו מבצעים אינטגרציה לפונקציה אי-שלילית (מ-{::nomarkdown}\( D\){:/nomarkdown} אל כל {::nomarkdown}\( A\){:/nomarkdown} - או ליתר דיוק, אל כל התומך של {::nomarkdown}\( \phi_{i}\left(x\right)\){:/nomarkdown} ב-{::nomarkdown}\( A\){:/nomarkdown}). לכן נקבל:

{::nomarkdown}\( \int_{D}f\left(x\right)\le\sum_{i=1}^{N}\int_{A}\phi_{i}f\le\sum_{i=1}^{\infty}\int_{A}\phi_{i}f\){:/nomarkdown}

כלומר, קיבלנו שלכל {::nomarkdown}\( D\){:/nomarkdown}, {::nomarkdown}\( \int_{D}f\){:/nomarkdown} הוא חסום; מכאן בפרט שלקבוצה של כל ה-{::nomarkdown}\( \int_{D}f\){:/nomarkdown} הללו קיים חסם עליון ולכן {::nomarkdown}\( \int_{A}f\){:/nomarkdown} מוגדר, ושווה לו. אנחנו גם יודעים שהחסם העליון הזה הוא לכל היותר {::nomarkdown}\( \sum_{i=1}^{\infty}\int_{A}\phi_{i}f\){:/nomarkdown}, כלומר קיבלנו את הכיוון הראשון שרצינו.

בכיוון השני, אנחנו מניחים ש-{::nomarkdown}\( f\){:/nomarkdown} (עדיין אי שלילית) אינטגרבילית ורוצים להוכיח ש-{::nomarkdown}\( \sum_{i=1}^{\infty}\int_{A}\phi_{i}f\){:/nomarkdown} מתכנס וחסום על ידי {::nomarkdown}\( \int_{A}f\){:/nomarkdown}; מן הסתם מכיוון שזה טור אי-שלילי מספיק להוכיח את החסימות. שוב, התעלול הוא לעבור לדבר על סכום סופי - מספיק אם נוכיח ש-{::nomarkdown}\( \sum_{i=1}^{N}\int_{A}\phi_{i}f\le\int_{A}f\){:/nomarkdown} לכל {::nomarkdown}\( N\){:/nomarkdown} טבעי. בהינתן {::nomarkdown}\( N\){:/nomarkdown} כזה, אפשר להסתכל על איחוד כל התומכים של {::nomarkdown}\( \phi_{1},\dots,\phi_{N}\){:/nomarkdown} - זה איחוד סופי של קבוצות קומפקטיות ולכן הוא בעצמו קבוצה קומפקטית, {::nomarkdown}\( D\subseteq A\){:/nomarkdown}. מן הסתם מספיק להוכיח ש-{::nomarkdown}\( \sum_{i=1}^{N}\int_{A}\phi_{i}f\le\int_{D}f\){:/nomarkdown}.

כעת, {::nomarkdown}\( \sum_{i=1}^{N}\int_{A}\phi_{i}f=\sum_{i=1}^{N}\int_{D}\phi_{i}f\){:/nomarkdown} (כי מחוץ ל-{::nomarkdown}\( D\){:/nomarkdown} ממילא כל ה-{::nomarkdown}\( \phi_{i}\){:/nomarkdown} הרלוונטיות מתאפסות), ומלינאריות נקבל {::nomarkdown}\( \sum_{i=1}^{N}\int_{D}\phi_{i}f=\int_{D}\sum_{i=1}^{N}\phi_{i}f\){:/nomarkdown}. מכיוון שלכל {::nomarkdown}\( x\){:/nomarkdown} מתקיים {::nomarkdown}\( \sum_{i=1}^{N}\phi_{i}f\left(x\right)\le f\left(x\right)\){:/nomarkdown} נקבל ש-{::nomarkdown}\( \int_{D}\sum_{i=1}^{N}\phi_{i}f\le\int_{D}f\){:/nomarkdown}, וזה מה שרצינו.

זה מסיים את הוכחת טענת האם-ורק-אם. כי למשל, אם נניח ש-{::nomarkdown}\( \int_{A}f\){:/nomarkdown} קיים, אז נקבל מייד ש-{::nomarkdown}\( \sum_{i=1}^{\infty}\int_{A}\phi_{i}f\le\int_{A}f\){:/nomarkdown} וכמו כן ש-{::nomarkdown}\( \sum_{i=1}^{\infty}\int_{A}\phi_{i}f\){:/nomarkdown} מתכנס. אבל אם {::nomarkdown}\( \sum_{i=1}^{\infty}\int_{A}\phi_{i}f\){:/nomarkdown} מתכנס אז נובע מהכיוון השני של ההוכחה ש-{::nomarkdown}\( \int_{A}f\le\sum_{i=1}^{\infty}\int_{A}\phi_{i}f\){:/nomarkdown} ולכן קיבלנו ששני האגפים שווים.

נשאר רק לטפל בפונקציה {::nomarkdown}\( f\){:/nomarkdown} כללית, לאו דווקא אי שלילית. זה דווקא השלב הפשוט ביותר שמבוסס על תעלול שכבר ראינו בפוסט הקודם - כותבים את {::nomarkdown}\( f\){:/nomarkdown} בתור הפרש של שתי פונקציות אי-שליליות, {::nomarkdown}\( f=f_{+}-f_{-}\){:/nomarkdown}, כאשר {::nomarkdown}\( f_{-}\left(x\right)=\max\left\{ -f\left(x\right),0\right\} \){:/nomarkdown}, וכעת:

{::nomarkdown}\( \int_{A}f=\int_{A}f_{+}-\int_{A}f_{-}\){:/nomarkdown}

זוהי, כזכור, ההגדרה של אינטגרל מוכלל עבור פונקציות כלליות. עכשיו נשתמש במה שכבר ראינו ונקבל

{::nomarkdown}\( \int_{A}f_{+}-\int_{A}f_{-}=\sum_{i=1}^{\infty}\int_{A}\phi_{i}f_{+}-\sum_{i=1}^{\infty}\int_{A}\int_{A}\phi_{i}f_{-}=\sum_{i=1}^{\infty}\int_{A}\phi_{i}\left(f_{+}-f_{-}\right)=\sum_{i=1}^{\infty}\int_{A}\phi_{i}f\){:/nomarkdown}

כאשר המעבר האמצעי, מהפרש שני סכומים לסכום בודד, דורש כמובן הצדקה - אפשר לבצע חיבור כזה רק אם שני הסכומים <strong>מתכנסים</strong>. הדרישה הכללית לכך שהטור {::nomarkdown}\( \sum_{i=1}^{\infty}\int_{A}\phi_{i}\left\|f\right\|\){:/nomarkdown} מבטיחה בדיוק את זה, ובכך מסתיימת הוכחת החלק הזה, והוכחת כל מה שרציתי להוכיח בפוסט הזה.
<h1>דברי סיכום ופרידה</h1>
הפוסט הזה היה ארוך מאוד כי התעקשתי לדחוף לתוכו אינסוף דברים שונים, שבספרי לימוד לרוב מקבלים כמה פרקים משל עצמם ולא רציתי להקדיש להם פוסטים נפרדים. עדיין, אני חושב שלא כל כך קשה לראות את התמונה הגדולה פה, אלא שאלו הפרטים הקטנים שעושים את המשפט הזה. זה לי מרגיש כמו מכונה ענקית שבה כל רגע משהו עלול להתרסק וברגע האחרון אנחנו ניצלים מחורבן גמור כי היי תראו! קומפקטיות אומרת שהופס הנה יש לנו כיסוי סופי ובדיוק בנקודה של הקצה של הצ'ופצ'יק פה אנחנו חייבים שמשהו יהיה סופי!

אז תשמעו, ככה זה. אם הולכים מספיק רחוק במתמטיקה, בכל כיוון שהוא, מגיעים למשפטים כאלו - והמשפט הזה הוא יחסית פשוט. אני חושב שהפרטים הטכניים כאן מעניינים, אבל מן הסתם אם מישהו לא מצליח לצלוח את כולם, אפשר להסתדר גם בלעדיהם. בינתיים.
