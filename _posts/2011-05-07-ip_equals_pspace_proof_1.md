---
id: 1127
title: "IP=PSPACE - ההוכחה (חלק א')"
date: 2011-05-07 18:09:06
layout: post
categories: 
  - תורת הסיבוכיות
tags: 
  - IP
  - IP=PSPACE
  - PSPACE
  - גם טכני זה כיף!
  - הוכחות יפות
  - טכני
  - פרוייקט "תוצאות מפתיעות בסיבוכיות"
---
<a href="http://www.gadial.net/?p=1074">בשעה טובה</a> גמרנו להציג את השחקנים בהוכחה של IP=PSPACE ובפוסט הזה ניתן להם להשתולל. ההוכחה מכילה מספר פרטים טכניים ונראית די מפחידה במבט ראשון, אבל הרעיונות שלה אינם כה מסובכים ואני חושב שכל קורא עם ידע בסיסי במתמטיקה יהיה מסוגל להבין אותה (לא בלי השקעה מצדו, כמובן). שיהיה לנו בהצלחה.

משפט אימרמן שהצגתי לא מזמן הצטמצם בסופו של דבר לפתרון של בעיה אחת - בעיית אי-הישיגות בגרף, שהייתה מה שנקרא {::nomarkdown}\( \mbox{coNL}\){:/nomarkdown}-שלמה. גם הוכחה ש-{::nomarkdown}\( \mbox{IP=PSPACE}\){:/nomarkdown} היא בעיקרה פתרון של בעיה אחת ספציפית - {::nomarkdown}\( \mbox{TQBF}\){:/nomarkdown}, שהוזכרה בפוסט הקודם. אם נציג מערכת הוכחה יעילה עבור בעיה זו, סיימנו, מכיוון שכל בעיה אחרת ב-{::nomarkdown}\( \mbox{PSPACE}\){:/nomarkdown} ניתן לתרגם לבעיית {::nomarkdown}\( \mbox{TQBF}\){:/nomarkdown} ולהסתפק במערכת ההוכחה עבור {::nomarkdown}\( \mbox{TQBF}\){:/nomarkdown} שכבר יש לנו. זה אולי ירגיז את חלקכם שרוצים לראות הוכחה שלמה ככל הניתן ל-{::nomarkdown}\( \mbox{IP=PSPACE}\){:/nomarkdown} ושמו לב שטרם הוכחתי ש-{::nomarkdown}\( \mbox{TQBF}\){:/nomarkdown} היא {::nomarkdown}\( \mbox{PSPACE}\){:/nomarkdown}-שלמה. זה נכון, וזה חוב שאחזיר מתישהו; אבל זה לא העיקר בהוכחה - כשנמצאה ההוכחה ל-{::nomarkdown}\( \mbox{IP=PSPACE}\){:/nomarkdown} הייתה עובדת היותה של {::nomarkdown}\( \mbox{TQBF}\){:/nomarkdown} שפה {::nomarkdown}\( \mbox{PSPACE}\){:/nomarkdown}-שלמה משהו ידוע ומוכר לגמרי.

עוד דבר שאסתפק בלהעיר עליו שתי מילים וזהו הוא העובדה ש-{::nomarkdown}\( \mbox{IP}\subseteq\mbox{PSPACE}\){:/nomarkdown} זו טענה קלה מאוד להוכחה בשיטת החיפוש הממצה הגס שדיברתי עליה בפוסט הקודם. אפשר לחשוב על מערכת ההוכחה האינטראקטיבית כעל "משחק" שבו הודעות המוכיח הן המהלכים שלו והודעות המוודא הן המהלכים שלו. להבדיל ממשחקים רגילים, כאן מעניינת אותנו <strong>ההסתברות</strong> שהמוכיח ישיג ניצחון, אולם בדיקה של הסתברות זו זהה באופיה לסריקת עץ המשחק ה"רגילה" שמיועדת לגלות למי יש אסטרטגיית נצחון במשחק, כך שלא ארחיב על כך יותר; השורה התחתונה היא שהכוח הגס של {::nomarkdown}\( \mbox{PSPACE}\){:/nomarkdown} ניצח שוב. החלק המאתגר בהוכחה הוא הכיוון השני של ההכלה, שהוא בדיוק מה שמערכת הוכחה אינטראקטיבית עבור {::nomarkdown}\( \mbox{TQBF}\){:/nomarkdown} תיתן לנו.

כמו שבדרך כלל עושים עם הוכחות מסובכות, מאוד כדאי להתחיל עם הוכחה של טענה חלשה יותר, שעדיין כוללת את הרעיונות המרכזיים של הההוכחה האמיתית ובכך מקלה מאוד על העיכול שלה. במקרה שלנו, נרצה להראות מערכת הוכחה אינטראקטיבית לשפה שהיא {::nomarkdown}\( \mbox{coNP}\){:/nomarkdown}-שלמה - השפה {::nomarkdown}\( \overline{\mbox{3SAT}}\){:/nomarkdown}. שפת כל פסוקי ה-CNF{::nomarkdown}\( 3\){:/nomarkdown} שאינם ספיקים (פסוק CNF הוא "וגם" של הרבה פסוקיות, שכל אחת מהן היא "או" של 3 ליטרלים, שכל אחד מהם הוא משתנה או שלילה של משתנה, ופסוק הוא ספיק אם יש השמה למשתנים שנותנת לו ערך אמת). ברור שאם פסוק הוא ספיק אז קל להוכיח זאת - פשוט נותנים למוודא את ההשמה המספקת. אבל אם הוא לא ספיק לא ברור מה אפשר לעשות, ולכן מערכת הוכחה אינטראקטיבית כאן היא מעניינת. השפה 3CNF מזכירה קצת את TQBF בכך ששתיהן עוסקות בפסוקים לוגיים; ב-TQBF הפסוק עצמו גם מכיל כמתים בנוסף לכל הצרות. אבל כבר כעת ברור שאנחנו הולכים לפתור מקרה דומה יחסית.

הרעיון הראשון בהוכחה הוא להפסיק לדבר על פסוקי CNF ולעבור לדבר על אובייקט אלגברי חביב ואהוב במיוחד - פולינומים. המעבר מפסוק לוגי לפולינום מכונה <strong>אריתמטיזציה</strong>, ובשלב הראשון כנראה ייראה לכם חסר ערך לחלוטין, סתם ניסוח מטופש של אותה בעיה עם עולם מושגים שונה. כמובן שהניסוח השונה לא יהיה סוף הסיפור.

איך אפשר לתרגם את משתנים לוגיים לפולינום, הרי {::nomarkdown}\( \mbox{T,F}\){:/nomarkdown} הם לא ערכים שבדרך כלל חוקי להציב בפולינום? ובכן, באופן טבעי יחסית נחשוב על 0 כמייצג {::nomarkdown}\( \mbox{F}\){:/nomarkdown} ועל 1 כמייצג {::nomarkdown}\( \mbox{T}\){:/nomarkdown}. אם בפסוק הלוגי יש משתנה {::nomarkdown}\( x_{1}\){:/nomarkdown}, אז בפולינום יהיה משתנה {::nomarkdown}\( X_{1}\){:/nomarkdown} מתאים (המעבר מאות קטנה לגדולה נועד רק כדי להבטיח שיהיה ברור מתי מדברים על פולינום ומתי מדברים על פסוק לוגי). פעולת "וגם" ניתנת לביצוע בידי כפל: {::nomarkdown}\( x_{1}\wedge x_{2}\){:/nomarkdown} הוא {::nomarkdown}\( X_{1}\cdot X_{2}\){:/nomarkdown}, ובאופן כללי אם {::nomarkdown}\( \varphi_{1},\varphi_{2}\){:/nomarkdown} הן שתי פסוקיות שמיוצגות בידי הפולינומים {::nomarkdown}\( P_{\varphi_{1}},P_{\varphi_{2}}\){:/nomarkdown} אז {::nomarkdown}\( \varphi_{1}\wedge\varphi_{2}\){:/nomarkdown} מיוצגת על ידי {::nomarkdown}\( P_{\varphi_{1}}\cdot P_{\varphi_{2}}\){:/nomarkdown}.

פעולת "לא" ניתנת לביצוע על ידי חיסור: {::nomarkdown}\( \neg x_{1}\){:/nomarkdown} מיוצג על ידי {::nomarkdown}\( 1-X_{1}\){:/nomarkdown}, ואם {::nomarkdown}\( P_{\varphi}\){:/nomarkdown} מייצג את {::nomarkdown}\( \varphi\){:/nomarkdown} אז {::nomarkdown}\( 1-P_{\varphi}\){:/nomarkdown} מייצג את {::nomarkdown}\( \neg\varphi\){:/nomarkdown}.

שתי הפעולות הללו מאפשרות ייצוג של כל פסוק שהוא כי אפשר "לסמלץ" איתן את "או" באמצעות כלל דה-מורגן: {::nomarkdown}\( x_{1}\vee x_{2}=\neg\left(\neg x_{1}\wedge\neg x_{2}\right)\){:/nomarkdown}. במילים אחרות, את {::nomarkdown}\( x_{1}\vee x_{2}\){:/nomarkdown} מייצגים על ידי הפולינום {::nomarkdown}\( 1-\left(1-X_{1}\right)\left(1-X_{2}\right)\){:/nomarkdown}.

משלושת אלו נובע שכל נוסחת 3CNF עם {::nomarkdown}\( n\){:/nomarkdown} משתנים, {::nomarkdown}\( \varphi\left(x_{1},\dots,x_{n}\right)\){:/nomarkdown}, ניתן לתרגם לפולינום {::nomarkdown}\( P\left(X_{1},\dots,X_{n}\right)\){:/nomarkdown} ב-{::nomarkdown}\( n\){:/nomarkdown} משתנים. לאלו מכם שאולי מכירים רק פולינומים במשתנה אחד נציין שפולינום מרובה משתנים הוא פשוט סכום של ביטויים מהצורה {::nomarkdown}\( aX_{1}^{k_{1}}X_{2}^{k_{2}}\dots X_{n}^{k_{n}}\){:/nomarkdown} - כלומר, מקדם כלשהו ואז מכפלה של חזקות של המשתנים. כל ביטוי כזה נקרא <strong>מונום</strong>. הדרגה של מונום היא סכום החזקות של כל המשתנים, והדרגה של הפולינום כולו היא הדרגה הגבוהה ביותר של מונום שבו. למשל, {::nomarkdown}\( 5xy+7xyz+2y^{2}z^{3}\){:/nomarkdown} הוא פולינום בשלושה משתנים שדרגתו 5.

נקודה אחת שכדאי לשים לב אליה היא שפסוקית עם 3 ליטרלים מתורגמת לפולינום ממעלה שלישית (בדקו זאת!), ושפסוק 3CNF עם {::nomarkdown}\( k\){:/nomarkdown} פסוקיות בסך הכל מתורגם לפולינום ממעלה {::nomarkdown}\( 3k\){:/nomarkdown} לכל היותר. כלומר, הדרגה של הפולינום היא "בערך" כאורך הפסוק; זה חשוב כדי להבטיח שאת מלאכת התרגום של נוסחה לפסוק אפשר יהיה לבצע בזמן פולינומי.

כעת, אם {::nomarkdown}\( P_{\varphi}\left(X_{1},\dots,X_{n}\right)\){:/nomarkdown} מייצג את הפסוק {::nomarkdown}\( \varphi\left(x_{1},\dots,x_{n}\right)\){:/nomarkdown}, אז מספר ההשמות המספקות של {::nomarkdown}\( \varphi\){:/nomarkdown} נתון על ידי הנוסחה {::nomarkdown}\( \sum_{b_{1}\in\left\{ 0,1\right\} }\sum_{b_{2}\in\left\{ 0,1\right\} }\dots\sum_{b_{n}\in\left\{ 0,1\right\} }P_{\varphi}\left(b_{1},\dots,b_{n}\right)\){:/nomarkdown}. זה נראה אולי קצת מפחיד במבט ראשון, אבל זה ממש לא נורא: אנחנו בסך הכל סוכמים הרבה מאוד איברים - לכל הצבה אפשרית של ערכי 0 ו-1 למשתנים {::nomarkdown}\( X_{1},\dots,X_{n}\){:/nomarkdown} אנחנו בודקים איזה ערך הפולינום קיבל ומוסיפים לסכום. אם כן, הפכנו את הבעיה שלנו לבעיה מסוג שונה, בעיה אלגברית יותר - בהינתן פולינום {::nomarkdown}\( P\left(X_{1},\dots,X_{n}\right)\){:/nomarkdown} ומספר {::nomarkdown}\( K\){:/nomarkdown}, להוכיח ש-{::nomarkdown}\( \sum_{b_{1}\in\left\{ 0,1\right\} }\dots\sum_{b_{n}\in\left\{ 0,1\right\} }P\left(b_{1},\dots,b_{n}\right)=K\){:/nomarkdown}. מכאן ואילך נתעסק רק בבעיה הזו.

עכשיו אתם אולי שואלים את עצמכם מה יצא לנו מכל העסק הזה - עברנו מבעיה פשוטה שמערבת פסוקים לוגיים, לבעיה יותר מסובכת עם פולינומים. הפאנץ' המרכזי כאן הוא זה: <strong>בפולינומים אפשר להציב ערכים נוספים</strong> פרט ל-0 ו-1. הצבה שכזו נראית במבט ראשון כמו ג'יבריש, כי מה קורה כשמציבים משהו שאינו אפס או אחד בפולינום שמנסה לייצג פסוק לוגי? מקבלים תוצאה שאין לה שום משמעות שקשורה לפסוק המקורי! אבל, תזכרו שאנחנו כבר לא מנסים לפתור בעיה שקשורה לפסוקים אלא בעיה כלשהי שקשורה לפולינומים, ולכן המשמעות המקורית ההיא לא חשובה לנו יותר. כפי שנראה בקרוב, היכולת להציב בפולינום ערכים שאינם 0 או 1 היא בדיוק מה שנותן למוודא את הכוח לבחון אינטראקטיבית את המוכיח.

אולי התכונה החשובה ביותר של פולינומים עם משתנה יחיד, וזו שבה נשתמש בהמשך, היא שהם לא יכולים להתאפס ביותר מדי נקודות: פולינום ממעלה {::nomarkdown}\( n\){:/nomarkdown} שאיננו זהותית אפס (כלומר, כל הצבה בו מניבה אפס) יכול לתת אפס רק בהצבה של לכל היותר {::nomarkdown}\( n\){:/nomarkdown} ערכים (לערכים כאלו קוראים "שורשים" של הפולינום). לפעמים קוראים בטעות לטענה הזו "המשפט היסודי של האלגברה", אבל המשפט היסודי של האלגברה הוא די הפוך - הוא הטענה שבמספרים המרוכבים, לפולינום ממעלה {::nomarkdown}\( n\){:/nomarkdown} יש בדיוק {::nomarkdown}\( n\){:/nomarkdown} שורשים (זה לא ניסוח מדויק; ייתכן שאותו שורש יחזור על עצמו כמה פעמים - אבל זה לא פוסט על המשפט היסודי של האלגברה, <a href="http://www.gadial.net/?p=215">כזה כבר היה</a>).

צריך להיות זהירים כאן - הטענה הזו על פולינומים נכונה רק כשהפולינום מוגדר מעל <strong>שדה</strong>, כמו המספרים הרציונליים או הממשיים. למשל, בקבוצה {::nomarkdown}\( \mathbb{Z}_{16}\){:/nomarkdown} של המספרים השלמים מ-0 עד 15 עם חיבור וכפל מודולו 16 לפולינום {::nomarkdown}\( x^{2}\){:/nomarkdown} ישנם שורשים למכביר: 0, וגם 4, וגם 8. אם כן, אפשר היה לדבר על הפולינום מעל הרציונליים, או הממשיים, אבל אלו שדות גדולים <strong>מדי</strong> לצרכים שלנו - בהמשך הפרוטוקול המוודא יצטרך לבחור באקראי איברים מהם, ומכיוון שהם שדות אינסופיים בחירה שכזו היא בעייתית. לכן עוברים לדבר על הפולינום מעל שדה סופי פשוט - קבוצה מהצורה {::nomarkdown}\( \mathbb{Z}_{p}\){:/nomarkdown} כאשר {::nomarkdown}\( p\){:/nomarkdown} הוא ראשוני (עבור ראשוניים הקבוצה הזו היא אכן שדה - הרי לכם דוגמה אחת לאופן שבו הראשוניים צצים באופן טבעי באלגברה). לכן הפרוטקול נפתח בבחירה של {::nomarkdown}\( p\){:/nomarkdown} גדול - כמה גדול? נדבר על זה אחר כך - על ידי המוכיח, שליחה למוודא, ובדיקה של המוודא שאותו {::nomarkdown}\( p\){:/nomarkdown} הוא אכן ראשוני בעזרת אלגוריתם כלשהו לבדיקת ראשוניות (מילר-רבין <a href="http://www.gadial.net/?p=202">שהזכרתי בבלוג בעבר</a> מספיק טוב כאן; הוא אמנם הסתברותי אבל כל מערכת ההוכחה האינטראקטיבית היא הסתברותית).

ועכשיו הטריק הוא זה: בואו נגדיר פולינום {::nomarkdown}\( g\left(X\right)\){:/nomarkdown} על ידי כך שניקח את הסכום של {::nomarkdown}\( P\){:/nomarkdown} שלעיל ונותיר בו את המשתנה הראשון בלי ידוע. כלומר:

{::nomarkdown}\( g\left(X\right)=\sum_{b_{2}\in\left\{ 0,1\right\} }\dots\sum_{b_{n}\in\left\{ 0,1\right\} }P\left(X,b_{2},\dots,b_{n}\right)\){:/nomarkdown} - שימו לב שהסכומים התחילו מ-{::nomarkdown}\( b_{2}\){:/nomarkdown}. אם למוודא היה ביד את הפולינום הזה, הוא היה יכול לבדוק בקלות האם הסכום המקורי יוצא {::nomarkdown}\( K\){:/nomarkdown} - הוא פשוט היה מחשב את {::nomarkdown}\( g\left(0\right)+g\left(1\right)\){:/nomarkdown} ובודק את התוצאה (למה זה עובד?). רק מה, חישוב של {::nomarkdown}\( g\left(X\right)\){:/nomarkdown} הוא בעייתי כמעט כמו חישוב של כל הסכומים, אם כי הוא <strong>טיפה</strong> פחות בעייתי שכן יש משתנה אחד פחות שמעורב במשחק. אז במקום לחשב את הפולינום בעצמו, המוודא יבקש מהמוכיח לשלוח לו אותו - כלומר, לשלוח למוודא את סדרת המקדמים של הפולינום. מעלת הפולינום היא אותה מעלה כשל {::nomarkdown}\( P\){:/nomarkdown} שכבר הסברנו שאינה גדולה, כך שמספר המקדמים שהמוכיח שולח אינו גדול. אחרי שהמוודא קיבל מהמוכיח את {::nomarkdown}\( g\){:/nomarkdown} הוא יכול לחשב את {::nomarkdown}\( g\left(0\right)+g\left(1\right)\){:/nomarkdown}, ואם קיבל משהו שונה מ-{::nomarkdown}\( K\){:/nomarkdown}, לדחות מייד. אבל אם הוא קיבל, כצפוי, {::nomarkdown}\( K\){:/nomarkdown}, מה עכשיו? הוא לא יכול לקבל, מהטעם הפשוט שהוא לא סומך על המוכיח! מה אם המוכיח שלח לו סתם פולינום שלא קשור ל-{::nomarkdown}\( P\){:/nomarkdown} בשום צורה (והינדס את הפולינום כדי שכן יקיים {::nomarkdown}\( g\left(0\right)+g\left(1\right)=K\){:/nomarkdown})?

אם כן, המוודא עושה את המשחק הבא: הוא אומר למוכיח "אוקיי, אני סומך עלייך שאם {::nomarkdown}\( g\){:/nomarkdown} הוא אכן הפולינום שהיית אמור לשלוח לי, אז הסכום המקורי יצא {::nomarkdown}\( K\){:/nomarkdown} ואפשר לשכוח ממנו. עכשיו בוא תוכיח לי ש-{::nomarkdown}\( g\){:/nomarkdown} הוא אכן הפולינום שהיית אמור לשלוח לי". אבל איך המוכיח יכול להוכיח את זה?

כאן מגיע הפאנץ' המובטח. המוודא יגריל מספר <strong>כלשהו</strong> {::nomarkdown}\( a\){:/nomarkdown} מתוך השדה, יציב אותו ב-{::nomarkdown}\( g\){:/nomarkdown} ויקבל מספר, {::nomarkdown}\( g\left(a\right)\){:/nomarkdown}. כעת הוא יפנה למוכיח את האתגר הבא: הוכח נא עבורי שמתקיים {::nomarkdown}\( \sum_{b_{2}\in\left\{ 0,1\right\} }\dots\sum_{b_{n}\in\left\{ 0,1\right\} }P\left(a,b_{2},\dots,b_{n}\right)=g\left(a\right)\){:/nomarkdown}. אבל מה זה האתגר הזה? זה בדיוק אותו דבר שהתחלנו ממנו - המוכיח מנסה להוכיח למוודא שאם לוקחים פולינום, מציבים במשתנים שלו את כל הקומבינציות האפשריות של 0 ו-1 וסוכמים, מקבלים מספר מסויים. ההבדל היחיד הוא שהפולינום החדש הוא בעל <strong>פחות משתנים</strong>, כי "חיסלנו" את אחד המשתנים על ידי כך שהצבנו בו {::nomarkdown}\( a\){:/nomarkdown}.

אם כן, המוכיח והמוודא יחזרו שוב על פרוטוקול ההוכחה, ובסוף יווצר אתגר חדש ששוב יהיה בו משתנה אחד פחות, וכן הלאה וכן הלאה עד שלבסוף המוודא יוותר עם פולינום בעל משתנה אחד בלבד - ועליו אפשר לבדוק בצורה ישירה אם הוא מקיים את הדרישה - פשוט מחשבים את ערכיו על 0 ו-1 וסוכמים.

הדרך היחידה שבה המוכיח יוכל לעבוד על המוודא כאן תהיה אם הוא יגריל פולינום {::nomarkdown}\( g\){:/nomarkdown} כך שבאורח קסום מתקיים {::nomarkdown}\( \sum_{b_{2}\in\left\{ 0,1\right\} }\dots\sum_{b_{n}\in\left\{ 0,1\right\} }P\left(a,b_{2},\dots,b_{n}\right)=g\left(a\right)\){:/nomarkdown} וזאת למרות ש-{::nomarkdown}\( g\){:/nomarkdown} איננו הפולינום שמוגדר על ידי המשוואה {::nomarkdown}\( \sum_{b_{2}\in\left\{ 0,1\right\} }\dots\sum_{b_{n}\in\left\{ 0,1\right\} }P\left(X,b_{2},\dots,b_{n}\right)\){:/nomarkdown}. מה הסיכוי שזה יקרה?

באופן כללי אם {::nomarkdown}\( p,q\){:/nomarkdown} הם שני פולינומים במשתנה יחיד, מה ההסתברות ש-{::nomarkdown}\( p\left(a\right)=q\left(a\right)\){:/nomarkdown} עבור {::nomarkdown}\( a\){:/nomarkdown} שנבחר באקראי? ובכן, זו ההסתברות ש-{::nomarkdown}\( a\){:/nomarkdown} יהיה שורש של הפולינום {::nomarkdown}\( p\left(a\right)-q\left(a\right)\){:/nomarkdown} - פולינום שאינו זהותית אפס, ולכן מספר שורשיו הוא לכל היותר כדרגת פולינום ההפרש - נאמר שהיא {::nomarkdown}\( d\){:/nomarkdown}. אז ההסתברות להצלחה היא {::nomarkdown}\( \frac{d}{p}\){:/nomarkdown}, וכאן צריך לחשוב על {::nomarkdown}\( d\){:/nomarkdown} כקטן יחסית ועל {::nomarkdown}\( p\){:/nomarkdown} כגדול. מכאן שההסתברות שהמוכיח <strong>לא</strong> יצליח לעבוד על המוודא בסיבוב מסויים היא {::nomarkdown}\( \left(1-\frac{d}{p}\right)\){:/nomarkdown}, ואם יש {::nomarkdown}\( n\){:/nomarkdown} סיבובים סך הכל בפרוטוקול, ההסתברות שהמוכיח לא יצליח לעבוד על המוודא באף אחד מהם היא {::nomarkdown}\( \left(1-\frac{d}{p}\right)^{n}\){:/nomarkdown}, ולא קשה לראות שזה מספר גדול מספיק כדי שהפרוטוקול יהיה מוצלח.

האם סיימנו? חס ושלום, לא. הראינו ש-{::nomarkdown}\( \overline{3\mbox{SAT}}\in\mbox{IP}\){:/nomarkdown}, אבל לא ש-{::nomarkdown}\( \mbox{TQBF}\in\mbox{IP}\){:/nomarkdown}. הפרוטקול שראינו כולל את מרבית הרעיונות של ההוכחה הכללית, אבל יש תעלול אחד נוסף שנזדקק לו. למה ומדוע? נסו לחזור על אותה הוכחה עבור {::nomarkdown}\( \mbox{TQBF}\){:/nomarkdown} ובדקו היכן אתם נתקעים. נסביר את הכל בפוסט הבא בנושא.
