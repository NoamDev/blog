---
id: 1555
title: "תחשיב הפסוקים - על נביעה לוגית והוכחות"
date: 2012-04-04 17:39:09
layout: post
categories: 
  - לוגיקה
tags: 
  - תחשיב הפסוקים
---
בפוסט הקודם הצגתי את התחביר של תחשיב הפסוקים - האופן שבו בונים נוסחאות מאוסף של סימנים, על פי כללים מסויימים, והתוצאה הייתה קבוצה שקראתי לה WFF ("נוסחאות בנויות היטב" או סתם "נוסחאות" מכאן ואילך). הצגתי גם את הסמנטיקה, אבל לא קראתי לה "סמנטיקה" מספיק בבירור, אז בואו נקדיש לזה כמה רגעים.

האובייקט הבסיסי בתחשיב הפסוקים היה <strong>משתנים לוגיים</strong>, {::nomarkdown}\( X_{1},X_{2},X_{3},\dots\){:/nomarkdown}. ההנחה היא שאנחנו מייחסים למשתנים הללו משמעות כלשהי, אבל מבחינה פורמלית תחשיב הפסוקים לא מתעניין במשמעות הזו. כל מה שהוא מתעניין בו הוא האם המשתנים מקבלים ערך {::nomarkdown}\( \mbox{T}\){:/nomarkdown} או {::nomarkdown}\( \mbox{F}\){:/nomarkdown}. בואו נתחיל עם דוגמה קונקרטית כדי להבין איך זה הולך. את המושג של <strong>גרף</strong> אני מניח שרוב הקוראים מכירים, אבל למי שלא: גרף {::nomarkdown}\( G=\left(V,E\right)\){:/nomarkdown} מורכב מקבוצה כלשהי (לא בהכרח סופית) של <strong>צמתים</strong> {::nomarkdown}\( V\){:/nomarkdown}, ושל זוגות של צמתים {::nomarkdown}\( E\subseteq V^{2}\){:/nomarkdown} שנקראים <strong>קשתות</strong>. חושבים על כך כאילו אם {::nomarkdown}\( \left(u,v\right)\in E\){:/nomarkdown} אז הצמתים {::nomarkdown}\( u,v\){:/nomarkdown} מחוברים בקשת, ואחרת לא. עכשיו, את הצמתים של {::nomarkdown}\( G\){:/nomarkdown} אפשר <strong>לצבוע</strong>; אני אניח לצורך פשטות שמותר לצבוע אותם רק באדום, כחול או ירוק. פורמלית, צביעה היא פונקציה {::nomarkdown}\( f:V\to\left\{ \mbox{R,G,B}\right\} \){:/nomarkdown} שלכל צומת מתאימה את הצבע שבו הוא נצבע (כל צומת חייב להיצבע). האתגר בדרך כלל הוא למצוא צביעה "חוקית" שבה אין שני צמתים שמחוברים בקשת וצבועים באותו הצבע - כלומר, {::nomarkdown}\( f\left(u\right)\ne f\left(v\right)\){:/nomarkdown} לכל קשת {::nomarkdown}\( \left(u,v\right)\in E\){:/nomarkdown} בגרף. לא תמיד יש צביעה כזו; למעשה, הבעיה "האם ניתן לצבוע גרף {::nomarkdown}\( G\){:/nomarkdown} נתון באופן חוקי באמצעות שלושה צמתים" היא בעיה {::nomarkdown}\( \mbox{NP}\){:/nomarkdown}-שלמה, מה שאומר שהיא ככל הנראה קשה לפתרון מבחינה חישובית. למה זה בכלל מעניין מישהו? ובכן, בעולם הגדול צביעה של גרפים היא הפשטה נאה לבעיות של הקצאת משאבים; בעולם הקטן שלנו היא פשוט דוגמה יפה למה שאני רוצה לדבר עליו.

נניח שנתון לי גרף {::nomarkdown}\( G\){:/nomarkdown}. כעת, לכל צומת {::nomarkdown}\( v\){:/nomarkdown} אני הולך להגדיר שלושה משתנים: {::nomarkdown}\( X_{R}^{v},X_{G}^{v},X_{B}^{v}\){:/nomarkdown}. אם {::nomarkdown}\( X_{R}^{v}=\mbox{T}\){:/nomarkdown}, אני מפרש את זה בתור האמירה "הצומת {::nomarkdown}\( v\){:/nomarkdown} נצבע בצבע {::nomarkdown}\( \mbox{R}\){:/nomarkdown}". מבחינת תחשיב הפסוקים עצמו, כל מה שהוא יודע זה ש"המשתנה {::nomarkdown}\( X_{R}^{v}\){:/nomarkdown} קיבל את הערך {::nomarkdown}\( \mbox{T}\){:/nomarkdown} בהשמה" - כל היתר הוא בדמיון שלי (גם לקרוא למשתנה הזה {::nomarkdown}\( X_{R}^{v}\){:/nomarkdown} זה בדמיון שלי; בפועל כל המשתנים הם מהצורה {::nomarkdown}\( X_{k}\){:/nomarkdown} כאשר {::nomarkdown}\( k\){:/nomarkdown} הוא מספר טבעי כלשהו).

כעת, כל השמה למשתנים מגדירה צביעה של הגרף {::nomarkdown}\( G\){:/nomarkdown}, אבל אף אחד לא מבטיח לי שהצביעה הזו הגיונית בכלל; ייתכן שיש צומת שנצבע ביותר מאשר צבע אחד; ייתכן שיש צומת שלא נצבע באף צבע; וכמובן, אף אחד לא מבטיח שהצביעה תהיה חוקית במובן זה שכל שני צמתים שכנים לא צבועים באותו הצבע. בכדי להבטיח שהצביעה תהיה בסדר אני צריך להוסיף <strong>מגבלות</strong> על הצביעה - כלומר, על ההשמות החוקיות. האופן שבו אני עושה את זה הוא להגדיר קבוצה של פסוקים, {::nomarkdown}\( ,\Phi_{G}\){:/nomarkdown} כך שכל השמה שמספקת <strong>את כל</strong> הפסוקים של {::nomarkdown}\( \Phi_{G}\){:/nomarkdown} חייבת להיות, בפרשנות שלי, צביעה חוקית. אילו פסוקים {::nomarkdown}\( \Phi_{G}\){:/nomarkdown} תכיל?

ובכן, לכל צומת {::nomarkdown}\( v\in V\){:/nomarkdown}, {::nomarkdown}\( \Phi_{G}\){:/nomarkdown} תכיל את הפסוק {::nomarkdown}\( X_{R}^{v}\vee X_{G}^{v}\vee X_{B}^{v}\){:/nomarkdown} שאומר "הצומת {::nomarkdown}\( v\){:/nomarkdown} צבוע לפחות בצבע אחד". היא תכיל את הפסוק {::nomarkdown}\( \neg\left(X_{R}^{v}\wedge X_{G}^{v}\right)\wedge\neg\left(X_{R}^{v}\wedge X_{B}^{v}\right)\wedge\neg\left(X_{G}^{v}\wedge X_{B}^{v}\right)\){:/nomarkdown} שאומר "הצומת {::nomarkdown}\( v\){:/nomarkdown} אינה צבועה ביותר מצבע אחד"; ולכל קשת {::nomarkdown}\( \left(u,v\right)\in E\){:/nomarkdown}, {::nomarkdown}\( \Phi_{G}\){:/nomarkdown} תכיל את הפסוק {::nomarkdown}\( \neg\left(X_{R}^{v}\wedge X_{R}^{u}\right)\wedge\neg\left(X_{G}^{v}\wedge X_{G}^{u}\right)\wedge\neg\left(X_{B}^{v}\wedge X_{B}^{u}\right)\){:/nomarkdown} שאומר "הצמתים {::nomarkdown}\( v,u\){:/nomarkdown} אינם צבועים באותו הצבע".

זה משלים את התיאור של {::nomarkdown}\( \Phi_{G}\){:/nomarkdown}, אבל הכיף רק מתחיל. לא קשה להוכיח (באופן מתמטי "רגיל", לא באופן פורמלי) שאם הגרף {::nomarkdown}\( G\){:/nomarkdown} מכיל ולו קשת יחידה, אז לא כל הצמתים בגרף בעלי אותו צבע (כי מה עם שני הצמתים שמחוברים בקשת?). בואו נניח לצורך פשטות ש-{::nomarkdown}\( G\){:/nomarkdown} סופי וקבוצת הקשתות שלו לא ריקה, אז הפסוק הבא נכון עבור כל השמה שמספקת את כל פסוקי {::nomarkdown}\( \Phi_{G}\){:/nomarkdown}: {::nomarkdown}\( \neg\left(\bigwedge_{v\in V}X_{R}^{v}\right)\wedge\neg\left(\bigwedge_{v\in V}X_{G}^{v}\right)\wedge\neg\left(\bigwedge_{v\in V}X_{B}^{v}\right)\){:/nomarkdown}. הפסוק הזה כמובן <strong>דומה</strong> לפסוקים שהוספנו ל-{::nomarkdown}\( \Phi_{G}\){:/nomarkdown}, אבל הוא לא נמצא ב-{::nomarkdown}\( \Phi_{G}\){:/nomarkdown}. מצד שני, די בבירור הוא "נובע" מתוך {::nomarkdown}\( \Phi_{G}\){:/nomarkdown} - גם מבחינה אינטואיטיבית, אבל גם מבחינה פורמלית; באופן כללי אנחנו אומרים שפסוק {::nomarkdown}\( \varphi\){:/nomarkdown} נובע לוגית מקבוצת פסוקים {::nomarkdown}\( \Phi\){:/nomarkdown} אם כל השמה שמספקת את {::nomarkdown}\( \Phi\){:/nomarkdown} (דהיינו, מספקת את כל הפסוקים ב-{::nomarkdown}\( \Phi\){:/nomarkdown}) מספקת גם את {::nomarkdown}\( \varphi\){:/nomarkdown}. מסמנים זאת {::nomarkdown}\( \Phi\models\varphi\){:/nomarkdown}. בפרט, פסוקים ש<strong>כל השמה</strong> מספקת אותם נקראים <strong>טאוטולוגיות</strong> ומסמנים זאת {::nomarkdown}\( \models\varphi\){:/nomarkdown} (אבל כמובן שאם {::nomarkdown}\( \varphi\){:/nomarkdown} טאוטולוגיה אז אפשר לכתוב גם {::nomarkdown}\( \Phi\models\varphi\){:/nomarkdown} לכל {::nomarkdown}\( \Phi\){:/nomarkdown} שרק נרצה).

כעת עולה מאליה השאלה - נניח שנתונה {::nomarkdown}\( \Phi\){:/nomarkdown}. איך מוצאים את כל ה-{::nomarkdown}\( \varphi\){:/nomarkdown} שנובעים ממנה? ואם יש {::nomarkdown}\( \varphi\){:/nomarkdown}, איך בודקים אם {::nomarkdown}\( \Phi\models\varphi\){:/nomarkdown}? האם יש דרך פשוטה להשתכנע בכך, או שחייבים לעבור על מי יודע כמה השמות? (יש רק מספר סופי של משתנים ה-{::nomarkdown}\( \varphi\){:/nomarkdown} ולכן רק מספר סופי של השמות שצריך לבדוק, אבל זה יכול להיות מספר גדול מאוד, ויש גם את העניין הזה ש-{::nomarkdown}\( \Phi\){:/nomarkdown} יכולה להיות אינסופית). מה שאנחנו רוצים כאן הוא <strong>מערכת הוכחה</strong> פשוטה עבור תחשיב הפסוקים.

מה זו מערכת הוכחה, באופן כללי? זו שאלה מצויינת, מהטעם הפשוט שיש סוגים רבים ושונים ביותר של מערכות הוכחה. בשורה התחתונה, אני חושב שאפשר להצביע על שלוש תכונות בסיסיות שפחות או יותר כל מערכת הוכחה תקיים, ברמה זו או אחרת: נאותות, שלמות ואפקטיביות.

נאותות ושלמות קל לתאר: נאותות אומרת "כל מה שניתן להוכחה, נכון", שבהקשר שלנו פירושו "כל מה שניתן להוכחה מתוך {::nomarkdown}\( \Phi\){:/nomarkdown} במערכת ההוכחה שלנו נובע לוגית מ-{::nomarkdown}\( \Phi\){:/nomarkdown} ". אני אשתמש בסימון {::nomarkdown}\( \Phi\vdash\varphi\){:/nomarkdown} כדי לומר "{::nomarkdown}\( \Phi\){:/nomarkdown} מוכיח (במערכת הוכחה ספציפית) את {::nomarkdown}\( \varphi\){:/nomarkdown}", ולכן אפשר לנסח את דרישת הנאותות פשוט בתור {::nomarkdown}\( \Phi\vdash\varphi\Rightarrow\Phi\models\varphi\){:/nomarkdown}. דרישת השלמות היא הכיוון השני, {::nomarkdown}\( \Phi\vdash\varphi\Leftarrow\Phi\models\varphi\){:/nomarkdown}: כאן אני דורש שכל מה שנובע לוגית מ-{::nomarkdown}\( \Phi\){:/nomarkdown} יהיה ניתן להוכחה. כבר אינטואיטיבית אפשר להרגיש שזו הדרישה הקשה יותר, אבל נדון על כך בהמשך.

דרישת האפקטיביות היא קצת יותר מעורפלת. אפקטיביות פירושה שהוכחות תהיינה <strong>פשוטות</strong>, במובן זה שלא יהיו בהן קפיצות מחשבתיות שדורשות יצירתיות או אינטואיציה; אנחנו רוצים שכל רכיב בהוכחה יהיה פשוט דיו עד כדי כך שניתן יהיה לתת אלגוריתם שמסוגל לבדוק הוכחות "בלי לחשוב" - במילים אחרות, אפשר לומר שאנחנו רוצים לדרוש שההוכחות תהיינה ניתנות לבדיקה על ידי מחשב. הוכחות מתמטיות בספרי מתמטיקה אמיתיים אינם כאלו; הן כתובות בשפה טבעית ומכילות הרבה קפיצות שהקורא אמור להשלים בעצמו. זו בדיוק הנקודה שבה מערכות הוכחה פורמליות מתנתקות מהמושג האינטואיטיבי שלנו של "הוכחה".

שלוש הדרישות שלעיל לא באמת מגדירות בשום צורה <strong>איך</strong> מערכת ההוכחה תעשה את מה שאנחנו דורשים ממנה, ובצדק; למה להגביל את עצמנו? תחת זאת, אפשר פשוט לדבר על מערכות הוכחה קונקרטיות ולראות שהן מקיימות את הדרישות הבסיסיות שלנו. מה שאציג כעת תהיה מקרה פרטי של מחלקה גדולה של מערכות הוכחה "מערכות הילברט" (שהקרדיט על תיאורן הפורמלי, פחות או יותר, מגיע להילברט ולפרגה). במערכת כזו יש לנו <strong>אקסיומות</strong>, ויש לנו <strong>כללי היסק</strong>, והוכחה של {::nomarkdown}\( \varphi\){:/nomarkdown} מתוך קבוצת <strong>הנחות {::nomarkdown}\( \Phi\){:/nomarkdown} </strong>היא סדרה סופית של פסוקים {::nomarkdown}\( \psi_{1},\dots,\psi_{n}\){:/nomarkdown} כך ש-{::nomarkdown}\( \psi_{n}=\varphi\){:/nomarkdown}, וכל {::nomarkdown}\( \psi_{i}\){:/nomarkdown} הוא או אקסיומה, או הנחה מתוך {::nomarkdown}\( \Phi\){:/nomarkdown}, או שהוא נובע מ-{::nomarkdown}\( \psi_{j}\){:/nomarkdown}-ים קודמים על ידי הפעלת <strong>כלל היסק</strong>. כדי שהמערכת תהיה אפקטיבית רק צריך לבחור אקסיומות שניתן לזהות אותן באופן אלגוריתמי (כלומר, או שתהיה קבוצה סופית של אקסיומות, או - אם זו קבוצה אינסופית - שלפחות יהיה קל לזהות מהי אקסיומה, למשל כי היא מתאימה לאיזו שהיא תבנית ברורה) ולבחור כללי היסק שניתן לזהות את
הפעלתם באופן אלגוריתמי.

מראש ברור שאנחנו מוגבלים בבחירת האקסיומות שלנו - אנחנו יכולים לבחור <strong>רק</strong> טאוטולוגיות בתור אקסיומות, אחרת אפשר לשכוח מהנאותות (כי לכל {::nomarkdown}\( \varphi\){:/nomarkdown} שהוא אקסיומה, מתקיים {::nomarkdown}\( \vdash\varphi\){:/nomarkdown}, כלומר יש הוכחה ל-{::nomarkdown}\( \varphi\){:/nomarkdown} ללא שום הנחות; ההוכחה הזו היא פשוט הסדרה {::nomarkdown}\( \varphi\){:/nomarkdown} עצמה. מנאותות כעת נובע ש-{::nomarkdown}\( \models\varphi\){:/nomarkdown}). עכשיו אפשר אולי להבין במשהו את הקושי שלנו בהוכחת שלמות - יש לנו רק סט מוגבל למדי של מחרוזות - אלו שמייצגות טאוטולוגיות ואלו של {::nomarkdown}\( \Phi\){:/nomarkdown} עצמה - ואנחנו יכולים לבצע רק סדרות סופיות של שינויים פשוטים במחרוזות הללו, ואיכשהו אנחנו צריכים לקבל מזה <strong>כל</strong> מחרוזת אפשרית שנובעת מ-{::nomarkdown}\( \Phi\){:/nomarkdown}? זה נשמע לא פשוט. כדי להקל עלינו, אפשר לפשט קצת את השפה: מספיק להרשות רק משתנים ואת הקשרים {::nomarkdown}\( \neg,\to\){:/nomarkdown}, וה"אתגר" שלנו יהיה לבנות רק פסוקים שכתובים בעזרת קשרים אלו (מכיוון שזוהי מערכת קשרים שלמה אנחנו לא "מאבדים כוח" - עדיין נוכל להביע את כל טבלאות האמת כך). כדאי להדגיש שהפישוט הזה הוא אכן רק פישוט; אפשר לקחת את מערכת ההוכחה שאציג עכשיו ולהרחיב אותה כך שתתמודד גם עם שאר הקשרים. זה פשוט לא מעניין במיוחד, כי אחרי שנסיים עם מערכת הוכחה עבור {::nomarkdown}\( \neg,\to\){:/nomarkdown} בלבד כבר נבין את העיקרון.

נעבור להצגת כלל ההיסק שלנו. יש לנו בחירה לא קטנה בנוגע לכללי ההיסק, אבל אני מעדיף להיות שמרן וללכת על כלל מוכר ופופולרי - מודוס פוננס, MP. הרעיון ב-MP הוא זה: נניח שכבר הוכחנו את {::nomarkdown}\( \alpha\to\beta\){:/nomarkdown} וגם הוכחנו את {::nomarkdown}\( \alpha\){:/nomarkdown}; משני אלו אפשר להסיק את {::nomarkdown}\( \beta\){:/nomarkdown}. ההגיון פשוט: אם הוכחנו ש"אם יורד גשם, אז אנחנו נרטבים" והוכחנו ש"יורד גשם", אז בעצם הוכחנו ש"אנחנו נרטבים". גם מבחינה פורמלית, קל לראות ש-MP משמר את הנאותות של מערכת ההוכחה שלנו: אם {::nomarkdown}\( \Phi\models\alpha\){:/nomarkdown} וגם {::nomarkdown}\( \Phi\models\alpha\to\beta\){:/nomarkdown} ויש לנו השמה כלשהי שמספקת את {::nomarkdown}\( \Phi\){:/nomarkdown}, אז היא מספקת בו זמנית את {::nomarkdown}\( \alpha\){:/nomarkdown} ואת {::nomarkdown}\( \alpha\to\beta\){:/nomarkdown}. אם היא לא הייתה מספקת את {::nomarkdown}\( \beta\){:/nomarkdown}, אז {::nomarkdown}\( \alpha\to\beta\){:/nomarkdown} היה פסוק שבו הרישא ({::nomarkdown}\( \alpha\){:/nomarkdown}) היא {::nomarkdown}\( \mbox{T}\){:/nomarkdown} אבל הסיפא היא {::nomarkdown}\( \mbox{F}\){:/nomarkdown} - וזה, על פי הסמנטיקה של תחשיב הפסוקים, אומר שהפסוק כולו מקבל {::nomarkdown}\( \mbox{F}\){:/nomarkdown} בהשמה, בסתירה לכך שכל השמה שמספקת את {::nomarkdown}\( \Phi\){:/nomarkdown} מספקת את {::nomarkdown}\( \alpha\to\beta\){:/nomarkdown}. לכן {::nomarkdown}\( \Phi\models\beta\){:/nomarkdown}.

טענה ראשונה שאפשר להוכיח על מערכת ההוכחה שלנו כעת היא זו: אם {::nomarkdown}\( \Phi\vdash\alpha\to\beta\){:/nomarkdown} אז {::nomarkdown}\( \Phi\cup\left\{ \alpha\right\} \vdash\beta\){:/nomarkdown}; כלומר, אם אנחנו יודעים להוכיח את {::nomarkdown}\( \alpha\to\beta\){:/nomarkdown} מתוך {::nomarkdown}\( \Phi\){:/nomarkdown}, אז אם נוסיף ל-{::nomarkdown}\( \Phi\){:/nomarkdown} את {::nomarkdown}\( \alpha\){:/nomarkdown} בתור הנחה, נוכל להוכיח את {::nomarkdown}\( \beta\){:/nomarkdown}. הנה ההוכחה הפורמלית:
<ol>
	<li>{::nomarkdown}\( \alpha\to\beta\){:/nomarkdown} (ניתן להוכחה מ-{::nomarkdown}\( \Phi\){:/nomarkdown}).</li>
	<li>{::nomarkdown}\( \alpha\){:/nomarkdown} (הנחה).</li>
	<li>{::nomarkdown}\( \beta\){:/nomarkdown} ({::nomarkdown}\( \mbox{MP}\){:/nomarkdown} על 1,2).</li>
</ol>
לא מסובך, נכון? שימו לב שלא נזקקנו כלל לאקסיומות; התוצאה הזו נובעת ישירות מ-{::nomarkdown}\( \mbox{MP}\){:/nomarkdown}. למעשה, כל מערכת הוכחה שמקיימת את התכונה הזו בעצם מכילה את MP, גם אם היא לא הצהירה על כך במפורש בכללי ההיסק שלה; דה פקטו, במערכת כזו אם הצלחנו להוכיח את {::nomarkdown}\( \alpha\to\beta\){:/nomarkdown} והצלחנו להוכיח את {::nomarkdown}\( \alpha\){:/nomarkdown} אז תנבע מכך הוכחה ל-{::nomarkdown}\( \beta\){:/nomarkdown}. אם לעומת זאת מערכת ההוכחה שלנו <strong>לא</strong> מקיימת את התכונה הזו - כלומר, יש {::nomarkdown}\( \alpha,\beta\){:/nomarkdown} כך ש-{::nomarkdown}\( \Phi\vdash\alpha\to\beta\){:/nomarkdown} וגם {::nomarkdown}\( \Phi\vdash\alpha\){:/nomarkdown} אבל לא {::nomarkdown}\( \Phi\vdash\beta\){:/nomarkdown} אז אפשר לשכוח מכך שמערכת ההוכחה תהיה שלמה, שהרי {::nomarkdown}\( \Phi\models\beta\){:/nomarkdown} בסיטואציה הזו. המסקנה מהדיון הקצרצר הזה הוא ש-{::nomarkdown}\( \mbox{MP}\){:/nomarkdown} הוא כלל גזירה שמתבקש מאוד לצרף אלינו; ולא נזדקק לשום כלל גזירה פרט אליו.

עכשיו, ראינו ש-{::nomarkdown}\( \Phi\vdash\alpha\to\beta\Rightarrow\Phi\cup\left\{ \alpha\right\} \vdash\beta\){:/nomarkdown}; מה בדבר הכיוון השני? האם, אם {::nomarkdown}\( \Phi\cup\left\{ \alpha\right\} \vdash\beta\){:/nomarkdown} אז נובע מכך ש-{::nomarkdown}\( \Phi\vdash\alpha\to\beta\){:/nomarkdown}? זה כבר לחלוטין לא מובן מאליו; אני טוען שמכך שאני יודע לייצר את המחרוזת {::nomarkdown}\( \beta\){:/nomarkdown} עם הוכחה שמורכבת מאברי {::nomarkdown}\( \Phi\){:/nomarkdown} ומ-{::nomarkdown}\( \alpha\){:/nomarkdown} אז אני אוכל לייצר את המחרוזת {::nomarkdown}\( \alpha\to\beta\){:/nomarkdown} שהיא לכאורה מורכבת <strong>יותר</strong>, וזאת תוך שימוש ב<strong>פחות</strong> הנחות, שהרי אין לי את {::nomarkdown}\( \alpha\){:/nomarkdown} כהנחה יותר. זו לא תוצאה מובנית מאליה, והיא מועילה למדי שכן היא מסייעת מאוד בפישוט הוכחות של טענות; במקום שנצטרך להוכיח משהו כמו {::nomarkdown}\( \Phi\vdash\left(\alpha\to\beta\right)\to\left(\alpha\to\gamma\right)\){:/nomarkdown} יהיה לנו מספיק להוכיח ש-{::nomarkdown}\( \Phi\cup\left\{ \alpha\to\beta\right\} \vdash\alpha\to\gamma\){:/nomarkdown}, ואפילו די יהיה להוכיח ש-{::nomarkdown}\( \Phi\cup\left\{ \alpha\to\beta,\alpha\right\} \vdash\gamma\){:/nomarkdown} - פחות עבודה, יותר הנחות. לתוצאה הזו - {::nomarkdown}\( \Phi\vdash\alpha\to\beta\Leftarrow\Phi\cup\left\{ \alpha\right\} \vdash\beta\){:/nomarkdown} - קוראים <strong>משפט הדדוקציה</strong>, וזה הדבר הלא טריוויאלי הראשון שאני רוצה להוכיח. כרגע מערכת ההוכחה שלי (שהיא נטולת אקסיומות) לא יכולה לבצע את הקסם הזה; במהלך ההוכחה של משפט הדדוקציה נראה לאילו אקסיומות אני נזקק.

בואו נתחיל מהדבר המטופש ביותר. {::nomarkdown}\( \Phi\cup\left\{ \alpha\right\} \vdash\alpha\){:/nomarkdown} תמיד, בלי קשר ל-{::nomarkdown}\( \Phi\){:/nomarkdown}, ולכן {::nomarkdown}\( \Phi\vdash\alpha\to\alpha\){:/nomarkdown} תמיד; מה שאנחנו בעצם רוצים לעשות הוא להראות שאפשר להוכיח את {::nomarkdown}\( \alpha\to\alpha\){:/nomarkdown} במערכת ההוכחה שלנו, עבור <strong>כל</strong> פסוק, ובלי <strong>שום</strong> הנחות (אלא רק בעזרת אקסיומות שהן חלק ממערכת ההוכחה). הפיתוי הראשון הוא להגיד ש-{::nomarkdown}\( \alpha\to\alpha\){:/nomarkdown} עצמה תהיה אקסיומה, לכל פסוק {::nomarkdown}\( \alpha\){:/nomarkdown}. מותר לנו לעשות את זה - {::nomarkdown}\( \alpha\to\alpha\){:/nomarkdown} היא טאוטולוגיה בלי קשר ל-{::nomarkdown}\( \alpha\){:/nomarkdown} - אבל זו אינה אקסיומה שימושית במיוחד ואנו מעדיפים שמערכת ההוכחה שלנו תהיה פשוטה ככל האפשר. בואו נחכה קצת עם ההוכחה של {::nomarkdown}\( \alpha\to\alpha\){:/nomarkdown} כדי לראות לאילו אקסיומות נזדקק בהוכחה של יתר המשפט ונראה אם הן יעבדו גם כאן.

אם {::nomarkdown}\( \beta\){:/nomarkdown} היא אקסיומה או הנחה ב-{::nomarkdown}\( \Phi\){:/nomarkdown}, איך נוכיח ש-{::nomarkdown}\( \Phi\vdash\alpha\to\beta\){:/nomarkdown}? שימו לב שגם כאן לא עוזרת לנו הידיעה ש-{::nomarkdown}\( \Phi\cup\left\{ \alpha\right\} \vdash\beta\){:/nomarkdown} מהטעם הפשוט שאם {::nomarkdown}\( \beta\){:/nomarkdown} היא אקסיומה או הנחה אז {::nomarkdown}\( \Phi\vdash\beta\){:/nomarkdown} ממילא, בלי קשר ל-{::nomarkdown}\( \alpha\){:/nomarkdown}. מכאן אנחנו נתקלים בתכונה כללית שמערכת ההוכחה שלנו צריכה לקיים: אם הוכחנו כבר את {::nomarkdown}\( \beta\){:/nomarkdown}, אז לכל {::nomarkdown}\( \alpha\){:/nomarkdown} אנחנו צריכים להיות מסוגלים להוכיח גם את {::nomarkdown}\( \alpha\to\beta\){:/nomarkdown}. אפשר אולי להוסיף את זה גם כן כמעין כלל גזירה, אבל אני מעדיף לחשוב על כללי גזירה כפונקציות שלקוחות פסוקים קיימים ומוציאות פלט יחיד, ואילו כאן כלל הגזירה יהיה משהו רב-ערכי שכזה: "<strong>לכל</strong> {::nomarkdown}\( \alpha\){:/nomarkdown} אפשר להוסיף אותו לפני {::nomarkdown}\( \beta\){:/nomarkdown}". אז בואו במקום להוסיף כלל גזירה חדש, נוסיף אקסיומה חדשה: אני ארצה להיות מסוגל להוכיח את {::nomarkdown}\( \alpha\to\beta\){:/nomarkdown} באמצעות {::nomarkdown}\( \mbox{MP}\){:/nomarkdown} ובאמצעות זה שאני יודע את {::nomarkdown}\( \beta\){:/nomarkdown}. האקסיומה שמתאימה כאן כמו כפפה ליד היא {::nomarkdown}\( \beta\to\left(\alpha\to\beta\right)\){:/nomarkdown} (בדיקה ישירה מראה כי זוהי טאוטולוגיה), אז זו בדיוק האקסיומה שאוסיף למערכת ההוכחה שלי. ליתר דיוק, הוספתי כאן <strong>תבנית אקסיומה</strong>; לא משנה איזה פסוקים נשתיל במקום {::nomarkdown}\( \alpha,\beta\){:/nomarkdown}, התוצאה גם היא תהיה אקסיומה של מערכת ההוכחה שלי. לתבנית האקסיומה הזו אני קורא <strong>תבנית אקסיומה מס' </strong><strong>1</strong>. בעזרתה אפשר להוכיח בקלות את מה שרצינו:
<ol>
	<li>{::nomarkdown}\( \beta\){:/nomarkdown} (אקסיומה/הנחה).</li>
	<li>{::nomarkdown}\( \beta\to\left(\alpha\to\beta\right)\){:/nomarkdown} (תבנית אקסיומה מס' 1).</li>
	<li>{::nomarkdown}\( \alpha\to\beta\){:/nomarkdown} ({::nomarkdown}\( \mbox{MP}\){:/nomarkdown} על 1,2)</li>
</ol>
אוקיי, זה היה קל. אז טיפלנו במקרה שבו {::nomarkdown}\( \beta\){:/nomarkdown} היא אקסיומה/הנחה; דחינו לעת עתה את המקרה שבו {::nomarkdown}\( \beta=\alpha\){:/nomarkdown}; מה נותר? המקרים שבהם {::nomarkdown}\( \beta\){:/nomarkdown} אינה אקסיומה/הנחה/{::nomarkdown}\( \alpha\){:/nomarkdown} ועם זאת מוכיחים את {::nomarkdown}\( \beta\){:/nomarkdown} מתוך {::nomarkdown}\( \Phi\cup\left\{ \alpha\right\} \){:/nomarkdown}. מסקנה: בסיטואציה כזו, {::nomarkdown}\( \beta\){:/nomarkdown} חייבת להתקבל על ידי הפעלת {::nomarkdown}\( \mbox{MP}\){:/nomarkdown} על שני פסוקים שניתן להניח באינדוקציה (על אורך ההוכחה) שעליהם משפט הדדוקציה כבר חל. כלומר, יש איזה שהוא פסוק {::nomarkdown}\( \gamma\){:/nomarkdown} כך ש-{::nomarkdown}\( \Phi\cup\left\{ \alpha\right\} \vdash\gamma\to\beta\){:/nomarkdown} וגם {::nomarkdown}\( \Phi\cup\left\{ \alpha\right\} \vdash\gamma\){:/nomarkdown}, ובגלל שאפשר להניח שמשפט הדדוקציה מתקיים עבורם, אז {::nomarkdown}\( \Phi\vdash\alpha\to\gamma\){:/nomarkdown} ו-{::nomarkdown}\( \Phi\vdash\alpha\to\left(\gamma\to\beta\right)\){:/nomarkdown}. האם די לנו בשני אלו, בתבנית האקסיומה הנוכחית וב-{::nomarkdown}\( \mbox{MP}\){:/nomarkdown} כדי להוכיח את {::nomarkdown}\( \alpha\to\beta\){:/nomarkdown}? ובכן, לא. אז מה עושים? מוסיפים עוד תבנית אקסיומה שתפורה בדיוק לסיטואציה הזו: התבנית {::nomarkdown}\( \left[\alpha\to\left(\gamma\to\beta\right)\right]\to\left[\left(\alpha\to\gamma\right)\to\left(\alpha\to\beta\right)\right]\){:/nomarkdown}. תסתכלו על הרכיבים של התבנית ותראו אם אתם מזהים מהיכן היא מגיעה; ובדקו באופן כלשהו שהתבנית הזו היא אכן טאוטולוגיה. לתבנית האקסיומה הזו אני קורא <strong>תבנית אקסיומה מס' </strong><strong>2</strong>.

עכשיו ההוכחה היא טריוויאלית:
<ol>
	<li>{::nomarkdown}\( \alpha\to\gamma\){:/nomarkdown} (ניתן להוכחה מ-{::nomarkdown}\( \Phi\){:/nomarkdown}).</li>
	<li>{::nomarkdown}\( \alpha\to\left(\gamma\to\beta\right)\){:/nomarkdown} (ניתן להוכחה מ-{::nomarkdown}\( \Phi\){:/nomarkdown}).</li>
	<li>{::nomarkdown}\( \left[\alpha\to\left(\gamma\to\beta\right)\right]\to\left[\left(\alpha\to\gamma\right)\to\left(\alpha\to\beta\right)\right]\){:/nomarkdown} (תבנית אקסיומה מס' 2).</li>
	<li>{::nomarkdown}\( \left(\alpha\to\gamma\right)\to\left(\alpha\to\beta\right)\){:/nomarkdown} ({::nomarkdown}\( \mbox{MP}\){:/nomarkdown} על 2,3).</li>
	<li>{::nomarkdown}\( \alpha\to\beta\){:/nomarkdown} ({::nomarkdown}\( \mbox{MP}\){:/nomarkdown} על 1,4).</li>
</ol>
נשאר לנו רק לטפל בחוב מההתחלה - להראות שאפשר להוכיח את {::nomarkdown}\( \alpha\to\alpha\){:/nomarkdown}. עכשיו יש לנו כלי נשק חדש - שתי תבניות אקסיומה שנמצאות ברשותנו ואנחנו לא מהססים להשתמש בהן. מפתה להשתמש בתבנית הראשונה כשמציבים בה {::nomarkdown}\( \alpha\){:/nomarkdown} במקום {::nomarkdown}\( \beta\){:/nomarkdown} ומקבלים {::nomarkdown}\( \alpha\to\left(\alpha\to\alpha\right)\){:/nomarkdown}, רק שזה לא עוזר לנו במיוחד כי אנחנו <strong>לא</strong> יכולים להוכיח את {::nomarkdown}\( \alpha\){:/nomarkdown} בשום צורה. כנראה שתבנית אקסיומה 1 לבדה לא ממש תעזור לנו וצריך להשתמש גם ב-2. בואו נציב גם ב-2 {::nomarkdown}\( \alpha\){:/nomarkdown} במקום
הכל ונראה מה נקבל:
<ol>
	<li>{::nomarkdown}\( \alpha\to\left(\alpha\to\alpha\right)\){:/nomarkdown} (תבנית אקסיומה מס' 1).</li>
	<li>{::nomarkdown}\( \left[\alpha\to\left(\alpha\to\alpha\right)\right]\to\left[\left(\alpha\to\alpha\right)\to\left(\alpha\to\alpha\right)\right]\){:/nomarkdown} (תבנית אקסיומה מס' 2).</li>
	<li>{::nomarkdown}\( \left(\alpha\to\alpha\right)\to\left(\alpha\to\alpha\right)\){:/nomarkdown} ({::nomarkdown}\( \mbox{MP}\){:/nomarkdown} על 1,2).</li>
</ol>
ו.. נתקענו. כדי להפיק תועלת מ-{::nomarkdown}\( \left(\alpha\to\alpha\right)\to\left(\alpha\to\alpha\right)\){:/nomarkdown} נצטרך להוכיח את {::nomarkdown}\( \alpha\to\alpha\){:/nomarkdown}, וזה בדיוק מה שאנחנו מנסים להוכיח! אז מה יצא לנו מכל זה?

אם כן, אולי לא כדאי מייד להציב גם ב-{::nomarkdown}\( \beta\){:/nomarkdown} וגם ב-{::nomarkdown}\( \gamma\){:/nomarkdown} את {::nomarkdown}\( \alpha\){:/nomarkdown}? אולי יש הצבה קצת יותר מועילה שאפשר לעשות? עם זאת, לא כדאי להציב דברים מופרעים יותר מדי: אם אנחנו מתכננים להשתמש ב-{::nomarkdown}\( \left[\alpha\to\left(\gamma\to\beta\right)\right]\to\left[\left(\alpha\to\gamma\right)\to\left(\alpha\to\beta\right)\right]\){:/nomarkdown}, זה אומר שנצטרך להפעיל עליה {::nomarkdown}\( \mbox{MP}\){:/nomarkdown}. זה אומר שנצטרך להוכיח איכשהו את {::nomarkdown}\( \left[\alpha\to\left(\gamma\to\beta\right)\right]\){:/nomarkdown}, וזה אומר ש-{::nomarkdown}\( \left[\alpha\to\left(\gamma\to\beta\right)\right]\){:/nomarkdown} חייב להתאים למבנה של תבנית אקסיומה כלשהי - מן הסתם, תבנית אקסיומה מס' 1. שימו לב איך <strong>אין לנו ברירה</strong> ואנחנו ממש נדחפים לכך שנהיה חייבים לבחור {::nomarkdown}\( \beta=\alpha\){:/nomarkdown}, אחרת {::nomarkdown}\( \left[\alpha\to\left(\gamma\to\beta\right)\right]\){:/nomarkdown} לעולם לא תתאים לתבנית של אקסיומה מס' 1. לעומת זאת, ל-{::nomarkdown}\( \gamma\){:/nomarkdown} יש לנו חופש בחירה מוחלט; בואו נתחיל נסיון הוכחה חדש ונראה מה ישתלם לנו לבחור בתור ערכו של {::nomarkdown}\( \gamma\){:/nomarkdown}.
<ol>
	<li>{::nomarkdown}\( \left[\alpha\to\left(\gamma\to\alpha\right)\right]\to\left[\left(\alpha\to\gamma\right)\to\left(\alpha\to\alpha\right)\right]\){:/nomarkdown} (תבנית אקסיומה מס' 2).</li>
	<li>{::nomarkdown}\( \alpha\to\left(\gamma\to\alpha\right)\){:/nomarkdown} (תבנית אקסיומה מס' 1).</li>
	<li>{::nomarkdown}\( \left(\alpha\to\gamma\right)\to\left(\alpha\to\alpha\right)\){:/nomarkdown} ({::nomarkdown}\( \mbox{MP}\){:/nomarkdown} על 1,2).</li>
</ol>
אנחנו כמעט שם! רק צריך לבחור ערך ל-{::nomarkdown}\( \gamma\){:/nomarkdown} כך ש-{::nomarkdown}\( \alpha\to\gamma\){:/nomarkdown} ייראה כמו תבנית האקסיומה {::nomarkdown}\( \alpha\to\left(\beta\to\alpha\right)\){:/nomarkdown}. אם כן, מתבקש לבחור {::nomarkdown}\( \gamma=\alpha\to\alpha\){:/nomarkdown}, ולקבל:
<ol>
	<li>{::nomarkdown}\( \left[\alpha\to\left(\alpha\to\alpha\right)\right]\to\left(\alpha\to\alpha\right)\){:/nomarkdown} (הצבנו {::nomarkdown}\( \gamma=\alpha\to\alpha\){:/nomarkdown}).</li>
	<li>{::nomarkdown}\( \alpha\to\left(\alpha\to\alpha\right)\){:/nomarkdown} (תבנית אקסיומה מס' 1).</li>
	<li>{::nomarkdown}\( \alpha\to\alpha\){:/nomarkdown} ({::nomarkdown}\( \mbox{MP}\){:/nomarkdown} על 1,2).</li>
</ol>
זה מסיים את הוכחת משפט הדדוקציה, וממחיש איך נראות הוכחות על מערכת ההוכחה הפורמלית שלנו; אלו הוכחות מילוליות, שפה ושם מציגות "קטעי קוד" מתוך מערכת ההוכחה הפורמלית עצמה. זו גם ככל הנראה ההוכחה הכי "כבדה" מבחינת כמות קטעי הקוד שמופיעים בה.

משפט הדדוקציה הוא כלי חשוב בדרך להוכחת משפט השלמות; יש עוד כלי אחד שאזדקק לו ויכריח אותנו להוסיף תבנית אקסיומה שלישית ואחרונה למערכת ההוכחה שלנו. בפוסט הבא נוכיח את הכלי הזה, נסיים את הצגת מערכת ההוכחה שלנו, ונוכיח את משפט השלמות.
