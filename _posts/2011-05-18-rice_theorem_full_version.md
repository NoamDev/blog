---
id: 1154
title: "משפט רייס - הגרסה המלאה"
date: 2011-05-18 08:22:29
layout: post
categories: 
  - חישוביות
tags: 
  - גם טכני זה כיף!
  - הוכחות יפות
  - חישוביות
  - משפט רייס
---
אי שם בראשית ימי הבלוג, כשדיברתי על תורת החישוביות <a href="http://www.gadial.net/?p=70">הזכרתי גם את משפט רייס</a>. באופן אינטואיטיבי, משפט רייס אומר שלא קיים אלגוריתם כללי שמסוגל, בהינתן קוד מחשב לחישוב של פונקציה כלשהי, לקבוע אם הפונקציה מקיימת תכונה "לא טריוויאלית" כלשהי, כשלא טריוויאלי פירושו "נכון לחלק מהפונקציות, אך לא לכולן". בשעתו נתתי הוכחה לגרסה הבסיסית והנפוצה של המשפט, אך מאז בגרתי והחכמתי ולמדתי על גרסה מלאה יותר ואני רוצה לנצל את הפוסט הזה כדי לתאר את המשפט עד הסוף.

ראשית, על אף שאפשר לנסח את המשפט עבור פונקציות כפי שעשיתי למעלה, הניסוח הסטנדרטי שלו הוא על <strong>שפות</strong>. שפה היא קבוצת מילים, כשמילה היא סדרת אותיות מתוך א"ב נתון כלשהו. בדרך כלל מניחים שהא"ב הוא הקבוצה {::nomarkdown}\( \left\{ 0,1\right\} \){:/nomarkdown}; זה לא ממש משנה משהו, מכיוון שפחות או יותר כל אובייקט מתמטי שבכלל אפשר להתעסק בו במחשב ניתן לתיאור כך - מספרים, גרפים, חבורות, קבצי מוזיקה, קידודים של תוכניות מחשב - בסופו של דבר כולם מיוצגים במחשב על ידי מילים שהאותיות שלהן הן 0 ו-1. שפה היא דרך לחלק את קבוצת כל המילים בעולם לשתיים - אלו שכן בשפה, ואלו שלא. למשל, אפשר לדבר על "שפת המספרים הראשוניים", או על "שפת הקבצים שמייצגים סרט וידאו שבאמצע שלו טום קרוז צץ ומתחיל לקפוץ על ספות", וכדומה.

נשתמש ב-{::nomarkdown}\( M\){:/nomarkdown} כדי לסמן תוכנית מחשב (ולפורמליים שמביניכם - מכונת טיורינג; אך לא נזדקק להבדל הזה כאן) שמה שהיא עושה בחיים הוא לקבל קלט כלשהו בתחילת ריצתה, לעשות חישוב כלשהו (מבלי לקבל קלט נוסף מהמשתמש), ובסוף לפלוט "כן" או "לא". נסמן בתור {::nomarkdown}\( L\left(M\right)\){:/nomarkdown} את קבוצת המילים ש-{::nomarkdown}\( M\){:/nomarkdown} אומרת עליהן כן - "מקבלת" אותן; ל-{::nomarkdown}\( L\left(M\right)\){:/nomarkdown} קוראים "השפה ש-{::nomarkdown}\( M\){:/nomarkdown} מקבלת". לקבוצת השפות שקיימת {::nomarkdown}\( M\){:/nomarkdown} שמקבלת אותן קוראים {::nomarkdown}\( \mbox{RE}\){:/nomarkdown}. שימו לב לאבחנה חשובה כאן - {::nomarkdown}\( M\){:/nomarkdown} לא חייבת לעצור תמיד! אם היא לא עוצרת על קלט מסויים, ודאי שהיא אינה מקבלת אותו (כי לקבל פירושו <strong>לעצור</strong> ולהגיד "כן") ולכן הוא אינו בשפה שלה. אם {::nomarkdown}\( M\){:/nomarkdown} דווקא כן עוצרת על כל קלט, אומרים שהיא <strong>מכריעה</strong> את {::nomarkdown}\( L\left(M\right)\){:/nomarkdown}, ולקבוצת השפות שקיימת מכונה שמכריעה אותן קוראים {::nomarkdown}\( \mbox{R}\){:/nomarkdown}. כפי שאתם ודאי מנחשים כבר (או יודעים כבר...), {::nomarkdown}\( \mbox{R}\ne\mbox{RE}\){:/nomarkdown}, כלומר היכולת של התוכנית לא לעצור על קלטים שעליהם התשובה שלילית מוסיפה לה כוח.

הדוגמה הקלאסית ביותר לשפה שנמצאת ב-{::nomarkdown}\( \mbox{RE}\){:/nomarkdown} אבל לא ב-{::nomarkdown}\( \mbox{R}\){:/nomarkdown}, ולכן גם מראה שיש בעיות שלא ניתן לפתור באופן חד משמעי (כי "אני יושב ומחכה לראות אם החישוב אי פעם יסתיים..." זו לא תשובה מספקת למי שרוצה תשובת כן או לא חד משמעית) מכונה "בעיית העצירה". {::nomarkdown}\( \mbox{HP}\){:/nomarkdown} בלועזית (מלשון Halting Problem) היא שפת כל תוכניות המחשב (זכרו - תוכנית מחשב היא בסך הכל סדרה ארוכה של אפסים ואחדים) שעוצרות מתישהו. שימו לב שאני לא מניח שהתוכנית מקבלת קלט - למעשה, אני מניח במוצהר שהתוכנית לא מקבלת קלט או מבצעת הגרלות כלשהן, כך שהריצה שלה היא תמיד אותו דבר. אפשר גם לדבר על גרסה שבה המכונה מקבלת קלט וכדומה (ולרוב זה מה שעושים) אבל איני צריך את זה כאן ואני די מעדיף את הגרסה הפשוטה הזו.

ראשית, שימו לב שבעיית העצירה ב-{::nomarkdown}\( \mbox{RE}\){:/nomarkdown} די בבירור - בהינתן {::nomarkdown}\( M\){:/nomarkdown}, אני פשוט אריץ אותה ואחכה לראות אם החישוב נגמר. אם הוא נגמר, אגיד "כן". אם הוא לא נגמר - ובכן, בעסה לי, אחכה לנצח; אבל על פי ההגדרה של {::nomarkdown}\( \mbox{RE}\){:/nomarkdown} זה לגיטימי.

מדוע בעיית העצירה אינה ב-{::nomarkdown}\( \mbox{R}\){:/nomarkdown}? כבר <a href="http://www.gadial.net/?p=65">הקדשתי פוסט לעניין הזה</a>, אך הנה הסבר חפוז: נניח שהיא כן, כלומר ניתן, בהינתן קוד של תוכנית מחשב, לקבוע אחרי חישוב שעוצר תמיד האם התוכנית הזו עוצרת או לא. אז אבנה תוכנית מחשב {::nomarkdown}\( M\){:/nomarkdown} שעושה את הדבר הבא: בודקת, באמצעות התוכנית שפותרת את בעיית העצירה, האם {::nomarkdown}\( M\){:/nomarkdown} עצמה עוצרת או לא. כלומר, {::nomarkdown}\( M\){:/nomarkdown} מעבירה את הקוד של עצמה לאותה תוכנית שפותרת את בעיית העצירה. כעת, אם התשובה הייתה "כן, {::nomarkdown}\( M\){:/nomarkdown} עוצרת" אז {::nomarkdown}\( M\){:/nomarkdown} תכף ומייד תיכנס ללולאה אינסופית; ואם התשובה הייתה "לא, {::nomarkdown}\( M\){:/nomarkdown} לא עוצרת" אז {::nomarkdown}\( M\){:/nomarkdown} תכף ומייד תעצור.

למה הדבר דומה? לכך שנלך ברחוב ויבוא נביא ויטען "אני יודע איזו יד אתם הולכים להרים כעת!". אתם שואלים "כן? איזו יד?". הוא אומר "אה... שמאל?" ואתם מרימים מייד את ימין. כל עוד הדבר הבא שתעשו <strong>נקבע לפי התשובה של הנביא</strong>, אתם מסוגלים להפוך את הנביא לנביא שקר. לב ההוכחה כאן הוא בכך ש-{::nomarkdown}\( M\){:/nomarkdown} מסוגלת לשאול את הנביא על עצמה; לא הוכחתי שהדבר אפשרי וזו אינה הוכחה טריוויאלית, אך כבר תיארתי את העניין ב<a href="http://www.gadial.net/?p=218">פוסט שזה בדיוק היה נושאו</a>. בדרך כלל כשמדברים על בעיית העצירה מציגים גרסה קצת שונה שלה מבחינת הניסוח כדי לעקוף את הקושי הזה.

עכשיו אפשר להציג את משפט רייס. המשפט עוסק בתכונות של שפות. למשל, "אני מכילה את כל המספרים הזוגיים" היא תכונה של שפה, כמו גם "יש בי רק מספר סופי של מילים" או "לא קיימת תוכנית מחשב שמקבלת אותי". שפה טבעית היא דרך נהדרת לתאר תכונות של שפות, אבל איך אפשר לתאר תכונות באופן מתמטי כללי ככל הניתן? ובכן, כמו ששפה היא קבוצה של מילים שכולן מקיימות קריטריון מסויים, כך גם על תכונה אפשר לחשוב בתור <strong>קבוצה של שפות</strong> שכולן מקיימות קריטריון מסויים; ולמעשה, אין הכרח לציין את הקריטריון במפורש - אפשר פשוט להגדיר "תכונה של שפות" בתור קבוצה {::nomarkdown}\( S\){:/nomarkdown} כלשהי של שפות.

השאלה שבה משפט רייס עוסק היא זו - האם אנחנו מסוגלים, בהינתן קוד של תוכנית מחשב {::nomarkdown}\( M\){:/nomarkdown} כלשהי, לקבוע האם {::nomarkdown}\( L\left(M\right)\in S\){:/nomarkdown}?

כדי לפשט קצת את העניינים, מראש נגביל את {::nomarkdown}\( S\){:/nomarkdown} להיות תת קבוצה של {::nomarkdown}\( \mbox{RE}\){:/nomarkdown} - כלומר, במשחק שלנו כלל לא משתתפות שפות שאין מכונה שמקבלת אותן (ולכן הן ממילא לא רלוונטיות לשאלה אם {::nomarkdown}\( L\left(M\right)\in S\){:/nomarkdown}, שהרי הן אינן מהצורה {::nomarkdown}\( L\left(M\right)\){:/nomarkdown} עבור אף {::nomarkdown}\( M\){:/nomarkdown}). השאלה שלנו, בניסוח הכי פורמלי שאפשר, היא זו - בהינתן {::nomarkdown}\( S\subseteq\mbox{RE}\){:/nomarkdown}, נגדיר שפה {::nomarkdown}\( L_{S}=\left\{ M\|L\left(M\right)\in S\right\} \){:/nomarkdown}. האם {::nomarkdown}\( L_{S}\in\mbox{R}\){:/nomarkdown}? ואם לא, האם {::nomarkdown}\( L_{S}\in\mbox{RE}\){:/nomarkdown}, לכל הפחות? (כלומר, האם נוכל לפחות לעצור תמיד ולהגיד "כן" אם {::nomarkdown}\( L\left(M\right)\in S\){:/nomarkdown}, הגם שאם התשובה שלילית לא בהכרח נעצור?)

משפט רייס אומר ש-{::nomarkdown}\( L_{S}\in\mbox{R}\){:/nomarkdown} רק במקרה שבו {::nomarkdown}\( S\){:/nomarkdown} טריוויאלית - {::nomarkdown}\( S=\emptyset\){:/nomarkdown} או {::nomarkdown}\( S=\mbox{RE}\){:/nomarkdown} (התכונה לא מתקיימת לאף שפה, או שהיא מתקיימת לכל שפה ב-{::nomarkdown}\( \mbox{RE}\){:/nomarkdown}). במקרה הראשון, {::nomarkdown}\( L_{S}\){:/nomarkdown} היא שפה ריקה ולכן תוכנית מחשב שמכריעה אותה פשוט אומרת מייד "לא"; במקרה השני תוכנית המחשב שמכריעה את {::nomarkdown}\( L_{S}\){:/nomarkdown} פשוט אומרת מייד "כן". זה לא ממש מעניין, כמובן.

הבה ונוכיח בזריזות את משפט רייס (כבר עשיתי זאת בעבר, כאמור). ההוכחה היא באמצעות <strong>רדוקציה</strong> מ-{::nomarkdown}\( \mbox{HP}\){:/nomarkdown} אל {::nomarkdown}\( L_{S}\){:/nomarkdown}. רדוקציה היא פשוט דרך להראות איך, אם {::nomarkdown}\( L_{S}\){:/nomarkdown} ניתנת להכרעה, אפשר לנצל זאת גם כדי להכריע את {::nomarkdown}\( \mbox{HP}\){:/nomarkdown} (ואת זה כבר אמרנו שאי אפשר לעשות). אם כן, נניח שיש לנו תוכנית מחשב שמכריעה את {::nomarkdown}\( L_{S}\){:/nomarkdown}. נניח לרגע כי השפה הריקה, {::nomarkdown}\( \emptyset\){:/nomarkdown} אינה ב-{::nomarkdown}\( S\){:/nomarkdown} (השפה הריקה היא פשוט השפה שאין בה כלל מילים; היא מתקבלת, למשל, על ידי תוכנית מחשבת שפולטת "לא" מייד לכל קלט). מכיוון ש-{::nomarkdown}\( S\){:/nomarkdown} אינה טריוויאלית, יש בה לפחות שפה אחת - נאמר, {::nomarkdown}\( L\in S\){:/nomarkdown}. מכיוון ש-{::nomarkdown}\( S\){:/nomarkdown} מכילה רק שפות ב-{::nomarkdown}\( \mbox{RE}\){:/nomarkdown}, אז יש תוכנית מחשב שמקבלת את {::nomarkdown}\( L\){:/nomarkdown}; נסמנה {::nomarkdown}\( M_{L}\){:/nomarkdown}.

כעת, מטרתנו היא לפתור את בעיית העצירה. אז נותנים לנו {::nomarkdown}\( M\){:/nomarkdown} כלשהי ושואלים אותנו אם היא עוצרת או לא. מה שאנו עושים הוא לקחת את הקוד של {::nomarkdown}\( M\){:/nomarkdown} ולהשתיל אותו בתוך תוכנית מחשב קצת יותר גדולה ומחוכמת, {::nomarkdown}\( U\){:/nomarkdown}. {::nomarkdown}\( U\){:/nomarkdown} מקבלת קלט {::nomarkdown}\( w\){:/nomarkdown} כלשהו, ואז עושה שני דברים:
<ol>
	<li> מריצה את {::nomarkdown}\( M\){:/nomarkdown}.</li>
	<li> מריצה את {::nomarkdown}\( M_{L}\){:/nomarkdown} על הקלט {::nomarkdown}\( w\){:/nomarkdown} ועונה כמוה.</li>
</ol>
מה הולך כאן? ובכן, אם {::nomarkdown}\( M\){:/nomarkdown} עוצרת מתישהו, אז שלב 1 יסתיים מתישהו ושלב 2 יתחיל. לכן {::nomarkdown}\( U\){:/nomarkdown} תתנהג על כל {::nomarkdown}\( w\){:/nomarkdown} בדיוק כמו {::nomarkdown}\( M_{L}\){:/nomarkdown}, כלומר {::nomarkdown}\( L\left(U\right)=L\left(M_{L}\right)=L\in S\){:/nomarkdown}. במילים אחרות, אם {::nomarkdown}\( M\){:/nomarkdown} עוצרת, השפה של {::nomarkdown}\( U\){:/nomarkdown} היא בעלת התכונה {::nomarkdown}\( S\){:/nomarkdown}.

לעומת זאת, אם {::nomarkdown}\( M\){:/nomarkdown} אינה עוצרת אף פעם גם {::nomarkdown}\( U\){:/nomarkdown} לא תעצור אף פעם - היא נתקעת בשלב 1 ולא מגיעה כלל לשלב 2. לכן השפה של {::nomarkdown}\( U\){:/nomarkdown} היא השפה הריקה, שאמרנו שאינה מקיימת את התכונה {::nomarkdown}\( S\){:/nomarkdown}. מכאן שאפשר להכריע אם {::nomarkdown}\( M\){:/nomarkdown} עוצרת או לא על ידי כך שמכריעים אם השפה של {::nomarkdown}\( U\){:/nomarkdown} היא בעלת התכונה או לא; סוף הסיפור.

מה קורה אם {::nomarkdown}\( S\){:/nomarkdown} דווקא כן מכילה את השפה הריקה? כמעט אותו דבר. הפעם נבחר בתור {::nomarkdown}\( L\){:/nomarkdown} שפה כלשהי שאינה ב-{::nomarkdown}\( S\){:/nomarkdown} (קיימת כזו כי {::nomarkdown}\( S\){:/nomarkdown} לא טריוויאלית), ונשים לב שכעת אם {::nomarkdown}\( M\){:/nomarkdown} עוצרת, אז {::nomarkdown}\( U\){:/nomarkdown} דווקא <strong>איננה</strong> בעלת התכונה, ואם {::nomarkdown}\( M\){:/nomarkdown} אינה עוצרת אז {::nomarkdown}\( U\){:/nomarkdown} היא כן בעלת התכונה; אבל עדיין - ברגע שהכרענו אם {::nomarkdown}\( U\){:/nomarkdown} בעלת התכונה או לא, הסיפור נגמר.

זה מסיים את משפט רייס הבסיסי, וכעת אני רוצה לעבור אל מה שהוא מטרת הפוסט הזה - ההרחבה שלו. טיפלתי לחלוטין בשאלה מתי {::nomarkdown}\( L_{S}\in\mbox{R}\){:/nomarkdown}, אבל עדיין נותרה השאלה מתי {::nomarkdown}\( L_{S}\in\mbox{RE}\){:/nomarkdown}. כאן פתאום הסימטריה היפה של ההוכחה מתחילה להישבר. ראשית, אם {::nomarkdown}\( S\){:/nomarkdown} אינה מכילה את השפה הריקה (המקרה הראשון בו טיפלנו) אז ההוכחה פשוט לא עובדת יותר אם כל מה שאנו מניחים הוא ש-{::nomarkdown}\( L_{S}\in\mbox{RE}\){:/nomarkdown}; אמנם, על ידי בדיקה אם {::nomarkdown}\( U\){:/nomarkdown} בעלת התכונה עדיין נוכל להשתכנע ש-{::nomarkdown}\( M\){:/nomarkdown} עוצרת, וזה מראה ש-{::nomarkdown}\( \mbox{HP}\in\mbox{RE}\){:/nomarkdown}, אבל את זה כבר ידענו - זה לא מוביל לסתירה כלשהי. אם {::nomarkdown}\( M\){:/nomarkdown} לא עוצרת, אז {::nomarkdown}\( L\left(U\right)\){:/nomarkdown} לא תהיה בעלת התכונה, ולכן אין שום דבר שמבטיח לנו שהתוכנית שמקבלת את {::nomarkdown}\( L_{S}\){:/nomarkdown} תעצור בכלל על {::nomarkdown}\( U\){:/nomarkdown}.

לעומת זאת, אם {::nomarkdown}\( S\){:/nomarkdown} כן מכילה את השפה הריקה, הסיפור שונה; במקרה הזה, אם {::nomarkdown}\( M\){:/nomarkdown} <strong>לא</strong> עוצרת, אז {::nomarkdown}\( L\left(U\right)\){:/nomarkdown} <strong>כן</strong> תהיה בעלת התכונה, ולכן התוכנית שמקבלת את {::nomarkdown}\( L_{S}\){:/nomarkdown} <strong>כן</strong> תעצור מתישהו על {::nomarkdown}\( U\){:/nomarkdown} ותגיד "כן". זה פותח לנו פתח ל<strong>הכרעה</strong> של {::nomarkdown}\( \mbox{HP}\){:/nomarkdown}: בהינתן {::nomarkdown}\( M\){:/nomarkdown}, ראשית נבנה ממנה את {::nomarkdown}\( U\){:/nomarkdown} כמו קודם, ואז נעשה שני דברים במקביל - גם נבדוק אם {::nomarkdown}\( U\in L_{S}\){:/nomarkdown}, וגם נריץ את {::nomarkdown}\( M\){:/nomarkdown} ונראה אם היא עוצרת. אפשר לבצע הרצות במקביל - המחשב שלכם עושה זאת כל הזמן (כמובן שהסיפור האמיתי מסובך יותר - לרוב מריצים תוכנית אחת לזמן מה, ואז מעבירים את הבקרה לתוכנית השניה, ואז חוזרים לראשונה, וכן הלאה). כעת מובטח לנו כי אחת משתי ההרצות תעצור מתישהו - אם {::nomarkdown}\( M\){:/nomarkdown} עוצרת, אז ההרצה של {::nomarkdown}\( M\){:/nomarkdown} עצמה תעצור; ואם היא לא עוצרת ולכן {::nomarkdown}\( L\left(U\right)\){:/nomarkdown} בעלת התכונה, אז הבדיקה אם {::nomarkdown}\( U\in L_{S}\){:/nomarkdown} תעצור מתישהו. במקרה הראשון (אם {::nomarkdown}\( M\){:/nomarkdown} עצרה), נעצור גם אנחנו ונאמר "כן"; במקרה השני נעצור ונאמר "לא", והנה הכרענו את {::nomarkdown}\( \mbox{HP}\){:/nomarkdown} - סתירה. לכן אם {::nomarkdown}\( \emptyset\in S\){:/nomarkdown} הרי ש-{::nomarkdown}\( L_{S}\notin\mbox{RE}\){:/nomarkdown}. אבל זה כל מה שניתוח נאיבי של ההוכחה נתן לנו; אנחנו רוצים אפיון מוחלט, טענת "אם ורק אם". להבין בדיוק אילו תנאים על {::nomarkdown}\( S\){:/nomarkdown} מבטיחים ש-{::nomarkdown}\( L_{S}\in\mbox{RE}\){:/nomarkdown} ואילו תנאים מבטיחים כי {::nomarkdown}\( L_{S}\notin\mbox{RE}\){:/nomarkdown}.

ובכן, פשוט אציג את התנאים, ואז אוכיח שהם עובדים. נקווה שלא אאבד יותר מדי קוראים.

בהינתן {::nomarkdown}\( S\subseteq\mbox{RE}\){:/nomarkdown}, השפה {::nomarkdown}\( L_{S}\in\mbox{RE}\){:/nomarkdown} אם ורק אם {::nomarkdown}\( S\){:/nomarkdown} מקיימת בו זמנית את שלוש התכונות הבאות:
<ol>
	<li> אם {::nomarkdown}\( L_{1}\in S\){:/nomarkdown}, {::nomarkdown}\( L_{2}\in\mbox{RE}\){:/nomarkdown} ו-{::nomarkdown}\( L_{1}\subseteq L_{2}\){:/nomarkdown} אז {::nomarkdown}\( L_{2}\in S\){:/nomarkdown}.</li>
	<li> אם {::nomarkdown}\( L_{1}\in S\){:/nomarkdown} אז יש ל-{::nomarkdown}\( L_{1}\){:/nomarkdown} תת-שפה סופית {::nomarkdown}\( L_{2}\subseteq L_{1}\){:/nomarkdown} כך ש-{::nomarkdown}\( L_{2}\in S\){:/nomarkdown}.</li>
	<li> שפת כל השפות הסופיות שב-{::nomarkdown}\( S\){:/nomarkdown} היא ב-{::nomarkdown}\( \mbox{RE}\){:/nomarkdown}.</li>
</ol>
התנאי השלישי דורש הסבר כלשהו. שפה סופית - שפה שמכילה רק מספר סופי של מילים - תמיד אפשר לקודד כמחרוזת סופית. אם המילים שלה הן {::nomarkdown}\( w_{1},w_{2},\dots,w_{n}\){:/nomarkdown} אז המחרוזת {::nomarkdown}\( \left(w_{1},w_{2},\dots,w_{n}\right)\){:/nomarkdown} (הסוגריים והפסיקים הם חלק מהמחרוזת - הם מקודדים על ידי תווי ASCII שמקודדים על ידי ספרות בינאריות) היא דרך לייצג את השפה בתור מילה סופית (עבור שפות אינסופיות אי אפשר לעשות תעלול דומה). התנאי השלישי, אם כן, אומר שבהינתן מחרוזת שמייצגת קבוצת מילים שכזו, אם היא מקיימת את התכונה {::nomarkdown}\( S\){:/nomarkdown} אפשר לעצור ולומר זאת לאחר זמן סופי.

בואו נראה רגע איך המשפט הזה מתיישב עם מה שכבר ראינו. ראינו שאם {::nomarkdown}\( S\){:/nomarkdown} לא טריוויאלית ו-{::nomarkdown}\( \emptyset\in S\){:/nomarkdown} אז {::nomarkdown}\( L_{S}\notin\mbox{RE}\){:/nomarkdown}. מה המשפט החדש אומר? ובכן, {::nomarkdown}\( \emptyset\){:/nomarkdown} היא בעלת התכונה שלכל {::nomarkdown}\( L\){:/nomarkdown} מתקיים {::nomarkdown}\( \emptyset\subseteq L\){:/nomarkdown}, ולכן אם {::nomarkdown}\( S\){:/nomarkdown} היא כזו ש-{::nomarkdown}\( L_{S}\in\mbox{RE}\){:/nomarkdown} ובפרט היא מקיימת את תנאי 1, אז {::nomarkdown}\( L\in S\){:/nomarkdown} לכל {::nomarkdown}\( L\in\mbox{RE}\){:/nomarkdown}, כלומר {::nomarkdown}\( S=\mbox{RE}\){:/nomarkdown} ולכן זוהי תכונה טריוויאלית. כלומר, או ש-{::nomarkdown}\( S\){:/nomarkdown} טריוויאלית, או ש-{::nomarkdown}\( L_{S}\notin\mbox{RE}\){:/nomarkdown}. אז אנחנו רואים בבירור שהמשפט שזה עתה הצגתי הוא הכללה של מה שכבר ראינו.

אז איך מוכיחים את המשפט? אני ממליץ לאלו מכם שיש להם נסיון כלשהו עם חישוביות לנסות ולהוכיח בעצמכם. זה מהמשפטים הללו שעיקר הקושי בהם הוא הגילוי של הקריטריון המתאים (איך בדיוק הגיעו לשלושת התנאים הללו? כנראה שהרבה ניסויים ובדיקה של מקרים פרטיים והתעמקות ומחשבה - כמו כל משפט מתמטי בערך), ומרגע שהניסוח הנכון קיים ההוכחה אינה כה נוראית.

הבה ונעבור להוכחה. ראשית נראה כי שלוש התכונות הללו הן הכרחיות, כלומר שאם משמיטים ולו אחת מהן, {::nomarkdown}\( L_{S}\notin\mbox{RE}\){:/nomarkdown} בודאות.

ראשית נשמיט את תכונה 1, כלומר נניח שיש {::nomarkdown}\( L_{1},L_{2}\){:/nomarkdown} כך ש-{::nomarkdown}\( L_{1}\subseteq L_{2}\){:/nomarkdown} וגם {::nomarkdown}\( L_{1},L_{2}\in\mbox{RE}\){:/nomarkdown} וגם {::nomarkdown}\( L_{1}\in S\){:/nomarkdown} אבל {::nomarkdown}\( L_{2}\notin S\){:/nomarkdown}. כעת נכריע את {::nomarkdown}\( \mbox{HP}\){:/nomarkdown} בדרך דומה למה שעוללנו קודם - בהינתן {::nomarkdown}\( M\){:/nomarkdown}, נבנה מכונה {::nomarkdown}\( U\){:/nomarkdown} ששפתה תהיה {::nomarkdown}\( L_{1}\){:/nomarkdown} אם {::nomarkdown}\( M\){:/nomarkdown} אינה עוצרת, ו-{::nomarkdown}\( L_{2}\){:/nomarkdown} אם היא כן עוצרת. אם {::nomarkdown}\( L_{S}\in\mbox{RE}\){:/nomarkdown} זה אומר שנוכל לזהות מתי {::nomarkdown}\( M\){:/nomarkdown} אינה עוצרת; וכאמור, לזהות מתי היא כן עוצרת אפשר לזהות פשוט על ידי הרצתה.

מה {::nomarkdown}\( U\){:/nomarkdown} עושה, על קלט {::nomarkdown}\( w\){:/nomarkdown}? ובכן, היא מריצה את המכונה שמקבלת את {::nomarkdown}\( L_{1}\){:/nomarkdown} על הקלט {::nomarkdown}\( w\){:/nomarkdown}, ובמקביל היא מריצה את {::nomarkdown}\( M\){:/nomarkdown}. אם בשלב כלשהו המכונה של {::nomarkdown}\( L_{1}\){:/nomarkdown} עצרה וקיבלה את {::nomarkdown}\( w\){:/nomarkdown}, אז גם {::nomarkdown}\( U\){:/nomarkdown} מקבלת את {::nomarkdown}\( w\){:/nomarkdown}; ואם בשלב כלשהו {::nomarkdown}\( M\){:/nomarkdown} עצרה, אז {::nomarkdown}\( U\){:/nomarkdown} מפסיקה את הרצת המכונה של {::nomarkdown}\( L_{1}\){:/nomarkdown} על {::nomarkdown}\( w\){:/nomarkdown} ותחת זאת מריצה את המכונה של {::nomarkdown}\( L_{2}\){:/nomarkdown} על {::nomarkdown}\( w\){:/nomarkdown} ועונה כמוה. מה הולך כאן?

ובכן, אם {::nomarkdown}\( M\){:/nomarkdown} <strong>אינה עוצרת</strong>, אז {::nomarkdown}\( U\){:/nomarkdown} תקבל את {::nomarkdown}\( w\){:/nomarkdown} אם ורק אם {::nomarkdown}\( w\in L_{1}\){:/nomarkdown}; במילים אחרות, {::nomarkdown}\( L\left(U\right)=L_{1}\){:/nomarkdown}, כפי שרצינו; ואילו אם {::nomarkdown}\( M\){:/nomarkdown} כן עוצרת, אז את {::nomarkdown}\( w\){:/nomarkdown} אפשר לקבל בשתי צורות אפשריות - או שנקבל אותו כבר בהתחלה, אם נזהה שהוא ב-{::nomarkdown}\( L_{1}\){:/nomarkdown}; או שנקבל אותו בהמשך, אם נזהה שהוא ב-{::nomarkdown}\( L_{2}\){:/nomarkdown}. אלא ש-{::nomarkdown}\( L_{1}\subseteq L_{2}\){:/nomarkdown}, כך שהאפשרות שנקבל אותו בהתחלה לא משנה כלום - מובטח לנו ש-{::nomarkdown}\( L\left(U\right)=L_{2}\){:/nomarkdown} במקרה זה, שבו {::nomarkdown}\( M\){:/nomarkdown} עוצרת. כפי שרצינו.

יפה, אז התנאי הראשון הכרחי. ומה עם השני? גם כאן מניחים שהתנאי לא מתקיים ומוכיחים שאם עדיין {::nomarkdown}\( L_{S}\in\mbox{RE}\){:/nomarkdown} אז אפשר להכריע את {::nomarkdown}\( \mbox{HP}\){:/nomarkdown}: נניח בשלילה שיש {::nomarkdown}\( L_{1}\in S\){:/nomarkdown} שכל תת-שפה סופית שלה אינה ב-{::nomarkdown}\( S\){:/nomarkdown}; אז בהינתן {::nomarkdown}\( M\){:/nomarkdown} נבנה {::nomarkdown}\( U\){:/nomarkdown} כך שאם {::nomarkdown}\( M\){:/nomarkdown} אינה עוצרת, {::nomarkdown}\( L\left(U\right)=L_{1}\){:/nomarkdown}, ואילו אם {::nomarkdown}\( M\){:/nomarkdown} כן עוצרת, {::nomarkdown}\( L\left(U\right)\){:/nomarkdown} היא שפה סופית כלשהי (ולכן לא ב-{::nomarkdown}\( S\){:/nomarkdown}). התעלול פשוט: {::nomarkdown}\( U\){:/nomarkdown} על קלט {::nomarkdown}\( w\){:/nomarkdown} תריץ את {::nomarkdown}\( M\){:/nomarkdown} במשך {::nomarkdown}\( \left\|w\right\|\){:/nomarkdown} צעדים - כלומר, מספר צעדים ששווה לאורך של {::nomarkdown}\( w\){:/nomarkdown}. אם {::nomarkdown}\( M\){:/nomarkdown} עצרה במהלך הצעדים הללו, {::nomarkdown}\( U\){:/nomarkdown} תעצור מייד ותגיד "לא"; אחרת, אחרי שהריצה את {::nomarkdown}\( M\){:/nomarkdown} במשך {::nomarkdown}\( \left\|w\right\|\){:/nomarkdown} צעדים, {::nomarkdown}\( U\){:/nomarkdown} תתייאש ותריץ את התוכנית עבור {::nomarkdown}\( L_{1}\){:/nomarkdown} על {::nomarkdown}\( w\){:/nomarkdown} ותענה כמוה.

מה קרה כאן? אם {::nomarkdown}\( M\){:/nomarkdown} עוצרת מתישהו, נניח אחרי 13 צעדים, אז {::nomarkdown}\( U\){:/nomarkdown} תדחה כל מילה שאורכה גדול מ-13; ולכן השפה של {::nomarkdown}\( U\){:/nomarkdown} סופית; ולכן היא אינה ב-{::nomarkdown}\( S\){:/nomarkdown}. אם לעומת זאת {::nomarkdown}\( M\){:/nomarkdown} אינה עוצרת אף פעם אז {::nomarkdown}\( U\){:/nomarkdown} תמיד תגיע לשלב שבו היא בודקת אם {::nomarkdown}\( w\){:/nomarkdown} שייכת ל-{::nomarkdown}\( L_{1}\){:/nomarkdown}, ולכן שפתה תהיה בדיוק {::nomarkdown}\( L_{1}\){:/nomarkdown}. מכאן הדרך להכרעת {::nomarkdown}\( \mbox{HP}\){:/nomarkdown} סלולה.

נותרנו עם התנאי השלישי. על פניו הוא נראה הסבוך מכולם, אבל במקרה שלו ההוכחה קלה עוד יותר ואפילו לא נזדקק להוכחה בדרך השלילה. אם {::nomarkdown}\( L_{S}\in\mbox{RE}\){:/nomarkdown} זה אומר שבהינתן מכונה {::nomarkdown}\( M\){:/nomarkdown}, ניתן לבדוק אם {::nomarkdown}\( L\left(M\right)\in S\){:/nomarkdown} ואם התשובה חיובית מובטח לנו שנעצור. אם כן, איך נבדוק, בהינתן שפה סופית {::nomarkdown}\( L\){:/nomarkdown}, ש-{::nomarkdown}\( L\in S\){:/nomarkdown}? פשוט מאוד: נבנה בעזרת הקידוד של {::nomarkdown}\( L\){:/nomarkdown} מכונה {::nomarkdown}\( M\){:/nomarkdown} כך ש-{::nomarkdown}\( L\left(M\right)=L\){:/nomarkdown}. מכונה כזו, בהינתן קלט, פשוט משווה אותו לרשימת המילים הסופית של {::nomarkdown}\( L\){:/nomarkdown} ומקבלת אם הוא שם. כעת כל שנותר לעשות כדי לבדוק אם {::nomarkdown}\( L\in S\){:/nomarkdown} הוא לבדוק אם {::nomarkdown}\( L\left(M\right)\in S\){:/nomarkdown}.

אם כן, הראנו כי אחד מהתנאים הללו בפני עצמו הוא הכרחי - אם הוא אינו מתקיים, {::nomarkdown}\( L_{S}\notin\mbox{RE}\){:/nomarkdown}. החלק המעניין כאן הוא האופן שבו השילוב של שלושתם - שלושה תנאים שנראים בלתי קשורים בעליל ממבט ראשון - מוכיח כי {::nomarkdown}\( L_{S}\in\mbox{RE}\){:/nomarkdown}. כמקודם, אני מאוד ממליץ לנסות ולחשוב על זה בעצמכם לפני שתקראו את ההוכחה.

בואו נבהיר לעצמנו מה צריך לעשות - אנחנו צריכים להראות איך, בהינתן תוכנית {::nomarkdown}\( M\){:/nomarkdown}, אפשר לבדוק אם {::nomarkdown}\( L\left(M\right)\in S\){:/nomarkdown}, כשהפריבילגיה שלנו היא שאם {::nomarkdown}\( L\left(M\right)\notin S\){:/nomarkdown} אנחנו לא חייבים לעצור, אלא רק להימנע ממתן תשובה שגויה. אז השאלה שלנו היא - איך אנחנו יכולים להשתכנע ב-100 אחוזי ודאות ש-{::nomarkdown}\( L\left(M\right)\in S\){:/nomarkdown}?

השפות הסופיות ב-{::nomarkdown}\( S\){:/nomarkdown} הן המפתח לפתרון. אם נגלה שפה סופית ב-{::nomarkdown}\( S\){:/nomarkdown} כך ש-{::nomarkdown}\( M\){:/nomarkdown} מקבלת את <strong>כל</strong> המילים שבה, אנחנו יכולים בודאות לסיים. מדוע? על פי תנאי מס' 1: אם הראינו כי {::nomarkdown}\( L\left(M\right)\){:/nomarkdown} מכילה שפה סופית ב-{::nomarkdown}\( S\){:/nomarkdown}, תנאי 1 אומר שגם היא עצמה ב-{::nomarkdown}\( S\){:/nomarkdown} ולכן ניתן בודאות לקבל.

אבל, תגידו, מי מבטיח לנו שבכלל <strong>קיימת</strong> שפה סופית ב-{::nomarkdown}\( S\){:/nomarkdown} שאותה {::nomarkdown}\( L\left(M\right)\){:/nomarkdown} מכילה? ובכן, תנאי 2, כמובן. שני התנאים מאפשרים לנו לנסח קריטריון אם-ורק-אם: {::nomarkdown}\( L\left(M\right)\in S\){:/nomarkdown} אם ורק אם קיימת {::nomarkdown}\( L_{1}\subseteq L\left(M\right)\){:/nomarkdown} סופית כך ש-{::nomarkdown}\( L_{1}\in S\){:/nomarkdown}.

האתגר שנותר הוא להסביר איך בודקים בפועל אם קיימת {::nomarkdown}\( L_{1}\in S\){:/nomarkdown} כזו שמקיימת {::nomarkdown}\( L_{1}\subseteq L\left(M\right)\){:/nomarkdown}. את הבדיקה הזו עושים עם תעלול סטנדרטי נוסף בתורת החישוביות - הרצה מבוקרת.

הרצה מבוקרת היא דרך לרוץ על אינסוף קלטים "בבת אחת" או "במקביל", למרות ששתי המילים הללו אינן נכונות במיוחד. מה שאני רוצה לעשות הוא לבנות רשימה של כל המילים שעליהן {::nomarkdown}\( M\){:/nomarkdown} עוצרת ומקבלת, אך סתם להריץ את {::nomarkdown}\( M\){:/nomarkdown} על מילה כלשהי, לחכות עד שתסיים ואז לעבור למילה הבאה לא יעבוד, כי לא בטוח ש-{::nomarkdown}\( M\){:/nomarkdown} תסיים בכלל. לכן התעלול הוא כזה: אני קובע סדר כלשהו על כל המילים הקיימות, {::nomarkdown}\( w_{1},w_{2},w_{3},\dots\){:/nomarkdown} (שיטה אחת - להשוות קודם על פי האורך, ולאחר מכן על פי המספר שהמילה מייצגת). אני מריץ את {::nomarkdown}\( M\){:/nomarkdown} זמן מה על {::nomarkdown}\( w_{1}\){:/nomarkdown} ומפסיק. לאחר מכן אני מריץ אותה זמן מה על {::nomarkdown}\( w_{2}\){:/nomarkdown}, ומפסיק. אז אני חוזר להריץ אותה על {::nomarkdown}\( w_{1}\){:/nomarkdown} תוך שאני ממשיך מאותה נקודה שבה הפסקתי קודם; ואז אני רץ על {::nomarkdown}\( w_{2}\){:/nomarkdown}. ואז על {::nomarkdown}\( w_{3}\){:/nomarkdown}. ואז שוב {::nomarkdown}\( w_{1}\){:/nomarkdown}, ושוב {::nomarkdown}\( w_{2}\){:/nomarkdown}, ושוב {::nomarkdown}\( w_{3}\){:/nomarkdown}, ואז {::nomarkdown}\( w_{4}\){:/nomarkdown} - אתם מבינים את העיקרון. בכל "סיבוב" ריצה אני נותן הרצה לכל המילים שכבר התעסקתי איתן קודם, ומוסיף מילה חדשה למשחק. זה מבטיח שבסופו של דבר, כל מילה תזכה לכך שירוצו עליה זמן לא חסום, ולכן לכל מילה שאותה {::nomarkdown}\( M\){:/nomarkdown} מקבל, בסוף אכן אגלה ש-{::nomarkdown}\( M\){:/nomarkdown} מקבל אותה. זו נראית כמו שיטה בזבזנית למדי, אבל זה בדיוק האופן שבו דברים עובדים בתורת החישוביות - המקום שבו מתעניינים רק בשאלה אם משהו אפשרי ברמה הכי תיאורטית.

מה עכשיו? ובכן, בכל פעם שבה תתגלה מילה חדשה שאותה {::nomarkdown}\( M\){:/nomarkdown} מקבלת, נבצע במקביל להרצה של {::nomarkdown}\( M\){:/nomarkdown} על כל המילים האפשריות גם בדיקה נוספת - כל תת-קבוצה של המילים ש-{::nomarkdown}\( M\){:/nomarkdown} קיבלה עד כה היא שפה סופית; פשוט נבדוק לכל שפה סופית כזו (שוב, על ידי הרצה מבוקרת) האם היא ב-{::nomarkdown}\( S\){:/nomarkdown}. אנחנו יכולים לעשות זאת, על פי כלל 3. אם מתישהו שפה סופית שכזו תתקבל, סיימנו - פשוט נעצור ונקבל. ואם אף פעם לא תתקבל שפה סופית שכזו? ובכן, החיים קשים ולא נעצור לעולם, אבל כבר אמרתי שאם אף שפה סופית שכזו לא מתקבלת, הרי שממילא {::nomarkdown}\( L\left(M\right)\notin S\){:/nomarkdown} ולכן כל מה שאני מחוייב לו הוא לא לקבל, ובפרט מותר לי לא לעצור.

אם כן, זה מסיים את ההוכחה הכללית ביותר של משפט רייס. אם זו הפעם הראשונה שאתם נתקלים בדברים כאלו אני מניח שזה נראה לכם מטורלל משהו; אם כן, מצויין! זה בדיוק האופי של תורת החישוביות שאני רוצה להעביר. אחרי שמתרגלים קצת לתורת החישוביות רואים שההוכחה הזו היא מאוד פשוטה וטבעית (לא סתם הפצרתי בכם לנסות ולגלות אותה בעצמכם) ולטעמי - גם יפה בצורה בלתי רגילה.
