---
id: 3283
title: "משפט קוק-לוין"
date: 2015-07-23 11:31:28
layout: post
categories: 
  - תורת הסיבוכיות
tags: 
  - NP-שלמות
  - משפט קוק-לוין
  - שאלת P=NP
---
חור מטריד שקיים בבלוג ואני מתכוון להשלים כעת הוא תיאור והוכחה של אחד מהמשפטים הבסיסיים והחשובים ביותר בתורת הסיבוכיות - משפט קוק-לוין. אף שכבר תיארתי את הבסיס לתורת הסיבוכיות בעבר, וגם הראיתי תוצאות מסובכות יותר מקוק-לוין, איכשהו המשפט הזה חמק ממני והגיע הזמן להשלים את החסר. בפוסט הזה לא רק אתאר את המשפט ואת הרקע שלו אלא גם אתאר את כל ההוכחה; מכיוון שזה לרוב המשפט בעל ההוכחה המסובכת ביותר שסטודנטים נתקלים בו בקורס המבוא לנושאים הללו, אני מקווה שהפוסט יתגלה כמועיל למדי. אני בעיקר רוצה להבהיר שההוכחה הזו <strong>אינה</strong> קשה ו<strong>אינה</strong> מפחידה כפי שהרושם הראשון שלה עשוי להצטייר (בפעם הראשונה שבה ראיתי הוכחה לא הבנתי כלום).

קל מאוד לנסח את המשפט: "השפה SAT היא NP-שלמה". אני מניח שאתם מכירים את המושגים הללו, כי אין טעם לקרוא ישר על משפט קוק-לוין בלי להכיר אותם, ובכל זאת תזכורת קטנה למי ששמע את המושגים ואין לו כוח לחזור עליהם: אנחנו מתעסקים פה ב<strong>בעיות הכרעה</strong> של <strong>שפות פורמליות</strong>, כלומר בהינתן מחרוזת {::nomarkdown}\( w\){:/nomarkdown} כלשהי אנחנו שואלים האם היא שייכת או לא לקבוצה {::nomarkdown}\( L\){:/nomarkdown} - קבוצה כזו נקראת "שפה".

השפה SAT היא דוגמה אחת לשפה שכזו, מאוד מעניינת: המחרוזות ששייכות אליה מקודדות פסוקים מתחשיב הפסוקים, שהם מהצורה הנורמלית CNF. כלומר, כל פסוק הוא מהצורה {::nomarkdown}\( \varphi=C_{1}\wedge C_{2}\wedge\dots\wedge C_{n}\){:/nomarkdown} כך שכל {::nomarkdown}\( C_{i}\){:/nomarkdown} כזו נקראת <strong>פסוקית</strong> והיא מהצורה {::nomarkdown}\( C=\left(l_{1}\vee l_{2}\vee\dots\vee l_{k}\right)\){:/nomarkdown} כאשר כל {::nomarkdown}\( l_{j}\){:/nomarkdown} כזה נקרא <strong>ליטרל</strong> והוא או משתנה או שלילה של משתנה (או מהצורה {::nomarkdown}\( x\){:/nomarkdown} או מהצורה {::nomarkdown}\( \neg x\){:/nomarkdown} עבור משתנה {::nomarkdown}\( x\){:/nomarkdown} כלשהו). שימו לב שמספר הליטרלים בכל פסוקית יכול להיות שונה; פסוק CNF פשוט לדוגמה הוא {::nomarkdown}\( \left(x\vee\neg y\right)\wedge\left(\neg x\vee y\vee z\right)\){:/nomarkdown}.

פסוק CNF נקרא ספיק אם קיימת השמה של <strong>ערכי אמת</strong> למשתנים שלו שמספקת אותו. כדי לספק פסוק CNF צריך לספק בו זמנית את <strong>כל</strong> הפסוקיות שלו; כדי לספק פסוקית צריך לספק <strong>לפחות</strong> ליטרל אחד. כדי לספק משתנה צריך להציב בו את הערך True, וכדי לספק שלילה של משתנה צריך להציב באותו משתנה את הערך False. זה הכל. בפועל אני מייצג את True ו-False בעזרת 1 ו-0, בהתאמה.

הבעיה של הכרעה האם פסוק CNF כלשהו שייך ל-SAT היא בעיה קשה, מבחינה חישובית: אם יש לפסוק {::nomarkdown}\( n\){:/nomarkdown} משתנים בסך הכל (פזורים לכל רוחב הפסוקיות שלו, לפעמים עם שלילה) אז יש {::nomarkdown}\( 2^{n}\){:/nomarkdown} השמות אפשריות לפסוק, ולעבור אחת אחת ולבדוק את כולן - זה פתרון שהוא לא <strong>יעיל מבחינה חישובית</strong>. זה לא אומר שאין שיטות מתוחכמות יותר, אבל אין שיטה שמבטיחה תמיד, גם במקרה הגרוע ביותר, זמן ריצה שנחשב "יעיל" (פולינומי). עם זאת, ל-SAT יש גם תכונה נחמדה מאוד: אם נתון לכם פסוק {::nomarkdown}\( \varphi\){:/nomarkdown} שאכן שייך ל-SAT, אז אפשר <strong>לשכנע</strong> אתכם יחסית בקלות בכך אם נותנים לכם <strong>הוכחה</strong> מתאימה לכך - במקרה הזה, ה"הוכחה" היא פשוט השמה מספקת עבור הפסוק; אתם בודקים בעצמכם שההשמה אכן מספקת ולא מרמים אתכם, ואם היא מספקת, השתכנעתם שהפסוק שייך ל-SAT.

הרעיון הזה, של שפות שקל <strong>לבדוק הוכחה</strong> לשייכות של מילה אליהן מגדיר את המחלקה NP. פורמלית, {::nomarkdown}\( L\in\mbox{NP}\){:/nomarkdown} אם קיים <strong>מוודא</strong> שהוא מכונת טיורינג פולינומית (אחזור על הפורמליזם שמגדיר מכונות טיורינג בהמשך, כשאזדקק לכך) {::nomarkdown}\( M\){:/nomarkdown} כך ש-{::nomarkdown}\( M\){:/nomarkdown} רצה על <strong>זוג</strong> קלטים, {::nomarkdown}\( x,y\){:/nomarkdown}; הרעיון הוא ש-{::nomarkdown}\( x\){:/nomarkdown} הוא המילה שאת שייכותה ל-{::nomarkdown}\( L\){:/nomarkdown} בודקים, ו-{::nomarkdown}\( y\){:/nomarkdown} הוא "הצעת הוכחה" לשייכות הזו. זמן הריצה הפולינומי של {::nomarkdown}\( M\){:/nomarkdown} נמדד רק ביחס ל-{::nomarkdown}\( x\){:/nomarkdown}, או לחילופים דורשים שהגודל של {::nomarkdown}\( y\){:/nomarkdown} יהיה פולינומי בגודל של {::nomarkdown}\( x\){:/nomarkdown}, אחרת במקום "הוכחה" היינו יכולים פשוט לדחוף {::nomarkdown}\( y\){:/nomarkdown} ג'יברישי ארוך מאוד ובכך לאפשר ל-{::nomarkdown}\( M\){:/nomarkdown} לרוץ המון זמן ולבדוק את שייכות {::nomarkdown}\( x\){:/nomarkdown} לשפה באופן ישיר, מה שכמובן מפספס את הפואנטה. עכשיו, אם {::nomarkdown}\( x\in L\){:/nomarkdown} הדרישה שלנו היא ש<strong>קיים {::nomarkdown}\( y\){:/nomarkdown} </strong>כך ש-{::nomarkdown}\( M\){:/nomarkdown} מסיימת את ריצתה על הזוג {::nomarkdown}\( x,y\){:/nomarkdown} ואומרת "כן", ואילו אם {::nomarkdown}\( x\notin L\){:/nomarkdown} אז <strong>לכל</strong> {::nomarkdown}\( y\){:/nomarkdown}, {::nomarkdown}\( M\){:/nomarkdown} תסיים את ריצתה על {::nomarkdown}\( x,y\){:/nomarkdown} עם אמירת "לא". שימו לב לחוסר הסימטריה פה ("קיים" אל מול "לכל"). זו כל ההגדרה. יש הגדרה שקולה, שמדברת על מכונת טיורינג אי דטרמיניסטית (וגם את ההגדרה שלי אפשר לנסח בצורה שונה, בעזרת יחסים) אבל אני לא אכנס לזה כרגע - ההוכחה שלי תהיה עבור ההגדרה שנתתי, והוכחות אחרות הן אותו הדבר בערך.

שפות ב-NP יש המון. המון המון המון. עשרות אלפי בעיות מעניינות במדעי המחשב הן בעלות התכונה היפה של NP. ולכן היה מעניין, במידת מה, לגלות שיש שפה ב-NP שמסוגלת <strong>לקודד את כולן</strong>. השפה הזו הייתה SAT, וזה התוכן של משפט קוק-לוין. למה אני מתכוון ב"לקודד"? בואו ניקח שפה {::nomarkdown}\( L\in\mbox{NP}\){:/nomarkdown} כלשהי; הטענה היא שלכל {::nomarkdown}\( x\){:/nomarkdown} (בין אם הוא ב-{::nomarkdown}\( L\){:/nomarkdown} ובין אם לאו) ניתן לבנות בזמן יעיל (פולינומי) פסוק CNF {::nomarkdown}\( \varphi_{x}\){:/nomarkdown} כך ש-{::nomarkdown}\( \varphi_{x}\in\mbox{SAT}\){:/nomarkdown} אם ורק אם {::nomarkdown}\( x\in L\){:/nomarkdown}. לבניה כזו קוראים <strong>רדוקציה</strong> פולינומית. לכן, ניסוח אחר למשפט קוק-לוין הוא: SAT היא בעלת התכונה שכל שפה ב-NP ניתנת לרדוקציה פולינומית אליה. שפה עם תכונה שכזו נקראת NP-קשה; השם "NP-שלמה" בא להעיד על כך שזו שפה שהיא גם NP-קשה וגם שייכת בעצמה ל-NP.

את המשפט פרסם סטיבן קוק בארה"ב ב-1971. ב-1973 התפרסמה בבריה"מ גרסה אחרת של המשפט שהוכיח לאוניד לוין. זו הייתה אחת מתופעות הלוואי העגומות של המלחמה הקרה - תורת הסיבוכיות התפתחה בארה"ב ובברה"מ באופן בלתי תלוי, וגם הזמנים המדויקים לא ברורים לי (לוין כנראה הוכיח את המשפט הרבה לפני 1973). הניסוח של לוין היה שונה ומה שאני מציג הוא את הניסוח של קוק; אבל מה שלוין עשה עדיין תפס את לב העניין ולכן אני מעדיף לקרוא למשפט על שם שניהם.

משפט קוק היה אמנם מעניין, אבל על פניו הוא לא הוכיח משהו מרגש במיוחד - ניתן ללא קושי מהותי לייצר שפה מלאכותית שהיא NP-שלמה. אבל זה לב העניין - זו תהיה שפה מלאכותית ולא מעניינת, וההוכחה תהיה פשוטה בהתאם. לעומת זאת, קוק תפס שפה חשובה ושימושית, אבל לאף אחד כנראה לא היה ברור <strong>עד כמה</strong> היא שימושית עד שריצ'ארד קארפ בא בשנת 1972 והציג רשימה של 21 בעיות ב-NP - בעיות מרכזיות ומעניינות במדעי המחשב - ש-SAT ניתנת לרדקוציה <strong>אליהן</strong> בדרך זו או אחרת. עכשיו, די קל לראות שניתן להרכיב רדוקציות; לכן אם {::nomarkdown}\( L_{1}\){:/nomarkdown} ניתנת לרדוקציה אל SAT, ואילו SAT ניתנת לרדוקציה אל {::nomarkdown}\( L_{2}\){:/nomarkdown}, אז {::nomarkdown}\( L_{1}\){:/nomarkdown} ניתנת לרדוקציה אל {::nomarkdown}\( L_{2}\){:/nomarkdown}. המשמעות: קארפ הוכיח שעוד 21 בעיות הן NP-שלמות (יום אחד אני ארצה לתאר את כל המאמר שלו בבלוג - זו יצירת מופת של רדוקציות יצירתיות ופשוטות). מכאן כבר הזרם היה בלתי ניתן לעצירה. כדי להוכיח שבעיה היא NP-שלמה, כל מה שצריך לעשות הוא לרדקץ אליה בעיה אחרת, שאנחנו כבר יודעים שהיא NP-שלמה, וככל שאנחנו מכירים יותר כאלו, כך יהיה לנו קל יותר לרדקץ; כיום יש אלפי בעיות שאנו יודעים שהן NP-שלמות. וכל זה נובע מהבסיס, שהוא SAT, דהיינו משפט קוק-לוין.

האנלוגיה הנכונה למשפט קוק-לוין היא בעיית העצירה של טיורינג, השייכת לתורת החישוביות. טיורינג הוכיח עבור בעיה קונקרטית שאין אלגוריתם שמסוגל לפתור אותה; ומכאן ואילך נפתחה הדרך להוכיח עבור שלל בעיות אחרות שאין דרך לפתור אותן, על ידי הצגה של רדוקציה מבעיית העצירה אליהן. כעת, בעיות NP-שלמות הן בוודאי בעיות ש<strong>ניתן</strong> לפתור, פשוט לא בהכרח ביעילות; האנלוגיה הנכונה היא לטעון שאם בעיה היא NP-שלמה אז היא בודאות לא שייכת ל-P. לרוע המזל, איננו יכולים להגיד זאת גם כיום. אנחנו יכולים להגיד שאם בעיה NP-שלמה כלשהי שייכת ל-P, אז ינבע מכך מייד ש<strong>כל</strong> הבעיות ב-NP שייכות ל-P (כי בהינתן בעיית NP כלשהו, נרדקץ אותה בזמן פולינומי לבעיה NP-שלמה ששייכת ל-P ואז נפתור את הבעיה הזו). כלומר, <strong>אם</strong> P שונה מ-NP אז כל הבעיות ה-NP-שלמות הן בודאות לא ב-P. השאלה הזו - האם P שונה מ-NP - היא אולי השאלה הפתוחה המרכזית במדעי המחשב התיאורטיים. כך היא הייתה בפעם הראשונה שכתבתי עליה בבלוג, וכך לצערי נשאר המצב גם כיום.

יפה, אז זה מה שהמשפט אומר; וקרוב לודאי שחידשתי מעט מאוד למי שכבר הכיר את ההגדרות. אז בואו נעבור למנה העיקרית שלנו - איך מוכיחים את המשפט?

הרעיון האינטואיטיבי הוא זה: נתונה לנו שפה {::nomarkdown}\( L\in\mbox{NP}\){:/nomarkdown}. ניקח מכונת טיורינג {::nomarkdown}\( M\){:/nomarkdown} עבורה. כעת, בהינתן {::nomarkdown}\( x\){:/nomarkdown} כלשהו, נבנה פסוק {::nomarkdown}\( \varphi_{x}\left(y\right)\){:/nomarkdown} שבצורה מחוכמת כלשהי יקודד בתוכו <strong>חישוב</strong> של {::nomarkdown}\( M\){:/nomarkdown} על {::nomarkdown}\( x,y\){:/nomarkdown}. שימו לב: כאן {::nomarkdown}\( y\){:/nomarkdown} מייצגים את <strong>המשתנים</strong> של הפסוק; הרעיון הוא שאנחנו יכולים להזין לפסוק ערכים שונים של {::nomarkdown}\( y\){:/nomarkdown}, ושהפסוק יסתפק או לא יסתפק בהתאם לשאלה האם {::nomarkdown}\( M\){:/nomarkdown} מחזירה "כן" על {::nomarkdown}\( x,y\){:/nomarkdown} או "לא". אבל זה רק הרעיון האינטואיטיבי. הביצוע יהיה קצת יותר מסובך. בפועל לקודד חישובים עם CNF זה לא טריוויאלי, אז אנחנו נשתמש גם ב<strong>משתני עזר</strong> שאסמן {::nomarkdown}\( z\){:/nomarkdown}, והפסוק יסומן {::nomarkdown}\( \varphi_{x}\left(y,z\right)\){:/nomarkdown}. שימו לב - גם {::nomarkdown}\( y\){:/nomarkdown} וגם {::nomarkdown}\( z\){:/nomarkdown} מייצגים <strong>וקטורים</strong> של משתנים, לא משתנים בודדים; כלומר, אני משתמש בכתיב הזה בתור קיצור לכתיב {::nomarkdown}\( \varphi_{x}\left(y_{1},\dots,y_{n},z_{1},\dots,z_{k}\right)\){:/nomarkdown} שתסכימו איתי שהוא מסורבל יותר. הרעיון הוא שלמשתני העזר הללו <strong>לא יהיה חופש בחירה</strong>: בהינתן השמה כלשהי ל-{::nomarkdown}\( y\){:/nomarkdown}-ים, תהיה בדיוק דרך אחת שבה אפשר לתת ערכים ל-{::nomarkdown}\( z\){:/nomarkdown}-ים אם אנחנו מקווים להצליח לספק את הפסוק; כל דרך אחרת שבה נציב ערכים ב-{::nomarkdown}\( z\){:/nomarkdown}-ים אוטומטית תגרום לכך שהפסוק לא יסתפק על ידי ההשמה הזו.

כדי להבין איך נראה חישוב של {::nomarkdown}\( M\){:/nomarkdown} צריך להיזכר בפרטים הטכניים של איך נראית מכונת טיורינג. יש למכונה <strong>סרט</strong> אינסופי שמחולק לתאים, כשבכל תא יכול להיות סימבול מתוך קבוצת סימבולים שנקראית <strong>אלפבית הסרט</strong>, {::nomarkdown}\( \Gamma\){:/nomarkdown}. בנוסף יש למכונה <strong>ראש קורא וכותב</strong> שבכל רגע נתון נמצא מעל תא אחד בסרט, ומחובר למערכת בקרה שיכולה להימצא ב<strong>מצבים פנימיים</strong> שונים ומשונים מתוך קבוצה סופית {::nomarkdown}\( Q\){:/nomarkdown} של מצבים. כל רגע נתון בחישוב ניתן לתיאור מלא באמצעות שלושה פרטים: המצב הפנימי הנוכחי של המכונה; המיקום של הראש; התוכן הנוכחי של הסרט. שלשה כזו נקראת <strong>קונפיגורציה</strong> וחישוב של מכונת טיורינג הוא סדרה של קונפיגורציות, שכל אחת מתקבלת מקודמתה בהתאם ל<strong>פונקצית המעברים</strong> של המכונה; זו פונקציה {::nomarkdown}\( \delta:Q\times\Gamma\to Q\times\Gamma\times\left\{ L,R,S\right\} \){:/nomarkdown} שלכל זוג {::nomarkdown}\( \left(q,\sigma\right)\){:/nomarkdown} של "המצב הפנימי הנוכחי {::nomarkdown}\( q\){:/nomarkdown} והתו {::nomarkdown}\( \sigma\){:/nomarkdown} שהראש כרגע קורא" מתאימה שלשה {::nomarkdown}\( \left(p,\tau,X\right)\){:/nomarkdown} שמשמעותה "עבור למצב {::nomarkdown}\( p\){:/nomarkdown}; כתוב {::nomarkdown}\( \tau\){:/nomarkdown} על הסרט במקום {::nomarkdown}\( \sigma\){:/nomarkdown}; והזז את הראש בהתאם ל-{::nomarkdown}\( X\){:/nomarkdown} (כאשר ימינה זה {::nomarkdown}\( R\){:/nomarkdown}, שמאלה זה {::nomarkdown}\( L\){:/nomarkdown} והישארות במקום זה {::nomarkdown}\( S\){:/nomarkdown})".

מכונה יכולה להיכנס למצב פנימי מיוחד שמסומן ב-{::nomarkdown}\( q_{acc}\){:/nomarkdown} שמשמעותו שהיא עצרה ואמרה "כן"; באופן דומה המצב {::nomarkdown}\( q_{no}\){:/nomarkdown} אומר שהמכונה עצרה ואמרה "לא". קונפיגורציה שבה זה המצב הפנימי של המכונה נקראת <strong>קונפיגורציה סופית</strong>. פרט לכך יש גם <strong>קונפיגורציה התחלתית</strong> מוסכמת - זו שבה כל הסרט ריק פרט לקלט של המכונה (במקרה שלנו, הזוג {::nomarkdown}\( x,y\){:/nomarkdown}), הראש הקורא נמצא בקצה השמאלי של הסרט (הקצה הימני לא קיים; זו המשמעות של האינסופית של הסרט) והמצב הפנימי של המכונה הוא איבר מיוחד של {::nomarkdown}\( Q\){:/nomarkdown} שמסומן לרוב ב-{::nomarkdown}\( q_{0}\){:/nomarkdown}.

אז השאלה שלנו היא זו: האם קיימת למכונה סדרת קונפיגורציות חוקיות כך שהקונפיגורציה ההתחלתית מתאימה לקלט {::nomarkdown}\( x,y\){:/nomarkdown}, והסדרה מסתיימת בקונפיגורציה סופית מקבלת? המשתנים {::nomarkdown}\( z\){:/nomarkdown} שלנו הולכים לקודד את סדרת הקונפיגורציות הזו.

עכשיו, לכאורה יש לנו בעיה כאן - איך נייצג קונפיגורציה, שהרי היא אינסופית? וכמו כן, גם סדרת הקונפיגורציות עשויה להיות באורך לא חסום. כאן נחלצת לעזרתנו העובדה ש-{::nomarkdown}\( M\){:/nomarkdown} היא פולינומית. זה אומר שקיים פולינום {::nomarkdown}\( p\left(n\right)\){:/nomarkdown} כך שמספר הצעדים המקסימלי ש-{::nomarkdown}\( M\){:/nomarkdown} מבצעת על {::nomarkdown}\( x,y\){:/nomarkdown} הוא {::nomarkdown}\( p\left(\left\|x\right\|\right)\){:/nomarkdown}. זה אומר שמספיק לנו להסתכל על {::nomarkdown}\( p\left(\left\|x\right\|\right)+1\){:/nomarkdown} התאים הראשונים של הסרט, כי {::nomarkdown}\( M\){:/nomarkdown} לא תגיע רחוק יותר, ועל סדרת קונפיגורציות מאורך {::nomarkdown}\( p\left(\left\|x\right\|\right)+1\){:/nomarkdown} כי {::nomarkdown}\( M\){:/nomarkdown} לא תבצע חישוב ארוך יותר. בואו נסמן {::nomarkdown}\( m=p\left(\left\|x\right\|\right)+1\){:/nomarkdown} אם כך.

כדי לעשות לעצמי את החיים קלים יותר, אני הולך להניח כמה הנחות מקלות על {::nomarkdown}\( M\){:/nomarkdown}. ראשית, שהיא מבצעת <strong>בדיוק</strong> {::nomarkdown}\( p\left(\left\|x\right\|\right)\){:/nomarkdown} צעדים, בלי תלות בערך של {::nomarkdown}\( y\){:/nomarkdown}, ובצעד האחרון עוברת לקונפיגורציה סופית. זה יחסוך לי את הטורח של לבדוק האם המכונה נעצרה בקונפיגורציה מוקדמת יותר מהאחרונה (זה לא טורח גדול, ועדיין). למה אפשר להניח את זה? כי קל לקחת את {::nomarkdown}\( M\){:/nomarkdown} שנתונה לי ולשנות קצת את הקידוד שלה כך שאם היא התכוונה להיכנס למצב סופי, היא "תתאפק קצת" ותחכה. לשם כך היא צריכה לתחזק מונה שסופר את הצעדים שלה וכדומה, אבל אפשר לעשות דברים כאלו עם מכונות טיורינג. זה מגדיל קצת את זמן הריצה - משנה את הפולינום {::nomarkdown}\( p\){:/nomarkdown} - אבל זמן הריצה עדיין יהיה פולינומי. באופן דומה, אני אניח שה-{::nomarkdown}\( y\){:/nomarkdown}-ים שהמכונה יכולה לקבל יחד עם {::nomarkdown}\( x\){:/nomarkdown} לא ארוכים מדי הם כולם מאותו האורך (אם זה מטריד אתכם תחשבו על כך שהמכונה יכולה לרוץ על כל הרישות של ה-{::nomarkdown}\( y\){:/nomarkdown} שקיבלה) וש-{::nomarkdown}\( p\){:/nomarkdown} גדול דיו כך שיש מקום ל-{::nomarkdown}\( x,y\){:/nomarkdown} על {::nomarkdown}\( m\){:/nomarkdown} התאים הראשונים של הסרט (על פניו הרשיתי ל-{::nomarkdown}\( y\){:/nomarkdown} להיות ארוך יותר, אבל אם המכונה לא תספיק לקרוא את כל התאים של {::nomarkdown}\( y\){:/nomarkdown} אפשר להחליף אותו ברישא של עצמו).

האינטואיציה עכשיו היא שלכל {::nomarkdown}\( 1\le i,j\le m\){:/nomarkdown} יהיה לנו משתנה {::nomarkdown}\( z_{i,j}\){:/nomarkdown} שאומר מה נמצא בתא ה-{::nomarkdown}\( j\){:/nomarkdown} בסרט בקונפיגורציה ה-{::nomarkdown}\( i\){:/nomarkdown}-ית; חשבו על זה בתור טבלה גדולה שבה השורות הן הקונפיגורציות, והעמודות הן התאים האינדיבידואליים בסרט. אני ארצה לכתוב דברים כמו {::nomarkdown}\( z_{i,j}=\sigma\){:/nomarkdown} כדי לומר שיש את האות {::nomarkdown}\( \sigma\){:/nomarkdown} בתא הזה. והנה מגיע טריק נחמד: אני יכול "לדחוף פנימה" גם את שני הפרמטרים הנוספים של הקונפיגורציה - המיקום של הראש והמצב הפנימי של המכונה. אם, למשל, בקונפיגורציה {::nomarkdown}\( i\){:/nomarkdown} הראש מצביע על התא {::nomarkdown}\( j\){:/nomarkdown}, המצב הפנימי הוא {::nomarkdown}\( q\){:/nomarkdown} ותוכן התא הזה הוא {::nomarkdown}\( \sigma\){:/nomarkdown}, אז במקום {::nomarkdown}\( z_{i,j}=\sigma\){:/nomarkdown} המשתנה יגיד {::nomarkdown}\( z_{i,j}=\left(q,\sigma\right)\){:/nomarkdown}. כלומר, הטבלה בגודל {::nomarkdown}\( m\times m\){:/nomarkdown} שלי מקודדת את כל המידע הדרוש על הקונפיגורציות.

אבל הנה בעיה: המשתנים שיש לי בפסוק CNF לא יכולים לקודד סימבולים מסובכים. הם בסך הכל יכולים לקבל ערכים של T ו-F. אלו משתנים בוליאניים. אז מה עושים? הפתרון לא מסובך במיוחד וסטנדרטי עבור מי שרגיל לקודד דברים עם CNF-ים; חלק מהקושי בהוכחה של משפט קוק-לוין ללא ספק נובע מכך שרוב מי שרואים אותו לא רגילים עדיין לשום דבר מסוג זה.

פתרון אחד הוא להתייאש ולתהות למה קוק טרח מלכתחילה להתעסק עם SAT ולא עם שפה גמישה קצת יותר. זו תשובה לגיטימית ויש ספרי לימוד שאכן משתמשים בוריאציה יותר מתוחכמת על השפה לצורך המשפט. אבל אני חושב שכדאי להישאר עם SAT כי זה לא כזה נורא. הרעיון הוא כזה: עבור כל ערך אפשרי {::nomarkdown}\( \gamma\){:/nomarkdown} שעשוי להתקבל על ידי המשתנה {::nomarkdown}\( z_{i,j}\){:/nomarkdown} שלנו (כלומר, תו {::nomarkdown}\( \sigma\){:/nomarkdown} או ביטוי מסובך יותר כמו {::nomarkdown}\( \left(q,\sigma\right)\){:/nomarkdown}) יהיה לנו משתנה בוליאני {::nomarkdown}\( z_{i,j}^{\gamma}\){:/nomarkdown}. הרעיון הוא איכשהו להבטיח שלכל {::nomarkdown}\( i,j\){:/nomarkdown}, <strong>בדיוק אחד</strong> מבין המשתנים {::nomarkdown}\( z_{i,j}^{\gamma}\){:/nomarkdown} יקבל את הערך T, והמשמעות של זה תהיה {::nomarkdown}\( z_{i,j}=\gamma\){:/nomarkdown}.

כדי להבטיח ש<strong>לפחות אחד</strong> מבין המשתנים יקבל T, אנחנו מוסיפים לפסוק שאנו בונים את הפסוקית {::nomarkdown}\( \bigvee_{\gamma}z_{i,j}^{\gamma}\){:/nomarkdown}, כלומר הפסוקית תכיל את כל המשתנים מהצורה {::nomarkdown}\( z_{i,j}^{\gamma}\){:/nomarkdown} עבור {::nomarkdown}\( i,j\){:/nomarkdown} קבוע וכל ה-{::nomarkdown}\( \gamma\){:/nomarkdown} האפשריים.

כדי להבטיח ש<strong>לכל היותר אחד</strong> מבין המשתנים יקבל T, אני מוסיף הרבה פסוקיות מהצורה {::nomarkdown}\( \neg z_{i,j}^{\gamma}\vee\neg z_{i,j}^{\gamma^{\prime}}\){:/nomarkdown}, לכל זוג {::nomarkdown}\( \gamma\ne\gamma^{\prime}\){:/nomarkdown} של ערכים אפשריים. פסוקית כזו אומרת "או ש-{::nomarkdown}\( z_{i,j}\ne\gamma\){:/nomarkdown} או ש-{::nomarkdown}\( z_{i,j}\ne\gamma^{\prime}\){:/nomarkdown}", כלומר, באופן שקול, "לא ייתכן שגם {::nomarkdown}\( z_{i,j}=\gamma\){:/nomarkdown} וגם {::nomarkdown}\( z_{i,j}=\gamma^{\prime}\){:/nomarkdown}".

יפה. אז מעכשיו אני יכול להשתמש בחופשיות בסימון {::nomarkdown}\( z_{i,j}=\gamma\){:/nomarkdown} כשבעצם ברור שהכוונה היא למשתנה {::nomarkdown}\( z_{i,j}^{\gamma}\){:/nomarkdown}. מה שהשגתי עד כה הוא שבניתי פסוק שכל השמה שמספקת אותו מגדירה סדרה של {::nomarkdown}\( m\){:/nomarkdown} קונפיגורציות מאורך {::nomarkdown}\( m\){:/nomarkdown}. מה נשאר לי לעשות? את הדברים הבאים:
<ol>
	<li>להבטיח שהקונפיגורציה הראשונה בסדרה היא הקונפיגורציה ההתחלתית של {::nomarkdown}\( M\){:/nomarkdown} על {::nomarkdown}\( x,y\){:/nomarkdown}.</li>
	<li>להבטיח שהקונפיגורציה האחרונה בסדרה היא מקבלת.</li>
	<li>להבטיח שהמעבר בין כל שתי קונפיגורציות סמוכות הוא חוקי.</li>
</ol>
את {::nomarkdown}\( 1\){:/nomarkdown} קל להבטיח. נסמן {::nomarkdown}\( x=x_{1}\cdots x_{k}\){:/nomarkdown} ו-{::nomarkdown}\( y=y_{1}\cdots y_{n}\){:/nomarkdown}, ונוסיף לפסוק שלנו פסוקיות שאומרות {::nomarkdown}\( z_{1,1}=\left(q_{0},x_{1}\right)\){:/nomarkdown} (כן, יש כאן מקרה קצה אם {::nomarkdown}\( x\){:/nomarkdown} ריק; אני בטוח שתדעו להתמודד איתו בעצמכם) ו-{::nomarkdown}\( z_{1,i}=x_{i}\){:/nomarkdown} עבור {::nomarkdown}\( i&gt;1\){:/nomarkdown} ו-{::nomarkdown}\( z_{1,k+1}=,\){:/nomarkdown} (שווה לסימן פסיק, או מה שזה לא יהיה שנשתמש בו בתור מפריד בין {::nomarkdown}\( x\){:/nomarkdown} ו-{::nomarkdown}\( y\){:/nomarkdown}) ו-{::nomarkdown}\( z_{1,k+1+i}=y_{i}\){:/nomarkdown}. האחרון מעניין, כי ה-{::nomarkdown}\( y_{i}\){:/nomarkdown}-ים הם לא קבועים - הם בעצמם משתנים. איך מקודדים את זה? ובכן, אם תזכרו שניה מה הקיצורים שלי מסמנים, אני בעצם מוסיף את הפסוקיות שמקודדות את הטענות הבאות: {::nomarkdown}\( z_{1,k+1+i}^{1}=y_{i}\){:/nomarkdown} ו-{::nomarkdown}\( z_{1,k+1+i}^{0}=\neg y_{i}\){:/nomarkdown} (שימו לב שמספיק לטפל בערכים 0 ו-1 כי זה כל מה ש-{::nomarkdown}\( y\){:/nomarkdown} יודע לקבל). אז יש לנו כאן שאלה כללית יותר של קידוד CNF-ים - איך מקודדים {::nomarkdown}\( x=y\){:/nomarkdown}? בקלות, הפסוקיות {::nomarkdown}\( \left(x\vee\neg y\right)\wedge\left(\neg x\vee y\right)\){:/nomarkdown}. ואיך מקודדים {::nomarkdown}\( x=\neg y\){:/nomarkdown}? בקלות, וזה נובע ממה שכבר ראינו: {::nomarkdown}\( \left(x\vee y\right)\wedge\left(\neg x\vee\neg y\right)\){:/nomarkdown}.

את 2 גם כן קל להבטיח על ידי פסוקית ענק שבודקת אם במקרה יש לנו מצב מקבל בקונפיגורציה האחרונה: {::nomarkdown}\( \bigvee_{i,\sigma}z_{m,i}=\left(q_{acc},\sigma\right)\){:/nomarkdown} כאשר כאן אנחנו רצים גם על כל {::nomarkdown}\( 1\le i\le m\){:/nomarkdown} וגם על כל {::nomarkdown}\( \sigma\){:/nomarkdown} אפשרי. יכלנו להניח עוד הנחות על המכונה כדי לפשט את החיים (למשל, שהיא חוזרת לתא הראשון בסרט ומרוקנת אותו לפני שהיא עוברת למצב מקבל) אבל הנוסחה פשוטה מספיק גם ככה לטעמי.

נשאר לנו רק 3, שהוא לב העניין. שימו לב שעד עכשיו הפסוק שבנינו היה פולינומי בגודלו - הוספנו רק מספר פולינומי של פסוקיות מגודל פולינומי (פולינומי בגודל של {::nomarkdown}\( x\){:/nomarkdown}). האתגר מגיע כשאנחנו רוצים להבטיח שכל שתי קונפיגורציות סמוכות מייצגות מעבר חוקי. על פניו יש המוני אפשרויות לזוגות כאלו ולכו תבדקו אותם ומהומה והצילו ולא מובטח על פניו שנקבל פסוק פולינומי שמקודד את כל המהומה הזו. לב לבו של העניין ושל כל המשפט נעוץ בכך שמכונת טיורינג היא מודל חישובי שמבצע שינויים <strong>לוקליים</strong> - בכל צעד חישוב, השינוי שעובר על תא אחד בקונפיגורציה לא מושפע מ<strong>כל</strong> הקונפיגורציה הקודמת, אלא רק מכמה תאים בקונפיגורציה הקודמת. זה אומר שאם אני רוצה לכתוב את הערך של {::nomarkdown}\( z_{i+1,t}\){:/nomarkdown}, אני צריך לכתוב פסוקיות שמחשבות כפונקציה של מספר מצומצם של משתנים {::nomarkdown}\( z_{i,r}\){:/nomarkdown}. אם לחדד, כל תא יכול להיות מושפע רק מהתא שבשורה הקודמת ומשני שכניו של התא הזה. הנה דוגמה שתמחיש את זה.

נניח שאני תא מס' 8 בשורה 5 ואני רוצה לדעת מה אמור להיות הערך שלי, על פי מה שקורה בשורה 4. הנה התרחישים שאני צריך להתחשב בהם:
<ol>
	<li>הראש של המכונה היה בתא 8 בשורה 4. במקרה הזה, לא משנה מה הראש מחליט לעשות, תא 8 בשורה 5 יהיה פונקציה בלעדית של תא 8 בשורה 4.</li>
	<li>הראש של המכונה היה בתא 7 בשורה 4. במקרה הזה, ייתכן שהראש יחליט לפנות ימינה (להגדיל את מס' התא שלו ב-1) ואז תא 8 יפסיק להכיל {::nomarkdown}\( \sigma\){:/nomarkdown} ויעבור להכיל {::nomarkdown}\( \left(q,\sigma\right)\){:/nomarkdown} עבור {::nomarkdown}\( q\){:/nomarkdown} כלשהו.</li>
	<li>הראש של המכונה היה בתא 9 בשורה 4. במקרה הזה, ייתכן שהראש יחליט לפנות שמאלה וזה כמו במקרה הקודם.</li>
	<li>כל מיקום אחר של הראש גורר שהוא לא יוכל להשפיע בשום צורה על תא 8.</li>
</ol>
אם כן, לכל {::nomarkdown}\( \gamma\){:/nomarkdown}, הערך של המשתנה {::nomarkdown}\( z_{i,j}^{\gamma}\){:/nomarkdown} נקבע לכל היותר על ידי המשתנים {::nomarkdown}\( z_{i-1,j-1}^{\gamma^{\prime}}\){:/nomarkdown}, {::nomarkdown}\( z_{i-1,j}^{\gamma^{\prime}}\){:/nomarkdown} ו-{::nomarkdown}\( z_{i-1,j+1}^{\gamma^{\prime}}\){:/nomarkdown} עבור כל {::nomarkdown}\( \gamma^{\prime}\){:/nomarkdown} אפשרי. זו קבוצה לא קטנה של משתנים, אבל גם לא גדולה יותר מדי. יש בה שלושה איברים כפול מספר ה-{::nomarkdown}\( \gamma^{\prime}\){:/nomarkdown} האפשריים. כזכור, {::nomarkdown}\( \gamma\){:/nomarkdown} הוא או תו מאלפבית הסרט {::nomarkdown}\( \Gamma\){:/nomarkdown} או שהוא זוג של תו מאלפבית הסרט ומצב פנימי {::nomarkdown}\( Q\){:/nomarkdown} של המכונה. אז יש לנו בסך הכל {::nomarkdown}\( \left\|\Gamma\right\|+\left\|\Gamma\right\|\left\|Q\right\|\){:/nomarkdown} אפשרויות כאלו. לכן כל משתנה תלוי לכל היותר ב-{::nomarkdown}\( 3\left(\left\|\Gamma\right\|+\left\|\Gamma\right\|\left\|Q\right\|\right)\){:/nomarkdown} משתנים אחרים. עכשיו מגיע נפנוף הידיים היחיד שאני מרשה לעצמי בהוכחה, כי הוא ברור לכל מי שמכיר קצת CNF-ים: <strong>כל</strong> קשר מהצורה {::nomarkdown}\( a=f\left(b_{1},b_{2},\dots,b_{n}\right)\){:/nomarkdown} כאשר {::nomarkdown}\( f\){:/nomarkdown} היא פונקציה בולינאנית אפשר לתאר באמצעות CNF, במובן זה שלכל הצבה אפשרית של ערכים ל-{::nomarkdown}\( b_{1},\dots,b_{n}\){:/nomarkdown}, הפסוק מסתפק אם ורק אם מציבים ב-{::nomarkdown}\( a\){:/nomarkdown} את {::nomarkdown}\( f\left(b_{1},\dots,b_{n}\right)\){:/nomarkdown}. מה שעשיתי קודם, עם {::nomarkdown}\( x=y\){:/nomarkdown} היה מקרה פרטי פשוט של זה.

בכל זאת, אם אתם סקרנים, הנה הרעיון הכללי. {::nomarkdown}\( a=f\left(b_{1},b_{2},\dots,b_{n}\right)\){:/nomarkdown} זו פשוט דרך אחרת לכתוב פונקציה כללית יותר, {::nomarkdown}\( g\left(a,b_{1},\dots,b_{n}\right)\){:/nomarkdown}, שמקבלת 1 כאשר {::nomarkdown}\( a=f\left(b_{1},b_{2},\dots,b_{n}\right)\){:/nomarkdown} ו-{::nomarkdown}\( 0\){:/nomarkdown} אחרת. אז האתגר שלנו הוא רק לדעת איך כותבים CNF עבור פונקציה בוליאנית כללית. לצורך כך קל יותר לחשוב על איך כותבים DNF, שהוא המושג הדואלי ל-CNF: זה פסוק מהצורה {::nomarkdown}\( C_{1}\vee\dots\vee C_{n}\){:/nomarkdown} כאשר כל פסוקית היא מהצורה {::nomarkdown}\( \left(l_{1}\wedge\dots\wedge l_{k}\right)\){:/nomarkdown}. פסוק כזה מקבל 1 אם ורק אם לפחות אחת מהפסוקיות מסתפקת; הרעיון הוא שכל פסוקית תתאים לשורה בטבלת האמת של {::nomarkdown}\( g\){:/nomarkdown}. תוכן הפסוקית יתאים לערכים שהמשתנים של {::nomarkdown}\( g\){:/nomarkdown} מקבלים באותה שורה. למשל, אם {::nomarkdown}\( g\left(x,y,z\right)\){:/nomarkdown} היא פונקציה כך ש-{::nomarkdown}\( g\left(1,0,1\right)=1\){:/nomarkdown} אז הפסוקית שתתאים להשמה הזו תהיה {::nomarkdown}\( x\wedge\neg y\wedge z\){:/nomarkdown}.

כעת, קל לראות שאם {::nomarkdown}\( \varphi\){:/nomarkdown} הוא פסוק DNF אז {::nomarkdown}\( \neg\varphi\){:/nomarkdown} הוא בעצם פסוק CNF בתחפושת - רק צריך להשתמש בכללי דה-מורגן כדי לדחוף את ה-{::nomarkdown}\( \neg\){:/nomarkdown} פנימה. למשל, בואו נכתוב DNF עבור {::nomarkdown}\( x=y\){:/nomarkdown}: בבירור זה ה-DNF {::nomarkdown}\( \left(x\wedge y\right)\vee\left(\neg x\wedge\neg y\right)\){:/nomarkdown}. עכשיו נפעיל {::nomarkdown}\( \neg\){:/nomarkdown} על הכל ונקבל:

{::nomarkdown}\( \neg\left[\left(x\wedge y\right)\vee\left(\neg x\wedge\neg y\right)\right]\equiv\neg\left(x\wedge y\right)\wedge\neg\left(\neg x\wedge\neg y\right)\equiv\left(\neg x\vee\neg y\right)\wedge\left(\neg\neg x\vee\neg\neg y\right)\equiv\left(\neg x\vee\neg y\right)\wedge\left(x\vee y\right)\){:/nomarkdown}

וקיבלנו CNF עבור <strong>השלילה</strong> של {::nomarkdown}\( x=y\){:/nomarkdown}, כלומר עבור {::nomarkdown}\( x\ne y\){:/nomarkdown}. המסקנה: אם אני רוצה למצוא CNF עבור {::nomarkdown}\( g\){:/nomarkdown}, בואו נמצא DNF עבור {::nomarkdown}\( \neg g\){:/nomarkdown} ואז נפעיל עליו {::nomarkdown}\( \neg\){:/nomarkdown}.

כמובן, נשאלת השאלה מה <strong>גודל</strong> ה-CNF הזה. התשובה היא שהוא עשוי להיות ענקי. אקספוננציאלי במספר המשתנים של {::nomarkdown}\( g\){:/nomarkdown}. כך גם אצלנו - הגודל של הפסוקיות שאני מוסיף עבור כל תא {::nomarkdown}\( z_{i,j}\){:/nomarkdown} שאני רוצה לתאר את הפונקציה שלו עשוי להיות אקספוננציאלי. אבל <strong>אקספוננציאלי במה</strong>? במספר שחישבתי קודם, {::nomarkdown}\( 3\left(\left\|\Gamma\right\|+\left\|\Gamma\right\|\left\|Q\right\|\right)\){:/nomarkdown}. המספר הזה <strong>אינו תלוי בגודל הקלט</strong> {::nomarkdown}\( x\){:/nomarkdown} שאנחנו עושים עבורו את הרדוקציה; זה קבוע שמתאר את המורכבות של המכונה עבור {::nomarkdown}\( L\){:/nomarkdown} ותו לא.

מכאן אנחנו לומדים שני דברים: ראשית, שהרדוקציה של משפט קוק-לוין היא פולינומית; שנית, שזה לא אומר שיהיה קל לממש אותה בפועל עבור מכונות מסובכות; ה-CNF המתקבל עשוי להיות מפלצתי בגודלו למרות זאת.

האם סיימנו את ההוכחה? באופן מפתיע למדי, כן! קיבלנו פסוק {::nomarkdown}\( \varphi_{x}\left(y,z\right)\){:/nomarkdown} כך שלכל הצבה של ערכים ל-{::nomarkdown}\( y\){:/nomarkdown}, מתקיים אחד משניים: אם {::nomarkdown}\( M\){:/nomarkdown} מקבלת את {::nomarkdown}\( x,y\){:/nomarkdown}, אז קיימת הצבה (יחידה) של ערכים ל-{::nomarkdown}\( z\){:/nomarkdown} שמספקת את {::nomarkdown}\( \varphi_{x}\left(y,z\right)\){:/nomarkdown}; ואם {::nomarkdown}\( M\){:/nomarkdown} דוחה את {::nomarkdown}\( x,y\){:/nomarkdown} אז כל הצבה של ערכים ל-{::nomarkdown}\( z\){:/nomarkdown}-ים לא תספק את {::nomarkdown}\( \varphi_{x}\){:/nomarkdown}. כלומר, {::nomarkdown}\( \varphi_{x}\){:/nomarkdown} הוא ספיק אם ורק אם {::nomarkdown}\( x\in L\){:/nomarkdown}. יותר מכך - יוצא שמספר ההשמות המספקות של {::nomarkdown}\( \varphi_{x}\){:/nomarkdown} שווה למספר ה-{::nomarkdown}\( y\){:/nomarkdown}-ים שעבורם {::nomarkdown}\( M\){:/nomarkdown} מקבלת את {::nomarkdown}\( x,y\){:/nomarkdown} (מספר ה"הוכחות" השונות של {::nomarkdown}\( x\){:/nomarkdown}). השוויון הזה מעניין כי הוא מצביע על השימושיות האפשרית של משפט קוק-לוין גם בטענות מתוחכמות יותר מסתם "SAT היא NP-שלמה", ואכן בנושאים מתקדמים יותר בסיבוכיות עושים וריאציות שכאלו על קוק-לוין כל הזמן; אבל אני אסתפק במה שהראיתי ואעצור כאן.
