---
id: 1329
title: "משפט המטריצה-עץ של קירכהוף"
date: 2011-09-13 20:35:51
layout: post
categories: 
  - אלגברה לינארית
  - תורת הגרפים
tags: 
  - אלגברה לינארית
  - גם טכני זה כיף!
  - הוכחות יפות
  - משפט קירכהוף
  - תורת הגרפים האלגברית
---
אני רוצה לדבר הפעם על מה שלטעמי הוא משפט יפהפה ביותר, גם בשל מה שהוא אומר וגם בשל ההוכחה שלו, שלטעמי מייצגת את כל מה שטוב במתמטיקה - גם דורשת הבנה טכנית לא טריוויאלית, וגם מכילה תובנה עמוקה שמאפשרת לראות מדוע המשפט נכון. העולם מסכים איתי, וההוכחה הזו מככבת בספר "Proofs from THE BOOK"; אני מקווה שכל מי שיתאמץ יצליח להבין אותה וליהנות כמוני ממנה.

המשפט מכונה בשם Matrix-tree theorem, או משפט קירכהוף (קירכהוף לא בדיוק הוכיח אותו אבל במאמר שלו המשפט מופיע באופן מובלע). כדי להגיע ישר לעניין ללא הקדמה ארוכה לא אציג מחדש את מושגי הבסיס שבהם עוסק המשפט; כדי להבין את הניסוח (וההוכחה) של המשפט יהיה צורך להכיר את מושגי הבסיס של גרף, עץ, מטריצה ודטרמיננטה. כולם מושגים פשוטים ומרכזיים במתמטיקה ואני ממליץ לקוראים שטרם שמעו עליהם ללכת ולקרוא ספרים בסיסיים בקומבינטוריקה ובאלגברה לינארית כי הם מפספסים עולמות נפלאים שלמים.

ראשית אציג גרסה של המשפט שעוסקת בגרפים לא מכוונים כי ההוכחה שלו פשוטה מעט יותר; לאחר מכן אסביר כיצד ניתן להוכיח את המשפט גם לגרפים מכוונים (באותה הצורה אבל עם תיקונים קלים). המשפט בא לענות על השאלה הקומבינטורית הבאה: בהינתן גרף סופי {::nomarkdown}\( G=\left(V,E\right)\){:/nomarkdown}, כמה עצים פורשים יש לו? כזכור, עץ פורש של {::nomarkdown}\( G\){:/nomarkdown} הוא תת-קבוצה של הקשתות שמהווה עץ (כלומר, כשמורידים מ-{::nomarkdown}\( G\){:/nomarkdown} את כל הקשתות שאינן בתת-הקבוצה נשארים עם גרף קשיר וחסר מעגלים). עובדה אחת שאתם אולי לא זוכרים והיא רלוונטית כאן היא שבגרף עם {::nomarkdown}\( n=\left\|V\right\|\){:/nomarkdown} צמתים, כל עץ הוא בעל בדיוק {::nomarkdown}\( n-1\){:/nomarkdown} קשתות (נסו להוכיח זאת לעצמכם!)

משפט קירכהוף אומר שבהינתן {::nomarkdown}\( G\){:/nomarkdown} כזה, מספר העצים הפורשים שלו הוא בדיוק הדטרמיננטה של מטריצה פשוטה מסויימת שמוגדרת באמצעות {::nomarkdown}\( G\){:/nomarkdown}. זה נשמע מאוד מאוד מפתיע ממבט ראשון - מה לדטרמיננטים ולספירת עצים פורשים? ובכן, אני מודה שגם אחרי שאני מכיר את הוכחת המשפט ומבין בדיוק למה הוא עובד, זה עדיין מפתיע אותי.

בואו נכניס מטריצות לתמונה. יש כמה וכמה מטריצות שאפשר להתאים לכל גרף {::nomarkdown}\( G\){:/nomarkdown}, ואחת מהן היא <strong>מטריצת הלפלסיאן</strong> {::nomarkdown}\( L_{G}\){:/nomarkdown} (ובקיצור אכתוב סתם {::nomarkdown}\( L\){:/nomarkdown}). ההגדרה של {::nomarkdown}\( L\){:/nomarkdown} אולי תיראה קצת מוזרה במבט ראשון אבל היא שימושית; למשל, עבור משפט קירכהוף.

ראשית, מכיוון שמטריצות מאונדקסות בדרך כלל עם מספרים טבעיים, הבה ונאנדקס גם את הגרף עם מספרים כאלו: {::nomarkdown}\( V=\left\{ v_{1},\dots,v_{n}\right\} \){:/nomarkdown} ו-{::nomarkdown}\( E=\left\{ e_{1},\dots,e_{m}\right\} \){:/nomarkdown}. בדרך כלל כשאתייחס לצומת זה יהיה עם אינדקס {::nomarkdown}\( i\){:/nomarkdown} או {::nomarkdown}\( j\){:/nomarkdown}, ולקשת עם אינדקס {::nomarkdown}\( k\){:/nomarkdown}.

כעת אנו מוכנים להגדיר את {::nomarkdown}\( L\){:/nomarkdown}: ראשית, {::nomarkdown}\( L_{ii}=d\left(v_{i}\right)\){:/nomarkdown}, כלומר הכניסה ה-{::nomarkdown}\( i\){:/nomarkdown} על האלכסון של {::nomarkdown}\( L\){:/nomarkdown} היא פשוט הדרגה של {::nomarkdown}\( v_{i}\){:/nomarkdown} - מספר הקשתות שמחוברות ל-{::nomarkdown}\( v_{i}\){:/nomarkdown}. כעת, לכל {::nomarkdown}\( i\ne j\){:/nomarkdown} נגדיר את {::nomarkdown}\( L_{ij}\){:/nomarkdown} להיות מינוס מספר הקשתות בין {::nomarkdown}\( v_{i}\){:/nomarkdown}ל-{::nomarkdown}\( v_{j}\){:/nomarkdown} (בדרך כלל יש רק קשת אחת בין כל שני צמתים בגרף, אבל כאן אנחנו מרשים יותר; כמובן שככל שיש יותר קשתות יהיו יותר עצים פורשים). אם נסמן את המספר הזה בסימון שהמצאתי כרגע, {::nomarkdown}\( d\left(v_{i},v_{j}\right)\){:/nomarkdown} ונסכים ש-{::nomarkdown}\( d\left(v_{i},v_{i}\right)\){:/nomarkdown} הוא פשוט דרגת {::nomarkdown}\( v_{i}\){:/nomarkdown} (במקום מספר הקשתות מ-{::nomarkdown}\( v_{i}\){:/nomarkdown} לעצמו), הרי שאפשר לכתוב את הלפלסיאן כך: {::nomarkdown}\( L_{ij}=d\left(v_{i},v_{j}\right)\){:/nomarkdown}.

בשלב הזה צריך להראות דוגמה כדי להבין מה קורה פה. אני אנקוט בגישה שונה - <strong>אתם</strong> תציירו לעצמכם דוגמה, כי זה הרבה יותר אפקטיבי מלקרוא דוגמה שמישהו אחר כתב (וכי אני עצלן), ואני אשב בצד ואחכה שתסיימו.

הגדרת הלפלסיאן עבור גרפים מכוונים כמעט זהה, בשני שינויים קלים: ראשית, {::nomarkdown}\( L_{ii}\){:/nomarkdown} הוא <strong>דרגת הכניסה</strong> של {::nomarkdown}\( v_{i}\){:/nomarkdown} - מספר הקשתות שנכנסות אליו - ולא הדרגה הכוללת; שנית, {::nomarkdown}\( L_{ij}\){:/nomarkdown} הוא מינוס מספר הקשתות מ-{::nomarkdown}\( v_{i}\){:/nomarkdown} <strong>אל</strong> {::nomarkdown}\( v_{j}\){:/nomarkdown} (כלומר, קשתות מ-{::nomarkdown}\( v_{j}\){:/nomarkdown} אל {::nomarkdown}\( v_{i}\){:/nomarkdown} לא נספרות ב-{::nomarkdown}\( L_{ij}\){:/nomarkdown}, אם כי הן כן ייספרו ב-{::nomarkdown}\( L_{ji}\){:/nomarkdown}). לא קשה לראות שההגדרה הזו מכלילה את ההגדרה לגרפים לא מכוונים אם נוקטים בתעלול הרגיל של לייצג גרף לא מכוון על ידי גרף מכוון שבו לכל זוג צמתים שיש ביניהם קשת בגרף הלא מכוון, היא מוחלפת בקשת לכל אחד משני הכיוונים בגרף המכוון.

כעת, יהא {::nomarkdown}\( r\){:/nomarkdown} אינדקס של צומת כלשהו בגרף, ונסמן ב-{::nomarkdown}\( L^{\left(r\right)}\){:/nomarkdown} את <strong>מטריצת המינור</strong> ה-{::nomarkdown}\( r\){:/nomarkdown}-ית של {::nomarkdown}\( L\){:/nomarkdown} - המטריצה שמתקבלת מ-{::nomarkdown}\( L\){:/nomarkdown} על ידי מחיקת השורה והעמודה ה-{::nomarkdown}\( r\){:/nomarkdown}-יות. אז הנה משפט קירכהוף, בגרסה שנכונה הן לגרפים מכוונים והן לגרפים לא מכוונים:

מספר העצים הפורשים של הגרף {::nomarkdown}\( G\){:/nomarkdown} שהשורש שלהם הוא {::nomarkdown}\( v_{r}\){:/nomarkdown} הוא {::nomarkdown}\( \det L^{\left(r\right)}\){:/nomarkdown}.

(בגרף לא מכוון אין ממש משמעות ל"שורש" ולכן כדי למצוא את מספר העצים הפורשים אפשר לבחור {::nomarkdown}\( r\){:/nomarkdown} שרירותי; בגרף מכוון שורש הוא הצומת היחיד בעץ שקיים מסלול ממנו אל שאר הצמתים בגרף).

שימו לב שעניין המינור הכרחי: לא קשה לראות ש-{::nomarkdown}\( \det L=0\){:/nomarkdown} תמיד כי סכום כל עמודה במטריצה הוא 0 ולכן שורות המטריצה תלויות לינארית. כמובן ש-{::nomarkdown}\( L\){:/nomarkdown} מעניינת גם לכשעצמה - למשל, יש חשיבות גדולה לערך העצמי הבא החיובי הקטן ביותר שלה; אבל לא אכנס לכל זה כרגע.

איך מוכיחים את המשפט? אפשר לנסות לחשב ישירות את הדטרמיננטה על פי ההגדרה ולהבין מה הולך שם. זו הוכחה לגיטימית ולא מעט ספרים נוקטים בה. אני מעדיף להשתמש בגישה אחרת ששולפת עוד כמה שפנים מהכובע ובסוף מאפשרת להבין בדיוק מה קורה פה - גישה שמשתמשת בנוסחת קושי-בינה.

את קושי-בינה לא רואים בדרך כלל בקורס בסיסי באלגברה לינארית וקצת חבל. יש לה גם הוכחה קומבינטורית יפהפיה משל עצמה (גם היא ב-Proofs from THE BOOK) שלא אציג כרגע. בבסיסה, הנוסחה היא הכללה של נוסחה בסיסית שכן רואים באלגברה לינארית: אם {::nomarkdown}\( A,B\){:/nomarkdown} הן מטריצות ריבועיות, אז {::nomarkdown}\( \det\left(A\cdot B\right)=\det A\cdot\det B\){:/nomarkdown}.

העניין הוא בכך שמטריצות ריבועיות עשויות להתקבל גם כמכפלה של מטריצות לא ריבועיות: אם {::nomarkdown}\( A\){:/nomarkdown} היא מטריצה {::nomarkdown}\( n\times m\){:/nomarkdown} ו-{::nomarkdown}\( B\){:/nomarkdown} היא מטריצה {::nomarkdown}\( m\times n\){:/nomarkdown} אז מכפלתם {::nomarkdown}\( AB\){:/nomarkdown} היא מטריצה {::nomarkdown}\( n\times n\){:/nomarkdown}, ולכן אפשר לדבר על הדטרמיננטה שלה. מצד שני, {::nomarkdown}\( A,B\){:/nomarkdown} אינן ריבועיות ולכן אין משמעות לדטרמינטטה שלהן. האם בכל זאת אפשר לעשות משהו?

אם {::nomarkdown}\( m&lt;n\){:/nomarkdown} אין על מה לדבר, אבל רק כי אז מובן מאליו ש-{::nomarkdown}\( \det AB=0\){:/nomarkdown}. למה מובן מאליו? ובכן, זה תרגיל טוב באלגברה לינארית: אם {::nomarkdown}\( m&lt;n\){:/nomarkdown} אז דרגת {::nomarkdown}\( A,B\){:/nomarkdown} היא לכל היותר {::nomarkdown}\( m\){:/nomarkdown} כל אחד; ולכן דרגת המכפלה {::nomarkdown}\( AB\){:/nomarkdown} גם היא לכל היותר {::nomarkdown}\( m\){:/nomarkdown}, ולכן {::nomarkdown}\( AB\){:/nomarkdown} היא מטריצה מדרגה לא מלאה ובהכרח הדטרמיננטה שלה היא 0.

מצד שני, אם {::nomarkdown}\( m&gt;n\){:/nomarkdown}, נוסחת קושי בינה נכנסת לפעולה. במילים מה שהולך כאן הוא הדבר הבא: {::nomarkdown}\( A\){:/nomarkdown} היא מטריצה מלבנית, אבל היא מכילה הרבה תת-מטריצות ריבועיות {::nomarkdown}\( n\times n\){:/nomarkdown}, שמתקבלות מבחירת תת-קבוצה של {::nomarkdown}\( n\){:/nomarkdown} מתוך {::nomarkdown}\( m\){:/nomarkdown} העמודות שלה. באותו האופן גם {::nomarkdown}\( B\){:/nomarkdown} מכילה הרבה תת-מטריצות ריבועיות {::nomarkdown}\( n\times n\){:/nomarkdown} שמתקבלות מבחירת תת-קבוצה של {::nomarkdown}\( n\){:/nomarkdown} מתוך {::nomarkdown}\( m\){:/nomarkdown} השורות שלה. אם נסמן ב-{::nomarkdown}\( \sigma\){:/nomarkdown} בחירה מסויימת של {::nomarkdown}\( n\){:/nomarkdown} מתוך {::nomarkdown}\( m\){:/nomarkdown} אינדקסים, אז נוסחת קושי-בינה היא פשוט {::nomarkdown}\( \det\left(AB\right)=\sum_{\sigma}\left(\det A_{\sigma}\cdot\det B_{\sigma}\right)\){:/nomarkdown}. כלומר: לכל בחירה אפשרית של {::nomarkdown}\( n\){:/nomarkdown} מתוך {::nomarkdown}\( m\){:/nomarkdown} אינדקסים {::nomarkdown}\( \sigma\){:/nomarkdown} ניקח מתוך {::nomarkdown}\( A\){:/nomarkdown} ו-{::nomarkdown}\( B\){:/nomarkdown} את תת המטריצות המתאימות (שימו לב שזו <strong>אותה בחירת אינדקסים</strong> לשתי המטריצות! זה מה שחשוב פה), נחשב את מכפלת הדטרמיננטות שלהן, ונסכום את הכל (אם {::nomarkdown}\( m&lt;n\){:/nomarkdown} אז אפשר להסכים על כך שהסכום ריק ולכן שווה 0, ובכך לקבל נוסחה שתקפה לכל מקרה אפשרי).

איך נוסחת קושי-בינה מסייעת לנו כאן? ובכן, את הלפלסיאן קל למדי לכתוב כמכפלה של מטריצות. בואו נדבר לבינתיים על המקרה של גרף לא מכוון שהוא פשוט קצת יותר, ונגדיר מטריצה {::nomarkdown}\( A\){:/nomarkdown} - "מטריצת החילה" (Incidence matrix) של הגרף. זו תהיה מטריצה {::nomarkdown}\( n\times m\){:/nomarkdown} שבה כל שורה מייצגת צומת בגרף וכל עמודה מייצגת קשת בגרף, כך שלכל קשת {::nomarkdown}\( e_{k}=\left(v_{i},v_{j}\right)\){:/nomarkdown} עם {::nomarkdown}\( i&lt;j\){:/nomarkdown} נקבע ש-{::nomarkdown}\( A_{ik}=1,A_{jk}=-1\){:/nomarkdown} וכל כניסה אחרת במטריצה היא 0. במילים אחרות, כל עמודה במטריצה הזו מכילה בדיוק 1 בודד ו-{::nomarkdown}\( -1\){:/nomarkdown} בודד, בשני הצמתים שמתאימים לקשת של אותה עמודה.

כעת זה תרגיל נחמד לבדוק שאכן {::nomarkdown}\( L=A\cdot A^{T}\){:/nomarkdown} (כאן {::nomarkdown}\( A^{T}\){:/nomarkdown} מייצג את השחלוף של {::nomarkdown}\( A\){:/nomarkdown}: {::nomarkdown}\( A_{ij}^{T}=A_{ji}\){:/nomarkdown}). ומהו {::nomarkdown}\( L^{\left(r\right)}\){:/nomarkdown}? לא קשה לראות שהוא {::nomarkdown}\( NN^{T}\){:/nomarkdown} כאשר {::nomarkdown}\( N\){:/nomarkdown} מתקבלת מ-{::nomarkdown}\( A\){:/nomarkdown} על ידי מחיקת השורה ה-{::nomarkdown}\( r\){:/nomarkdown}. שימו לב שאנחנו לא מוחקים מ-{::nomarkdown}\( A\){:/nomarkdown} עמודות; הקשתות שהיו מחוברות ל-{::nomarkdown}\( v_{r}\){:/nomarkdown} עדיין מיוצגות ב-{::nomarkdown}\( N\){:/nomarkdown}, אבל באופן "חלקי" - העמודה שלהן מכילה רק 1 או רק {::nomarkdown}\( -1\){:/nomarkdown}. זו אולי הנקודה הקריטית ביותר בהמשך ההוכחה.

עכשיו, על פי קושי-בינה, {::nomarkdown}\( \det\left(L^{\left(r\right)}\right)=\sum_{\sigma}\det N_{\sigma}\det N_{\sigma}^{T}=\sum_{\sigma}\det\left(N_{\sigma}\right)^{2}\){:/nomarkdown}. הצטמצמנו להבנה של מהו {::nomarkdown}\( \det\left(N_{\sigma}\right)\){:/nomarkdown} לכל בחירה מתאימה של עמודות. שימו לב של-{::nomarkdown}\( N\){:/nomarkdown} יש {::nomarkdown}\( n-1\){:/nomarkdown} שורות (כי בגרף המקורי היו {::nomarkdown}\( n\){:/nomarkdown} צמתים והסרנו את השורה של הצומת {::nomarkdown}\( v_{r}\){:/nomarkdown} מהמטריצה {::nomarkdown}\( A\){:/nomarkdown} כדי לקבל את {::nomarkdown}\( N\){:/nomarkdown}), ולכן כל {::nomarkdown}\( \sigma\){:/nomarkdown} היא בחירה של {::nomarkdown}\( n-1\){:/nomarkdown} עמודות, כלומר של {::nomarkdown}\( n-1\){:/nomarkdown} קשתות מהגרף המקורי. והנה לב ההוכחה, התובנה המרכזית בה, מה שהופך את הכל לברור לדעתי: אותה בחירה {::nomarkdown}\( \sigma\){:/nomarkdown} של {::nomarkdown}\( n-1\){:/nomarkdown} עמודות היא <strong>בדיקה שלנו האם מועמד כלשהו לתפקיד עץ פורש הוא אכן עץ פורש</strong>. הדטרמיננטה {::nomarkdown}\( \det N_{\sigma}\){:/nomarkdown} תהיה בדיוק אבן הבוחן: אם {::nomarkdown}\( \sigma\){:/nomarkdown} אכן מהווה בחירה של {::nomarkdown}\( n-1\){:/nomarkdown} קשתות שיוצרות עץ פורש, נקבל ש-{::nomarkdown}\( \det N_{\sigma}=\pm1\){:/nomarkdown}; ואחרת נקבל {::nomarkdown}\( \det N_{\sigma}=0\){:/nomarkdown}. זה בבירור מסיים את ההוכחה שכן אז נקבל ש-{::nomarkdown}\( \sum_{\sigma}\det\left(N_{\sigma}\right)^{2}\){:/nomarkdown} הוא בדיוק מספר ה-{::nomarkdown}\( \sigma\){:/nomarkdown}-ות שעבורן קיבלנו עץ פורש, כלומר מספר העצים הפורשים של הגרף.

אתם עוד איתי? אם כן, הבנתם את ההוכחה; נותר לגהץ את הפרטים.

נתחיל במקרה שבו {::nomarkdown}\( \sigma\){:/nomarkdown} לא מגדירה עץ פורש בגרף {::nomarkdown}\( G\){:/nomarkdown}. אנחנו רוצים להראות ש-{::nomarkdown}\( \det N_{\sigma}=0\){:/nomarkdown} במקרה הזה, ונעשה זאת על ידי כך שנוכיח שבמטריצה {::nomarkdown}\( N_{\sigma}\){:/nomarkdown} יש קבוצה של שורות שסכומן אפס. תוצאה בסיסית על עצים היא שאם גרף לא מכוון עם {::nomarkdown}\( n\){:/nomarkdown} צמתים ו-{::nomarkdown}\( n-1\){:/nomarkdown} קשתות הוא גם קשיר, אז הוא עץ; לכן אם {::nomarkdown}\( \sigma\){:/nomarkdown} אינה משרה עץ בהכרח יש שני רכיבי קשירות. {::nomarkdown}\( v_{r}\){:/nomarkdown} נמצא באחד מהם; בואו נסתכל דווקא על השני - וליתר דיוק, על השורות במטריצה {::nomarkdown}\( N_{\sigma}\){:/nomarkdown} שמתאימות לצמתים של אותו רכיב קשירות שני. אני טוען שסכום כל השורות הללו הוא 0. מדוע? ובכן, נעבור עמודה עמודה: כל עמודה מתאימה לקשת שמחברת שני צמתים. אם שניהם אינם ברכיב הקשירות ממילא, אז בשורות שמתאימות לרכיב הקשירות כל הכניסות בעמודה הזו יהיו 0. אם שניהם ברכיב הקשירות, אז תהיה שורה שבה יופיע 1, ושורה שבה יופיע {::nomarkdown}\( -1\){:/nomarkdown}, ובשאר השורות 0 - ושוב, הסכום הוא 0. ואם אחד מהצמתים ברכיב הקשירות והשני לא? ובכן, זה בלתי אפשרי כי זה נוגד את ההגדרה של רכיב קשירות: אם צומת נמצא ברכיב קשירות מסויים, כך גם כל שכניו.

הטיעון הטכני ביותר יהיה ההוכחה ש-{::nomarkdown}\( \det N_{\sigma}=\pm1\){:/nomarkdown} כאשר {::nomarkdown}\( \sigma\){:/nomarkdown} כן מתאימה לעץ פורש, אבל אחר כך סיימנו את ההוכחה כולה. הרעיון הוא שבמקרה הזה, אפשר לסדר מחדש את שורות ועמודות {::nomarkdown}\( N_{\sigma}\){:/nomarkdown} כך שתתקבל מטריצה משולשית תחתונה (מטריצה שבה כל הכניסות מעל לאלכסון הראשי הן 0), ואת הדטרמיננטה של מטריצה משולשית קל לחשב - זו בסך הכל מכפלת האיברים שעל האלכסון. מכיוון שסידור מחדש של שורות או עמודות משנה רק את הסימן של הדטרמיננטה, זה יסיים את ההוכחה. את המטריצה המסודרת-מחדש אסמן ב-{::nomarkdown}\( M\){:/nomarkdown}.

אמרנו ש-{::nomarkdown}\( \sigma\){:/nomarkdown} מהווה עץ. מה שנעשה הוא להתחיל לפרק את העץ לגורמים. ראשית, בואו נזכור ש<strong>עלה</strong> בעץ הוא צומת מדרגה 1, כלומר שמחובר בדיוק לצומת אחר אחד. עוד משפט חשוב על עצים הוא שבעץ יש לפחות שני עלים; לא אוכיח אותו כרגע.

הבה ונסמן ב-{::nomarkdown}\( u_{1}\){:/nomarkdown} עלה שכזה<strong> </strong>שהוא <strong>שונה </strong>מ-<strong>{::nomarkdown}\( v_{r}\){:/nomarkdown} </strong>(תמיד יש כזה; אפילו אם {::nomarkdown}\( v_{r}\){:/nomarkdown} הוא עלה, יש עוד עלה שאפשר לבחור) וב-{::nomarkdown}\( e_{1}\){:/nomarkdown} את הקשת בעץ שמחוברת אליו. השורה הראשונה במטריצה-המסודרת-מחדש שלנו תהיה זו של {::nomarkdown}\( u_{1}\){:/nomarkdown}, והעמודה הראשונה תהיה זו של {::nomarkdown}\( e_{1}\){:/nomarkdown}. מכיוון ש-{::nomarkdown}\( u_{1}\){:/nomarkdown} מחובר <strong>רק</strong> ל-{::nomarkdown}\( e_{1}\){:/nomarkdown} בעץ, הכניסה {::nomarkdown}\( M_{11}\){:/nomarkdown} תהיה שווה ל-1 או ל-{::nomarkdown}\( -1\){:/nomarkdown}(לא משנה לנו איזה מהם), וכמו כן {::nomarkdown}\( M_{1j}=0\){:/nomarkdown} לכל {::nomarkdown}\( j&gt;1\){:/nomarkdown} (ובכלל לא משנה איך אני הולך לסדר את יתר העמודות), שכן כל העמודות הללו מתאימות לקשתות ש-{::nomarkdown}\( u_{1}\){:/nomarkdown} לא מחובר אליהן.

כעת נסיר את {::nomarkdown}\( u_{1}\){:/nomarkdown} מהעץ שלנו (ויחד איתו את {::nomarkdown}\( e_{1}\){:/nomarkdown}), ושוב נקבל עץ, ולכן שוב יש בו צומת מדרגה 1 שאינו {::nomarkdown}\( v_{r}\){:/nomarkdown}. זה יהיה {::nomarkdown}\( u_{2}\){:/nomarkdown} והקשת שמתאימה לו תהיה {::nomarkdown}\( e_{2}\){:/nomarkdown}. זה אומר ש-{::nomarkdown}\( M_{22}\){:/nomarkdown} הוא שוה {::nomarkdown}\( \pm1\){:/nomarkdown}; ואנו יודעים בודאות שעבור הקשתות שטרם טיפלנו בהן, {::nomarkdown}\( u_{2}\){:/nomarkdown} אינו מחובר לאף אחת מהן ולכן {::nomarkdown}\( M_{2j}=0\){:/nomarkdown} לכל {::nomarkdown}\( j&gt;2\){:/nomarkdown} (אולי הוא היה מחובר ל-{::nomarkdown}\( e_{1}\){:/nomarkdown}, אבל זה אומר רק שאולי {::nomarkdown}\( M_{12}\ne0\){:/nomarkdown} וזה לא מפריע לנו כי כניסה זו היא <strong>מתחת</strong> לאלכסון הראשי). העיקרון ברור - נמשיך לבנות כך סדרה {::nomarkdown}\( u_{1},u_{2},\dots,u_{n-1}\){:/nomarkdown} של צמתים ו-{::nomarkdown}\( e_{1},e_{2},\dots,e_{n-1}\){:/nomarkdown} של קשתות. הצומת היחיד שלא נגענו בו הוא {::nomarkdown}\( v_{r}\){:/nomarkdown} עצמו, שהשורה שמתאימה לו בכלל לא מופיעה ב-{::nomarkdown}\( N\){:/nomarkdown} כך שהוא לא רלוונטי לבניה שעשינו. קיבלנו מטריצה משולשת תחתונה שעל האלכסון יש לה רק {::nomarkdown}\( \pm1\){:/nomarkdown} וזה מסיים את ההוכחה.

אני מאוד מקווה שנהניתם מההוכחה הזו כפי שאני נהניתי ממנה.

בואו נעבור עכשיו לדבר על מה צריך להשתנות בהוכחה אם נרצה להוכיח את המשפט לגרפים מכוונים. כבר אמרתי שצריך לשנות את הגדרת מטריצת הלפלסיאן עצמה קצת: {::nomarkdown}\( L_{ii}\){:/nomarkdown} הוא דרגת הכניסה של כל צומת ו-{::nomarkdown}\( L_{ij}\){:/nomarkdown} הוא מינוס מספר הקשתות מ-{::nomarkdown}\( v_{i}\){:/nomarkdown} <strong>אל</strong> {::nomarkdown}\( v_{j}\){:/nomarkdown}. זו לא מטריצה סימטרית ולכן גם לא בהכרח ניתן לכתוב אותה בתור {::nomarkdown}\( A\cdot A^{T}\){:/nomarkdown}; אבל אפשר לעשות משהו טוב כמעט באותה מידה.

הבה ונגדיר שוב מטריצה {::nomarkdown}\( A\){:/nomarkdown} מסדר {::nomarkdown}\( n\times m\){:/nomarkdown} (כלומר - שורה לכל צומת ועמודה לכל קשת, כמקודם) באופן הבא: לכל קשת {::nomarkdown}\( e_{k}=v_{i}\to v_{j}\){:/nomarkdown} (כלומר, מהצומת {::nomarkdown}\( v_{i}\){:/nomarkdown} אל הצומת {::nomarkdown}\( v_{j}\){:/nomarkdown}) יתקיים {::nomarkdown}\( A_{ik}=1,A_{jk}=-1\){:/nomarkdown} ושאר הכניסות יהיו אפס; במילים אחרות, זו בדיוק אותה מטריצה {::nomarkdown}\( A\){:/nomarkdown} כמו קודם רק שעכשיו אנחנו קובעים איזו כניסה תהיה חיובית ואיזו כניסה תהיה שלילית על פי כיוון הקשת {::nomarkdown}\( e_{k}\){:/nomarkdown}.

בנוסף, נגדיר מטריצה {::nomarkdown}\( B\){:/nomarkdown} מסדר {::nomarkdown}\( n\times m\){:/nomarkdown} באופן הבא: לכל קשת {::nomarkdown}\( e_{k}=v_{i}\to v_{j}\){:/nomarkdown} יתקיים {::nomarkdown}\( B_{ik}=0,B_{jk}=-1\){:/nomarkdown} ושאר הכניסות יהיו אפס. כלומר, {::nomarkdown}\( B\){:/nomarkdown} זהה ל-{::nomarkdown}\( A\){:/nomarkdown} פרט לכך שבכל עמודה יש רק {::nomarkdown}\( -1\){:/nomarkdown} עבור הצומת שאליו הקשת נכנסת; לא מופיע 1 עבור הצומת שממנו הקשת יוצאת.

עכשיו לא קשה לראות ש-{::nomarkdown}\( L=A\cdot B^{T}\){:/nomarkdown} וש-{::nomarkdown}\( L^{\left(r\right)}\){:/nomarkdown} הוא {::nomarkdown}\( N_{A}N_{B}^{T}\){:/nomarkdown} כאשר {::nomarkdown}\( N_{A},N_{B}\){:/nomarkdown} מתקבלים מ-{::nomarkdown}\( A,B\){:/nomarkdown} בהתאמה על ידי מחיקת השורה ה-{::nomarkdown}\( r\){:/nomarkdown}. אז קושי-בינה מניבה פה {::nomarkdown}\( \det\left(L^{\left(r\right)}\right)=\sum_{\sigma}\det\left(N_{A\sigma}\right)\det\left(N_{B\sigma}\right)\){:/nomarkdown}. עכשיו צריך להבין מה קורה פה.

היינו רוצים לומר שאם {::nomarkdown}\( \sigma\){:/nomarkdown} לא מגדיר עץ, אז נקבל ש-{::nomarkdown}\( \det\left(N_{A\sigma}\right)=0\){:/nomarkdown} בדיוק כמו קודם ואז גם המכפלה תתאפס. לרוע המזל, "{::nomarkdown}\( \sigma\){:/nomarkdown} לא מגדיר עץ" הוא מקרה הרבה יותר מסובך כאשר הגרף שלנו מכוון, כי הקריטריון של "גרף עם {::nomarkdown}\( n-1\){:/nomarkdown} קשתות שהוא קשיר הוא עץ" פשוט לא נכון. בעץ מכוון, צריך שיהיה צומת (השורש) שקיים מסלול ממנו לכל הצמתים האחרים, ומספיקה קשת אחת בכיוון הלא נכון כדי לקלקל את זה. לכן בואו נתחיל קודם כל דווקא מדיבור על המקרה שבו {::nomarkdown}\( \sigma\){:/nomarkdown} כן מגדיר עץ. מה נשתנה הפעם?

ובכן, הפעם צריכים להיות קצת יותר זהירים בגלל ש-{::nomarkdown}\( \det\left(N_{A\sigma}\right)\det\left(N_{B\sigma}\right)\){:/nomarkdown} הוא לא ריבוע. מה שאנחנו רוצים לטעון הוא שמתקיים {::nomarkdown}\( \det\left(N_{A\sigma}\right)=\det\left(N_{B\sigma}\right)\){:/nomarkdown} וששניהם שווים או 1 או {::nomarkdown}\( -1\){:/nomarkdown}. אפשר להשתמש בשיטת הסידור-מחדש של מטריצה כמו קודם; רק צריך להיות זהירים ולסדר את {::nomarkdown}\( N_{A\sigma}\){:/nomarkdown} ואת {::nomarkdown}\( N_{B\sigma}\){:/nomarkdown} באותו האופן בדיוק כדי שהשינוי בסימן, אם היה כזה, יהיה זהה אצל שניהם.

אחרי הסידור מחדש של המטריצה, מה שמתקבל מ-{::nomarkdown}\( N_{A\sigma}\){:/nomarkdown} ומ-{::nomarkdown}\( N_{B\sigma}\){:/nomarkdown} היא כמקודם מטריצה משולשית תחתונה, אבל מה נמצא על האלכסון? כאן האופן שבו ביצענו את הסדר הופך להיות קריטי: להזכירכם, בשיטה שלנו בשלב ה-{::nomarkdown}\( i\){:/nomarkdown} קבענו את השורה ה-{::nomarkdown}\( i\){:/nomarkdown} להיות צומת {::nomarkdown}\( u_{i}\){:/nomarkdown} שבשלב הזה היה עלה, ואת העמודה להיות קשת {::nomarkdown}\( e_{i}\){:/nomarkdown} שהיא הקשת ש<strong>נכנסת</strong> אל {::nomarkdown}\( u_{i}\){:/nomarkdown}. כלומר, הן על פי ההגדרה של {::nomarkdown}\( A\){:/nomarkdown} והן על פי ההגדרה של {::nomarkdown}\( B\){:/nomarkdown}, הכניסה המתאימה תהיה {::nomarkdown}\( -1\){:/nomarkdown}. זה מבטיח שהדטרמיננטה תהיה מכפלה של {::nomarkdown}\( -1\){:/nomarkdown}-ים ושלא ישתרבב פנימה איזה 0 שיאפס את כולה (מה שהיה עלול לקרות עם {::nomarkdown}\( B\){:/nomarkdown}, שבו יש אפסים שלא היו בהוכחה עבור גרפים לא מכוונים).

עכשיו נחזור למקרה שבו {::nomarkdown}\( \sigma\){:/nomarkdown} הוא לא עץ. מי שיושיע אותנו כאן הוא שאנחנו משתמשים גם ב-{::nomarkdown}\( N_{A\sigma}\){:/nomarkdown} וגם ב-{::nomarkdown}\( N_{B\sigma}\){:/nomarkdown}: הדטרמיננטה של אחד מהם תתאפס, ולא משנה מה. התעלול פשוט: אם {::nomarkdown}\( \sigma\){:/nomarkdown} הוא כזה שאפילו גרף התשתית של העץ שלנו (מה שמקבלים כשמוחקים את כיווני הקשתות) איננו עץ אז {::nomarkdown}\( \det\left(N_{A\sigma}\right)=0\){:/nomarkdown} מאותו שיקול כמו במקרה הלא מכוון (סכום שורות שהוא אפס, מה שמובטח על ידי ה-1 וה-{::nomarkdown}\( -1\){:/nomarkdown} שיש בכל עמודה שם - וזה משהו שאין ב-{::nomarkdown}\( B\){:/nomarkdown}), ואילו אם גרף התשתית הוא כן עץ, אז נסדר מחדש את {::nomarkdown}\( N_{B\sigma}\){:/nomarkdown} על פי אותה שיטה שבה השתמשנו עד כה במקרים שבהם {::nomarkdown}\( \sigma\){:/nomarkdown} הגדיר עץ. נקבל מטריצה משולשית תחתונה כמו תמיד, רק שהפעם אחד מהאיברים על האלכסון יהיה 0. מדוע? כי אם {::nomarkdown}\( \sigma\){:/nomarkdown} איננו עץ למרות שגרף התשתית הוא כן עץ, זה אומר שיש קשת אחת שמכוונת בכיוון "הלא נכון", ואז הכניסה על האלכסון שמתאימה לקשת הזו ולצומת שמחוברת אליה תהיה 0 (כי הקשת <strong>יוצאת</strong> מהצומת במקום להיכנס אליו).

אם כן, המקרה המכוון הוא מעט יותר מסובך מהמקרה הלא מכוון אבל גם בו יש תובנות יפות לגבי <strong>למה</strong> זה עובד - ושוב, אני מקווה שנהניתם.
