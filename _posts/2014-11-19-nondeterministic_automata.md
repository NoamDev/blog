---
id: 3194
title: "אוטומטים אי דטרמיניסטיים ושאר מריעין בישין"
date: 2014-11-19 16:51:21
layout: post
categories: 
  - תורת הסיבוכיות
tags: 
  - אוטומטים
  - אוטומטים אי דטרמיניסטיים
---
בפוסט הקודם הצגתי את המושג של אוטומט סופי דטרמיניסטי והגדרתי אותו בצורה פורמלית. בשביל מתמטיקאים, הגדרה פורמלית היא סדין אדום. מייד מתעוררות שאלות - למה להגדיר כך ולא אחרת? האם כל ההנחות שהשתמשנו בהן נחוצות? מה קורה אם משנים קצת את כללי המשחק? אם מקלים על הנחות מסויימות? וכן הלאה. ובכן, בואו ננסה לחשוב על ההנחות שלנו ועל אילו מהן אפשר לוותר.

הנחה אחת הייתה שאני מראש מדבר רק על פתרון בעיות "כן/לא". לא ניגע בה, למרות שאפשר. הנחה אחרת הייתה שהגודל של קלטים ופלטים הוא סופי. גם בה לא ניגע, למרות שאפשר. ההנחות הללו <strong>משנות לנו את סוג הבעיות</strong> שאנחנו רוצים לעסוק בהן, ולכן שינוי שלהן יעביר אותנו לדיבור על דברים שאינם קשורים ישירות לנושא של שפות רגולריות.

הנחה אחרת הייתה הנחת הסופיות של האוטומט - קבוצת המצבים שלו יכולה להיות גדולה, אבל היא חייבת להיות סופית. זו הנחה שהיא בבירור הכרחית - זה תרגיל נחמד להוכיח שאם אנחנו מרשים לקבוצת המצבים להיות אינסופית, אז ה"אוטומט" המתקבל יכול לקבל כל שפה שהיא. אבל אי אפשר לממש אותו בפועל או אפילו לתת לו תיאור מפורש סופי (למשל, אלגוריתם שמחשב את הפונקציה {::nomarkdown}\( \delta\left(q,\sigma\right)\){:/nomarkdown} של האוטומט), אז מה הטעם.

עוד הנחה הייתה שהאוטומט קורא את הקלט שלו רק בכיוון אחד - כלומר, אנחנו הולכים על הקלט משמאל לימין, וברגע שקראנו אות מהקלט היא אבודה לנצח ולא נוכל לחזור אליה. זו הנחה <strong>מאוד</strong> כבדה ולא טריוויאלית ונראה שיהיה קשה מאוד להצדיק אותה. אני הולך להצדיק אותה בעתיד על ידי האבחנה שמודל שבו אפשר לעשות את זה הוא שקול בכוחו החישובי למודל הפשוט שלנו, אבל זה ידרוש עוד כלי מרכזי (משפט נרוד) שטרם הצגתי, ולכן לא ניגע בהנחה הזו כרגע.

אבל היו שתי הנחות שהרבה פחות קל להצדיק ואנחנו הולכים להעיף אותן לכל הרוחות הפעם: ראשית, שהאוטומט פועל בצורה מוזרה שבה הוא קורא אות אחת מהקלט <strong>בכל צעד חישוב</strong> שלו. למה שלא נאפשר לו לעשות צעדי חישוב "על ריק"? ובכן, אנחנו הולכים להרשות לו. אבל עצרו רגע ותחשבו על זה - תראו שאם זה כל מה שאנחנו משנים במודל שלנו, לא הרווחנו כמעט שום דבר - המודל החדש שנקבל יהיה אפילו <strong>יותר מסורבל</strong> מהמודל הנוכחי, כי צעד חישוב "על ריק" כזה בעצם לא עושה כלום. אתם תתחילו להגיד לעצמכם "נו, אם אתה רוצה לעבור אל <strong>{::nomarkdown}\( p\){:/nomarkdown} </strong>על ריק, למה לא הלכת לשם מלכתחילה?". אז בפני עצמה ההנחה שאנחנו קוראים אות בכל צעד חישוב היא סבירה. אלא אם האוטומט יהיה מסוגל <strong>לבחור</strong> בין קריאת אות קלט ובין ביצוע צעד חישוב על ריק.

אלא שכרגע המודל שלנו הוא <strong>דטרמיניסטי</strong>, מה שאומר שיש לו <strong>פונקציית מעברים</strong>. בואו ניזכר מה זה אומר, פונקציה: פונקציה {::nomarkdown}\( f:A\to B\){:/nomarkdown} מתאימה לכל איבר ב-{::nomarkdown}\( A\){:/nomarkdown} איבר <strong>אחד ויחיד</strong> ב-{::nomarkdown}\( B\){:/nomarkdown}. זה אומר שאין לנו "בחירה" בין שני פלטים אפשריים של הפונקציה בהינתן קלט מסויים, וגם אין לנו את האפשרות להגיד "לא רוצים להוציא פלט, מה תעשו לנו". באוטומט, ה-{::nomarkdown}\( A\){:/nomarkdown} של פונקציית המעברים הוא אוסף כל הזוגות של מצב ואות קלט, ואילו {::nomarkdown}\( B\){:/nomarkdown} הוא המצבים. מה שאנחנו רוצים לעשות הוא לזרוק לפח את הדרישה שפונקציית המעברים {::nomarkdown}\( \delta:Q\times\Sigma\to\Sigma\){:/nomarkdown} היא פונקציה - כלומר, בהינתן הזוג של המצב הנוכחי ואות הקלט הנוכחית, אנחנו רוצים להרשות לאוטומט כמה אפשרויות בחירה - כמה מצבים שונים שהוא יכול לעבור אליהם. או אפילו להרשות לו לא לעבור לשום מצב בכלל אלא "להיתקע", מה שיסיים את החישוב מייד בלי לקבל את מילת הקלט. אוטומט כזה נקרא <strong>אי דטרמיניסטי</strong> (שימו לב שאני עדיין לא מרשה מעברים "על ריק"; אל זה נגיע אחר כך).

כשמציירים את האוטומט בתור גרף, קל להדגים אי דטרמיניזם - בסך הכל מדובר על מצבים שמהם לא יוצא חץ עבור אות מסויימת, או שיוצא יותר מחץ אחד עבור אות מסויימת:

<strong><a href="http://www.gadial.net/wp-content/uploads/2014/11/diagram0011.png"><img class="aligncenter size-full wp-image-3196" alt="diagram001" src="http://www.gadial.net/wp-content/uploads/2014/11/diagram0011.png" width="433" height="114" /></a></strong>

אבל איך מתארים אוטומט כזה בצורה פורמלית? דרך אחת היא להגיד שאין לנו יותר פונקציית מעברים אלא <strong>יחס</strong> מעברים - אוסף של שלשות מהצורה {::nomarkdown}\( \left(q,\sigma,p\right)\){:/nomarkdown} שבא לומר שהאוטומט יכול, אם הוא במצב {::nomarkdown}\( q\){:/nomarkdown} וקורא {::nomarkdown}\( \sigma\){:/nomarkdown}, לעבור למצב {::nomarkdown}\( p\){:/nomarkdown} (מבחינה פורמלית פונקציה היא פשוט מקרה פרטי של יחס, עם דרישות נוספות שמבטיחות שלכל קלט יהיה פלט אחד ויחיד). עם זאת, אני מעדיף דווקא לנקוט בגישה השניה, שאומרת שעדיין יכולה להיות לנו פונקציית מעברים, אם רק נשנה את הטווח שלה. דרך הפתרון שאני מציג כאן היא די סטנדרטית כאשר רוצים להגדיר פונקציות "רב ערכיות" בצורה פורמלית.

מה שאני אומר הוא שהפונקציה שלי, לכל קלט של {::nomarkdown}\( \left(q,\sigma\right)\){:/nomarkdown}, תחזיר <strong>קבוצה</strong> - את קבוצת המצבים שאפשר לעבור אליהם כשהאוטומט במצב {::nomarkdown}\( q\){:/nomarkdown} וקורא {::nomarkdown}\( \sigma\){:/nomarkdown}. הקבוצה הזו יכולה להכיל איבר בודד (קבוצה כזו נקראת "סינגלטון") כמו שקורה באוטומט דטרמיניסטי; יכולה להיות ריקה; ויכולה להכיל שניים או יותר מצבים. כך שההגדרה הזו תופסת בו זמנית את הרעיון של "היתקעות" ושל "בחירה בין אפשרויות" מבלי להשליך לפח את האפשרות של דטרמיניזם. כלומר, הרחבנו את המודל של אוטומט סופי דטרמיניסטי; עם קצת שינויים סינטקטיים, אפשר לחשוב על כל אוטומט דטרמיניסטי כמקרה פרטי של אוטומט אי דטרמיניסטי. פורמלית כותבים את פונקציית המעברים כך: {::nomarkdown}\( \delta:Q\times\Sigma\to2^{Q}\){:/nomarkdown} (הסימון {::nomarkdown}\( 2^{Q}\){:/nomarkdown} פירושו "כל-תתי הקבוצות של {::nomarkdown}\( Q\){:/nomarkdown}"; קרוב לודאי שהוא נראה מוזר ושרירותי עבור מי שלא מכיר את תורת הקבוצות, אבל סמכו עלי שיש בו הגיון יפה).

התיאור הפורמלי של האוטומט שבציור, אם כן, הוא זה: {::nomarkdown}\( Q=\left\{ q_{0},q_{1},q_{2}\right\} \){:/nomarkdown} ו-{::nomarkdown}\( F=\left\{ q_{2}\right\} \){:/nomarkdown} ופונקציית המעברים הבאה:

{::nomarkdown}\( \delta\left(q_{0},a\right)=\left\{ q_{0},q_{1}\right\} ,\delta\left(q_{0},b\right)=\left\{ q_{0}\right\} \){:/nomarkdown}

{::nomarkdown}\( \delta\left(q_{1},\sigma\right)=\left\{ q_{2}\right\} \){:/nomarkdown}

{::nomarkdown}\( \delta\left(q_{2},\sigma\right)=\emptyset\){:/nomarkdown}

מה שעדיין חסר לי הוא הסבר של מה זה אומר שאוטומט אי דטרמיניסטי כזה <strong>רץ</strong> על מילה, ומתי הוא <strong>מקבל</strong> אותה. המושג של ריצה נותר זהה - ריצה של אוטומט על מילה {::nomarkdown}\( w\){:/nomarkdown} היא סדרה של מצבים שכל אחד מהם מתקבל מקודמו על ידי פונקציית המעברים, בהתאם לקלט שהאוטומט קורא. אם קודם אמרנו ש-{::nomarkdown}\( p\){:/nomarkdown} נובע מ-{::nomarkdown}\( q\){:/nomarkdown} כאשר האוטומט קורא {::nomarkdown}\( \sigma\){:/nomarkdown} אם התקיים {::nomarkdown}\( \delta\left(q,\sigma\right)=p\){:/nomarkdown}, עכשיו אנחנו אומרים את זה אם מתקיים {::nomarkdown}\( p\in\delta\left(q,\sigma\right)\){:/nomarkdown}, כלומר אם {::nomarkdown}\( p\){:/nomarkdown} הוא אחד המצבים שהאוטומט <strong>עשוי</strong> לעבור אליהם.

זה אומר שלאוטומט אי דטרמיניסטי יכולות להיות <strong>הרבה ריצות שונות</strong> על אותה מילת קלט. חלק מהריצות הללו עשויות להסתיים במצב מקבל וחלק לא - כלומר, האוטומט לכאורה "מקבל ודוחה בו זמנית" את המילה. מכאן שכשאנחנו באים לענות על השאלה האם {::nomarkdown}\( w\in L\left(A\right)\){:/nomarkdown}, אנחנו בעצם שואלים שאלה על מה קורה בכל הריצות של {::nomarkdown}\( A\){:/nomarkdown} על {::nomarkdown}\( w\){:/nomarkdown}. תשובה סבירה אחת היא שנאמר ש-{::nomarkdown}\( A\){:/nomarkdown} מקבלת את {::nomarkdown}\( w\){:/nomarkdown} רק אם <strong>כל</strong> ריצה של {::nomarkdown}\( A\){:/nomarkdown} על {::nomarkdown}\( w\){:/nomarkdown} מסתיימת בקבלה, אבל אז נקבל מודל חדש שלא נוח לעבוד איתו (כי מה עוזר לנו שיש הרבה מסלולי חישוב אפשריים אם אנחנו צריכים לעבוד כדי להבטיח שבכולם האוטומט יקבל את המילים הנכונות?). לכן אנחנו מעדיפים את ההגדרה השניה: {::nomarkdown}\( w\in L\left(A\right)\){:/nomarkdown} אם <strong>קיים</strong> מסלול חישוב כלשהו של {::nomarkdown}\( A\){:/nomarkdown} על {::nomarkdown}\( w\){:/nomarkdown} שהוא מקבל. אפילו אם יש מיליארד מסלולי חישוב דוחים, ורק אחד שמקבל - המילה עדיין תהיה בשפה של האוטומט.

בואו נסתכל לרגע באוטומט שציירתי למעלה. מה הוא מקבל? אפשר לראות שבהתחלה הוא יכול לקרוא אותיות באופן חופשי ולהישאר במצב ההתחלתי, וכך זה יכול להימשך לנצח בעיקרון (ואז האוטומט לא יגיע למצב מקבל אף פעם). אלא שהוא יכול גם לעבור ל-{::nomarkdown}\( q_{1}\){:/nomarkdown} אחרי קריאה של {::nomarkdown}\( a\){:/nomarkdown}. אם הוא יעשה את זה, בצעד הבא הוא יעבור ל-{::nomarkdown}\( q_{2}\){:/nomarkdown}, ואז הוא "ייתקע" כי אין לו לאן ללכת. אז מתי הוא יקבל? רק אם שני צעדי החישוב האחרונים שלו (המעבר ל-{::nomarkdown}\( q_{1}\){:/nomarkdown} ואחריו המעבר ל-{::nomarkdown}\( q_{2}\){:/nomarkdown}) הם בדיוק הצעדים שבהם קוראים את שתי האותיות האחרונות במילה. צעד החישוב האחרון מתבצע תמיד, בלי תלות בשאלה מה האות האחרונה במילה, אבל הצעד שלפניו יכול להתבצע רק אם האות היא {::nomarkdown}\( a\){:/nomarkdown}. המסקנה: האוטומט מקבל בדיוק את המילים שבהן {::nomarkdown}\( a\){:/nomarkdown} היא האות הלפני-אחרונה.

העניין הזה, ש-{::nomarkdown}\( A\){:/nomarkdown} מקבל מילה אם ורק אם קיים ל-{::nomarkdown}\( A\){:/nomarkdown} מסלול חישוב מקבל על המילה, יכול להיות מבלבל למדי. זה הופך את {::nomarkdown}\( A\){:/nomarkdown} למשהו לא מציאותי; כדי לדעת אם הוא מקבל מילה, אי אפשר סתם "להריץ אותו ולראות מה קורה", כי אם ההרצה תסתיים בדחייה של המילה, זה עדיין לא אומר שהאוטומט לא מקבל את המילה - אולי יש מסלול חישוב אחר שבו הוא כן יקבל אותה. דרך נחמדה לתת אינטואיציה היא לחשוב על {::nomarkdown}\( A\){:/nomarkdown} כאילו הוא מצויד ב"מטבע קסם" - בכל פעם שבה הוא צריך לבצע בחירה אי דטרמיניסטית בין כמה אפשרויות הוא מטיל את המטבע, והמטבע יגריל את האפשרות "הטובה ביותר" במובן זה שאם יש ל-{::nomarkdown}\( A\){:/nomarkdown} מסלול חישוב מקבל כלשהו על המילה, מטבע הקסם יוודא ש-{::nomarkdown}\( A\){:/nomarkdown} ילך במסלול החישוב הזה (או, אם יש כמה, באחד מהם).

זה קצת מזכיר חישוב הסתברותי, אבל זה לא - אנחנו לא דורשים ש-{::nomarkdown}\( A\){:/nomarkdown} תקבל בהסתברות גבוהה או משהו דומה; אין לנו חישובי הסתברויות בכלל. ייתכן שזה גם מזכיר חישוב קוונטי - כאילו {::nomarkdown}\( A\){:/nomarkdown} נמצאת בסופרפוזיציה של הרבה ריצות אפשריות - אבל אם עקבתם אחרי סדרת הפוסטים שלי על חישוב קוונטי (או, יותר סביר, סתם מכירים חישוב קוונטי וכנראה יותר טוב ממני) אתם יודעים שחישוב קוונטי לא ממש עובד ככה ושאנחנו מתעלמים מההיבטים המורכבים שלו (איך לגלות את התוצאה, למשל). אז אני מעדיף לא ללכת יותר מדי לכיוון של אינטואיציות ולקוות שההגדרה המדויקת מספיק טובה כדי להבין מה הולך פה.

פורמלית, אנחנו רוצים להגדיר הרחבה של {::nomarkdown}\( \delta\){:/nomarkdown}, {::nomarkdown}\( \hat{\delta}:Q\times\Sigma^{*}\to2^{Q}\){:/nomarkdown}, באופן דומה לאיך שעשינו את זה עם אוטומט דטרמיניסטי - באינדוקציה. אז נגדיר {::nomarkdown}\( \hat{\delta}\left(q,\varepsilon\right)=\left\{ q\right\} \){:/nomarkdown} ו-{::nomarkdown}\( \hat{\delta}\left(q,w\sigma\right)=\bigcup_{p\in\hat{\delta}\left(q,w\right)}\delta\left(p,\sigma\right)\){:/nomarkdown}. במילים - קבוצת המצבים שאליהם ניתן להגיע מ-{::nomarkdown}\( q\){:/nomarkdown} על ידי קריאת {::nomarkdown}\( w\sigma\){:/nomarkdown} היא קבוצת המצבים שאליהם ניתן להגיע על ידי קריאת {::nomarkdown}\( \sigma\){:/nomarkdown} מתוך אחד מהמצבים שאליהם ניתן להגיע מ-{::nomarkdown}\( q\){:/nomarkdown} על ידי קריאת {::nomarkdown}\( w\){:/nomarkdown}. מכיוון ש-{::nomarkdown}\( \hat{\delta}\){:/nomarkdown} מקבלת מצב יחיד ופולטת קבוצה של מצבים כבר אי אפשר להרכיב אותה על עצמה ובשל כך יש את האיחוד הזה בחוץ. אפשר גם להתחכם מבחינת הסימון ולהגדיר {::nomarkdown}\( \hat{\delta}:2^{Q}\times\Sigma^{*}\to2^{Q}\){:/nomarkdown} באופן הבא: {::nomarkdown}\( \hat{\delta}\left(\left\{ q\right\} ,w\right)\){:/nomarkdown} יהיה שווה ל-{::nomarkdown}\( \hat{\delta}\left(q,w\right)\){:/nomarkdown} שכבר הגדרנו, ועבור קבוצות {::nomarkdown}\( P\subseteq Q\){:/nomarkdown} כלליות נגדיר {::nomarkdown}\( \hat{\delta}\left(P,w\right)=\bigcup_{p\in P}\hat{\delta}\left(p,w\right)\){:/nomarkdown} (כאן הכתיב של {::nomarkdown}\( \hat{\delta}\left(p,w\right)\){:/nomarkdown} הוא בעצם דרך מקוצרת לכתוב {::nomarkdown}\( \hat{\delta}\left(\left\{ p\right\} ,w\right)\){:/nomarkdown} - ל"רמאות" כזו יש אפילו שם מקובל - Abuse of Notation. עכשיו אפשר לכתוב {::nomarkdown}\( \hat{\delta}\left(q,w\sigma\right)=\hat{\delta}\left(\hat{\delta}\left(q,w\right),\sigma\right)\){:/nomarkdown} מבלי שתהיה עם זה בעיה.

עכשיו מתעוררות שתי שאלות, שקשורות אחת לשניה בקשר הדוק. הראשונה - נניח שנותנים לנו אוטומט אי דטרמיניסטי {::nomarkdown}\( A\){:/nomarkdown} ומילה {::nomarkdown}\( w\){:/nomarkdown} ושואלים אותנו אם {::nomarkdown}\( w\in L\left(A\right)\){:/nomarkdown} - מה אנחנו עושים? אנחנו כבר יודעים שאי אפשר סתם להריץ את {::nomarkdown}\( A\){:/nomarkdown} על {::nomarkdown}\( w\){:/nomarkdown} ולבחור שרירותית בחירות אי דטרמיניסטיות כי אם הריצה לא תסתיים בקבלה זה לא אומר לנו עדיין כלום. השאלה השניה - האם המודל האי דטרמיניסטי שקול בכוחו למודל הדטרמיניסטי? דהיינו, האם בהינתן {::nomarkdown}\( A\){:/nomarkdown} אי דטרמיניסטי קיים אוטומט {::nomarkdown}\( A^{\prime}\){:/nomarkdown} דטרמיניסטי כך ש-{::nomarkdown}\( L\left(A\right)=L\left(A^{\prime}\right)\){:/nomarkdown}?

השאלה הראשונה בעצם מבקשת מאיתנו למצוא אלגוריתם כלשהו להכרעת שאלת השייכות של מילה לשפה של אוטומט אי דטרמיניסטי; השאלה השניה מבקשת את אותו דבר בדיוק אבל תוך הדרישה הנוספת שכמות הזכרון שהאלגוריתם הזה צריך תהיה <strong>חסומה.</strong> כמו כן, תשובה לשאלה הראשונה אפשר לתת בנפנוף ידיים, אבל תשובה לשאלה השניה אתן על ידי בניה מפורשת ומדויקת.

פתרון כוח גס לשאלה הראשונה זה קל. בהינתן מילה {::nomarkdown}\( w\){:/nomarkdown} מאורך {::nomarkdown}\( m\){:/nomarkdown}, יש רק מספר סופי של מסלולי חישוב אפשריים של {::nomarkdown}\( A\){:/nomarkdown} על {::nomarkdown}\( w\){:/nomarkdown}. הנה חסם טיפשי: אם דרגת היציאה המקסימלית של צומת ב-{::nomarkdown}\( A\){:/nomarkdown} היא {::nomarkdown}\( k\){:/nomarkdown}, אז יש לכל היותר {::nomarkdown}\( k^{m}\){:/nomarkdown} מסלולי חישוב אפשריים (למה?) אז אפשר לעבור על כולם. אבל סיבוכיות הזכרון של האלגוריתם הזה ככל הנראה תהיה גבוהה, כי צריך לזכור איכשהו באילו מסלולים כבר עברנו. זה לא אלגוריתם שנוח לממש בפועל במחשב. ודאי יש דרך קלה יותר. עצרו רגע וחשבו מהי.

ועכשיו, במקום לגלות לכם את הפתרון, אני הולך לעצור לרגע ולפתור בעיה שהיא לכאורה שונה לגמרי, אבל כמובן שתתקשר למה שאנחנו רוצים לעשות. הבעיה היא זו: נתונות לנו שתי שפות רגולריות {::nomarkdown}\( L_{1},L_{2}\){:/nomarkdown}; אנחנו רוצים להוכיח שגם החיתוך שלהן, {::nomarkdown}\( L_{1}\cap L_{2}\){:/nomarkdown}, שפת כל המילים שנמצאות גם ב-{::nomarkdown}\( L_{1}\){:/nomarkdown} וגם ב-{::nomarkdown}\( L_{2}\){:/nomarkdown} - היא שפה רגולרית. כלומר, אם {::nomarkdown}\( A_{1}=\left(\Sigma,Q_{1},q_{0}^{1},\delta_{1},F_{1}\right)\){:/nomarkdown} ו-{::nomarkdown}\( A_{2}=\left(\Sigma,Q_{2},q_{0}^{2},\delta_{2},F_{2}\right)\){:/nomarkdown} הם אוטומטים עבור השפות, אנחנו רוצים לבנות מהם אוטומט {::nomarkdown}\( A=\left(\Sigma,Q,q_{0},\delta,F\right)\){:/nomarkdown} כך ש-{::nomarkdown}\( L\left(A\right)=L_{1}\cap L_{2}\){:/nomarkdown}.

אלגוריתם נאיבי שעושה דבר כזה יפעל כך: בהינתן {::nomarkdown}\( w\){:/nomarkdown}, קודם כל יריץ את {::nomarkdown}\( A_{1}\){:/nomarkdown} על {::nomarkdown}\( w\){:/nomarkdown}, ואם {::nomarkdown}\( A_{1}\){:/nomarkdown} קיבלה, יריץ את {::nomarkdown}\( A_{2}\){:/nomarkdown} על {::nomarkdown}\( w\){:/nomarkdown} ויענה כמוה. הבעיה היא שאנחנו רוצים לבנות אוטומט עבור שפת החיתוך, ואוטומט לא יכול לבצע שתי הרצות בזו-אחר-זו של אותה מילה, בגלל הגישה המוגבלת שיש לו למילה - הוא יכול לקרוא אותה רק פעם אחת. לכן הפתרון הוא שהאוטומט יבצע סימולציה של {::nomarkdown}\( A_{1},A_{2}\){:/nomarkdown} <strong>בו זמנית</strong>. בכל רגע נתון, המצב של האוטומט שלנו יהיה זוג {::nomarkdown}\( \left(p,q\right)\){:/nomarkdown} שאומר "הסימולציה של {::nomarkdown}\( A_{1}\){:/nomarkdown} נמצאת כרגע במצב {::nomarkdown}\( p\){:/nomarkdown} והסימולציה של {::nomarkdown}\( A_{2}\){:/nomarkdown} נמצאת כרגע במצב {::nomarkdown}\( q\){:/nomarkdown}". כל אות שאנחנו קוראים מהקלט תגרום לנו לקדם את שני המצבים בזוג בו זמנית, בהתאם למעברים באוטומטים שלהם.

פורמלית, ההגדרה של {::nomarkdown}\( A\){:/nomarkdown} היא זו: {::nomarkdown}\( Q=Q_{1}\times Q_{2}\){:/nomarkdown}, {::nomarkdown}\( F=F_{1}\times F_{2}\){:/nomarkdown} (כי מצב מקבל הוא זוג {::nomarkdown}\( \left(p,q\right)\){:/nomarkdown} שבו שני המצבים הם מקבלים, כל אחד באוטומט שלו), {::nomarkdown}\( q_{0}=\left(q_{0}^{1},q_{0}^{2}\right)\){:/nomarkdown}, ופונקציית המעברים מוגדרת לכל {::nomarkdown}\( p\in Q_{1},q\in Q_{2},\sigma\in\Sigma\){:/nomarkdown} באופן הבא: {::nomarkdown}\( \delta\left(\left(p,q\right),\sigma\right)=\left(\delta_{1}\left(p,\sigma\right),\delta_{2}\left(q,\sigma\right)\right)\){:/nomarkdown}. לא קשה להוכיח באינדוקציה שהבניה הזו אכן עובדת ו-{::nomarkdown}\( A\){:/nomarkdown} מקבל את שפת החיתוך. האוטומט הזה נקרא <strong>אוטומט מכפלה</strong> כי קבוצת המצבים שלו היא מכפלה של קבוצות המצבים של האוטומטים שאנחנו מסמלצים.

נחזור כעת אל סילוק האי-דטרמיניזם שלנו. כאן אנחנו רוצים לעשות משהו דומה - לבצע סימולציה של כמה חישובים במקביל. כל החישובים הולכים להתבצע <strong>על אותו אוטומט</strong>, ולכן נשאלת השאלה - מה מבדיל חישובים שונים זה מזה? ובכן, כמובן, הבחירות האי דטרמיניסטיות שבוצעו במהלך החישוב, שאומרות שה"היסטוריה" של החישוב - כל המצבים שהיינו בהם עד כה, עד וכולל המצב הנוכחי - תהיה שונה בין חישובים שונים. וכאן מגיע הפאנץ': <strong>לא אכפת לנו מההיסטוריה</strong>. הדבר היחיד שמעניין אותנו בחישוב כלשהו הוא <strong>איפה אנחנו נמצאים כרגע</strong>. שני חישובים אי דטרמיניסטיים שונים, שאחרי קריאת כך-וכך אותיות הגיעו שניהם לאותו מצב, הם מבחינתנו מרגע זה והלאה אותו דבר בדיוק - זה שהם הגיעו לאותו מצב בשתי דרכים שונות לא משפיע בשום צורה על מה שיקרה מכאן והלאה. למי מכם שמכיר <a href="http://www.gadial.net/2012/01/19/markov_chains_and_linear_algebra/">שרשראות מרקוב</a>, זו בדיוק תכונת "חוסר הזכרון" של שרשראות מרקוב.

אם {::nomarkdown}\( \left\|Q\right\|=n\){:/nomarkdown}, המשמעות היא שאנחנו צריכים בכל עת לתחזק עד {::nomarkdown}\( n\){:/nomarkdown} "ריצות במקביל" של האוטומט. בפועל מה שנעשה יהיה פשוט יותר - הסימולציה שלנו תתבצע על ידי כך שנזכור בכל שלב את <strong>קבוצת המצבים</strong> שבהם האוטומט שאנחנו מסמלצים נמצא ב<strong>לפחות אחד</strong> ממסלולי החישוב שלו. אלגוריתמית, אפשר לחשוב על זה בתור מערך באורך {::nomarkdown}\( n\){:/nomarkdown} של ערכים בוליאניים ("כן/לא") שאנחנו מעדכנים בכל צעד. זה כל הזכרון שנזדקק לו, ומכיוון שהוא לא תלוי בגודל מילת הקלט {::nomarkdown}\( w\){:/nomarkdown} זהו זכרון חסום. כאשר נבנה אוטומט דטרמיניסטי עבור האלגוריתם הזה, האוטומט יכיל מצב אחד לכל סדרת ערכים אפשרית של המערך - דהיינו, יהיו לו {::nomarkdown}\( 2^{n}\){:/nomarkdown} מצבים. זה מספר <strong>קבוע</strong> ו<strong>סופי</strong>, אבל הוא אקספוננציאלי במספר המצבים של האוטומט שאנחנו מסמלצים. מסתבר שזה בלתי נמנע - לכל {::nomarkdown}\( n\){:/nomarkdown} טבעי אפשר למצוא שפה שיש אוטומט אי-דטרמיניסטי עם {::nomarkdown}\( O\left(n\right)\){:/nomarkdown} מצבים עבורה, אבל כל אוטומט סופי דטרמיניסטי עבורה יהיה עם {::nomarkdown}\( \Omega\left(2^{n}\right)\){:/nomarkdown} מצבים. השפות הללו הן הכללה של השפה שנתתי בתור דוגמה - עבור {::nomarkdown}\( n\){:/nomarkdown}, זו תהיה השפה של כל המילים הבינאריות שיש בהן 1 בדיוק {::nomarkdown}\( n\){:/nomarkdown} צעדים מהסוף. כמובן, עוד לא הסברתי איך מוכיחים ש<strong>כל</strong> אוטומט סופי דטרמיניסטי עבור השפה יהיה בעל לפחות כך-וכך מצבים; זה משהו שיינתן לנו על ידי <strong>משפט נרוד</strong> שכבר הזכרתי בפוסט.

נעבור לבניה הפורמלית. נניח ש-{::nomarkdown}\( A_{ND}=\left(\Sigma,Q_{ND},q_{0}^{ND},\delta_{ND},F_{ND}\right)\){:/nomarkdown} הוא אוטומט אי דטרמיניסטי כלשהו, אז נבנה אוטומט דטרמיניסטי {::nomarkdown}\( A_{D}=\left(\Sigma,Q_{D},q_{0}^{D},\delta_{D},F_{D}\right)\){:/nomarkdown} כך ש-{::nomarkdown}\( L\left(A_{ND}\right)=L\left(A_{D}\right)\){:/nomarkdown}.

הבסיס של הבניה הוא זה: {::nomarkdown}\( Q_{D}=2^{Q_{ND}}\){:/nomarkdown}. כלומר, כל מצב של האוטומט הדטרמיניסטי הוא, מבחינה פורמלית, <strong>קבוצה</strong> - קבוצה של מצבים מתוך {::nomarkdown}\( Q_{ND}\){:/nomarkdown}. זה די מבלבל, כי התרגלנו אולי לחשוב על מצבים של אוטומט בתור מין "אטומים" - אובייקטים שאנחנו מסמנים ב-{::nomarkdown}\( q_{t}\){:/nomarkdown} ואין להם מבנה מתמטי מורכב יותר. אבל מבחינה פורמלית, זה לא הכרחי; כל מה שאנחנו דורשים על אוטומט הוא שקבוצת המצבים שלו תהיה קבוצה סופית כלשהי, והאיברים של אותה קבוצה יכולים להיות כל דבר - מספרים טבעיים, מחרוזות, סימבולים, או אפילו קבוצות. בבניה הנוכחית, נוח לנו שהאיברים הללו יהיו קבוצות. מכאן מגיע שם הבניה: האוטומט {::nomarkdown}\( A_{D}\){:/nomarkdown} שבנינו נקרא <strong>אוטומט חזקה</strong>, כי קבוצת המצבים שלו היא קבוצת החזקה של קבוצת המצבים של האוטומט {::nomarkdown}\( A_{ND}\){:/nomarkdown}.

כעת, {::nomarkdown}\( q_{0}^{D}=\left\{ q_{0}^{ND}\right\} \){:/nomarkdown}. כלומר, המצב ההתחלתי של האוטומט הדטרמיניסטי הוא קבוצה (הרי אמרנו שכל מצב של האוטומט הוא קבוצה...) שהאיבר היחיד שלה הוא המצב ההתחלתי של האוטומט האי-דטרמיניסטי. כלומר, הסימולציה שלנו מתחילה עם חישוב יחיד, שמתחיל ב-{::nomarkdown}\( q_{0}^{ND}\){:/nomarkdown}. למעשה, אפשר היה להרחיב עוד קצת את המודל האי-דטרמיניסטי ולהרשות כמה מצבים התחלתיים שונים, ואז הסימולציה הייתה מתחילה עם קבוצת כל המצבים הללו וזה היה כל ההבדל.

כמו כן, {::nomarkdown}\( F_{D}=\left\{ P\subseteq Q_{ND}\ \|\ P\cap F_{ND}\ne\emptyset\right\} \){:/nomarkdown}, כלומר המצבים המקבלים שלנו הם אלו שבהם <strong>לפחות אחת</strong> מהסימולציות נמצאת באותו הרגע במצב מקבל.

נשאר רק לתאר את פונקציית המעברים, לכל {::nomarkdown}\( P\in Q_{D}\){:/nomarkdown} ו-{::nomarkdown}\( \sigma\in\Sigma\){:/nomarkdown}: {::nomarkdown}\( \delta_{D}\left(P,\sigma\right)=\hat{\delta}_{ND}\left(P,\sigma\right)\){:/nomarkdown}. דהיינו, האוטומט הדטרמיניסטי הולך מהמצב {::nomarkdown}\( P\){:/nomarkdown} שלנו על ידי קריאת {::nomarkdown}\( \sigma\){:/nomarkdown} אל קבוצת כל המצבים באוטומט האי דטרמיניסטי שניתן להגיע אליהם בצעד אחד ממצב כלשהו ב-{::nomarkdown}\( P\){:/nomarkdown} על ידי קריאת {::nomarkdown}\( \sigma\){:/nomarkdown}. מתבקש. קל להוכיח שמתקיים {::nomarkdown}\( \hat{\delta}_{D}\left(P,w\right)=\hat{\delta}_{ND}\left(P,w\right)\){:/nomarkdown} לכל מילה {::nomarkdown}\( w\){:/nomarkdown} ומכאן הוכחת השקילות של שני האוטומטים כבר נובעת מאליה.

זה מסיים את הטיפול במודל האי דטרמיניסטי, אבל עדיין לא סיימנו - אני עדיין צריך לטפל בהקלה השניה על כללי המשחק ולהסתכל על המודל שבו אפשר לבצע מעבר בין מצבים בלי לקרוא אות. למעבר כזה אני אקרא "מעבר-{::nomarkdown}\( \varepsilon\){:/nomarkdown}". ונתחיל בדוגמא לאוטומט שמשתמש במעברים כאלו:

<a href="http://www.gadial.net/wp-content/uploads/2014/11/diagram002.png"><img class="aligncenter size-full wp-image-3197" alt="diagram002" src="http://www.gadial.net/wp-content/uploads/2014/11/diagram002.png" width="419" height="119" /></a>

האוטומט הזה מקבל את כל המילים שבנויות מרצף של 0 או יותר {::nomarkdown}\( a\){:/nomarkdown}-ים, אחריו רצף של 0 או יותר {::nomarkdown}\( b\){:/nomarkdown}-ים ואחריו רצף של 0 או יותר {::nomarkdown}\( c\){:/nomarkdown}-ים. בהמשך נראה איך ייראה אוטומט בלי מעברי-{::nomarkdown}\( \varepsilon\){:/nomarkdown} שעושה את זה ועד כמה מעברי ה-{::nomarkdown}\( \varepsilon\){:/nomarkdown} מפשטים את דרך ההצגה שלנו, אבל בינתיים אני ממליץ לכם לנסות ולבנות אוטומט כזה (אי דטרמיניסטי!) בעצמכם ולראות כמה אתם מסתבכים כדי שתוכלו להעריך את הפשטות היחסית של האוטומט הזה. מה שהוא עושה הוא זה: כל עוד יש {::nomarkdown}\( a\){:/nomarkdown}-ים לקרוא, קורא אותם. אחר כך קופץ למצב הבא על ידי מעבר {::nomarkdown}\( \varepsilon\){:/nomarkdown}, קורא שם {::nomarkdown}\( b\){:/nomarkdown}-ים כל עוד יש, ואז קופץ למצב האחרון וקורא שם {::nomarkdown}\( c\){:/nomarkdown}-ים כל עוד יש, עד (בתקווה) סוף המילה. כמובן, שימו לב שאני מייחס לאוטומט מעין חוכמה שאין לו (לדעת מתי ה-{::nomarkdown}\( a\){:/nomarkdown}-ים "נגמרו") - בפועל מה שקורה הוא שיש לאוטומט המון מסלולי חישוב אפשריים שרובם פשוט "נתקעים" (למשל, אם האות הראשונה במילה היא {::nomarkdown}\( a\){:/nomarkdown} אבל האוטומט בחר לבצע את מסע ה-{::nomarkdown}\( \varepsilon\){:/nomarkdown} אל {::nomarkdown}\( q_{1}\){:/nomarkdown} במקום לקרוא אותה) ואני פשוט מתאר את הריצה המקבלת. שימו לב איך אני נעזר בכך שהאוטומט הוא אי-דטרמיניסטי, ולא "רק" יכול לבצע מסעי-{::nomarkdown}\( \varepsilon\){:/nomarkdown}.

אתם כבר יודעים מה סדר הפעולות כשמציעים מודל מורחב שכזה. ראשית, תוהים איך להגדיר אותו פורמלית; שנית, תוהים איך להגדיר פורמלית "ריצה" במודל ומה זה אומר שהמודל "מקבל" מילה; ולבסוף, תוהים איך להוכיח שהוא שקול למודל פשוט יותר.

ובכן, ההגדרה פורמלית זהה לגמרי לזו של אוטומט אי דטרמיניסטי רגיל, פרט להגדרת פונקציית המעברים - {::nomarkdown}\( \delta:Q\times\left(\Sigma\cup\left\{ \varepsilon\right\} \right)\to2^{Q}\){:/nomarkdown}. כלומר, "הרחבנו" את הא"ב {::nomarkdown}\( \Sigma\){:/nomarkdown} על ידי הוספת הסימבול {::nomarkdown}\( \varepsilon\){:/nomarkdown} ו-{::nomarkdown}\( \delta\left(q,\varepsilon\right)\){:/nomarkdown} מחזיר את כל המצבים שאליהם ניתן להגיע מ-{::nomarkdown}\( q\){:/nomarkdown} על ידי מסע-{::nomarkdown}\( \varepsilon\){:/nomarkdown} יחיד. לרוע המזל, לסימבול {::nomarkdown}\( \varepsilon\){:/nomarkdown} כבר יש משמעות מאוד קונקרטית עבורנו - המילה הריקה. Hilarity ensues.

כדי להבין את הבעיה, בואו ננסה להגדיר את פונקציית המעברים המורחבת {::nomarkdown}\( \hat{\delta}\){:/nomarkdown}, שתתאר מה האוטומט עושה על מילים. כרגיל, מתחילים בלהגדיר אותה על המילה הריקה. עבור אוטומט אי דטרמיניסטי רגיל הגדרנו {::nomarkdown}\( \hat{\delta}\left(q,\varepsilon\right)=\left\{ q\right\} \){:/nomarkdown}; אבל מה נגדיר עבור אוטומט עם מסעי-{::nomarkdown}\( \varepsilon\){:/nomarkdown}? ובכן, העובדה שאנחנו משתמשים באותו סימון כדי לתאר מסע-{::nomarkdown}\( \varepsilon\){:/nomarkdown} וגם את המילה הריקה נותנת לנו אינטואיציה חזקה שצריך להגדיר {::nomarkdown}\( \hat{\delta}\left(q,\varepsilon\right)=\delta\left(q,\varepsilon\right)\){:/nomarkdown}. אבל זה <strong>לגמרי לא נכון</strong>! הנקודה הזו מבלבלת אנשים למוות. ממשלות כבר נפלו בגללה. טיסות חלל התרסקו, וקת'ולהו התעורר (אבל כשהוא ניסה להבין את הבעיה הוא גם נרדם שוב). בואו ננסה להבין מה הולך כאן.

כדי לעשות סדר בבלאגן, אני רוצה לשנות לרגע את השם של מסעי-{::nomarkdown}\( \varepsilon\){:/nomarkdown} ולקרוא להם מסעי-{::nomarkdown}\( \spadesuit\){:/nomarkdown}. כלומר, אני מגדיר את פונקציית המעברים {::nomarkdown}\( \delta:Q\times\left(\Sigma\cup\left\{ \spadesuit\right\} \right)\to2^{Q}\){:/nomarkdown}, ועכשיו אני רוצה להסביר לכם למה השוויון {::nomarkdown}\( \hat{\delta}\left(q,\varepsilon\right)=\delta\left(q,\spadesuit\right)\){:/nomarkdown} הוא לא נכון (קחו שניה כדי לוודא שאתם מבינים למה לא הפכתי את ה-{::nomarkdown}\( \varepsilon\){:/nomarkdown} באגף שמאל ל-{::nomarkdown}\( \spadesuit\){:/nomarkdown}). הסיבה פשוטה: {::nomarkdown}\( \delta\left(q,\spadesuit\right)\){:/nomarkdown} היא קבוצת כל המצבים שאפשר להגיע אליה מ-{::nomarkdown}\( q\){:/nomarkdown} על ידי ביצוע של <strong>מסע-{::nomarkdown}\( \spadesuit\){:/nomarkdown} אחד בדיוק</strong> בזמן ש-{::nomarkdown}\( \hat{\delta}\left(q,\varepsilon\right)\){:/nomarkdown} היא קבוצת כל המצבים שאפשר להגיע אליהם על ידי ביצוע של 0 או יותר מסעים שלא קוראים אות. באוטומט שבאיור מתקיים ש-{::nomarkdown}\( \delta\left(q_{0},\spadesuit\right)=\left\{ q_{1}\right\} \){:/nomarkdown} אבל {::nomarkdown}\( \hat{\delta}\left(q_{0},\varepsilon\right)=\left\{ q_{0},q_{1},q_{2}\right\} \){:/nomarkdown}.

עכשיו, נניח לרגע שפתרנו איכשהו את הבעיה של ההגדרה של {::nomarkdown}\( \hat{\delta}\){:/nomarkdown} עבור {::nomarkdown}\( \varepsilon\){:/nomarkdown}. מה יקרה כשננסה להמשיך את ההגדרה האינדוקטיבית, כלומר להגדיר את {::nomarkdown}\( \hat{\delta}\left(q,w\sigma\right)\){:/nomarkdown}? צריך להכניס לתמונה איכשהו את מסעי-{::nomarkdown}\( \varepsilon\){:/nomarkdown}. האינטואיציה הראשונה (שלי, לפחות) היא להרשות ל-{::nomarkdown}\( \sigma\){:/nomarkdown} להיות לא רק איבר של {::nomarkdown}\( \Sigma\){:/nomarkdown} אלא גם {::nomarkdown}\( \varepsilon\){:/nomarkdown}, המילה הריקה, ולהגדיר באותו האופן בדיוק גם במקרה הזה: {::nomarkdown}\( \hat{\delta}\left(q,w\sigma\right)=\delta\left(\hat{\delta}\left(q,w\right),\sigma\right)\){:/nomarkdown}. אבל בואו נציב שניה {::nomarkdown}\( \sigma=\varepsilon\){:/nomarkdown} - אנחנו מקבלים את המשוואה {::nomarkdown}\( \hat{\delta}\left(q,w\right)=\delta\left(\hat{\delta}\left(q,w\right),\varepsilon\right)\){:/nomarkdown} שמגדירה את {::nomarkdown}\( \hat{\delta}\left(q,w\right)\){:/nomarkdown} באמצעות {::nomarkdown}\( \hat{\delta}\left(q,w\right)\){:/nomarkdown} - הגדרה מעגלית. ברור שמשהו כאן לא עובד כל כך טוב וצריך איכשהו לתקן ועדיף מבלי להתייחס אל {::nomarkdown}\( \sigma\){:/nomarkdown} בתור משהו שיכול לייצג גם את {::nomarkdown}\( \varepsilon\){:/nomarkdown}. כלומר - צריך להתייחס למעברי-{::nomarkdown}\( \varepsilon\){:/nomarkdown} בצורה שונה מיתר המעברים.

זו הסיבה שבגללה אני לא אוהב את השימוש הכפול בסימבול {::nomarkdown}\( \varepsilon\){:/nomarkdown} כדי לתאר גם את המילה הריקה, וגם את המעברים שאינם קוראים אות. אבל אין מה לעשות - זה הסימון המקובל בספרות ובפרט בספרי הלימוד הרלוונטיים לטעמי (זה של הופקרופט ואולמן; זה של סיפסר; וזה של האוניברסיטה הפתוחה בישראל). לכן גם אני אשתמש בו, אבל בזהירות.

אז איך נגדיר את {::nomarkdown}\( \hat{\delta}\left(q,\varepsilon\right)\){:/nomarkdown}? ובכן, אנחנו צריכים כתיב פורמלי עבור "כל המצבים שישיגים מ-{::nomarkdown}\( q\){:/nomarkdown} על ידי 0 או יותר מסעי-{::nomarkdown}\( \varepsilon\){:/nomarkdown}". נסמן את הקבוצה הזו ב-{::nomarkdown}\( \mbox{Cl}^{\varepsilon}\left(q\right)\){:/nomarkdown} - <strong>סגור-{::nomarkdown}\( \varepsilon\){:/nomarkdown}</strong> של {::nomarkdown}\( q\){:/nomarkdown} (Cl הוא קיצור של Closure - סגור, שמבוטא בחולם). לטעמי הדרך הנחמדה ביותר להגדיר את הקבוצה הזו היא בתור הקבוצה הקטנה ביותר של מצבים שמכילה את {::nomarkdown}\( q\){:/nomarkdown} וסגורה ביחס למעברי {::nomarkdown}\( \varepsilon\){:/nomarkdown}. פורמלית, {::nomarkdown}\( q\in\mbox{Cl}^{\varepsilon}\left(q\right)\){:/nomarkdown} וכמו כן אם {::nomarkdown}\( p\in\mbox{Cl}^{\varepsilon}\left(q\right)\){:/nomarkdown} ו-{::nomarkdown}\( p^{\prime}\in\delta\left(p,\varepsilon\right)\){:/nomarkdown} אז גם {::nomarkdown}\( p^{\prime}\in\mbox{Cl}^{\varepsilon}\left(q\right)\){:/nomarkdown}.

כעת נגדיר:

{::nomarkdown}\( \hat{\delta}\left(q,\varepsilon\right)=\mbox{Cl}^{\varepsilon}\left(q\right)\){:/nomarkdown}

{::nomarkdown}\( \hat{\delta}\left(q,w\sigma\right)=\mbox{Cl}^{\varepsilon}\left(\delta\left(\hat{\delta}\left(q,w\right),\sigma\right)\right)\){:/nomarkdown}

גם כאן אני מניח באופן מובלע ש-{::nomarkdown}\( \delta\){:/nomarkdown} מוגדרת על קבוצות של מצבים ולא רק על מצבים בודדים.

מה שההגדרה שלי בעצם אומרת היא זו: ראשית, כל עוד לא קראתם אף אות, המצבים שישיגים מ-{::nomarkdown}\( q\){:/nomarkdown} הם בדיוק אלו שניתן להגיע אליהם על ידי 0 או יותר מסעי-{::nomarkdown}\( \varepsilon\){:/nomarkdown} מ-{::nomarkdown}\( q\){:/nomarkdown}. כעת, המצבים שישיגים מ-{::nomarkdown}\( q\){:/nomarkdown} על ידי קריאת {::nomarkdown}\( w\sigma\){:/nomarkdown} (כאשר {::nomarkdown}\( \sigma\in\Sigma\){:/nomarkdown}) הם בדיוק המצבים שניתן להגיע אליהם מאחד המצבים ב-{::nomarkdown}\( \hat{\delta}\left(q,w\right)\){:/nomarkdown} על ידי כך שקודם כל מבצעים מסע תוך קריאת {::nomarkdown}\( \sigma\){:/nomarkdown} ולאחר מכן מבצעים כמה מסעי-{::nomarkdown}\( \varepsilon\){:/nomarkdown} שרוצים.

זה מסיים את שלב ההגדרות - וקצת מדכא לראות כמה מתוסבכת ההגדרה של רעיון יחסית פשוט כמו מסעי-{::nomarkdown}\( \varepsilon\){:/nomarkdown}. נשאר להוכיח שאוטומט אי דטרמיניסטי עם מסעי-{::nomarkdown}\( \varepsilon\){:/nomarkdown} שקול לאוטומט אי דטרמיניסטי בלי מסעים כאלו - להראות איך אפשר "לסלק" מסעי {::nomarkdown}\( \varepsilon\){:/nomarkdown}. מספיק לעבור למודל אי דטרמיניסטי בלי מסעי-{::nomarkdown}\( \varepsilon\){:/nomarkdown} כדי להוכיח שקילות למודל הדטרמיניסטי הרגיל, כי כבר ראינו שהמודל האי-דטרמיניסטי שקול למודל הדטרמיניסטי. בסילוק אי-דטרמיניזם ניפחנו אקספוננציאלית את מספר המצבים; בסילוק מסעי-{::nomarkdown}\( \varepsilon\){:/nomarkdown} מספר המצבים כלל לא ישתנה, רק נוסיף עוד קשתות לגרף של האוטומט.

הרעיון הוא פשוט: אנחנו רוצים להגדיר את {::nomarkdown}\( \delta\left(q,\sigma\right)\){:/nomarkdown} עבור האוטומט <strong>בלי</strong> מסעי-{::nomarkdown}\( \varepsilon\){:/nomarkdown}, בצורה ש"תסמלץ" את מה שהאוטומט עם מסעי ה-{::nomarkdown}\( \varepsilon\){:/nomarkdown} יכול לעשות. זה אומר ש-{::nomarkdown}\( \delta\left(q,\sigma\right)\){:/nomarkdown} תכלול את כל המצבים שאפשר להגיע אליהם מ-{::nomarkdown}\( q\){:/nomarkdown} באופן הבא: ביצוע של 0 או יותר מסעי-{::nomarkdown}\( \varepsilon\){:/nomarkdown} מ-{::nomarkdown}\( q\){:/nomarkdown}; ביצוע צעד תוך קריאת {::nomarkdown}\( \sigma\){:/nomarkdown}; ביצוע 0 או יותר מסעי-{::nomarkdown}\( \varepsilon\){:/nomarkdown} מהמצב שאליו הגענו. למרבה המזל, יש לנו כבר כעת דרך קומפקטית מאוד לכתוב את כל המהומה הזו: {::nomarkdown}\( \hat{\delta}\){:/nomarkdown}! ההגדרה של {::nomarkdown}\( \hat{\delta}\){:/nomarkdown} עבור אוטומט עם מסעי {::nomarkdown}\( \varepsilon\){:/nomarkdown} הייתה מסובכת, אבל עכשיו אפשר להשתמש בה בצורה חופשית ולקבל בניה מאוד פשוטה.

פורמלית, נניח ש-{::nomarkdown}\( A_{EM}=\left(\Sigma,Q,q_{0},\delta_{EM},F_{EM}\right)\){:/nomarkdown} הוא אוטומט עם מסעי-{::nomarkdown}\( \varepsilon\){:/nomarkdown}. אז נבנה אוטומט בלי מסעים כאלו, {::nomarkdown}\( A_{ND}=\left(\Sigma,Q,q_{0},\delta_{ND},F_{ND}\right)\){:/nomarkdown} שקול. קבוצת המצבים והמצב ההתחלתי של שניהם יהיו זהים, ולב הבניה טמון בהגדרת פונקציית המעברים, שהיא פשוטה כל כך לניסוח פורמלי שזה מרגיש כמו רמאות:

{::nomarkdown}\( \delta_{ND}\left(q,\sigma\right)=\hat{\delta}_{EM}\left(q,\sigma\right)\){:/nomarkdown}

נשאר רק לטפל במצבים המקבלים. מן הסתם נרצה שכל מצב מקבל של {::nomarkdown}\( A_{EM}\){:/nomarkdown} יהיה מצב מקבל של {::nomarkdown}\( A_{ND}\){:/nomarkdown}, אבל למרבה הצער - זה לא מספיק. יש לנו מקרה קצה מעצבן שצריך לטפל בו - המילה הריקה. כי מה קורה? הבניה שלנו של פונקציית המעברים מבטיחה שהאוטומטים יתנהגו בצורה מאוד דומה - שיתקיים {::nomarkdown}\( \hat{\delta}_{ND}\left(q,w\right)=\hat{\delta}_{EM}\left(q,w\right)\){:/nomarkdown} כמעט לכל מילה. אבל עבור {::nomarkdown}\( w=\varepsilon\){:/nomarkdown} השוויון הזה פשוט לא נכון. למה? כי באוטומט עם מסעי-{::nomarkdown}\( \varepsilon\){:/nomarkdown}, אפשר להגיע לקבוצה לא קטנה של מצבים תוך קריאת המילה הריקה - {::nomarkdown}\( \mbox{Cl}^{\varepsilon}\left(q_{0}\right)\){:/nomarkdown}, אם להיות פורמליים - אבל באוטומט בלי מסעי {::nomarkdown}\( \varepsilon\){:/nomarkdown} המצב <strong>היחיד</strong> שאפשר להגיע אליו בלי לקרוא אף אות הוא {::nomarkdown}\( q_{0}\){:/nomarkdown}.

אם {::nomarkdown}\( \varepsilon\notin L\left(A_{EM}\right)\){:/nomarkdown} כל זה לא רלוונטי. אבל אם {::nomarkdown}\( \varepsilon\in L\left(A_{EM}\right)\){:/nomarkdown} אז אין לנו ברירה; אנחנו <strong>חייבים</strong> שיתקיים {::nomarkdown}\( q_{0}\in F_{ND}\){:/nomarkdown} אחרת פשוט לא יתקיים {::nomarkdown}\( \varepsilon\in L\left(A_{ND}\right)\){:/nomarkdown}. מכאן אנחנו מקבלים את ההגדרה הבאה:

{::nomarkdown}\( F_{ND}=\begin{cases}F_{EM} &amp; \varepsilon\notin L\left(A_{EM}\right)\\F_{EM}\cup\left\{ q_{0}\right\} &amp; \varepsilon\in L\left(A_{EM}\right)\end{cases}\){:/nomarkdown}

השאלה היא האם ה"תיקון" הזה לא עשוי לקלקל לנו איכשהו את יתר השפה שהאוטומט מקבל. קל לראות שזה לא יכול לקרות, והנה הסבר בנפנוף ידיים: הדבר היחיד שיכול להשתבש הוא שבמקרה בו {::nomarkdown}\( \varepsilon\in L\left(A_{EM}\right)\){:/nomarkdown} תהיה מילה לא ריקה {::nomarkdown}\( w\){:/nomarkdown} כך ש-{::nomarkdown}\( w\notin L\left(A_{EM}\right)\){:/nomarkdown} אבל {::nomarkdown}\( q_{0}\in\hat{\delta}_{ND}\left(q_{0},w\right)\){:/nomarkdown} . עצרו רגע להסביר לעצמכם למה זה המקרה הבעייתי היחיד.

אני רוצה לשכנע אתכם שזה לא יכול לקרות. ספציפית, שאם {::nomarkdown}\( q_{0}\in\hat{\delta}_{ND}\left(q_{0},w\right)\){:/nomarkdown} אז {::nomarkdown}\( w\in L\left(A_{EM}\right)\){:/nomarkdown}. ההסבר פשוט מאוד: מכיוון ש-{::nomarkdown}\( q_{0}\in\hat{\delta}_{ND}\left(q_{0},w\right)\){:/nomarkdown}, הרי ש-{::nomarkdown}\( q_{0}\in\hat{\delta}_{EM}\left(q_{0},w\right)\){:/nomarkdown}, כלומר באוטומט עם מסעי ה-{::nomarkdown}\( \varepsilon\){:/nomarkdown} אפשר להגיע אל {::nomarkdown}\( q_{0}\){:/nomarkdown} על ידי קריאת {::nomarkdown}\( w\){:/nomarkdown}. כעת, מכיוון ש-{::nomarkdown}\( \varepsilon\in L\left(A_{EM}\right)\){:/nomarkdown} המשמעות של זה היא שבאותו אוטומט, קיימת סדרה של מסעי-{::nomarkdown}\( \varepsilon\){:/nomarkdown} שמובילה מ-{::nomarkdown}\( q_{0}\){:/nomarkdown} אל מצב מקבל כלשהו. לכן כדי לקבל את {::nomarkdown}\( w\){:/nomarkdown} באוטומט הזה קודם כל נקרא אותו בצורה שמעבירה אותנו ל-{::nomarkdown}\( q_{0}\){:/nomarkdown} בסוף הקריאה של אותיות {::nomarkdown}\( w\){:/nomarkdown}, ואז מבצעת עוד סדרה של מסעי-{::nomarkdown}\( \varepsilon\){:/nomarkdown} אל מצב מקבל.

זה מסיים את ההוכחה, והחל מהפוסט הבא נוכל להשתמש בחופשיות באוטומטים אי-דטרמיניסטיים עם מסעי-{::nomarkdown}\( \varepsilon\){:/nomarkdown} כדי לעשות דברים. רק תרגול אחד לסיום - נסו לקחת את האוטומט שמצויר לעיל ולסלק לו את מסעי ה-{::nomarkdown}\( \varepsilon\){:/nomarkdown}. הנה מה שאמור להתקבל:

<a href="http://www.gadial.net/wp-content/uploads/2014/11/diagram003.png"><img class="aligncenter size-full wp-image-3195" alt="diagram003" src="http://www.gadial.net/wp-content/uploads/2014/11/diagram003.png" width="460" height="192" /></a>
