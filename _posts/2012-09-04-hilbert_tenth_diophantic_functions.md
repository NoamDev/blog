---
id: 2172
title: "הבעיה העשירית של הילברט - פונקציות דיופנטיות וחיות אחרות (רקורסיביות)"
date: 2012-09-04 11:31:10
layout: post
categories: 
  - חישוביות
  - לוגיקה
  - תורת המספרים
tags: 
  - הבעיה העשירית של הילברט
  - פונקצהי פרימיטיבית רקורסיבית
  - פונקציה דיופנטית
  - פונקציה רקורסיבית
---
אנו ממשיכים בדרך שלנו אל ההוכחה שלא קיים אלגוריתם שפותר את הבעיה העשירית של הילברט. אני מניח שקראתם את <a href="http://www.gadial.net/2012/08/27/hilbert_tenth_intro/">פוסט המבוא</a> ולכן קופץ ישר לעניינים הפעם. המושג המרכזי בפוסט הקודם היה <strong>קבוצה דיופנטית</strong>. זוהי קבוצה {::nomarkdown}\( S=\left\{ \left(a_{1},\dots,a_{n}\right)\right\} \){:/nomarkdown} של {::nomarkdown}\( n\){:/nomarkdown}-יות של מספרים טבעיים חיוביים, כך שקיים פולינום {::nomarkdown}\( p\left(x_{1},\dots,x_{n},y_{1},\dots,y_{m}\right)\){:/nomarkdown} בעל התכונה הבאה: למשוואה הדיופנטית {::nomarkdown}\( q\left(y_{1},\dots,y_{m}\right)=0\){:/nomarkdown}, עבור {::nomarkdown}\( q\left(y_{1},\dots,y_{m}\right)=p\left(a_{1},\dots,a_{n},y_{1},\dots,y_{m}\right)\){:/nomarkdown} יש פתרון בשלמים חיוביים אם ורק אם {::nomarkdown}\( \left(a_{1},\dots,a_{n}\right)\in S\){:/nomarkdown}. אפשר גם לעשות ההפך - להתחיל מפולינום {::nomarkdown}\( p\left(x_{1},\dots,x_{n},y_{1},\dots,y_{m}\right)\){:/nomarkdown} ולסמן קבוצה {::nomarkdown}\( S_{p}\){:/nomarkdown} שכוללת את כל ה-{::nomarkdown}\( n\){:/nomarkdown}-יות שכאשר מציבים אותם במקום ה-{::nomarkdown}\( x\){:/nomarkdown}-ים, מקבלים משוואה דיופנטית עם פתרון בשלמים חיוביים.

אם לא הבנתם כלום ממה שכתבתי כרגע, נסו לקרוא שוב את המבוא.

בפוסט הקודם ראינו שאפשר להגדיר יחסים מוכרים באופן הזה, למשל את יחס החלוקה (שהוא קבוצת הזוגות {::nomarkdown}\( \left(a,b\right)\){:/nomarkdown} כך ש-{::nomarkdown}\( a\|b\){:/nomarkdown}, כלומר {::nomarkdown}\( a\){:/nomarkdown} מחלק את {::nomarkdown}\( b\){:/nomarkdown}, כלומר קיים {::nomarkdown}\( c\){:/nomarkdown} שלם כך ש-{::nomarkdown}\( b=ac\){:/nomarkdown}). בואו נראה לצורך החימום עוד דוגמה - היחס "קטן-שווה", הידוע גם כ-{::nomarkdown}\( a\le b\){:/nomarkdown}. נגדיר אותו באופן הבא:

{::nomarkdown}\( x\le y\iff\exists z\left(x+z-1=y\right)\){:/nomarkdown}

רגע, מה? מה הולך כאן? מה אלו הסימונים הללו? אני עובר לשיטה שבה מרטין דיוויס משתמש במאמר שלו כי היא אלגנטית וקצרה יותר. כאן הפולינום שלי הוא {::nomarkdown}\( p\left(x,y,z\right)=x+z-1-y\){:/nomarkdown}, והמשתנים שבהם צריך להציב ערכים הם {::nomarkdown}\( x,y\){:/nomarkdown} ואז לראות אם למשוואה הדיופנטית שנותרה לנו, שיש בה רק את המשתנה {::nomarkdown}\( z\){:/nomarkdown}, יש פתרון. די ברור בסימון של דיוויס מי המשתנים ששייכים לקבוצה הראשונה (אלו שבאגף שמאל של החצים) ומי המשתנים שבקבוצה השניה (אלו שיש סימן {::nomarkdown}\( \exists\){:/nomarkdown} - "קיים" לפניהם) והיכן הפולינום עצמו (מה שבסוגריים, עד כדי העברת אגפים אם יש צורך). אז אני מקווה שאנחנו מיודדים עם הסימון הזה כעת וגם מבינים למה הפולינום שלעיל אכן מגדיר את {::nomarkdown}\( x\le y\){:/nomarkdown}.

עכשיו, תרגיל - מה השתנה כאן?

{::nomarkdown}\( x&lt;y\iff\exists z\left(x+z=y\right)\){:/nomarkdown}

ולמה?

עכשיו בואו נעבור למשהו קצת יותר מתוחכם. ראינו כבר שיש פולינום {::nomarkdown}\( p_{1}\){:/nomarkdown} שמגדיר את הקבוצה {::nomarkdown}\( S_{p_{1}}=\left\{ \left(a,b\right)\ \|\ a\|b\right\} \){:/nomarkdown}. ראינו גם שיש פולינום {::nomarkdown}\( p_{2}\){:/nomarkdown} שמגדיר את הקבוצה {::nomarkdown}\( S_{p_{2}}=\left\{ \left(a,b\right)\ \|\ a\le b\right\} \){:/nomarkdown}. האם יש פולינום שמגדיר את הקבוצה {::nomarkdown}\( S=\left\{ \left(a,b\right)\ \|\ a\le b\wedge a\|b\right\} \){:/nomarkdown} ({::nomarkdown}\( \wedge\){:/nomarkdown} הוא הסימן של "וגם"; ו-{::nomarkdown}\( \vee\){:/nomarkdown} הוא הסימן של "או"), כלומר הקבוצה {::nomarkdown}\( S_{p_{1}}\cap S_{p_{2}}\){:/nomarkdown}? התשובה חיובית: הפולינום {::nomarkdown}\( p_{1}^{2}+p_{2}^{2}\){:/nomarkdown}. למה? כי אחרי הצבת ערכים בו, נשאר עם משוואה דיופנטית שהדרך היחידה שלה להתאפס היא שגם {::nomarkdown}\( p_{1}^{2}\){:/nomarkdown} יתאפס וגם {::nomarkdown}\( p_{2}^{2}\){:/nomarkdown} יתאפס (כי אם אחד מהם לא מתאפס, אז אחרי העלאה בריבוע הוא חיובי ולכן הסכום יהיה גדול מאפס). את העניין הזה אפשר כמובן להכליל לחיתוך על מספר סופי כלשהו של נחתכים. המסקנה: מחלקת הקבוצות הדיופנטיות סגורה לחיתוכים סופיים. ומה עם איחודים סופיים? גם אותם אפשר לקבל. הקבוצה {::nomarkdown}\( S_{p_{1}}\cup S_{p_{2}}\){:/nomarkdown} מוגדרת על ידי הפולינום {::nomarkdown}\( p_{1}p_{2}\){:/nomarkdown} - הוכיחו זאת לעצמכם.

אם אנחנו כבר עוסקים במשפטים "כלליים" על קבוצות דיופנטיות, הנה משפט מעניין במיוחד: קבוצה {::nomarkdown}\( S\){:/nomarkdown} של טבעיים חיוביים היא דיופנטית אם ורק אם קיים פולינום {::nomarkdown}\( p\){:/nomarkdown} כך ש-{::nomarkdown}\( S\){:/nomarkdown} היא בדיוק קבוצת הערכים <strong>החיוביים</strong> ש-{::nomarkdown}\( p\){:/nomarkdown} מחזיר (לכל קלט שהוא).

זה משפט מעניין למדי כי הוא מוציא מהתמונה לגמרי את עניין ה"בדוק אם משוואה דיופנטית כלשהי היא פתירה". כמובן שזה לא עושה את החיים קלים במיוחד - קודם, כדי לברר אם איבר כלשהו שייך לקבוצה, היה צריך להציב אותו בפולינום שהגדיר את הקבוצה ולקוות שאפשר יהיה להבין אם המשוואה הדיופנטית שנקבל היא פתירה או לא; עכשיו בכלל לא ברור מה אפשר לעשות חוץ מלהציב ערכים ב-{::nomarkdown}\( p\){:/nomarkdown} ולהתפלל שהאיבר שלנו יצוץ מתישהו או שנבין למה הוא לא יכול לצוץ אף פעם.

איך מוכיחים את המשפט? זה תרגיל נחמד. קחו רגע לחשוב עליו לפני שאתם קוראים את ההוכחה.

נתחיל מהכיוון הקל. נניח שיש לנו קבוצה {::nomarkdown}\( S\){:/nomarkdown} שמוגדרת על ידי {::nomarkdown}\( p\left(y_{1},\dots,y_{n}\right)\){:/nomarkdown} בדרך ה"חדשה" שתיארתי - {::nomarkdown}\( S\){:/nomarkdown} היא קבוצת הערכים החיוביים ש-{::nomarkdown}\( p\){:/nomarkdown} יכול להחזיר. אנחנו רוצים למצוא פולינום {::nomarkdown}\( q\){:/nomarkdown} כך ש-{::nomarkdown}\( S=S_{q}\){:/nomarkdown}, כאשר {::nomarkdown}\( S_{q}\){:/nomarkdown} מוגדרת בשיטה הישנה (ערכים שאחרי שמציבים אותם ב-{::nomarkdown}\( q\){:/nomarkdown} מקבלים משוואה דיופנטית פתירה). מה נגדיר? פשוט מאוד: {::nomarkdown}\( q\left(x,y_{1},\dots,y_{n}\right)=x-p\left(y_{1},\dots,y_{n}\right)\){:/nomarkdown}. ברור שכאשר {::nomarkdown}\( a\in S\){:/nomarkdown} אז {::nomarkdown}\( q\left(a,y_{1},\dots,y_{m}\right)\){:/nomarkdown}, שמגדיר את המשוואה {::nomarkdown}\( a=p\left(y_{1},\dots,y_{n}\right)\){:/nomarkdown} יהיה פתיר; וכמובן שאם {::nomarkdown}\( a=p\left(y_{1},\dots,y_{n}\right)\){:/nomarkdown} פתירה אז {::nomarkdown}\( a\in S\){:/nomarkdown}, ממש על פי הגדרה.

האתגר הוא הכיוון השני. נניח ש-{::nomarkdown}\( S_{q}\){:/nomarkdown} מוגדרת על ידי {::nomarkdown}\( q\){:/nomarkdown} בצורה ה"ישנה"; איך נמצא פולינום {::nomarkdown}\( p\){:/nomarkdown} שמגדיר אותה בצורה ה"חדשה"? ובכן, נניח ש-{::nomarkdown}\( a\in S\){:/nomarkdown}. אז {::nomarkdown}\( q\left(a,y_{1},\dots,y_{m}\right)\){:/nomarkdown} פתיר - אפשר לקבל ממנו אפס. לכן {::nomarkdown}\( p\left(y_{1},\dots,y_{m}\right)=a-q\left(a,y_{1},\dots,y_{m}\right)\){:/nomarkdown} הולך להחזיר {::nomarkdown}\( a\){:/nomarkdown} כאשר מציבים בו בדיוק את הערכים של ה-{::nomarkdown}\( y\){:/nomarkdown}-ים שמאפסים את {::nomarkdown}\( q\left(a,y_{1},\dots,y_{m}\right)\){:/nomarkdown}. אבל זה לא מספיק טוב, כי עבור ערכים שונים של ה-{::nomarkdown}\( y\){:/nomarkdown}-ים {::nomarkdown}\( q\){:/nomarkdown} לא בהכרח יתאפס ואז {::nomarkdown}\( a-q\left(a,y_{1},\dots,y_{m}\right)\){:/nomarkdown} יהיה מספר לא קשור. רק מה, צריך לזכור שמותר ל-{::nomarkdown}\( p\){:/nomarkdown} להחזיר מספרים לא קשורים, בתנאי שהם <strong>שליליים</strong> (או אפס) אז בואו נוודא שנחזיר מספר שלילי, פשוט על ידי כוח גס: {::nomarkdown}\( p\left(y_{1},\dots,y_{m}\right)=a\left(1-q^{2}\left(a,y_{1},\dots,y_{m}\right)\right)\){:/nomarkdown}. הבהירו לעצמכם למה הפולינום הזה עושה את העבודה.

אבל רגע, עוד לא סיימנו! הפולינום שלנו עושה את העבודה עבור ערך ספציפי של {::nomarkdown}\( a\){:/nomarkdown}, ואנחנו רוצים שהוא יעבוד לכל {::nomarkdown}\( a\){:/nomarkdown}. זו לא בעיה, כמובן: הפולינום ה"נכון" הוא {::nomarkdown}\( p\left(x,y_{1},\dots,y_{m}\right)=x\left(1-q^{2}\left(x,y_{1},\dots,y_{m}\right)\right)\){:/nomarkdown}, ועכשיו באמת סיימנו את הוכחת המשפט.

בואו נקפוץ לרגע לתוצאה שנובעת מהמשפט הזה, ומהטענה הכללית בהרבה (שהיא היעד הסופי שלנו בסדרת הפוסטים הזו) לפיה כל קבוצה הניתנת למניה רקורסיבית היא דיופנטית; בפרט הדבר נכון לקבוצת הראשוניים (כי יש אלגוריתם שבודק אם מספר הוא ראשוני או לא). לכן קיים פולינום {::nomarkdown}\( p\){:/nomarkdown}, כך שכאשר מציבים בו מספרים שלמים, הערכים החיוביים שמתקבלים הם <strong>בדיוק</strong> כל המספרים הראשוניים! התוצאה הזו היא הדבר הכי קרוב שאני מכיר ל"נוסחה עבור הראשוניים". יש אפילו בניות קונסטרוקטיביות של פולינום {::nomarkdown}\( p\){:/nomarkdown} כזה (שנראות די מפלצתיות ולא אציג כאן). עדיין, קשה להגיד שזו תוצאה שימושית במיוחד בגלל האופן האקראי משהו שבו מקבלים ראשוניים מתוך הנוסחה הזו - מציבים ערכים ב-{::nomarkdown}\( p\){:/nomarkdown} ומתפללים שיצא משהו חיובי. אף אחד לא ערב לכך שזה יקרה רוב הזמן, ושהראשוני שנמצא יהיה מעניין (כלומר, מתאים לאי-אלו קריטריונים שיש לנו). כמובן, "ראשוניים" כאן זה סתם בגלל שהראשוניים הם אחת מהקבוצות הפופולריות ביותר של מספרים טבעיים, אם לא הפופולרית מכולן.

הבנו קבוצות דיופנטיות? יפה. אז בואו נעבור לסוג מיוחד של קבוצה - פונקציה. פונקציה היא יחס - קבוצה של איברים מהצורה {::nomarkdown}\( \left(x_{1},\dots,x_{n},y\right)\){:/nomarkdown} - עם התכונה המיוחדת שלכל {::nomarkdown}\( x_{1},\dots,x_{n}\){:/nomarkdown} <strong>קיים</strong> {::nomarkdown}\( y\){:/nomarkdown} כך ש-{::nomarkdown}\( \left(x_{1},\dots,x_{n},y\right)\){:/nomarkdown} שייך לקבוצה, ואותו {::nomarkdown}\( y\){:/nomarkdown} הוא יחיד. חשבו על {::nomarkdown}\( \left(x_{1},\dots,x_{n}\right)\){:/nomarkdown} בתור "קלט" ועל {::nomarkdown}\( y\){:/nomarkdown} בתור "פלט" של הפונקציה. לרוב מסמנים פונקציה ב-{::nomarkdown}\( f\){:/nomarkdown}, ואז במקום לומר ש-{::nomarkdown}\( \left(x_{1},\dots,x_{n},y\right)\){:/nomarkdown} שייך לפונקציה, כותבים {::nomarkdown}\( f\left(x_{1},\dots,x_{n}\right)=y\){:/nomarkdown}. רובכם בוודאי יודעים את זה (אבל זכרו שלא כל מי שמכיר פונקציות גם מכיר את הגדרתן הפורמלית, התורת-קבוצתית).

ובכן, פונקציה היא דיופנטית אם כשהיא שמה עליה את הכובע של "קבוצה", היא קבוצה דיופנטית. <strong>שימו לב מה זה לא אומר</strong>! זה לא אומר שפונקציה דיופנטית היא בהכרח פולינום! לא, לא לא! למעשה, הדבר החשוב ביותר שנעשה בכל סדרת הפוסטים הזו יהיה להוכיח שהפונקציה האקספוננציאלית היא דיופנטית.

עכשיו אפשר לעצור לרגע ולראות את היעד הסופי שלנו. המטרה שלנו היא להוכיח שקבוצות דיופנטיות וקבוצות הניתנות למניה רקורסיבית הן אותו דבר. כדי לעשות את זה, אני צריך לתת הגדרה פורמלית ל"קבוצות הניתנות למניה רקורסיבית". ההגדרה הסטנדרטית היא באמצעות מכונות טיורינג, אבל לצורך שלנו הרבה יותר נוח יהיה להשתמש במודל חישובי אחר, כזה שהוא הרבה יותר דומה באופיו לפונקציות הדיופנטיות מלכתחילה - <strong>פונקציות רקורסיביות</strong>. התוצאה שאני חותר אליה היא שפונקציה היא רקורסיבית אם ורק אם היא דיופנטית; ראשית כל עלינו להבין, אם כן, מהי פונקציה רקורסיבית. נתחיל עם מה שלא: זו <strong>לא</strong> פונקציה ש"קוראת לעצמה"! המילה "רקורסיה" כאן קיימת מסיבות היסטוריות (ובקרוב נבין את המוטיבציה לה), אבל שם הרבה יותר מתאים לפונקציות רקורסיביות הוא פשוט "פונקציות ניתנות לחישוב".

מאיפה צצו הפונקציות הרקורסיביות? שאלה טובה. הן מופיעות במאמר המפורסם של קורט גדל שבו הוא הוכיח את משפטי אי השלמות שלו, וכבר הזכרתי אותן <a href="http://www.gadial.net/2009/05/10/godel_incompleteness_proof_sketch/">בפוסט שעסק בהוכחה</a> ולמיטב הבנתי גדל הוא זה שהמציא את הניסוח הזה שלהן, אבל אולי אני טועה. עם זאת, מה שהופיע במאמר של גדל לא היה שלם - היה חסר כלל אחד שהופיע רק מאוחר יותר, ואפרט על כך עוד מעט.

הפונקציות הרקורסיביות מוגדרות על ידי אוסף של פונקציות <strong>בסיס</strong> פשוטות ביותר, ש"ברור" לנו שאפשר לחשב אותן, ועוד כמה <strong>פעולות יצירה</strong> שמאפשרות ליצור פונקציות חדשות על בסיס פונקציות קיימות, וגם אותן "ברור" לנו שניתן לחשב. מה פשר ה"ברור" הזה? בימינו, זה אומר שאפשר לכתוב תוכנית מחשב שמבצעת את החישובים הללו. זה מראה שמחשבים מודרניים חזקים <strong>לפחות</strong> כמו פונקציות רקורסיביות - כל פונקציה רקורסיבית היא ניתנת לחישוב בידי מחשב מודרני. מצד שני, וזה הרבה יותר מפתיע, גם כל פונקציה שמחשב מודרני יכול לחשב היא רקורסיבית. כדי להוכיח את זה צריך לעבוד לא מעט ואני לא הולך לעשות זאת כאן (אבל יום אחד אני מקווה לעשות את זה).

כל הפונקציות הרקורסיביות הן פונקציות מהטבעיים החיוביים לטבעיים החיוביים; לכאורה זה קצת מגביל אותנו כי הרי מחשב יכול להתעסק גם במספרים שליליים ובדברים שהם בכלל לא מספרים, אבל מכיוון שהכל ניתן לקידוד בתור מספר טבעי חיובי (כל מידע שמיוצג במחשב, לא <strong>כל </strong>דבר בעולם!) זה לא באמת מפריע לנו.

הפונקציות הרקורסיביות הבסיסיות הן:
<ol>
	<li>הפונקציה הקבועה {::nomarkdown}\( c\left(x\right)=1\){:/nomarkdown}.</li>
	<li>פונקציית העוקב {::nomarkdown}\( s\left(x\right)=x+1\){:/nomarkdown}</li>
	<li>פונקצית ההטלה, {::nomarkdown}\( U_{i}^{n}\left(x_{1},\dots,x_{n}\right)=x_{i}\){:/nomarkdown} (המוגדרת לכל {::nomarkdown}\( n,i\){:/nomarkdown}).</li>
</ol>
טוב, עבור פונקציות הבסיס הללו לא קשה לראות שהן דיופנטיות. הפונקציה הראשונה מוגדרת על ידי:

{::nomarkdown}\( y=c\left(x\right)\iff\left(y=1\right)\){:/nomarkdown}

השניה מוגדרת על ידי:

{::nomarkdown}\( y=s\left(x\right)\iff\left(y=x+1\right)\){:/nomarkdown}

והשלישית מוגדרת על ידי:

{::nomarkdown}\( y=U_{i}^{n}\left(x_{1},\dots,x_{n}\right)\iff\left(y=x_{i}\right)\){:/nomarkdown}

טוב, זה היה מטופש למדי. איפה האתגר? בהמשך.

הפעולה הראשונה שממנה בונים פונקציות רקורסיביות חדשות מתוך הקיימות היא <strong>הרכבה</strong>. היא מוגדרת כך: אם {::nomarkdown}\( g_{1},\dots,g_{m}\){:/nomarkdown} הן פונקציות רקורסיביות על המשתנים {::nomarkdown}\( x_{1},\dots,x_{n}\){:/nomarkdown} ואילו {::nomarkdown}\( f\){:/nomarkdown} היא פונקציה רקורסיבית על {::nomarkdown}\( m\){:/nomarkdown} משתנים, אז הפונקציה {::nomarkdown}\( h\left(x_{1},\dots,x_{n}\right)=f\left(g_{1}\left(x_{1},\dots,x_{n}\right),\dots,g_{m}\left(x_{1},\dots,x_{n}\right)\right)\){:/nomarkdown} גם היא רקורסיבית. מה שאנחנו רוצים להראות הוא שאותו הדבר קורה עם פונקציות דיופנטיות, כלומר שאם {::nomarkdown}\( g_{1},\dots,g_{m},f\){:/nomarkdown} כולן דיופנטיות, כך גם {::nomarkdown}\( h\){:/nomarkdown}.

למרבה המזל, את זה קל להראות כבר עם מעט התכונות שראינו של פונקציות דיופנטיות:

{::nomarkdown}\( y=h\left(x_{1},\dots,x_{n}\right)\iff\exists t_{1},\dots,t_{m}\left(y=f\left(t_{1},\dots,t_{m}\right)\wedge t_{1}=g_{1}\left(x_{1},\dots,x_{n}\right)\wedge\dots\wedge t_{m}=g_{m}\left(x_{1},\dots,x_{n}\right)\right)\){:/nomarkdown}

מה בעצם עשינו כאן? אגף ימין מגדיר פולינום גדול, שמקבל בתור משתנים את {::nomarkdown}\( x_{1},\dots,x_{n}\){:/nomarkdown} וגם את המשתנים {::nomarkdown}\( t_{1},\dots,t_{m}\){:/nomarkdown}. עכשיו הוא לוקח את הפולינום שמגדיר את {::nomarkdown}\( f\){:/nomarkdown} (כשהמשתנים בו מתאימים ל-{::nomarkdown}\( t_{1},\dots,t_{m}\){:/nomarkdown} ו-{::nomarkdown}\( y\){:/nomarkdown}), את הפולינום שמגדיר את {::nomarkdown}\( g_{1}\){:/nomarkdown} (כשהמשתנים בו מתאימים ל-{::nomarkdown}\( x_{1},\dots,x_{n}\){:/nomarkdown} ו-{::nomarkdown}\( t_{1}\){:/nomarkdown}), את הפולינום שמגדיר את {::nomarkdown}\( g_{2}\){:/nomarkdown} (כבר הבנתם...?) וכן הלאה עד {::nomarkdown}\( g_{m}\){:/nomarkdown}, ואז מחבר את הריבועים של כולם (זו מהות ה-{::nomarkdown}\( \wedge\){:/nomarkdown} שעושים על כולם).

כן, זה כבר לא מובן מאליו, וזה יסתבך בהמשך. לכן כדאי לנקוט גישה קצת יותר כללית לעניין הזה. אפשר לגייס כאן את הלוגיקה המתמטית לעזרתנו; הרי מה שעשינו לעיל הוא פשוט לכתוב פסוק מסויים ב<a href="http://www.gadial.net/2012/06/17/first_order_logic/">לוגיקה מסדר ראשון</a> שאיכשהו מובטח לנו שהוא מגדיר פונקציה דיופנטית. הפסוק הזה הכיל סימנים לפונקציות דיופנטיות, את סימן השוויון, את סימן ה"וגם" ואת סימן ה"קיים". האם אפשר להשתמש בעוד דברים? כן, וחיזוק ה"שפה" שלנו הוא היעד הטכני המרכזי שלנו. ארחיב על כל זה בצורה מסודרת כשהזמן יגיע.

לבינתיים, הבה ונראה את הפעולה השניה שמשמשת לבנית פונקציות רקורסיביות: <strong>רקורסיה פרימיטיבית</strong>. מכאן הגיע השם "רקורסיבי" לפונקציות הללו (כי אצל גדל זו הייתה פעולת הבניה החשובה באמת, שנתנה למחלקת הפונקציות הזו את המורכבות שלה). זו לא פעולה קלה לעיכול מבחינה פורמלית, אבל הרעיון הבסיסי פשוט: אנחנו מגדירים פונקציה באמצעות ערכים קטנים יותר שלה. זה הכל.

רקורסיה פרימיטיבית מוגדרת כך: בהינתן פונקציה רקורסיבית {::nomarkdown}\( f\){:/nomarkdown} על {::nomarkdown}\( n\){:/nomarkdown} משתנים ("תנאי ההתחלה"), ופונקציה רקורסיבית {::nomarkdown}\( g\){:/nomarkdown} על {::nomarkdown}\( n+2\){:/nomarkdown} משתנים ("צעד הרקורסיה"), אנחנו מגדירים פונקציה חדשה, {::nomarkdown}\( h\){:/nomarkdown}, על {::nomarkdown}\( n+1\){:/nomarkdown} משתנים (שעליהם כדאי לחשוב כך: {::nomarkdown}\( n\){:/nomarkdown} המשתנים הראשונים הם "פרמטרים" קבועים ואילו המשתנה האחרון הוא מה שעליו מוגדרת הרקורסיה), באופן הבא:

{::nomarkdown}\( h\left(x_{1},\dots,x_{n},1\right)=f\left(x_{1},\dots,x_{n}\right)\){:/nomarkdown}

{::nomarkdown}\( h\left(x_{1},\dots,x_{n},t+1\right)=g\left(t,h\left(x_{1},\dots,x_{n},t\right),x_{1},\dots,x_{n}\right)\){:/nomarkdown}

מה קורה כאן? הערך של {::nomarkdown}\( h\){:/nomarkdown} ב"התחלה", כשהמשתנה האחרון הוא 1, נקבע על ידי הפרמטרים ופונקצית תנאי ההתחלה. בהמשך, הערך של {::nomarkdown}\( h\){:/nomarkdown} עבור ערך כלשהו של המשתנה האחרון נקבע על ידי {::nomarkdown}\( g\){:/nomarkdown}, כשהיא מביאה בחשבון את הערך הקודם של המשתנה האחרון, הערך ש-{::nomarkdown}\( h\){:/nomarkdown} החזירה על הערך הקודם הזה, והפרמטרים. זה נראה קצת מפחיד אבל זה לא באמת נורא.

איך מראים שהפעולה הזו משמרת דיופנטיות? או, זה כבר קצת מסובך. למרבה המזל, אפשר לשאוב השראה מקורט גדל עצמו; במאמר שלו הוא הוכיח שאפשר להגדיר את הפעולה הזו בשפה מסדר ראשון מסויימת; למרות שהשפה שלנו היא קצת שונה, אפשר יהיה לשאוב השראה ורעיונות מהטכניקות שלו. את זה נעשה בפוסט המשך; לעת עתה בואו נחשוב על נסיון נאיבי ואיך הוא נכשל:

{::nomarkdown}\( y=h\left(x_{1},\dots,x_{n},z\right)\iff\exists t_{1},t_{2},\dots,t_{z}(t_{1}=f\left(x_{1},\dots,x_{n}\right)\wedge\){:/nomarkdown}

{::nomarkdown}\( \wedge t_{2}=g\left(1,t_{1},x_{1},\dots,x_{n}\right)\wedge t_{3}=g\left(2,t_{2},x_{1},\dots,x_{n}\right)\wedge\dots\){:/nomarkdown}

{::nomarkdown}\( \wedge t_{z}=g\left(z-1,t_{z-1},x_{1},\dots,x_{n}\right)\wedge y=t_{z})\){:/nomarkdown}

מה הולך כאן? אנחנו אומרים ש-{::nomarkdown}\( y=h\left(x_{1},\dots,x_{n},z\right)\){:/nomarkdown} רק אם קיימת <strong>סדרה</strong> {::nomarkdown}\( t_{1},\dots,t_{z}\){:/nomarkdown} שהאיבר הראשון בה הוא {::nomarkdown}\( f\left(x_{1},\dots,x_{n}\right)\){:/nomarkdown} - הערך ההתחלתי הנכון, בהינתן הפרמטרים - וכל איבר בה נובע מקודמו על ידי {::nomarkdown}\( g\){:/nomarkdown}, וכמו כן האיבר האחרון הוא {::nomarkdown}\( y\){:/nomarkdown}. מבחינה רעיונית הכל נכון; הבעיה היא סינטקטית - הפסוק שכתבתי כאן לא מתאים ל"שפה" שהצגתי עד כה, מה שאומר שעל פניו לא ברור אם אפשר איכשהו לתרגם אותו חזרה לפולינום שמגדיר פונקציה דיופנטית. בעיה מהותית אחת היא שאורך הפסוק <strong>אינו קבוע</strong>! הוא תלוי ב-{::nomarkdown}\( z\){:/nomarkdown}, כי ככל ש-{::nomarkdown}\( z\){:/nomarkdown} יותר גדול, יש יותר משתנים {::nomarkdown}\( t_{1},\dots,t_{z}\){:/nomarkdown}. אם עבור ערכים שונים של {::nomarkdown}\( z\){:/nomarkdown} יש פסוקים שונים, זה אומר שגם יהיו פולינומים שונים, אבל אנחנו צריכים פולינום יחיד שמטפל <strong>בכל</strong> {::nomarkdown}\( z\){:/nomarkdown}. לכן הבניה הזו לא מוצלחת ונזדקק לפיתוח של כלי טכני חדש - פונקציה דיופנטית שמסוגלת לקודד סדרות שרירותיות - על מנת להציע בניה טובה יותר, וגם זה לא יספיק לנו. אבל על כך נדבר בהמשך.

בואו נסיים את הצגת הפונקציות הרקורסיביות עם פעולת היצירה האחרונה. הפעולה הזו לא הופיעה במאמר של גדל; גדל לא נזקק לה לצורך משפטי אי השלמות. הצורך בה צץ רק כאשר החלו לחשוב על הפונקציות הרקורסיביות כמתארות את "כל מה שניתן לחשב", שכן קיימות פונקציות שבבירור ניתן לחשב אותן (כלומר, קיים אלגוריתם שעושה זאת) אבל הן אינן ניתנות לייצור באמצעות כללי היצירה שהראיתי עד כה. בעתיד אני מקווה להראות את הדוגמה הקלאסית ביותר - <strong>פונקציית אקרמן</strong>, שגדלה "מהר מדי" מכדי שתהיה ניתנת לתיאור באמצעות כללי היצירה הנוכחיים.

אם כן, פונקציות שניתנות ליצירה באמצעות כללי היצירה הנוכחיים מתוך פונקציות הבסיס נקראות <strong>פונקציות פרימיטיביות רקורסיביות</strong>, וקיימות פונקציות ניתנות לחישוב שאינן פרימיטיביות רקורסיביות. הכלל שפותר את הבעיה הזו הוא כלל שמאפשר לבצע "חיפוש בלתי חסום": אם נתונות פונקציות רקורסיביות {::nomarkdown}\( f,g\){:/nomarkdown} על {::nomarkdown}\( n+1\){:/nomarkdown} משתנים, אז מוגדרת באמצעותן פונקציה רקורסיבית {::nomarkdown}\( h\){:/nomarkdown} על {::nomarkdown}\( n\){:/nomarkdown} משתנים באופן הבא:

{::nomarkdown}\( h\left(x_{1},\dots,x_{n}\right)=\min_{y}\left(f\left(x_{1},\dots,x_{n},y\right)=g\left(x_{1},\dots,x_{n},y\right)\right)\){:/nomarkdown}

כמקודם, חשבו על {::nomarkdown}\( x_{1},\dots,x_{n}\){:/nomarkdown} בתור "פרמטרים". אחרי שקבענו אותם, אנחנו יכולים לחפש את ה-{::nomarkdown}\( y\){:/nomarkdown} המינימלי שעבורו {::nomarkdown}\( f\){:/nomarkdown} תהיה שווה ל-{::nomarkdown}\( g\){:/nomarkdown}, וזה הערך ש-{::nomarkdown}\( h\){:/nomarkdown} תחזיר על אותם פרמטרים. אלא שכאן מייד צצה השאלה הפשוטה - מה קורה אם בכלל לא קיים {::nomarkdown}\( y\){:/nomarkdown} כזה? התשובה היא שבמקרה זה {::nomarkdown}\( h\){:/nomarkdown} תהיה <strong>לא מוגדרת</strong> על הקלט. מרגע שהכנסו את הכלל החדש הזה, שנקרא <strong>כלל המינימיזציה</strong> לתמונה, גרמנו לכך שקבוצת הפונקציות הרקורסיביות תכלול גם פונקציות <strong>חלקיות</strong>, כאלו שלא מוגדרות לכל הקלטים (ולמעשה, אפילו הפונקציה שאינה מוגדרת לאף קלט היא רקורסיבית; פשוט קחו את {::nomarkdown}\( f\){:/nomarkdown} להיות הפונקציה שמחזירה תמיד 1 ואת {::nomarkdown}\( g\){:/nomarkdown} להיות הפונקציה שמחזירה תמיד 2). מה שמעניין כאן הוא שפונקציית אקרמן שהזכרתי לעיל כן מוגדרת לכל קלט, כלומר כלל המינימיזציה הכרחי כדי שנוכל "לתפוס" את כל הפונקציות הניתנות לחישוב שמוגדרות לכל קלט; זה לא שהוספנו אותו רק כדי להיות מסוגלים לטפל בפונקציות חלקיות.

טוב, אז הבנו בערך מה זה הכלל הזה; איך אפשר להראות שאם {::nomarkdown}\( f,g\){:/nomarkdown} דיופנטיות, כך גם {::nomarkdown}\( h\){:/nomarkdown}?

שוב, מבחינה רעיונית הפסוק שמגדיר את התכונה הזו אינו מסובך:

{::nomarkdown}\( y=h\left(x_{1},\dots,x_{n}\right)\iff f\left(x_{1},\dots,x_{n},y\right)=g\left(x_{1},\dots,x_{n},y\right)\wedge\){:/nomarkdown}

{::nomarkdown}\( \wedge\forall t\left(t&lt;y\to f\left(x_{1},\dots,x_{n},y\right)\ne g\left(x_{1},\dots,x_{n},y\right)\right)\){:/nomarkdown}

אבל שימו לב לשימוש ב-{::nomarkdown}\( \forall\){:/nomarkdown} ("לכל") כאן. אני כבר יכול לומר ש<strong>אין שום סיכוי</strong> שבשפה שלנו נוכל להשתמש ב-{::nomarkdown}\( \forall\){:/nomarkdown} בצורה חופשית ועדיין לקוות שאפשר יהיה לתרגם את הסיפור חזרה לפונקציה דיופנטית. מה שכן נוכל לעשות - וזה לב ליבה של המטרה הטכנית שלנו - הוא להשתמש ב-{::nomarkdown}\( \forall\){:/nomarkdown} <strong>חסום</strong>, כלומר במקום לומר "לכל {::nomarkdown}\( t\){:/nomarkdown}", לומר "לכל {::nomarkdown}\( t\){:/nomarkdown} שקטן מ-{::nomarkdown}\( y\){:/nomarkdown}", שזה בדיוק מה שאנחנו צריכים כאן, בעצם.

אם כן, עכשיו היעדים הטכניים שלנו קצת יותר ברורים. יש לנו שתי פעולות יצירה שאנחנו רוצים להוכיח שמשמרות דיופנטיות של פונקציות. האופן הטכני שבו נעשה זאת הוא להגדיר שפה מסדר ראשון מסויימת, שבה מותר להשתמש בקבוצה מאוד מוגדרת ומדויקת של סימנים, כך שכל פונקציה שמוגדרת באמצעות השפה הזו היא אוטומטית דיופנטית. כדי שהשפה הזו תהיה חזקה אנחנו מוסיפים לה שני כלי עבודה מרכזיים - האחד הוא פונקציה לקידוד סדרות סופיות, והשני הוא כמת "לכל" חסום. בשביל לטפל בפונקציה לקידוד סדרות סופיות יש להשתמש במשפט מתמטי נפוץ שחביב עלי מאוד - <strong>משפט השאריות הסיני</strong>, ולכן אקדיש לו את הפוסט הבא.
