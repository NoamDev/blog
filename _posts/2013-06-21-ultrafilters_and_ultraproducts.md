---
id: 2589
title: "על על-מסננים ועל-מכפלות"
date: 2013-06-21 09:50:52
layout: post
categories: 
  - לוגיקה
  - תורת הקבוצות
tags: 
  - מסננים
  - משפט הקומפקטיות
  - על-מכפלות
  - תורת המודלים
---
אני רוצה להציג הפעם שני מושגים יחסית מופשטים, עם שימושים נרחבים בתורת הקבוצות, בטופולוגיה ובלוגיקה (ובעוד מקומות) - על-מסננים (אולטרה פילטרים באנגלית) ועל-מכפלות. אבל אציג את המושגים הללו באופן קצת יותר כללי, בתור מקרים פרטיים של מסננים ומכפלות מצומצמות. תצטרכו להמתין טיפה בסבלנות לפני שיהיה ברור למה הנושאים הללו מגניבים; ההקשר הנוכחי הוא ההוכחה שהתחלתי <a href="http://www.gadial.net/2013/06/15/p_vs_np_on_abelian_groups_intro/">בפוסט הקודם</a> לפיה {::nomarkdown}\( \mbox{P}\ne\mbox{NP}\){:/nomarkdown} מעל חבורות אבליות אינסופיות, אבל את השימוש הזה נראה רק בפוסט המשך; עם זאת, גם בפוסט הזה אני מתכנן להראות כמה דברים נחמדים.

בשביל להבין את המושגים הבסיסיים מספיק להכיר את תורת הקבוצות האלמנטרית, אבל בשביל הלהטוטים שאעשה לקראת הסוף כבר צריך להכיר לוגיקה מסדר ראשון, שלמרבה המזל כבר <a href="http://www.gadial.net/2012/06/17/first_order_logic/">הצגתי בבלוג בעבר</a>. בואו ניגש לאקשן.

הרעיון שמאחורי <strong>מסנן</strong> הוא זה: נתונה לנו קבוצה {::nomarkdown}\( X\){:/nomarkdown} כלשהי - ה"עולם" שלנו, למשל המספרים הטבעיים. ל-{::nomarkdown}\( X\){:/nomarkdown} יש המוני תת-קבוצות (כבר עבור הטבעיים יש מספר לא בן מניה של תת-קבוצות) ועל הקבוצות הללו יש מעין "היררכייה" - {::nomarkdown}\( A\){:/nomarkdown} נמצאת "מעל" {::nomarkdown}\( B\){:/nomarkdown} בהיררכייה אם {::nomarkdown}\( B\subseteq A\){:/nomarkdown}. זה נותן לנו תחושה ש-{::nomarkdown}\( A\){:/nomarkdown} "גדולה יותר" מ-{::nomarkdown}\( B\){:/nomarkdown} במובן מסויים. מה שמסנן עושה הוא לאפיין אוסף כלשהו של תת-קבוצות של {::nomarkdown}\( X\){:/nomarkdown} שהן "גדולות" או "גבוהות בהיררכייה". כמובן שעל אותה קבוצה אפשר להגדיר הרבה מסננים, ובכך לתת הרבה משמעויות ל"קבוצות גדולות" שכאלו.

אז איך מוגדר מסנן? פורמלית, זו קבוצה לא ריקה {::nomarkdown}\( D\subseteq2^{X}\){:/nomarkdown} (אוסף של תת-קבוצות של {::nomarkdown}\( X\){:/nomarkdown}) שלא כוללת את הקבוצה הריקה וסגורה לחיתוך ולהכלה כלפי מעלה. פורמלית:
<ol>
	<li>{::nomarkdown}\( \emptyset\notin D\){:/nomarkdown} ו-{::nomarkdown}\( X\in D\){:/nomarkdown}.</li>
	<li>אם {::nomarkdown}\( B\subseteq A\){:/nomarkdown} ו-{::nomarkdown}\( B\in D\){:/nomarkdown} אז גם {::nomarkdown}\( A\in D\){:/nomarkdown}.</li>
	<li>אם {::nomarkdown}\( A,B\in D\){:/nomarkdown} אז גם {::nomarkdown}\( A\cap B\in D\){:/nomarkdown}.</li>
</ol>
שימו לב לכך ש-{::nomarkdown}\( X\in D\){:/nomarkdown} נובע מההנחה ש-{::nomarkdown}\( D\){:/nomarkdown} לא ריקה ומתכונה 2, ולכן פשוט דרשתי {::nomarkdown}\( X\in D\){:/nomarkdown} במפורש במקום לומר ש-{::nomarkdown}\( D\){:/nomarkdown} לא ריקה.

ההגדרה מייד מעלה תהיה - למה דווקא התכונות הללו? אפשר עוד להבין את זה שהקבוצה הריקה לא בפנים (אם היא "גדולה", מי לא?) ואת זה ש-{::nomarkdown}\( X\){:/nomarkdown} בפנים (אם היא לא "גדולה", מי כן?) וגם הכלה כלפי מעלה נראית סבירה; אבל חיתוך? המממ. האינטואיציה היא שאם קבוצה היא <strong>ממש</strong> גדולה, אז גם לחתוך אותה עם קבוצה גדולה אחרת לא יוכל לקלקל את זה יותר מדי. כדי לקבל את התחושה כדאי לראות תכף ומייד דוגמאות. אז ניקח קבוצה <strong>אינסופית</strong> {::nomarkdown}\( X\){:/nomarkdown} ונתהה האם אנחנו מסוגלים למצוא מסנן מעל {::nomarkdown}\( X\){:/nomarkdown}. די בבירור {::nomarkdown}\( D=\left\{ X\right\} \){:/nomarkdown} הוא מסנן, אבל טריוויאלי לגמרי ולכן לא מעניין. אז הנה מסנן יותר מעניין: {::nomarkdown}\( D\){:/nomarkdown} יהיה קבוצת כל הקבוצות שהן <strong>קו-סופיות</strong>. קבוצה היא קו-סופית אם <strong>המשלימה</strong> שלה היא סופית, כלומר אם יש בה את כל האיברים ב-{::nomarkdown}\( X\){:/nomarkdown} פרט למספר סופי של איברים. פורמלית, {::nomarkdown}\( D=\left\{ A\subseteq X\ \|\ \overline{A}&lt;\infty\right\} \){:/nomarkdown} ({::nomarkdown}\( \overline{A}\){:/nomarkdown} הוא סימון פשוט יותר ל-{::nomarkdown}\( X\backslash A\){:/nomarkdown}).

זה בוודאי מתאים לתחושה האינטואיטיבית שלנו של "גודל"; האם זה מקיים את האקסיומות? ובכן, בבירור אקסיומה 1 מתקיימת; גם אקסיומה 2 די פשוטה, שהרי אם {::nomarkdown}\( B\subseteq A\){:/nomarkdown} אז {::nomarkdown}\( \overline{A}\subseteq\overline{B}\){:/nomarkdown}, כלומר ב-{::nomarkdown}\( \overline{A}\){:/nomarkdown} יש עוד פחות איברים מאשר ב-{::nomarkdown}\( \overline{B}\){:/nomarkdown} הסופית, ולכן גם היא סופית בעצמה. ומה באשר לחיתוך? ובכן, כאן נחלצים כללי דה-מורגן לעזרתנו: {::nomarkdown}\( \overline{A\cap B}=\overline{A}\cup\overline{B}\){:/nomarkdown}. האיחוד של שתי קבוצות סופיות גם הוא סופי, כי גודלו חסום על ידי סכום הגדלים של הקבוצות: {::nomarkdown}\( \left\|\overline{A\cap B}\right\|=\left\|\overline{A}\cup\overline{B}\right\|\le\left\|\overline{A}\right\|+\left\|\overline{B}\right\|\){:/nomarkdown} ולכן {::nomarkdown}\( A\cap B\){:/nomarkdown} גם היא קבוצה קו-סופית. הנה לנו דוגמה לא טריוויאלית למסנן, שנקראת <strong>מסנן פרשה</strong>.

בואו נראה דוגמה אחרת. נניח ש-{::nomarkdown}\( A\subseteq X\){:/nomarkdown} היא תת-קבוצה לא ריקה כלשהי של {::nomarkdown}\( X\){:/nomarkdown}. נניח שהחלטנו לראות את {::nomarkdown}\( A\){:/nomarkdown} בתור קבוצה "גדולה", כלומר אנחנו בונים מסנן כך ש-{::nomarkdown}\( A\in D\){:/nomarkdown}. אוטומטית נובע מכך ש-{::nomarkdown}\( D\){:/nomarkdown} חייב לכלול את כל הקבוצות שמכילות את {::nomarkdown}\( A\){:/nomarkdown}. האם זה לכשעצמו מספיק כדי ליצור מסנן? בהחלט: {::nomarkdown}\( D=\left\{ B\subseteq X\ \|\ A\subseteq B\right\} \){:/nomarkdown} הוא בבירור מסנן - קל לבדוק ש-3 האקסיומות מתקיימות. מסנן כזה - שמתקבל מלקיחת כל הקבוצות שמכילות קבוצה נתונה {::nomarkdown}\( A\){:/nomarkdown} - נקרא <strong>מסנן ראשי</strong> (מי שבקיאים בתורת החוגים ודאי יזכרו כעת במושג של <strong>אידאל ראשי</strong> שהוא דומה מאוד - זה אידאל שנוצר על ידי איבר יחיד). האם כל מסנן הוא ראשי? ובכן, דרך פשוטה לבדוק זאת היא זו: לוקחים מסנן {::nomarkdown}\( D\){:/nomarkdown} ומסתכלים על {::nomarkdown}\( \bigcap D\){:/nomarkdown} - החיתוך של <strong>כל</strong> הקבוצות במסנן. אם {::nomarkdown}\( D\){:/nomarkdown} הוא ראשי אנחנו מצפים לקבל את {::nomarkdown}\( A\){:/nomarkdown} - הקבוצה שממנה {::nomarkdown}\( D\){:/nomarkdown} נבנה. אם קיבלנו, למשל, קבוצה ריקה, אז {::nomarkdown}\( D\){:/nomarkdown} אינו ראשי. קל לראות שמסנן פרשה הוא לא ראשי, בדיוק בצורה הזו (כי למשל, לכל {::nomarkdown}\( a\in X\){:/nomarkdown}, הקבוצה {::nomarkdown}\( A=X\backslash\left\{ a\right\} \){:/nomarkdown} שייכת ל-{::nomarkdown}\( D\){:/nomarkdown}, אבל החיתוך של כולן הוא ריק).

לעומת זאת, אם {::nomarkdown}\( X\){:/nomarkdown} סופית ו-{::nomarkdown}\( D\){:/nomarkdown} הוא מסנן מעל {::nomarkdown}\( X\){:/nomarkdown}, אז {::nomarkdown}\( \bigcap D\){:/nomarkdown} הוא חיתוך של מספר סופי של קבוצות ולכן באינדוקציה אפשר להראות ש-{::nomarkdown}\( \bigcap D\in D\){:/nomarkdown}, ומכאן ש-{::nomarkdown}\( D=\left\{ B\subseteq X\ \|\ \bigcap D\subseteq B\right\} \){:/nomarkdown}. כלומר, במובן מסויים כל המסננים מעל קבוצות סופיות הם פשוטים, ואנחנו יודעים בדיוק איך הם נראים. לכן אנחנו מדברים על מסננים בהקשר של קבוצות אינסופיות, ומעתה והלאה {::nomarkdown}\( X\){:/nomarkdown} תמיד יהיה קבוצה אינסופית.

משחק החיתוכים הזה עשוי לעורר שאלה אחרת - נניח שיש לנו "מועמד למסנניות" {::nomarkdown}\( S\subseteq2^{X}\){:/nomarkdown} - אוסף כלשהו של תת-קבוצות של {::nomarkdown}\( X\){:/nomarkdown} שאנחנו מקווים שיהיה מסנן. מן הסתם הוא לא תמיד יהיה מסנן כי עשויות להיות חסרות בו קבוצות - למשל, ייתכן ש-{::nomarkdown}\( S\){:/nomarkdown} קבוצה {::nomarkdown}\( A\){:/nomarkdown} שיש קבוצה שמכילה אותה ואינה ב-{::nomarkdown}\( S\){:/nomarkdown}; או שיש שתי קבוצות ב-{::nomarkdown}\( S\){:/nomarkdown} שהחיתוך שלהן לא ב-{::nomarkdown}\( S\){:/nomarkdown}; התחושה היא שאפשר יהיה "לתקן" את זה על ידי הוספת עוד קבוצות - <strong>להרחיב</strong> את {::nomarkdown}\( S\){:/nomarkdown} עד שנקבל מסנן. אבל האם תמיד אפשר לעשות את זה?

זכרו שאסור שהקבוצה הריקה תהיה שייכת למסנן {::nomarkdown}\( D\){:/nomarkdown}. אז אם {::nomarkdown}\( \emptyset\in S\){:/nomarkdown} ברור שלא משנה כמה נרחיב את {::nomarkdown}\( S\){:/nomarkdown} - מסנן כבר לא נקבל. אבל האם אם {::nomarkdown}\( \emptyset\notin S\){:/nomarkdown} אנחנו בסדר? לא בהכרח; הכי נצטרך לוודא ש-{::nomarkdown}\( S\){:/nomarkdown} סגורה לחיתוך. סגירות לחיתוך שתי קבוצות גוררת סגירות לחיתוך מספר <strong>סופי</strong> כלשהו של קבוצות, ולכן אנחנו חייבים לדרוש שלכל סדרה סופית של קבוצות {::nomarkdown}\( A_{1},A_{2},\dots,A_{n}\in S\){:/nomarkdown} יתקיים {::nomarkdown}\( \bigcap A_{i}\ne\emptyset\){:/nomarkdown}. התכונה הזו - חיתוך כל מספר סופי של איברים של {::nomarkdown}\( S\){:/nomarkdown} הוא לא ריק - נקראת <strong>תכונת החיתוכים הסופיים</strong> והיא מככבת גם בטופולוגיה; במקרה שלנו, מסתבר שהיא לא רק הכרחית לכך ש-{::nomarkdown}\( S\){:/nomarkdown} תהיה ניתנת להרחבה למסנן אלא גם מספיקה: אם {::nomarkdown}\( S\){:/nomarkdown} מקיימת את תכונת החיתוכים הסופיים, אז קיים מסנן {::nomarkdown}\( D\){:/nomarkdown} שמכיל את {::nomarkdown}\( S\){:/nomarkdown}.

איך בונים את {::nomarkdown}\( D\){:/nomarkdown}? הבניה גם כן באה בצורה טבעית למדי. ברור שנצטרך להכניס ל-{::nomarkdown}\( D\){:/nomarkdown} את {::nomarkdown}\( S\){:/nomarkdown}, ולכן גם כל חיתוך סופי של איברים מ-{::nomarkdown}\( S\){:/nomarkdown} (כי אקסיומה 3), ולכן גם כל קבוצה שמכילה חיתוך סופי של איברים מ-{::nomarkdown}\( S\){:/nomarkdown} (כי אקסיומה 2), אז בואו ננסה להגדיר את {::nomarkdown}\( D\){:/nomarkdown} כך:

{::nomarkdown}\( D=\left\{ A\subseteq X\ \|\ \exists A_{1},\dots,A_{n}\in S:\bigcap A_{i}\subseteq A\right\} \){:/nomarkdown}

לא קשה להראות ש-{::nomarkdown}\( D\){:/nomarkdown} הוא מסנן; התכונה המאתגרת היא 3, וגם היא פשוטה למדי (אם {::nomarkdown}\( \bigcap A_{i}\subseteq A\){:/nomarkdown} ו-{::nomarkdown}\( \bigcap B_{i}\subseteq B\){:/nomarkdown} אז {::nomarkdown}\( \bigcap A_{i}\cap\bigcap B_{i}\subseteq A\cap B\){:/nomarkdown}). מה שנחמד הוא ש-{::nomarkdown}\( D\){:/nomarkdown} הוא המסנן <strong>הקטן ביותר</strong> שמכיל את {::nomarkdown}\( S\){:/nomarkdown}; פורמלית, {::nomarkdown}\( D\){:/nomarkdown} הוא חיתוך כל המסננים שמכילים את {::nomarkdown}\( S\){:/nomarkdown} (והנה אתגר חדש: להוכיח שחיתוך של מספר כלשהו של מסננים הוא בעצמו מסנן, וש-{::nomarkdown}\( D\){:/nomarkdown} הוא אכן החיתוך הזה). אומרים ש-{::nomarkdown}\( D\){:/nomarkdown} הוא המסנן ש<strong>נוצר</strong> על ידי {::nomarkdown}\( S\){:/nomarkdown}.

עכשיו משהתוודענו קצת למסננים, בואו נעבור לתקל שאלה אחרת - כמה גדול מסנן יכול להיות? נניח שיש לנו מסנן {::nomarkdown}\( D\){:/nomarkdown} ואנחנו רוצים להגדיל אותו ככל הניתן, למסנן "גדול ביותר" {::nomarkdown}\( U\){:/nomarkdown}. מה אפשר להוסיף ל-{::nomarkdown}\( D\){:/nomarkdown}? ובכן, ברור מה <strong>אי אפשר</strong> להוסיף ל-{::nomarkdown}\( D\){:/nomarkdown}: אם {::nomarkdown}\( A\in D\){:/nomarkdown} אז בשום פנים ואופן אי אפשר להוסיף ל-{::nomarkdown}\( D\){:/nomarkdown} את {::nomarkdown}\( \overline{A}\){:/nomarkdown}, כי אחרת נקבל ש-{::nomarkdown}\( A\cap\overline{A}=\emptyset\in U\){:/nomarkdown}. לכן כל מסנן {::nomarkdown}\( U\){:/nomarkdown} שמכיל את {::nomarkdown}\( D\){:/nomarkdown} חייב לקיים את התכונה שלכל קבוצה {::nomarkdown}\( A\in X\){:/nomarkdown}, לא ייתכן שגם {::nomarkdown}\( A\in U\){:/nomarkdown} וגם {::nomarkdown}\( \overline{A}\in U\){:/nomarkdown}. אם זה הדבר <strong>היחיד</strong> שמגביל את {::nomarkdown}\( U\){:/nomarkdown}, כלומר אם <strong>לכל</strong> {::nomarkdown}\( A\in X\){:/nomarkdown} או שמתקיים {::nomarkdown}\( A\in U\){:/nomarkdown} או שמתקיים {::nomarkdown}\( \overline{A}\in U\){:/nomarkdown}, אומרים ש-{::nomarkdown}\( U\){:/nomarkdown} הוא <strong>על-מסנן</strong>.

את הדיון הזה נהוג לפרמל באופן הבא: מסנן {::nomarkdown}\( U\){:/nomarkdown} הוא על-מסנן אם ורק אם {::nomarkdown}\( U\){:/nomarkdown} הוא מקסימלי, כלומר לא קיים מסנן {::nomarkdown}\( U^{\prime}\){:/nomarkdown} כך ש-{::nomarkdown}\( U\subset U^{\prime}\){:/nomarkdown} (הכלה ממש). הכיוון של "אם {::nomarkdown}\( U\){:/nomarkdown} הוא על-מסנן אז הוא מקסימלי" הוא ברור ועליו כבר דיברנו - אם {::nomarkdown}\( U\subset U^{\prime}\){:/nomarkdown} אז יש {::nomarkdown}\( A\in U^{\prime}\){:/nomarkdown} כך ש-{::nomarkdown}\( A\notin U\){:/nomarkdown}, ומכיוון ש-{::nomarkdown}\( U\){:/nomarkdown} הוא על-מסנן אז {::nomarkdown}\( \overline{A}\in U\){:/nomarkdown} ולכן {::nomarkdown}\( A\cap\overline{A}=\emptyset\in U^{\prime}\){:/nomarkdown}. האתגר הוא להוכיח שמסנן מקסימלי יקיים את תכונת העל-מסנניות תמיד. נניח בשלילה ש-{::nomarkdown}\( U\){:/nomarkdown} הוא מסנן מקסימלי אבל יש איזה {::nomarkdown}\( A\in X\){:/nomarkdown} כך ש-{::nomarkdown}\( A\notin U\){:/nomarkdown} וגם {::nomarkdown}\( \overline{A}\notin U\){:/nomarkdown}, אז אפשר פשוט להוסיף את {::nomarkdown}\( A\){:/nomarkdown} ל-{::nomarkdown}\( U\){:/nomarkdown} ולקבל קבוצה שאינה בהכרח מסנן, אבל <strong>היא יוצרת</strong> מסנן {::nomarkdown}\( U^{\prime}\){:/nomarkdown} שמכיל ממש את {::nomarkdown}\( U\){:/nomarkdown}. למה היא בהכרח יוצרת מסנן? כי היא מקיימת את תכונת החיתוכים הסופיים, שהרי אם יש לנו קבוצות {::nomarkdown}\( B_{1},\dots,B_{n}\){:/nomarkdown} כך ש-{::nomarkdown}\( A\cap\bigcap B_{i}=\emptyset\){:/nomarkdown} זה אומר ש-{::nomarkdown}\( \bigcap B_{i}\subseteq\overline{A}\){:/nomarkdown} ולכן היינו צריכים לקבל {::nomarkdown}\( \overline{A}\in U\){:/nomarkdown} (למה הנימוק שנתתי מספיק?).

יפה. כעת, נותנים לנו קבוצה {::nomarkdown}\( S\){:/nomarkdown} שמקיימת את תכונת החיתוכים הסופיים. אנחנו יודעים שאפשר להרחיב אותה למסנן, אבל האם בהכרח ניתן להרחיב אותה לעל-מסנן? התשובה היא "כן, אבל". יש לנו כאן סיטואציה דומה ל"כל קבוצה בלתי תלויה של וקטורים במרחב וקטורי ניתנת להרחבה לבסיס", וכמו שם כך גם כאן ההוכחה תהיה פשוטה, אבל תתבסס על <a href="http://www.gadial.net/2012/06/04/choice_order_zorn/">אקסיומת הבחירה</a>, או ליתר דיוק על הלמה של צורן השקולה לה. הרעיון הוא כזה: מספיק לבנות מסנן מקסימלי שמכיל את {::nomarkdown}\( S\){:/nomarkdown}. אז נסתכל על קבוצת כל המסננים שמכילים את {::nomarkdown}\( S\){:/nomarkdown}; על פי הלמה של צורן, מספיק להראות שכל שרשרת של מסננים (קבוצה של מסננים שמכילים את {::nomarkdown}\( S\){:/nomarkdown} שלכל זוג מביניהם, אחד מהם מוכל בשני) היא בעלת חסם מלעיל בקבוצה (יש מסנן שמכיל את כל המסננים בשרשרת). את זה קל להראות - בהינתן שרשרת, ניקח את האיחוד של כל איבריה ונרחיב אותו למסנן שיהיה החסם מלעיל. כדי להראות שאפשר להרחיב את האיחוד הזה צריך להראות שהאיחוד מקיים את תכונת החיתוכים הסופיים. נניח שהוא לא, אז יש {::nomarkdown}\( A_{1},\dots,A_{n}\){:/nomarkdown} באיחוד כך ש-{::nomarkdown}\( \bigcap A_{n}=\emptyset\){:/nomarkdown}. זה רק מספר סופי של {::nomarkdown}\( A_{i}\){:/nomarkdown}-ים ולכן יש איבר בשרשרת שמכיל את כולם, והופס! סתירה לכך שהוא מסנן. הוכחה סטנדרטית לגמרי שאמורה לנבוע מאליה למי שמכיר את טכניקת ההוכחה הזו והבין מהם מסננים.

שימו לב שבמקרה שבו {::nomarkdown}\( U\){:/nomarkdown} הוא על-מסנן <strong>ראשי</strong>, הוא לא מסנן מעניין במיוחד. נניח ש-{::nomarkdown}\( U\){:/nomarkdown} הוא על-מסנן ראשי, כלומר {::nomarkdown}\( U=\left\{ B\in X\ \|\ A\subseteq B\right\} \){:/nomarkdown} עבור איזו שהיא {::nomarkdown}\( A\){:/nomarkdown}, אז אני טוען ש-{::nomarkdown}\( A=\left\{ a\right\} \){:/nomarkdown}, כלומר {::nomarkdown}\( A\){:/nomarkdown} היא יחידון; זאת מכיוון שניקח {::nomarkdown}\( a\in A\){:/nomarkdown} כלשהו ונשים לב לכך שאו {::nomarkdown}\( \left\{ a\right\} \){:/nomarkdown} או {::nomarkdown}\( \overline{\left\{ a\right\} }\){:/nomarkdown} שייכים ל-{::nomarkdown}\( U\){:/nomarkdown}. אם {::nomarkdown}\( \left\{ a\right\} \in U\){:/nomarkdown} אז מכיוון ש-{::nomarkdown}\( A\subseteq\left\{ a\right\} \){:/nomarkdown} נקבל ש-{::nomarkdown}\( A=\left\{ a\right\} \){:/nomarkdown}; מצד שני, פשוט לא ייתכן ש-{::nomarkdown}\( \overline{\left\{ a\right\} }\in U\){:/nomarkdown} כי {::nomarkdown}\( A\not\subseteq\overline{\left\{ a\right\} }\){:/nomarkdown}! לכן העל-מסננים שמתעניינים בהם באמת הם אלו שאינם ראשיים. האם יש לנו דוגמה לעל-מסנן שכזה? ובכן, כן! ניקח את {::nomarkdown}\( D\){:/nomarkdown} להיות מסנן פרשה מעל {::nomarkdown}\( X\){:/nomarkdown} - כזכור, המסנן שכולל את כל הקבוצות הקו-סופיות. נרחיב אותו לעל-מסנן {::nomarkdown}\( U\){:/nomarkdown}. נניח בשלילה ש-{::nomarkdown}\( U=\left\{ B\in X\ \|\ A\subseteq B\right\} \){:/nomarkdown}, אז כפי שראינו, {::nomarkdown}\( A=\left\{ a\right\} \){:/nomarkdown}. אבל אז {::nomarkdown}\( \overline{A}\){:/nomarkdown} היא קבוצה קו-סופית, ולכן {::nomarkdown}\( \overline{A}\in D\subseteq U\){:/nomarkdown}, וקיבלנו סתירה.

יופי, אז הגדרנו מסננים וראינו כל מני דברים עליהם, פרט לדבר אחד: <strong>בשביל מה בכלל צריך אותם</strong>? ובכן, נעבור למה שהוא עיקר הפוסט - המושג של <strong>מכפלה מצומצמת</strong>, ובפרט של על-מכפלות. אבל לפני זה, טיפת מוטיבציה.

אם יש לנו שתי קבוצות {::nomarkdown}\( A,B\){:/nomarkdown}, אז <strong>המכפלה הקרטזית</strong> שלהן, שמסומנת {::nomarkdown}\( A\times B\){:/nomarkdown}, היא אוסף הזוגות של איבר מ-{::nomarkdown}\( A\){:/nomarkdown} ואיבר מ-{::nomarkdown}\( B\){:/nomarkdown}. את הרעיון הזה קל להכליל: אם {::nomarkdown}\( A_{1},\dots,A_{n}\){:/nomarkdown} הן קבוצות, אז {::nomarkdown}\( \prod A_{i}\){:/nomarkdown} הוא אוסף ה-{::nomarkdown}\( n\){:/nomarkdown}-יות שבהן האיבר במקום ה-{::nomarkdown}\( i\){:/nomarkdown} שייך ל-{::nomarkdown}\( A_{i}\){:/nomarkdown}. למי שהתרגל לחשוב על מכפלות בתור {::nomarkdown}\( n\){:/nomarkdown}-יות אני רוצה להציע נקודת מבט קצת שונה: נחשוב על כל איבר ב-{::nomarkdown}\( \prod A_{i}\){:/nomarkdown} בתור <strong>פונקציה</strong>, {::nomarkdown}\( f:\left\{ 1,\dots,n\right\} \to\bigcup A_{i}\){:/nomarkdown}, עם הדרישה שלכל {::nomarkdown}\( i\in\left\{ 1,\dots,n\right\} \){:/nomarkdown} מתקיים {::nomarkdown}\( f\left(i\right)\in A_{i}\){:/nomarkdown}.

הטוב בדרך ההתבוננות הזו היא שבעזרתה קל להגדיר מכפלות קרטזיות על אוספים <strong>כלליים</strong> של קבוצות, כל עוד יש לנו דרך כלשהי "לאנדקס" את הקבוצות הללו. אפשר לקחת קבוצה שרירותית {::nomarkdown}\( I\){:/nomarkdown} להיות "קבוצת האינדקסים" שלנו (למשל, {::nomarkdown}\( I=\left\{ 1,\dots,n\right\} \){:/nomarkdown} או {::nomarkdown}\( I=\mathbb{N}\){:/nomarkdown}, אבל אפשר גם {::nomarkdown}\( I=\mathbb{R}\){:/nomarkdown} או דברים מופרעים יותר). עכשיו נניח שלכל {::nomarkdown}\( i\in I\){:/nomarkdown} יש לנו קבוצה {::nomarkdown}\( A_{i}\){:/nomarkdown}; אפשר להגדיר את המכפלה {::nomarkdown}\( \prod_{i\in I}A_{i}\){:/nomarkdown} בתור אוסף הפונקציות {::nomarkdown}\( f:I\to\bigcup_{i\in I}A_{i}\){:/nomarkdown} כך ש-{::nomarkdown}\( f\left(i\right)\in A_{i}\){:/nomarkdown} לכל {::nomarkdown}\( i\in I\){:/nomarkdown}. זה מאפשר לנו לבנות מכפלות די מוזרות למראה, כמו מכפלה של מספר לא בן מניה של קבוצות שכל אחת מאונדקסת על ידי מספר ממשי כלשהו. בפועל אם אתם רוצים לחשוב על מקרה קונקרטי, אפשר להסתפק ב-{::nomarkdown}\( I=\mathbb{N}\){:/nomarkdown}, שהוא יחסית פשוט ({::nomarkdown}\( A_{1}\times A_{2}\times A_{3}\times\dots\){:/nomarkdown}).

עכשיו לפאנץ'. מה קורה אם לקבוצות שמכפילים יש <strong>מבנה</strong>? במתמטיקה אוהבים לבנות מתוך אובייקטים קיימים אובייקטים חדשים, למשל על ידי מכפלה. אפשר להכפיל חבורות ולקבל חבורה, ואפשר להכפיל חוגים ולקבל חוג, אבל האם תמיד מכפלה תיתן לנו אובייקט חדש? ובכן, קחו שדה {::nomarkdown}\( \mathbb{F}\){:/nomarkdown} כלשהו. למרבה הבעסה, {::nomarkdown}\( \mathbb{F}\times\mathbb{F}\){:/nomarkdown} <strong>לא</strong> יהיה שדה. למה? כי לא כל איבר בו יהיה הפיך: {::nomarkdown}\( \left(1,0\right)\){:/nomarkdown} אינו איבר האפס של {::nomarkdown}\( \mathbb{F}\times\mathbb{F}\){:/nomarkdown}, אבל הוא אינו הפיך (כי לא משנה מה נכפיל בו, בקואורדינטה השניה תמיד יהיה 0).

עם זאת, יש דרך <strong>לצמצם</strong> את המכפלה {::nomarkdown}\( \mathbb{F}\times\mathbb{F}\){:/nomarkdown} כך ששוב נקבל שדה: אם <strong>נזהה</strong> את האיברים מהצורה {::nomarkdown}\( \left(a,b\right)\){:/nomarkdown} עם האיברים מהצורה {::nomarkdown}\( \left(a,b^{\prime}\right)\){:/nomarkdown}, כלומר נגיד שאיברים של {::nomarkdown}\( \mathbb{F}\times\mathbb{F}\){:/nomarkdown} הם זהים אם הקואורדינטה הראשונה שלהם זהה, מה שנקבל יהיה עותק של {::nomarkdown}\( \mathbb{F}\){:/nomarkdown}, שהוא שדה. אותו דבר עם {::nomarkdown}\( \mathbb{F}^{3}\){:/nomarkdown} - שוב, כשמזהים איברים אם הקואורדינטה הראשונה שלהם זהה. וכדומה עבור {::nomarkdown}\( \mathbb{F}^{n}\){:/nomarkdown}. אוקיי, זה משעמם לחלוטין; מתי זה מתחיל להיות מעניין? או - כשכופלים <strong>אינסוף</strong> עותקים של {::nomarkdown}\( \mathbb{F}\){:/nomarkdown}. אז יתברר שלא חייבים זהות בקואורדינטה אחת מסויימת כדי עדיין לקבל שדה, אלא אפשר להקל מאוד את הדרישות.

בואו נעבור שניה לדוגמה קצת שונה, שלקוחה מהחיים האמיתיים - אנליזה פונקציונלית, במקרה שלנו. אני מדבר על פונקציות ממשיות - {::nomarkdown}\( f:\mathbb{R}\to\mathbb{R}\){:/nomarkdown}, שכבר ברור מהדיון הקודם שלנו שאפשר לחשוב עליהן בתור איברים ב<strong>מכפלה קרטזית</strong> של עותקים של {::nomarkdown}\( \mathbb{R}\){:/nomarkdown}, כשכל עותק מאונדקס על ידי מספר ממשי כלשהו ({::nomarkdown}\( c\){:/nomarkdown}). מסיבות טכניות שלא אכנס אליהן כאן, נוח מאוד לפעמים לחשוב על שתי פונקציות {::nomarkdown}\( f,g\){:/nomarkdown} כזהות אם קבוצת המספרים שעליהם {::nomarkdown}\( f,g\){:/nomarkdown} לא מסכימים היא <strong>ממידה אפס</strong> (לא אכנס גם להגדרה של מידה כאן; זו הכללה רבת עוצמה של מושג הנפח - או במקרה של {::nomarkdown}\( \mathbb{R}\){:/nomarkdown}, האורך). פורמלית, {::nomarkdown}\( \mu\left(\left\{ x\in\mathbb{R}\ \|\ f\left(x\right)\ne g\left(x\right)\|\right\} \right)=0\){:/nomarkdown} כאשר {::nomarkdown}\( \mu\){:/nomarkdown} היא פונקצית המידה הרגילה על {::nomarkdown}\( \mathbb{R}\){:/nomarkdown}. אפשר לנסח את זה גם בצורה חיובית: קבוצת הנקודות ש-{::nomarkdown}\( f,g\){:/nomarkdown} מסכימות עליהן היא <strong>מאוד גדולה</strong>. כמה גדולה? עד כדי כך שהמשלימה שלה היא ממידה אפס. נשמע מוכר? ובכן, כן: כל {::nomarkdown}\( \mathbb{R}\){:/nomarkdown} אינו ממידה אפס ואיחוד של שתי קבוצות ממידה אפס הוא ממידה אפס, ומכאן מקבלים די בקלות שקבוצת כל הקבוצות שהמשלימה שלהן היא ממידה אפס הן מסנן על {::nomarkdown}\( \mathbb{R}\){:/nomarkdown}. אז מה עשינו כאן? הגדרנו שהפונקציות {::nomarkdown}\( f,g\){:/nomarkdown} הן זהות אם קבוצת הנקודות שעליהן {::nomarkdown}\( f,g\){:/nomarkdown} הסכימו הייתה שייכת למסנן מסוים שהוגדר מעל {::nomarkdown}\( \mathbb{R}\){:/nomarkdown}. <strong>צמצמנו את המכפלה</strong> {::nomarkdown}\( \prod_{x\in\mathbb{R}}\mathbb{R}_{x}\){:/nomarkdown} ביחס למסנן הזה.

פורמלית העסק הזה מתבצע עם יחסי שקילות. נניח שנתונה לנו מכפלה כלשהי {::nomarkdown}\( \mathcal{A}=\prod_{i\in I}A_{i}\){:/nomarkdown} ונתון לנו מסנן {::nomarkdown}\( D\){:/nomarkdown} על הקבוצה {::nomarkdown}\( I\){:/nomarkdown}. אז נגדיר יחס שקילות {::nomarkdown}\( \equiv_{D}\){:/nomarkdown} על {::nomarkdown}\( \mathcal{A}\){:/nomarkdown} באופן הבא: {::nomarkdown}\( f\equiv_{D}g\){:/nomarkdown} אם {::nomarkdown}\( \left\{ i\in I\ \|\ f\left(i\right)=g\left(i\right)\right\} \in D\){:/nomarkdown}.

למה זה יחס שקילות? ובכן, {::nomarkdown}\( \left\{ i\in I\ \|\ f\left(i\right)=f\left(i\right)\right\} =I\in D\){:/nomarkdown}, אז רפלקסיביות זה קל, וסימטריה זה עוד יותר קל. אבל מה עם טרנזיטיביות? ובכן, יהיו {::nomarkdown}\( f,g,h\in\mathcal{A}\){:/nomarkdown} ונגדיר {::nomarkdown}\( B=\left\{ i\in I\ \|\ f\left(i\right)=g\left(i\right)\right\} \){:/nomarkdown} ו-{::nomarkdown}\( C=\left\{ i\in I\ \|\ g\left(i\right)=h\left(i\right)\right\} \){:/nomarkdown}. אולי קצת מפתה לומר שיתקיים {::nomarkdown}\( \left\{ i\in I\ \|\ f\left(i\right)=h\left(i\right)\right\} =B\cap C\){:/nomarkdown} אבל זה לא נכון; מה שכן נכון הוא ש-{::nomarkdown}\( B\cap C\subseteq\left\{ i\in I\ \|\ f\left(i\right)=h\left(i\right)\right\} \){:/nomarkdown}. לכן אם {::nomarkdown}\( f\equiv_{D}g\){:/nomarkdown} ו-{::nomarkdown}\( g\equiv_{D}h\){:/nomarkdown}, ולכן {::nomarkdown}\( B,C\in D\){:/nomarkdown}, אז גם {::nomarkdown}\( \left\{ i\in I\ \|\ f\left(i\right)=h\left(i\right)\right\} \in D\){:/nomarkdown} (זה נובע משילוב אקסיומות 2 ו-3) ולכן {::nomarkdown}\( f\equiv_{D}h\){:/nomarkdown} וקיבלנו גם טרנזיטיביות.

אם {::nomarkdown}\( \equiv_{D}\){:/nomarkdown} הוא יחס שקילות אז אפשר לחלק בו. מקבלים את הקבוצה

{::nomarkdown}\( \prod_{i\in I}A_{i}/\equiv_{D}=\left\{ \left[f\right]_{D}\ \|f\in\prod_{i\in I}A_{i}\right\} \){:/nomarkdown}

כאשר {::nomarkdown}\( \left[f\right]_{D}\){:/nomarkdown} הוא סימון מחלקת השקילות של {::nomarkdown}\( f\){:/nomarkdown} לפי יחס השקילות {::nomarkdown}\( \equiv_{D}\){:/nomarkdown}. לדבר הזה קוראים מכפלה מצומצמת, וכדי לסמן אותו בצורה פשוטה להבא אשתמש בסימון {::nomarkdown}\( \prod_{D}A_{i}\){:/nomarkdown}. במקרה שבו {::nomarkdown}\( D\){:/nomarkdown} הוא על-מסנן קוראים למכפלה המצומצמת הזו על-מכפלה, ובמקרה שבו {::nomarkdown}\( D\){:/nomarkdown} הוא על-מסנן ו-{::nomarkdown}\( A_{i}=A\){:/nomarkdown} לכל {::nomarkdown}\( i\in I\){:/nomarkdown}, כלומר המכפלה היא כולה של עותקים של {::nomarkdown}\( A\){:/nomarkdown} ספציפי אחד, אז לעל-המכפלה קוראים על-חזקה.

רעיון הבניה הזה הוא לטעמי מגניב למדי לכשעצמו (ואני מקווה שכל מי שמכיר את המושג של "פונקציות שקולות אם הן נבדלות רק בקבוצה ממידה אפס" ולא הכיר מסננים עכשיו מרגיש קצת יותר נוח עם המושג הזה), אבל עד כה כל מה שעשינו היה יבש למדי. עכשיו מגיע האקשן האמיתי, בדמות משפט Łoś. קודם כל אצטט את המשפט בלי להיכנס לפרטיו (כולל ההגדרות, שהן חשובות לכשעצמן) ואז ניגש לעבודה.

עד כה הדיון כולו היה דיון טהור בתורת הקבוצות, בלי להכניס מושגים מלוגיקה. אבל אנחנו רוצים לערב במשחק את תורת המודלים, ונעשה זאת כך: נניח שיש לנו שפה כלשהי מסדר ראשון {::nomarkdown}\( \mathcal{L}\){:/nomarkdown}. שפה כזו כוללת, כזכור, סימני יחס, סימני פונקציות וסימני קבועים. <strong>מודל</strong> {::nomarkdown}\( \mathcal{M}\){:/nomarkdown} לשפה הזו כולל קבוצה לא ריקה כלשהי (ה<strong>תחום</strong> של המודל) ופרשנויות שמתאימות לכל סימן ב-{::nomarkdown}\( \mathcal{L}\){:/nomarkdown} אובייקט מתאים - לכל סימן יחס, יחס על התחום של {::nomarkdown}\( \mathcal{M}\){:/nomarkdown}; לכל סימן פונקציה, פונקציה על התחום של {::nomarkdown}\( \mathcal{M}\){:/nomarkdown} ולכל סימן קבוע, איבר מהתחום של {::nomarkdown}\( \mathcal{M}\){:/nomarkdown}. אם יש לנו מודל, אז לכל פסוק {::nomarkdown}\( \varphi\){:/nomarkdown} (פסוק הוא נוסחה ללא משתנים חופשיים) או ש-{::nomarkdown}\( \mathcal{M}\models\varphi\){:/nomarkdown} - המודל <strong>מספק</strong> את {::nomarkdown}\( \varphi\){:/nomarkdown}, כלומר נותן לו ערך אמת - או ש-{::nomarkdown}\( \mathcal{M}\not\models\varphi\){:/nomarkdown}.

כעת בואו נניח שיש לנו קבוצת אינדקסים כללית {::nomarkdown}\( I\){:/nomarkdown} וקבוצת מודלים {::nomarkdown}\( \mathcal{M}_{i}\){:/nomarkdown}, {::nomarkdown}\( i\in I\){:/nomarkdown}, שכולם מודלים של אותה השפה. ונניח שיש לנו על-מסנן {::nomarkdown}\( U\){:/nomarkdown} עבור {::nomarkdown}\( I\){:/nomarkdown}. אז אפשר לבנות את העל-מכפלה {::nomarkdown}\( \mathcal{B}=\prod_{U}\mathcal{M}\){:/nomarkdown}. אני מניח שברור אינטואיטיבית איך עושים את זה - הפרטים הטכניים טיפה יותר מסובכים ואחזור אליהם בהמשך. נשאלת השאלה - אילו פסוקים {::nomarkdown}\( \mathcal{B}\){:/nomarkdown} מספק? התשובה פשוטה, צפויה, אלגנטית ויפהפיה:

{::nomarkdown}\( \mathcal{B}\models\varphi\iff\left\{ i\in I\ \|\ \mathcal{M}_{i}\models\varphi\right\} \in D\){:/nomarkdown}

במילים: {::nomarkdown}\( \mathcal{B}\){:/nomarkdown} מספק נוסחה {::nomarkdown}\( \varphi\){:/nomarkdown} אם ורק אם אוסף האינדקסים של מודלים במכפלה שיוצרת את {::nomarkdown}\( \mathcal{B}\){:/nomarkdown} שמספקים את {::nomarkdown}\( \varphi\){:/nomarkdown} שייך ל-{::nomarkdown}\( D\){:/nomarkdown}. כדי שהתוצאה הזו תתקיים אנחנו חייבים להסתכל על על-מכפלה; המשפט פשוט לא נכון עבור מכפלות מצומצמות כלליות.

בפרט קורה משהו מפתיע כאשר כל ה-{::nomarkdown}\( \mathcal{M}_{i}\){:/nomarkdown} שווים, כלומר כאשר אנו מסתכלים על על-חזקה {::nomarkdown}\( \mathcal{B}\){:/nomarkdown} של {::nomarkdown}\( \mathcal{M}\){:/nomarkdown}: במקרה הזה, {::nomarkdown}\( \mathcal{B}\models\varphi\iff\mathcal{M}\models\varphi\){:/nomarkdown}. במילים אחרות, קיבלנו מ-{::nomarkdown}\( \mathcal{M}\){:/nomarkdown} מודל חדש שמבחינת לוגיקה מסדר ראשון נראה <strong>אותו הדבר בדיוק</strong> כמו {::nomarkdown}\( \mathcal{M}\){:/nomarkdown}, למרות שהוא יכול להיות משמעותית מורכב יותר.

אם לחזור לדוגמה של השדה {::nomarkdown}\( \mathbb{F}\){:/nomarkdown}, בואו ניקח את {::nomarkdown}\( I=\mathbb{N}\){:/nomarkdown}, ואת {::nomarkdown}\( U\){:/nomarkdown} להיות על-מסנן כלשהו. ונסתכל על {::nomarkdown}\( \prod_{U}\mathbb{F}\){:/nomarkdown}. נוסחאות השדה ניתנות לניסוח כולן בלוגיקה מסדר ראשון עם השפה המתאימה, ולכן {::nomarkdown}\( \prod_{U}\mathbb{F}\){:/nomarkdown} יקיים בדיוק את אותן נוסחאות כמו {::nomarkdown}\( \mathbb{F}\){:/nomarkdown}, ובפרט את אקסיומות השדה - כלומר, קיבלנו שדה חדש, {::nomarkdown}\( \prod_{U}\mathbb{F}\){:/nomarkdown}. מצד שני, מנין לנו שהוא אינו זהה ל-{::nomarkdown}\( \mathbb{F}\){:/nomarkdown}? או, טוב ששאלתם. באופן מצער למדי, הוא <strong>עשוי</strong> להיות זהה ל-{::nomarkdown}\( \mathbb{F}\){:/nomarkdown}, במקרה שהעל-מסנן שלנו הוא לא מעניין מספיק - וזה בדיוק המקרה שבו העל-מסנן הוא ראשי. כזכור, במקרה הזה המסנן הוא מהצורה {::nomarkdown}\( U=\left\{ B\subseteq I\ \|\ i\in B\right\} \){:/nomarkdown} עבור {::nomarkdown}\( i\in I\){:/nomarkdown} כלשהו, כלומר נקבל ש-{::nomarkdown}\( f\equiv_{U}g\){:/nomarkdown} אם ורק אם {::nomarkdown}\( f\left(i\right)=g\left(i\right)\){:/nomarkdown} וזו הסיטואציה ה"מנוונת" שתיארנו קודם; אבל אם {::nomarkdown}\( U\){:/nomarkdown} מרחיב את מסנן פרשה אז {::nomarkdown}\( U\){:/nomarkdown} אינו ראשי, ולכן אין קבוצה קבועה של אינדקסים שאם {::nomarkdown}\( f,g\){:/nomarkdown} מזדהים עליהם אז הם זהים. קיבלנו מתוך {::nomarkdown}\( \mathbb{F}\){:/nomarkdown} שדה <strong>חדש</strong> ומעניין {::nomarkdown}\( \prod_{U}\mathbb{F}\){:/nomarkdown}.

כמה מעניין? הו הו הו. בואו ניקח את {::nomarkdown}\( \mathbb{F}=\mathbb{R}\){:/nomarkdown} ונתהה איך {::nomarkdown}\( \prod_{U}\mathbb{R}\){:/nomarkdown} נראה. מבלי להיכנס יותר לעובי הקורה, בואו ננסה להבין ראשית כל איך {::nomarkdown}\( \mathbb{R}\){:/nomarkdown} "משתכן" בתוך השדה הזה. את המספר הממשי {::nomarkdown}\( a\in\mathbb{R}\){:/nomarkdown} אפשר לייצג ב-{::nomarkdown}\( \prod_{U}\mathbb{R}\){:/nomarkdown} על ידי הפונקציה הקבועה {::nomarkdown}\( f_{a}\left(i\right)=a\){:/nomarkdown} - ליתר דיוק, על ידי מחלקת השקילות {::nomarkdown}\( \left[f_{a}\right]_{U}\){:/nomarkdown} (זכרו! {::nomarkdown}\( U\){:/nomarkdown} הוא על-מסנן מעל קבוצת האינדקסים {::nomarkdown}\( I=\mathbb{N}\){:/nomarkdown}).

עכשיו, בואו נתבונן בפונקציה {::nomarkdown}\( g\left(i\right)=i\){:/nomarkdown} - זו פונקציה עולה, וקל לראות ש-{::nomarkdown}\( g\not\equiv_{U}f_{a}\){:/nomarkdown} עבור אף {::nomarkdown}\( a\in\mathbb{R}\){:/nomarkdown}, שכן לכל {::nomarkdown}\( a\in\mathbb{R}\){:/nomarkdown}, {::nomarkdown}\( \left\{ i\in\mathbb{N}\ \|\ g\left(i\right)=f_{a}\left(i\right)\right\} =\left\{ a\right\} \notin U\){:/nomarkdown}. לכן {::nomarkdown}\( g\){:/nomarkdown} מייצגת "מספר" חדש שאינו ממשי. מצד שני, הוא איבר של {::nomarkdown}\( \prod_{U}\mathbb{R}\){:/nomarkdown}, שהוא שדה סדור שמקיים את כל התכונות של {::nomarkdown}\( \mathbb{R}\){:/nomarkdown}. בפרט אפשר להשוות את {::nomarkdown}\( g\){:/nomarkdown} עם כל {::nomarkdown}\( f_{a}\){:/nomarkdown}. עוד לא נכנסתי להגדרות פורמליות, אבל אתם כבר ודאי מנחשים ש-{::nomarkdown}\( f_{a}&lt;g\){:/nomarkdown} אם ורק אם הקבוצה {::nomarkdown}\( \left\{ i\in\mathbb{N}\ \|\ f_{a}\left(i\right)&lt;g\left(i\right)\right\} \){:/nomarkdown} שייכת ל-{::nomarkdown}\( U\){:/nomarkdown}. ומכיוון שהחל מ-{::nomarkdown}\( k\){:/nomarkdown} הראשון שעבורו {::nomarkdown}\( a&lt;k\){:/nomarkdown} יתקיים {::nomarkdown}\( f_{a}\left(i\right)&lt;g\left(i\right)\){:/nomarkdown} לכל {::nomarkdown}\( i\ge k\){:/nomarkdown}, הרי ש-{::nomarkdown}\( \left\{ i\in\mathbb{N}\ \|\ f_{a}\left(i\right)&lt;g\left(i\right)\right\} \){:/nomarkdown} היא קו-סופית ואכן שייכת ל-{::nomarkdown}\( U\){:/nomarkdown}. המסקנה: השדה {::nomarkdown}\( \prod_{D}\mathbb{R}\){:/nomarkdown} מכיל מספרים שגדולים מכל מספר ממשי, <strong>אבל הוא עדיין שדה</strong>. אפשר גם למצוא למספרים הללו הופכי, ולקבל מספרים שקטנים מכל מספר ממשי - קיבלנו מודל ל<strong>אנליזה לא סטנדרטית</strong>. כבר הראיתי בבלוג שקיים מודל כזה, כפועל יוצא של <a href="http://www.gadial.net/2013/03/21/fol_completeness_corollaries/">משפט הקומפקטיות</a>; אבל עכשיו אנחנו יכולים להבין איך הוא נראה, בערך (בערך, כי אנחנו לא באמת יודעים איך {::nomarkdown}\( U\){:/nomarkdown} נראה, רק ש-{::nomarkdown}\( U\){:/nomarkdown} הוא על-מסנן של {::nomarkdown}\( \mathbb{N}\){:/nomarkdown} שכולל את כל הקבוצות הקו-סופיות).

האופן שבו העל-חזקה {::nomarkdown}\( \prod_{D}\mathbb{R}\){:/nomarkdown} החליפה את משפט הקומפקטיות אינו מקרי - אני רוצה להראות עכשיו איך משפט הקומפקטיות עצמו נובע מכל מה שעשינו עד כה.

משפט הקומפקטיות, כזכור, אומר שאם יש לנו קבוצת פסוקים {::nomarkdown}\( \Phi\){:/nomarkdown} שלכל תת-קבוצה סופית שלה יש מודל, אז גם ל-{::nomarkdown}\( \Phi\){:/nomarkdown} יש מודל (מודל לקבוצת פסוקים הוא מודל שמספק את כל הפסוקים בקבוצה). באופן "קלאסי" מוכיחים את המשפט הזה בהתבסס על כך ש"ספיק" ו"עקבי" הם מושגים זהים בלוגיקה מסדר ראשון, תוך התבססות על <a href="http://www.gadial.net/2013/02/25/godel_completeness_proof_1/">משפט השלמות של גדל</a>. זו הוכחה שמתבססת על <strong>תורת ההוכחות</strong> והיא יפהפיה; אבל עכשיו אני רוצה לתת הוכחה שהיא לגמרי תורת-מודלים ואין בה בכלל זכר למערכות הוכחה או משפט השלמות של גדל (שאגב, ניתן להוכיח <strong>בעזרת</strong> משפט הקומפקטיות, כך שמה שאני מציג כאן הוא גם צעד ראשון של הוכחה של משפט השלמות בעזרת תורת המודלים).

הרעיון הוא פשוט: אם לכל תת-קבוצה סופית של {::nomarkdown}\( \Phi\){:/nomarkdown} יש מודל {::nomarkdown}\( \mathcal{M}_{i}\){:/nomarkdown}, אז בואו ניקח את כל המודלים הללו וניצור על-מכפלה שלהם ביחס לעל-מסנן {::nomarkdown}\( U\){:/nomarkdown} שנבחר בצורה חכמה. אם נבחר את העל-מסנן כמו שצריך, נקבל ש-{::nomarkdown}\( \prod_{U}\mathcal{M}_{i}\){:/nomarkdown} מספק את {::nomarkdown}\( \Phi\){:/nomarkdown}. במילים אחרות, אנחנו בונים בצורה "חצי-קונסטרוקטיבית" את המודל של {::nomarkdown}\( \Phi\){:/nomarkdown}; אמנם אנחנו לא נדע איך בדיוק {::nomarkdown}\( U\){:/nomarkdown} נראה ולכן זו לא בניה קונסטרוקטיבית מלאה, אבל היא בהחלט יותר קונקרטית באופיה מאשר ההוכחה של משפט הקומפטיות עם משפט השלמות.

ראשית כל, על איזו קבוצה אנחנו רוצים להגדיר את {::nomarkdown}\( U\){:/nomarkdown} בכלל? קבוצת האינדקסים {::nomarkdown}\( I\){:/nomarkdown} שלנו צריכה לאנדקס את כל תת-הקבוצות הסופיות של {::nomarkdown}\( \Phi\){:/nomarkdown}, אז זה בדיוק מה שנעשה: באופן כללי, בהינתן קבוצה {::nomarkdown}\( \Phi\){:/nomarkdown} כלשהי (לאו דווקא של פסוקים), אפשר להגדיר {::nomarkdown}\( I=\left\{ \Phi^{\prime}\subseteq\Phi\ \|\ \left\|\Phi^{\prime}\right\|&lt;\infty\right\} \){:/nomarkdown}, כלומר ה"עולם" שעליו מגדירים מסננים יכלול את כל תת-הקבוצות הסופיות של קבוצה נתונה. יכלתי להציג את העולם הזה כבר בהתחלה, יחד עם יתר הדוגמאות למסננים, אבל העדפתי לחכות עד שתהיה לי דוגמה קונקרטית לסיטואציה שבה הוא צץ מעצמו.

אם כן, {::nomarkdown}\( I\){:/nomarkdown} זו קבוצת האינדקסים, ו-{::nomarkdown}\( \mathcal{M}_{i}\){:/nomarkdown} הוא מודל של {::nomarkdown}\( i\in I\){:/nomarkdown} לכל {::nomarkdown}\( i\in I\){:/nomarkdown} (זכרו שכל {::nomarkdown}\( i\){:/nomarkdown} כזה הוא בעצם {::nomarkdown}\( \Phi^{\prime}\){:/nomarkdown} - תת-קבוצה סופית של {::nomarkdown}\( \Phi\){:/nomarkdown}, ואנו מניחים ש-{::nomarkdown}\( \Phi^{\prime}\){:/nomarkdown} היא ספיקה). איזה על-מסנן {::nomarkdown}\( U\){:/nomarkdown} של {::nomarkdown}\( I\){:/nomarkdown} ניקח? אם ניקח על-מסנן ראשי, נקבל ש-{::nomarkdown}\( \prod_{U}\mathcal{M}_{i}\){:/nomarkdown} זהה לאחד מהמודלים במכפלה ותו לא; זה לא מספיק טוב. אולי ניקח על-מסנן שמרחיב את מסנן פרשה? גם זה לאו דווקא יעבוד. קחו {::nomarkdown}\( \varphi\in\Phi\){:/nomarkdown}: אנחנו רוצים להראות ש-{::nomarkdown}\( \prod_{U}\mathcal{M}_{i}\models\varphi\){:/nomarkdown}. מה שאנחנו יודעים הוא שזה קורה אם {::nomarkdown}\( \left\{ i\in I\ \|\ \mathcal{M}_{i}\models\varphi\right\} \in U\){:/nomarkdown}, אבל למה שזה יהיה נכון עבור מסנן פרשה? אנחנו יכולים להיות בטוחים ש-{::nomarkdown}\( \mathcal{M}_{i}\models\varphi\){:/nomarkdown} רק עבור {::nomarkdown}\( i\in I\){:/nomarkdown} שהם קבוצה {::nomarkdown}\( \Phi^{\prime}\){:/nomarkdown} כך ש-{::nomarkdown}\( \varphi\in\Phi^{\prime}\){:/nomarkdown}. יש הרבה כאלו, אבל אוסף כל ה-{::nomarkdown}\( i\){:/nomarkdown}-ים שבהם זה קורה הוא בוודאי לא קבוצה קו-סופית ולכן אי אפשר להיות בטוחים שהוא ב-{::nomarkdown}\( U\){:/nomarkdown}. אין מנוס - צריך מסנן אחר.

איך נגדיר את המסנן החדש? בצורה הכי טבעית שרק אפשר: פשוט <strong>נדרוש </strong>שלכל {::nomarkdown}\( \varphi\in\Phi\){:/nomarkdown}, הקבוצה {::nomarkdown}\( \left\{ i\in I\ \|\ \mathcal{M}_{i}\models\varphi\right\} \){:/nomarkdown} תהיה במסנן. במילים אחרות, ניקח את המסנן ש<strong>נוצר</strong> מתוך הקבוצה הזו. כדי להוכיח שבכלל אפשר ליצור מסנן מתוך הקבוצה הזו צריך להראות שהיא מקיימת את תכונת החיתוכים הסופיים: כלומר, שבהינתן קבוצה סופית {::nomarkdown}\( \left\{ \varphi_{1},\varphi_{2},\dots,\varphi_{k}\right\} \){:/nomarkdown}, קיים {::nomarkdown}\( i\in I\){:/nomarkdown} כך ש-{::nomarkdown}\( \mathcal{M}_{i}\models\varphi_{j}\){:/nomarkdown} לכל {::nomarkdown}\( 1\le j\le k\){:/nomarkdown}. אבל {::nomarkdown}\( \left\{ \varphi_{1},\varphi_{2},\dots,\varphi_{k}\right\} \){:/nomarkdown} היא תת-קבוצה סופית של {::nomarkdown}\( \Phi\){:/nomarkdown} ולכן היא בעצמה איבר של {::nomarkdown}\( I\){:/nomarkdown}, ועם מודל {::nomarkdown}\( \mathcal{M}_{i}\){:/nomarkdown} כנדרש. לכן אפשר לבנות על-מסנן שמקיים בדיוק את התכונה שנזקקנו לה, וזה מסיים את הוכחת משפט הקומפקטיות.

שני השימושים שראינו היו פשוטים להחריד - איפה העוקץ? הוא נמצא, כמובן, בכך שטרם הוכחתי או אפילו ניסתי במפורש את משפט Łoś. עכשיו אעשה את זה - זה יהיה החלק המסיים של הפוסט, וגם החלק הטכני ביותר בו, כך שאני מקווה שגם מי שילך לאיבוד עכשיו הרוויח מספיק מהפוסט עד כה.

ראשית כל צריך להסביר איך בדיוק בונים על-מכפלה של מודלים (או אפילו "סתם" מכפלה מצומצמת, זה עובד באותה מידה). אז נניח ש-{::nomarkdown}\( I\){:/nomarkdown} היא קבוצת אינדקסים, {::nomarkdown}\( D\){:/nomarkdown} הוא מסנן עליה ולכל {::nomarkdown}\( i\in I\){:/nomarkdown} יש לנו מודל {::nomarkdown}\( \mathcal{M}_{i}\){:/nomarkdown} עבור השפה {::nomarkdown}\( \mathcal{L}\){:/nomarkdown}. כל מודל כזה כולל בפרט קבוצה שהיא התחום של המודל - בדרך כלל הייתי קורא לה {::nomarkdown}\( D^{\mathcal{M}_{i}}\){:/nomarkdown} אבל כאן {::nomarkdown}\( D\){:/nomarkdown} מתאר את המסנן וזה עשוי להיות בעייתי, אז אני אסמן את התחום של {::nomarkdown}\( \mathcal{M}_{i}\){:/nomarkdown} בתור {::nomarkdown}\( \mathcal{U}_{i}\){:/nomarkdown}.

המודל {::nomarkdown}\( \mathcal{M}=\prod_{D}\mathcal{M}_{i}\){:/nomarkdown} ייבנה כך: העולם שלו יהיה {::nomarkdown}\( \mathcal{U}=\prod_{D}\mathcal{U}_{i}\){:/nomarkdown}, שהוא פשוט מכפלה מצומצת של קבוצות אז אנחנו יודעים בדיוק איך לבנות אותו. זכרו - האיברים של העולם הזה הן <strong>מחלקות שקילות</strong> של פונקציות {::nomarkdown}\( f:I\to\bigcup\mathcal{U}_{i}\){:/nomarkdown}. עכשיו נותר להסביר איך מגדירים במודל {::nomarkdown}\( \prod_{D}\mathcal{M}_{i}\){:/nomarkdown} את הפרשנויות של סימני היחס {::nomarkdown}\( R\){:/nomarkdown}, סימני הפונקציה {::nomarkdown}\( F\){:/nomarkdown} וסימני הקבועים {::nomarkdown}\( c\){:/nomarkdown} שיש ב-{::nomarkdown}\( \mathcal{L}\){:/nomarkdown}.

בואו ניקח סימן יחס {::nomarkdown}\( R\){:/nomarkdown}, ולצורך פשטות נניח שהוא דו מקומי: {::nomarkdown}\( R\left(x,y\right)\){:/nomarkdown} (הרי סימני יחס כלליים יותר יטופלו באותו האופן). זכרו שלכל מודל {::nomarkdown}\( \mathcal{M}_{i}\){:/nomarkdown} יש לנו יחס {::nomarkdown}\( R^{\mathcal{M}_{i}}\){:/nomarkdown} מעל העולם של המודל ש"מפרש" את {::nomarkdown}\( R\){:/nomarkdown} באותו מודל. אנחנו צריכים להחליט מתי עבור {::nomarkdown}\( f,g\in\mathcal{U}\){:/nomarkdown} יתקיים ש-{::nomarkdown}\( \left(f,g\right)\in R^{\mathcal{M}}\){:/nomarkdown}, אז ניקח את ההגדרה הטבעית ביותר לכך: {::nomarkdown}\( \left(f,g\right)\in R^{\mathcal{M}}\){:/nomarkdown} אם ורק אם {::nomarkdown}\( \left\{ i\in I\ \|\ \left(f\left(i\right),g\left(i\right)\right)\in R^{\mathcal{U}_{i}}\right\} \in D\){:/nomarkdown} (רגע של מחשבה מבהיר לנו שאנחנו <strong>חייבים</strong> להגדיר את היחס ככה אם אנחנו רוצים שמשהו כמו משפט Łoś יתקיים).

עכשיו בואו ניקח סימן פונקציה {::nomarkdown}\( F\in\mathcal{L}\){:/nomarkdown}. שוב, נניח שזו פונקציה חד-מקומית {::nomarkdown}\( F\left(x\right)\){:/nomarkdown} כי המקרה הכללי דומה. אנחנו צריכים להגדיר פונקציה {::nomarkdown}\( F^{\mathcal{M}}:\mathcal{U}\to\mathcal{U}\){:/nomarkdown}. איך נעשה את זה? שוב, בצורה הכי טבעית שאפשר: {::nomarkdown}\( F^{\mathcal{M}}\left(f\right)=g_{f}\){:/nomarkdown}, כך ש-{::nomarkdown}\( g_{f}\left(i\right)=F^{\mathcal{M}_{i}}\left(f\left(i\right)\right)\){:/nomarkdown}.

ומה עם קבועים? ובכן, גם זה פשוט: אם {::nomarkdown}\( c\in\mathcal{L}\){:/nomarkdown} הוא סימן קבוע, עם פרשנויות {::nomarkdown}\( c^{\mathcal{M}_{i}}\){:/nomarkdown} במודלים השונים, אז נגדיר {::nomarkdown}\( c^{\mathcal{M}}=f\){:/nomarkdown} כאשר {::nomarkdown}\( f\){:/nomarkdown} היא הפונקציה {::nomarkdown}\( f\left(i\right)=c^{\mathcal{M}_{i}}\){:/nomarkdown}.

כל ההגדרות שנתתי נראות טבעיות ופשוטות, אבל האמת היא שרימיתי בהן כהוגן כי "שכחתי" שהאיברים של {::nomarkdown}\( \mathcal{U}\){:/nomarkdown} הם לא פונקציות, אלא <strong>מחלקות שקילות</strong> של פונקציות. זה אומר שצריך לבדוק שכל ההגדרות שנתתי הן <strong>מוגדרות היטב</strong> - לא תלויות בבחירת נציגים. למשל, כשכתבתי {::nomarkdown}\( \left(f,g\right)\in R^{\mathcal{M}}\){:/nomarkdown} בעצם התכוונתי לכתוב {::nomarkdown}\( \left(\left[f\right]_{D},\left[g\right]_{D}\right)\in R^{\mathcal{M}}\){:/nomarkdown}. אבל אולי יש פונקציות {::nomarkdown}\( f^{\prime},g^{\prime}\){:/nomarkdown} כך ש-{::nomarkdown}\( f\equiv_{D}f^{\prime}\){:/nomarkdown} ו-{::nomarkdown}\( g\equiv_{D}g^{\prime}\){:/nomarkdown}, וגם {::nomarkdown}\( \left\{ i\in I\ \|\ \left(f\left(i\right),g\left(i\right)\right)\in R^{\mathcal{U}_{i}}\right\} \in D\){:/nomarkdown} אבל {::nomarkdown}\( \left\{ i\in I\ \|\ \left(f^{\prime}\left(i\right),g^{\prime}\left(i\right)\right)\in R^{\mathcal{U}_{i}}\right\} \notin D\){:/nomarkdown}? במקרה הזה, מצד אחד {::nomarkdown}\( \left(\left[f\right]_{D},\left[g\right]_{D}\right)\in R^{\mathcal{M}}\){:/nomarkdown} ומצד שני {::nomarkdown}\( \left(\left[f^{\prime}\right]_{D},\left[g^{\prime}\right]_{D}\right)\notin R^{\mathcal{M}}\){:/nomarkdown} וזה כמובן אבסורד כי {::nomarkdown}\( \left(\left[f\right]_{D},\left[g\right]_{D}\right)=\left(\left[f^{\prime}\right]_{D},\left[g^{\prime}\right]_{D}\right)\){:/nomarkdown}.

אז איך מוכיחים שההגדרה עובדת? באופן לא מפתיע, אנו נזקקים לשימוש בתכונות שמגדירות מסננים, כפי שנזקקנו להן כשהוכחנו ש-{::nomarkdown}\( \equiv_{D}\){:/nomarkdown} הוא יחס טרנזיטיבי. נגדיר {::nomarkdown}\( B=\left\{ i\in I\ \|\ \left(f\left(i\right),g\left(i\right)\right)\in R^{\mathcal{U}_{i}}\right\} \){:/nomarkdown} ונגדיר {::nomarkdown}\( C_{1}=\left\{ i\in I\ \|\ f\left(i\right)=f^{\prime}\left(i\right)\right\} \){:/nomarkdown} ונגדיר {::nomarkdown}\( C_{2}=\left\{ i\in I\ \|\ g\left(i\right)=g^{\prime}\left(i\right)\right\} \){:/nomarkdown}, אז אם {::nomarkdown}\( B\in D\){:/nomarkdown} נקבל שגם {::nomarkdown}\( B\cap C_{1}\cap C_{2}\in D\){:/nomarkdown}, ולכן גם {::nomarkdown}\( \left\{ i\in I\ \|\ \left(f^{\prime}\left(i\right),g^{\prime}\left(i\right)\right)\in R^{\mathcal{U}_{i}}\right\} \in D\){:/nomarkdown} (כי היא מכילה את {::nomarkdown}\( B\cap C_{1}\cap C_{2}\){:/nomarkdown} - למה?) ולכן אם {::nomarkdown}\( \left(\left[f\right]_{D},\left[g\right]_{D}\right)\in R^{\mathcal{M}}\){:/nomarkdown} אז גם {::nomarkdown}\( \left(\left[f^{\prime}\right]_{D},\left[g^{\prime}\right]_{D}\right)\in R^{\mathcal{M}}\){:/nomarkdown}, ובאותו האופן גם הכיוון ההפוך מתקיים.

תעלול דומה צריך לעשות גם כדי להוכיח ש-{::nomarkdown}\( F^{\mathcal{M}}\){:/nomarkdown} מוגדרת היטב, כלומר שאם {::nomarkdown}\( f\equiv_{D}f^{\prime}\){:/nomarkdown} אז {::nomarkdown}\( F^{\mathcal{M}}\left(\left[f\right]_{D}\right)=F^{\mathcal{M}}\left(\left[f^{\prime}\right]_{D}\right)\){:/nomarkdown}. מה נעשה? כזכור, {::nomarkdown}\( F^{\mathcal{M}}\left(f\right)=\left[g_{f}\right]_{D}\){:/nomarkdown} כאשר {::nomarkdown}\( g_{f}\left(i\right)=F^{\mathcal{M}_{i}}\left(f\left(i\right)\right)\){:/nomarkdown} (הפעם כתבתי במפורש ש-{::nomarkdown}\( F^{\mathcal{M}}\){:/nomarkdown} מחזיר מחלקת שקילות). אנחנו רוצים להראות ש-{::nomarkdown}\( g_{f}\equiv_{D}g_{f^{\prime}}\){:/nomarkdown}. בבירור {::nomarkdown}\( \left\{ i\in I\ \|\ g_{f}\left(i\right)=g_{f^{\prime}}\left(i\right)\right\} \){:/nomarkdown} <strong>מכילה</strong> את הקבוצה {::nomarkdown}\( \left\{ i\in I\ \|\ f\left(i\right)=f^{\prime}\left(i\right)\right\} \){:/nomarkdown}, ומכיוון ש-{::nomarkdown}\( f\equiv_{D}f^{\prime}\){:/nomarkdown} הקבוצה השניה ב-{::nomarkdown}\( D\){:/nomarkdown}, ולכן גם הראשונה ב-{::nomarkdown}\( D\){:/nomarkdown}. אלו פרטים טכניים, אבל כשמתעסקים איתם בידיים סוף סוף אפשר לקבל תחושה אמיתית למה האקסיומות שמגדירות מסננים הן הכרחיות ולמה הן קולעות בול לנקודה שהמושג של מסנן מנסה לתפוס.

עכשיו אפשר להזכיר את משפט Łoś:

{::nomarkdown}\( \mathcal{M}\models\varphi\iff\left\{ i\in I\ \|\ \mathcal{M}_{i}\models\varphi\right\} \in D\){:/nomarkdown}

איך מוכיחים אותו? ובכן, לא בצורה כיפית אלא בצורה סטנדרטית בלוגיקה - אינדוקציה. מכיוון שהפוסט הזה כבר התארך דיו, אתחמק מההוכחה ואסיים אותו כאן.
