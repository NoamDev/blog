---
id: 1358
title: "כפל מטריצות - מה, לעזאזל?"
date: 2011-10-06 06:57:37
layout: post
categories: 
  - אלגברה לינארית
  - תורת הגרפים
tags: 
  - אלגברה לינארית
  - כפל מטריצות
  - מטריצות
---
בפוסט הקודם הצגתי מטריצות בתור כלי שעוזר לי לפתור מערכת משוואות - במקום לכתוב כל פעם את כל מערכת המשוואות, אני כותב מטריצה ו"מדרג" אותה והתהליך חוסך לי כתיבה מיותרת וקצת יותר קל לקריאה. זו מן הסתם לא הסיבה למה מטריצות הן כל כך מעניינות ו"אחד המושגים הבסיסיים ביותר במתמטיקה" כפי שאני שוב ושוב מפמפם. הסיבה האמיתית היא שמטריצות הן יצורים <strong>אלגבריים</strong> - אפשר להגדיר עליהן פעולות של חיבור וכפל שבמובן מסויים מזכירות מאוד את החיבור והכפל הרגילים, וזה מעניק למטריצות <strong>מבנה</strong> מעניין.

כשאני אומר "מזכיר", אני מתכוון שמתקיים למשל {::nomarkdown}\( A+B=B+A\){:/nomarkdown} (כלל החילוף), ושמתקיים {::nomarkdown}\( A\left(B+C\right)=AB+AC\){:/nomarkdown} (כלל הפילוג) ומתקיים {::nomarkdown}\( \left(AB\right)C=A\left(BC\right)\){:/nomarkdown} (כלל הקיבוץ, שמתקיים גם לחיבור). בנוסף, עוד לפני שהפוסט הזה יסתיים נראה איך פעולת הכפל של מטריצות מתקשרת הן לפתרון משוואות והן לבעיה שונה לחלוטין - ספירת מסלולים בגרפים.

בנוסף אגלה כבר עכשיו שאחד מה"גביעים הקדושים" שאני חותר אליהם בדיבורים על אלגברה לינארית הוא ייצוג של פונקציות חשובות מסויימות (טרנספורמציות לינאריות) בתור מטריצות, ואז כפל מטריצות יתאים בדיוק לפעולה של הרכבת פונקציות. אם להיות יותר קונקרטיים, דוגמה לכך באה לידי ביטוי בציור אובייקטים תלת ממדיים: אפשר לבצע עליהם מניפולציות גאומטריות שונות ומשונות דוגמת סיבוב סביב ציור מסויים, שיקוף, וכיווץ או מתיחה - כל הפעולות הללו הן טרנספורמציות לינאריות וקיימות מטריצות שמתארות אותן, ואפשר "לאגור" ביצוע של פעולות שונות על ידי כפל של המטריצות הללו עד לקבלה של מטריצה אחת סופית שמייצגת את כל השינויים שביצענו (מי שיפתח ספריה של גרפיקה תלת ממדית, נאמר OpenGL, קרוב לודאי שיתקל שם במטריצות).

ולמה כל ההקדמה הזו? כי כפי שנראה, פעולת הכפל שאציג לא ממש תהיה מה שאנשים מצפים לה ממבט ראשון.

בואו ניזכר טיפה מהן מטריצות. מטריצה {::nomarkdown}\( A\){:/nomarkdown} שהיא מסדר {::nomarkdown}\( n\times m\){:/nomarkdown} כוללת {::nomarkdown}\( nm\){:/nomarkdown} "כניסות", כך שכל כניסה היא בעלת שני אינדקסים - הראשון בין 1 ו-{::nomarkdown}\( n\){:/nomarkdown} ("שורה") והשני בין 1 ו-{::nomarkdown}\( m\){:/nomarkdown} ("עמודה"). כל כניסה כוללת מספר כלשהו (לצורך הדיון בינתיים אני מניח שזה מספר ממשי). את הכניסה בשורה {::nomarkdown}\( i\){:/nomarkdown} ועמודה {::nomarkdown}\( j\){:/nomarkdown} מסמנים ב-{::nomarkdown}\( A_{ij}\){:/nomarkdown}.

כעת, אם יש לנו שתי מטריצות {::nomarkdown}\( A,B\){:/nomarkdown}, כיצד נגדיר מטריצה {::nomarkdown}\( C=A+B\){:/nomarkdown}? בתור התחלה, אף אחד לא אומר שאנחנו בכלל יודעים איך להגדיר כזה דבר; אם {::nomarkdown}\( A,B\){:/nomarkdown} לא שתיהן בדיוק מאותם מימדים - כלומר, עם {::nomarkdown}\( n\){:/nomarkdown} שורות ועם {::nomarkdown}\( m\){:/nomarkdown} עמודות, החיבור כלל לא מוגדר פשוט כי לא ברור איך נכון להגדיר אותו. אבל, אם {::nomarkdown}\( A,B\){:/nomarkdown} שתיהן מאותן מימדים יש הגדרה מאוד טבעית שצצה לראש - נחבר אותן "כניסה כניסה". בדוגמה:

{::nomarkdown}\( \left[\begin{array}{cc}a_{11} &amp; a_{12}\\a_{21} &amp; a_{22}\end{array}\right]+\left[\begin{array}{cc}b_{11} &amp; b_{12}\\b_{21} &amp; b_{22}\end{array}\right]=\left[\begin{array}{cc}a_{11}+b_{11} &amp; a_{12}+b_{12}\\a_{21}+b_{21} &amp; a_{22}+b_{22}\end{array}\right]\){:/nomarkdown}

ובהגדרה פורמלית: אם {::nomarkdown}\( C=A+B\){:/nomarkdown} אז {::nomarkdown}\( C_{ij}=A_{ij}+B_{ij}\){:/nomarkdown}.

זה מוביל אותנו גם להגדרה מאוד טבעית ופשוטה של כפל: אם {::nomarkdown}\( C=AB\){:/nomarkdown} אז {::nomarkdown}\( C_{ij}=A_{ij}B_{ij}\){:/nomarkdown}. כלומר, כופלים את המטריצות "כניסה כניסה". זו <strong>לא</strong> ההגדרה שאני רוצה להציג. לא שזו לא הגדרה קיימת; למכפלה "כניסה כניסה" קוראים "מכפלת הדמר", מסמנים אותה ב-{::nomarkdown}\( A\circ B\){:/nomarkdown} ומתעסקים איתה קצת. אלא שהשם "כפל מטריצות" שמור לפעולה שונה, שהיא פי עשרות מונים יותר נפוצה ושימושית.

זו נקודה שכדאי לעצור ולהתעכב עליה: אף אחד לא <strong>מחייב</strong> אותנו, כשאנחנו קוראים לפעולה כלשהי "כפל", לוודא שהיא אכן הכללה "טבעית" של פעולת כפל קיימת או כל דבר דומה; זה פשוט עניין של מתן שם שאנחנו אוהבים לפעולה שאנחנו אוהבים. ייתכן שנדמה שהיה צריך מבחינה מוסרית לקרוא לפעולת הכפל שאציג בשם "הרכבת מטריצות" או משהו דומה לכך, אבל אין לכך שום סיבה אמיתית. למעשה, ככל שמתקדמים בלימודי האלגברה כך נתקלים ביותר ויותר אובייקטים שיש בהם פעולה שמכונה "כפל" אבל איננה דומה לכפל "רגיל". המשמעות של המילה הזו אצל מתמטיקאים היא פשוט רחבה הרבה יותר מאשר נדמה במבט ראשון. אני מקווה שמספיק בשכנוע הזה כדי להסביר מדוע הטרמינולוגיה הזו היא מוזרה במבט ראשון, אבל לגיטימית לגמרי.

נעבור להגדרה. ראשית כל, בואו נדבר על מטריצות פשוט במיוחד - כאלו שיש להן רק שורה אחת, או רק עמודה אחת. מטריצה כזו נקראת <strong>וקטור</strong>. יותר במדויק - מטריצה בת שורה אחת היא <strong>וקטור שורה</strong> ומטריצה בעלת עמודה אחת היא <strong>וקטור עמודה</strong>. אפשר לחשוב על וקטורים כאלו פשוט בתור סדרות של מספרים: {::nomarkdown}\( \left(a_{1},a_{2},\dots,a_{n}\right)\){:/nomarkdown} ו-{::nomarkdown}\( \left(b_{1},b_{2},\dots,b_{n}\right)\){:/nomarkdown} הם וקטורים בעלי {::nomarkdown}\( n\){:/nomarkdown} איברים כל אחד. למי שמכיר וקטורים במשמעות גאומטרית - זה אותו הדבר, וארחיב על כך בעתיד.

כעת, וקטורים אפשר לכפול באמצעות מה שנקרא <strong>מכפלה סקלרית</strong>. מכפלה סקלרית פירושו שכופלים את הוקטורים איבר-איבר, אבל לא עוצרים כאן - אחר כך גם <strong>מחברים</strong> את התוצאה של כל פעולות הכפל הללו. יש לפעולה הזו משמעות גאומטרית כאשר חושבים על הוקטורים כעל אובייקטים גאומטריים אבל לא אכנס לכך כרגע; חשוב לי להדגיש שאפילו הפעולה הזו לא באה לגמרי משום מקום.

פורמלית, {::nomarkdown}\( \left(a_{1},a_{2},\dots,a_{n}\right)\cdot\left(b_{1},b_{2},\dots,b_{n}\right)=a_{1}b_{1}+a_{2}b_{2}+\dots+a_{n}b_{n}\){:/nomarkdown}, וזו ההזדמנות שלי להציג סימן מקוצר לחיבור שהוא קריטי כשמדברים על כפל מטריצות: {::nomarkdown}\( \Sigma\){:/nomarkdown}. בסימון המקוצר הזה המכפלה הסקלרית של הוקטורים שלמעלה מתוארת כך: {::nomarkdown}\( \sum_{i=1}^{n}a_{i}b_{i}\){:/nomarkdown}. מה שקורה כאן הוא שבתחתית של ה-{::nomarkdown}\( \Sigma\){:/nomarkdown} מגדירים "משתנה אינדקס" בשם {::nomarkdown}\( i\){:/nomarkdown} ו"מאתחלים" אותו ל-1; ה-{::nomarkdown}\( n\){:/nomarkdown} למעלה פירושו "לכל ערך טבעי של {::nomarkdown}\( i\){:/nomarkdown} החל מערך האתחול שלו ועד ל-{::nomarkdown}\( n\){:/nomarkdown}", וה-{::nomarkdown}\( a_{i}b_{i}\){:/nomarkdown} אומר שלכל {::nomarkdown}\( i\){:/nomarkdown} שרצים עליו, מוסיפים לסכום של {::nomarkdown}\( a_{i}b_{i}\){:/nomarkdown}. אין כאן שום דבר יותר מאשר כתיב מקוצר של {::nomarkdown}\( a_{1}b_{1}+a_{2}b_{2}+\dots+a_{n}b_{n}\){:/nomarkdown} שדורש הרבה, הרבה פחות מקום; ולשם שינוי אני לא אתחיל להגדיר פעולות כפל מוזרות גם על ה-{::nomarkdown}\( \Sigma\){:/nomarkdown} הזה עצמו.

עכשיו אפשר לתת הגדרה בנפנוף ידיים מהיר של כפל מטריצות: {::nomarkdown}\( C=AB\){:/nomarkdown} היא מטריצה שהכניסה ה-{::nomarkdown}\( ij\){:/nomarkdown} שלה היא התוצאה של המכפלה הסקלרית של השורה ה-{::nomarkdown}\( i\){:/nomarkdown} של {::nomarkdown}\( A\){:/nomarkdown} עם העמודה ה-{::nomarkdown}\( j\){:/nomarkdown} של {::nomarkdown}\( B\){:/nomarkdown}. הרי על שורה של מטריצה אפשר לחשוב גם כוקטור שורה העומד בפני עצמו; ועל עמודה של {::nomarkdown}\( j\){:/nomarkdown} אפשר לחשוב גם כוקטור עמודה העומד בפני עצמו; ואפשר להכפיל אותם; והתוצאה תהיה מספר, אז ההגדרה שנתתי היא בעלת משמעות.

יש בכל זאת בעיה אחת שמייד קופצת: כדי לכפול סקלרית שני וקטורים הם צריכים להיות מאותו האורך. אם אני כופל <strong>שורות</strong> של {::nomarkdown}\( A\){:/nomarkdown} ב<strong>עמודות</strong> של {::nomarkdown}\( B\){:/nomarkdown}, זה אומר שאני צריך שהאורך של כל שורה של {::nomarkdown}\( A\){:/nomarkdown} יהיה זהה לאורך של כל עמודה של {::nomarkdown}\( B\){:/nomarkdown}. זה אומר, למשל, שאי אפשר לכפול יחד שתי מטריצות מסדר {::nomarkdown}\( 2\times3\){:/nomarkdown}! במטריצה {::nomarkdown}\( \left[\begin{array}{ccc}1 &amp; 2 &amp; 3\\1 &amp; 2 &amp; 3\end{array}\right]\){:/nomarkdown} האורך של כל שורה הוא 3 (כמספר העמודות במטריצה) והאורך של כל עמודה הוא 2 (כמספר השורות במטריצה) וזה אומר שעל פי ההגדרה שנתתי אי אפשר לכפול אותה אפילו עם עצמה! זה מוזר למדי אבל זו אכן תוצאה הכרחית של ההגדרה שלי.

לכן הנה הכלל: אם {::nomarkdown}\( A\){:/nomarkdown} היא מטריצה מסדר {::nomarkdown}\( n\times m\){:/nomarkdown} ({::nomarkdown}\( n\){:/nomarkdown} שורות, {::nomarkdown}\( m\){:/nomarkdown} עמודות) ו-{::nomarkdown}\( B\){:/nomarkdown} היא מטריצה מסדר {::nomarkdown}\( k\times l\){:/nomarkdown} ({::nomarkdown}\( k\){:/nomarkdown} שורות, {::nomarkdown}\( l\){:/nomarkdown} עמודות) אז כדי שתהיה משמעות למכפלה {::nomarkdown}\( AB\){:/nomarkdown} חייב להתקיים {::nomarkdown}\( m=k\){:/nomarkdown} (מספר העמודות של {::nomarkdown}\( A\){:/nomarkdown} שווה למספר השורות של {::nomarkdown}\( B\){:/nomarkdown}). אם אכן {::nomarkdown}\( m=k\){:/nomarkdown}, אז המכפלה {::nomarkdown}\( AB\){:/nomarkdown} תהיה מטריצה מסדר {::nomarkdown}\( n\times l\){:/nomarkdown} ({::nomarkdown}\( n\){:/nomarkdown} שורות, {::nomarkdown}\( l\){:/nomarkdown} עמודות), כי יש כניסה ב-{::nomarkdown}\( AB\){:/nomarkdown} לכל זוג של שורה ב-{::nomarkdown}\( A\){:/nomarkdown} ועמודה ב-{::nomarkdown}\( B\){:/nomarkdown} שמוכפלות סקלרית.

בואו נראה דוגמה: {::nomarkdown}\( \left[\begin{array}{ccc}1 &amp; 2 &amp; \pi\\0 &amp; 3 &amp; 6\end{array}\right]\left[\begin{array}{cc}5 &amp; 0\\1 &amp; 0\\0 &amp; 1\end{array}\right]=\left[\begin{array}{cc}7 &amp; \pi\\3 &amp; 6\end{array}\right]\){:/nomarkdown}. למה הכניסה {::nomarkdown}\( 1,1\){:/nomarkdown} של המכפלה היא 7? כי זו התוצאה של המכפלה הסקלרית {::nomarkdown}\( \left(1,2,\pi\right)\cdot\left(5,1,0\right)=5+2+\pi\cdot0=7\){:/nomarkdown}. נסו להבהיר לעצמכם למה שאר הכניסות קיבלו את הערכים שהן קיבלו, ולמה הממדים של התוצאה הם {::nomarkdown}\( 2\times2\){:/nomarkdown}. אם הצלחתם, כבר הבנתם את ההגדרה גם אם טרם הבנתם "למה".

בואו נגדיר כפל באופן פורמלי כדי שלא יהיו ספקות. אם {::nomarkdown}\( A\){:/nomarkdown} היא מטריצה מסדר {::nomarkdown}\( n\times m\){:/nomarkdown} ו-{::nomarkdown}\( B\){:/nomarkdown} היא מטריצה מסדר {::nomarkdown}\( m\times k\){:/nomarkdown} אז {::nomarkdown}\( C=AB\){:/nomarkdown} היא מטריצה מסדר {::nomarkdown}\( n\times k\){:/nomarkdown} כך ש-

{::nomarkdown}\( C_{ij}=\sum_{r=1}^{m}A_{ir}B_{rj}\){:/nomarkdown}

זה הכל.

לכפל מטריצות יש תכונה מוזרה אחת (מוזרה עבור מי שרגיל לכפל "רגיל") שצריך לשים על השולחן כמה שיותר מהר: לא בהכרח מתקיים {::nomarkdown}\( AB=BA\){:/nomarkdown}. ראשית, בכלל לא ברור שתהיה משמעות גם ל-{::nomarkdown}\( AB\){:/nomarkdown} וגם ל-{::nomarkdown}\( BA\){:/nomarkdown}; בשביל זה שתי המטריצות חייבות להיות עם אותו מספר שורות ועמודות - מטריצות כאלו מכונות <strong>מטריצות ריבועיות</strong>. אבל גם אם {::nomarkdown}\( A,B\){:/nomarkdown} שתיהן ריבועיות מסדר {::nomarkdown}\( n\times n\){:/nomarkdown} זה ממש לא נכון שבהכרח יתקיים {::nomarkdown}\( AB=BA\){:/nomarkdown} (אם כי לפעמים זה כן קורה). למשל, {::nomarkdown}\( \left[\begin{array}{cc}1 &amp; 1\\0 &amp; 0\end{array}\right]\left[\begin{array}{cc}1 &amp; 0\\1 &amp; 0\end{array}\right]=\left[\begin{array}{cc}1 &amp; 0\\0 &amp; 0\end{array}\right]\){:/nomarkdown} אבל {::nomarkdown}\( \left[\begin{array}{cc}1 &amp; 0\\1 &amp; 0\end{array}\right]\left[\begin{array}{cc}1 &amp; 1\\0 &amp; 0\end{array}\right]=\left[\begin{array}{cc}1 &amp; 1\\1 &amp; 1\end{array}\right]\){:/nomarkdown}. אתם צריכים לחשוב על זה שהתכונה הזו לא מתקיימת בתור דבר <strong>טוב</strong>: זה אומר שאפשר לתאר עם כפל מטריצות עולם יותר עשיר משנדמה לנו, כי במציאות יש גם פעולות שהן לא חילופיות באופן הזה (למשל, הטרנספורמציות של צורות תלת ממדיות שהזכרתי בתחילת הפוסט אינן כאלו - לסובב ואז לשקף לא תמיד נותן אותו דבר כמו לשקף ואז לסובב).

עכשיו אני רוצה חיש קל להראות שני שימושים שונים לגמרי של הפעולה הזו. הראשון יהיה קשור למערכות של משוואות לינאריות. הטענה שלי היא פשוטה: מערכת משוואות לינארית ניתנת לתיאור פשוט באמצעות כפל מטריצות. בואו נתחיל עם דוגמה - המערכת

{::nomarkdown}\( 2x+3y=17\){:/nomarkdown}

{::nomarkdown}\( 8x-4y=6\){:/nomarkdown}

ממש לא מעניין אותי הפתרון של המערכת. מה שכן מעניין אותי היא לתרגם את הבעיה "פתור את המערכת" לבעיה "פתור את המשוואה הבאה שמערבת מטריצות". לשם כך ראשית כל אסתכל על המטריצה של מקדמי המשוואה: {::nomarkdown}\( \left[\begin{array}{cc}2 &amp; 3\\8 &amp; -4\end{array}\right]\){:/nomarkdown}. שימו לב שבניגוד לקודם, כעת אני לא לא מכניס פנימה גם את המספרים שמעבר לסימן השווה; אותם אני מכניס לוקטור נפרד - וקטור העמודה {::nomarkdown}\( \left[\begin{array}{c}17\\6\end{array}\right]\){:/nomarkdown}. בנוסף, אני אכניס לתמונה וקטור חדש לגמרי - וקטור של <strong>משתנים</strong>: {::nomarkdown}\( \left[\begin{array}{c}x\\y\end{array}\right]\){:/nomarkdown}. כעת מערכת המשוואות שלמעלה זהה לחלוטין למשוואה הבודדת הבאה על מטריצות:

{::nomarkdown}\( \left[\begin{array}{cc}2 &amp; 3\\8 &amp; -4\end{array}\right]\left[\begin{array}{c}x\\y\end{array}\right]=\left[\begin{array}{c}17\\6\end{array}\right]\){:/nomarkdown}

לא מאמינים? ובכן, קל לחשב על פי ההגדרה שנתתי שמתקיים {::nomarkdown}\( \left[\begin{array}{cc}2 &amp; 3\\8 &amp; -4\end{array}\right]\left[\begin{array}{c}x\\y\end{array}\right]=\left[\begin{array}{c}2x+3y\\8x-4y\end{array}\right]\){:/nomarkdown} (זכרו שוקטור עמודה הוא<strong> מטריצה</strong>, פשוט עם עמודה בודדת) ולכן השוויון שלמעלה הוא השוויון {::nomarkdown}\( \left[\begin{array}{c}2x+3y\\8x-4y\end{array}\right]=\left[\begin{array}{c}17\\6\end{array}\right]\){:/nomarkdown} ומכיוון שמשווים וקטורים "כניסה כניסה" זו בדיוק מערכת המשוואות המקורית.

בינתיים זה נראה עדיין כמו הבדל בשיטת הסימון, אבל מתישהו ההבדל הזה הופך להיות כל כך אפקטיבי עד שאי אפשר להתעלם ממנו יותר. עבורי זה קורה כשמבינים שאת פעולות הדירוג שהצגתי בפוסט הקודם אפשר להציג גם כן בתור פעולות של כפל מטריצות. בואו ננסה להבין איך זה קורה.

ראשית, בואו נסתכל על מטריצה מיוחדת - <strong>מטריצת היחידה</strong>, {::nomarkdown}\( I=\left[\begin{array}{ccc}1 &amp; 0 &amp; 0\\0 &amp; 1 &amp; 0\\0 &amp; 0 &amp; 1\end{array}\right]\){:/nomarkdown}. זו מטריצה מסדר {::nomarkdown}\( 3\times3\){:/nomarkdown} אבל על פי אותו עיקרון ניתן להגדיר מטריצת יחידה לכל סדר (אבל היא חייבת להיות ריבועית) במילים, לכל כניסה {::nomarkdown}\( ii\){:/nomarkdown} יש במטריצת היחידה 1, ולכל כניסה {::nomarkdown}\( ij\){:/nomarkdown} כך ש-{::nomarkdown}\( i\ne j\){:/nomarkdown} יש בה 0. המקומות שבהם נמצאים ה-1-ים של המטריצה נקראים <strong>האלכסון הראשי</strong> של המטריצה.

המטריצה הזו מעניינת כי אם {::nomarkdown}\( A\){:/nomarkdown} היא מטריצה מסדר {::nomarkdown}\( n\times m\){:/nomarkdown} ו-{::nomarkdown}\( I\){:/nomarkdown} היא מטריצת יחידה מסדר {::nomarkdown}\( n\times n\){:/nomarkdown} אז {::nomarkdown}\( IA=A\){:/nomarkdown}. כדי להבין למה, בואו ננסה להבין מהי הכניסה ה-{::nomarkdown}\( ij\){:/nomarkdown} של {::nomarkdown}\( IA\){:/nomarkdown}: זו המכפלה הסקלרית של השורה ה-{::nomarkdown}\( i\){:/nomarkdown} של {::nomarkdown}\( I\){:/nomarkdown} בעמודה ה-{::nomarkdown}\( j\){:/nomarkdown} של {::nomarkdown}\( A\){:/nomarkdown}. השורה ה-{::nomarkdown}\( i\){:/nomarkdown} של {::nomarkdown}\( I\){:/nomarkdown} כוללת רק אפסים חוץ ממקום אחד שכולל 1 - בדיוק המקום ה-{::nomarkdown}\( i\){:/nomarkdown}. אז כשכופלים את השורה הזו בעמודה ה-{::nomarkdown}\( j\){:/nomarkdown} של {::nomarkdown}\( A\){:/nomarkdown} אנחנו מתעלמים מכל הכניסות בעמודה הזו חוץ מאחת - הכניסה ה-{::nomarkdown}\( i\){:/nomarkdown}-ית, שהיא בדיוק מה שנמצא בשורה ה-{::nomarkdown}\( i\){:/nomarkdown}-ית של {::nomarkdown}\( A\){:/nomarkdown}. לכן בכניסה ה-{::nomarkdown}\( ij\){:/nomarkdown} של {::nomarkdown}\( IA\){:/nomarkdown} יהיה בדיוק את האיבר בכניסה ה-{::nomarkdown}\( ij\){:/nomarkdown} של {::nomarkdown}\( A\){:/nomarkdown}.

כעת בואו נחזור על אותה פעולת כפל אבל עם מטריצה שהיא "כמעט {::nomarkdown}\( I\){:/nomarkdown}" פרט לכך שהחלפנו את השורה הראשונה עם השניה. מהי הכניסה ה-{::nomarkdown}\( 1j\){:/nomarkdown} של המכפלה הפעם? היא תכיל את האיבר ה<strong>שני</strong> בעמודה ה-{::nomarkdown}\( j\){:/nomarkdown} של {::nomarkdown}\( A\){:/nomarkdown}. כלומר, השורה הראשונה במכפלה תכיל את השורה ה<strong>שניה</strong> של {::nomarkdown}\( A\){:/nomarkdown}, ובאופן לא מפתיע השורה השניה במכפלה תכיל את השורה הראשונה של {::nomarkdown}\( A\){:/nomarkdown}. גם כאן מומלץ לבדוק אותי עצמאית.

מה שראינו פה הוא עקרון כללי: אם נבצע פעולה אלמנטרית כלשהי על מטריצת היחידה {::nomarkdown}\( I\){:/nomarkdown} - בין אם החלפת שורות, או כפל שורה במספר, או חיבור כפולה של שורה אחת לשורה אחרת - נקבל מטריצה (שמכונה, באופן לא מפתיע, "מטריצה אלמנטרית") שהכפל שלה ב-{::nomarkdown}\( A\){:/nomarkdown} זהה להפעלת הפעולה האלמנטרית הזו על {::nomarkdown}\( A\){:/nomarkdown}.

אם כן, נניח ש-{::nomarkdown}\( \overline{x}\){:/nomarkdown} מסמן לנו וקטור של משתנים, ו-{::nomarkdown}\( \overline{c}\){:/nomarkdown} וקטור של מספרים, מערכת כללית של משוואות לינאריות מתוארת על ידי {::nomarkdown}\( A\overline{x}=\overline{c}\){:/nomarkdown} (שימו לב ש-{::nomarkdown}\( \overline{x}\){:/nomarkdown} ו-{::nomarkdown}\( \overline{c}\){:/nomarkdown} בכלל לא חייבים להיות מאותו האורך; אורכו של הראשון הוא מספר המשתנים ואורכו של השני הוא מספר המשוואות). כעת, אם {::nomarkdown}\( E\){:/nomarkdown} היא מטריצה אלמנטרית כלשהי, אפשר לכפול בה את שני אגפי המשוואה ולקבל {::nomarkdown}\( \left(EA\right)\overline{x}=E\overline{c}\){:/nomarkdown} (כמובן, צריך להוכיח שדברים כאלו באמת עובדים; אלו הוכחות לא מעניינות ולא אציג אותן כאן). אם אנחנו רוצים להפעיל שתי פעולות אלמנטריות, {::nomarkdown}\( E_{1}\){:/nomarkdown} ו-{::nomarkdown}\( E_{2}\){:/nomarkdown}, אפשר לכפול את המשוואה בהן בזו אחר זו ולקבל {::nomarkdown}\( \left(E_{2}\left(E_{1}A\right)\right)\overline{x}=E_{2}\left(E_{1}\overline{c}\right)\){:/nomarkdown}. כעת העובדה שכפל מטריצות מקיים את חוץ הקיבוץ הופכת לקריטית: זה אומר ש-{::nomarkdown}\( E_{2}\left(E_{1}A\right)=\left(E_{2}E_{1}\right)A\){:/nomarkdown}, ולכן במקום לכפול את {::nomarkdown}\( A\){:/nomarkdown} קודם ב-{::nomarkdown}\( E_{1}\){:/nomarkdown} ואז ב-{::nomarkdown}\( E_{2}\){:/nomarkdown} אפשר לכפול את {::nomarkdown}\( A\){:/nomarkdown} רק פעם אחת במטריצה {::nomarkdown}\( E_{2}E_{1}\){:/nomarkdown} ש"מקודדת בתוכה" הפעלה של שתי פעולות אלמנטריות ולא רק אחת. באותו אופן, אם אנחנו רוצים להפעיל על {::nomarkdown}\( A\){:/nomarkdown} כמות סופית כלשהי של פעולות אלמנטריות, אפשר קודם כל לכפול את המטריצות האלמנטריות אלו באלו ובסוף לקבל מטריצה {::nomarkdown}\( E\){:/nomarkdown} שכבר מאחסנת בתוכה את כל הפעולות שרוצים לבצע על {::nomarkdown}\( A\){:/nomarkdown} כשהן מסודרות לפי הסדר הנכון. אחרי הכפל נקבל {::nomarkdown}\( \left(EA\right)\overline{x}=E\overline{c}\){:/nomarkdown}; מכיוון ש-{::nomarkdown}\( E\overline{c}\){:/nomarkdown} הוא בעצמו וקטור אחר של מספרים, מה שקיבלנו בסופו של דבר הוא משוואה אחרת מהצורה {::nomarkdown}\( B\overline{x}=\overline{d}\){:/nomarkdown}, שבה אנחנו יכולים להניח ש-{::nomarkdown}\( B\){:/nomarkdown} היא מטריצה מצומצמת. בקיצור, כשבפוסט הבא אחזור לעסוק בפתרון משוואות אוכל לצמצם את כל הבעיה שלנו למשוואות מהצורה {::nomarkdown}\( B\overline{x}=\overline{d}\){:/nomarkdown} עם מטריצות מצומצמות.

את הרעיון הזה לפיו מטריצה אחת יכולה "לאגור" הרבה פעולות שונות שכל אחד מקודדת על ידי מטריצה אחרת הזכרתי גם בהקשר של פעולות על אובייקטים תלת ממדיים קודם, וזה בדיוק אותו הסיפור שם. אני חושב שזו המחשה טובה מאין כמוה לכוח שיש בחוק הקיבוץ, שאנחנו לא תמיד שמים לב אליו. אנסה לתת המחשה פשטנית: נגיד שיש לנו אלף אובייקטים, ועל כל אחד אנחנו רוצים לבצע את אותה סדרה של אלף טרנספורמציות. בלי חוק הקיבוץ, היינו צריכים להפעיל את אותן אלף טרנספורמציות על כל אחד מאלף האובייקטים - מיליון פעולות; אבל עם חוק הקיבוץ אנחנו כופלים את המטריצות של אלף הטרנספורמציות יחד, ואת התוצאה אנחנו כופלים בכל אחד מאלף האובייקטים. סך הכל אלפיים פעולות - הבדל של סדרי גודל (כמובן, העניין הזה של "אגירה" ניתן להמחשה גם עבור פעולות פשוטות כמו חיבור מספרים - זה בדיוק מה שקורה בחשבון בנק, למשל. איכשהו, אני חושב שהדוגמה עובדת הרבה יותר טוב עבור פעולה כמו כפל מטריצות שאליה אנחנו הרבה פחות מורגלים ומסוגלת לתאר טרנספורמציות יותר מורכבות מסתם חיבור או חיסור).

למשוואות נחזור בפוסט הבא, וכעת אני רוצה לדבר בחטף על דוגמה שונה לשימוש בכפל מטריצות, בהקשר של גרפים. כשאני אומר "גרף", אני מתכוון לקבוצה {::nomarkdown}\( V\){:/nomarkdown} של צמתים ו-{::nomarkdown}\( E\){:/nomarkdown} של קשתות שמחברות זוגות של צמתים; מי שלא מכיר את המושג מוזמן לקרוא <a href="http://www.gadial.net/?p=125">את הפוסט</a> שבו תיארתי אותו לראשונה.

אנחנו רוצים לספור מסלולים בגרף. מסלול הוא פשוט סדרה של צמתים כל שכל שני צמתים בסדרה מחוברים בקשת, ואורכו הוא כמספר הקשתות שבו. לכל מסלול גם יש צומת התחלתי וצומת סופי - הצמתים הראשונים והאחרונים בסדרה. כך למשל {::nomarkdown}\( v\to u\){:/nomarkdown} הוא מסלול באורך 1 מ-{::nomarkdown}\( v\){:/nomarkdown} אל {::nomarkdown}\( u\){:/nomarkdown}, ו-{::nomarkdown}\( v\to u\to w\){:/nomarkdown} הוא מסלול באורך 2 מ-{::nomarkdown}\( v\){:/nomarkdown} אל {::nomarkdown}\( w\){:/nomarkdown} (שעובר ב-{::nomarkdown}\( u\){:/nomarkdown}). גם {::nomarkdown}\( v\){:/nomarkdown} לבדו הוא מסלול: מסלול באורך 0 עם צומת התחלה {::nomarkdown}\( v\){:/nomarkdown} וצומת סיום {::nomarkdown}\( v\){:/nomarkdown}. זה נשמע מטופש אבל תכף נראה שזו הגדרה מועילה.

בגרף שלנו נרשה שצומת יכיל קשת אל עצמו (מה שנקרא "חוג עצמי") ולכן {::nomarkdown}\( v\to v\){:/nomarkdown} הוא מסלול חוקי וגם נרשה כמה קשתות בין שני צמתים (מה שנקרא "קשתות מקבילות"); שני מסלולים שכוללים בדיוק את אותה סדרת צמתים אבל מתישהו משתמשים בקשתות שונות ייחשבו שונים. אפשר לאסור על כל השכלולים הללו ועדיין מה שאציג יעבוד, אבל אני רוצה להראות תוצאה כללית ככל האפשר ולכן מרשה את זה (ובפועל לעתים קרובות אכן יש צורך בחוגים עצמיים וקשתות מקבילות; למשל, כשהגרף שלנו מגיע מאוטומט סופי דטרמיניסטי). בנוסף, הגרף יכול להיות מכוון - קשת היא תמיד מצומת א' אל צומת ב' ומסלול חייב להיות עם כיוון הקשתות כדי להיות חוקי.

כעת, נניח שיש לנו גרף עם {::nomarkdown}\( n\){:/nomarkdown} צמתים, {::nomarkdown}\( v_{1},\dots,v_{n}\){:/nomarkdown}. מגדירים עבורו מטריצה {::nomarkdown}\( A\){:/nomarkdown} מסדר {::nomarkdown}\( n\times n\){:/nomarkdown} - "מטריצת השכנויות/סמיכויות" שלו - באופן הבא: {::nomarkdown}\( A_{ij}\){:/nomarkdown} שווה למספר הקשתות מ-{::nomarkdown}\( i\){:/nomarkdown} אל {::nomarkdown}\( j\){:/nomarkdown}. כלומר זה מספר שלם אי שלילי (בגלל שאנחנו מרשים קשתות מקבילות, {::nomarkdown}\( A_{ij}\){:/nomarkdown} יכול להיות גדול מ-1; ובגלל שהגרף מכוון {::nomarkdown}\( A_{ij}\){:/nomarkdown} לא בהכרח שווה ל-{::nomarkdown}\( A_{ji}\){:/nomarkdown}).

מכיוון ש-{::nomarkdown}\( A\){:/nomarkdown} היא מטריצה ריבועית, אפשר לכפול אותה בעצמה. {::nomarkdown}\( A^{k}\){:/nomarkdown} היא מה שמקבלים כשכופלים את {::nomarkdown}\( A\){:/nomarkdown} בעצמה {::nomarkdown}\( k\){:/nomarkdown} פעמים. כמו ש-{::nomarkdown}\( a^{0}=1\){:/nomarkdown} עבור מספרים, כך מגדירים גם ש-{::nomarkdown}\( A^{0}=I\){:/nomarkdown} כאשר {::nomarkdown}\( I\){:/nomarkdown} היא מטריצת היחידה מסדר {::nomarkdown}\( n\times n\){:/nomarkdown}.

כעת אפשר לעבור לתוצאה המקסימה: {::nomarkdown}\( A^{t}\){:/nomarkdown} היא מטריצה שמקודדת בדיוק את מספרי המסלולים מאורך {::nomarkdown}\( t\){:/nomarkdown} בין כל שני צמתים בגרף; יותר בפירוט, {::nomarkdown}\( A_{ij}^{t}\){:/nomarkdown} הוא בדיוק מספר המסלולים מאורך {::nomarkdown}\( t\){:/nomarkdown} מ-{::nomarkdown}\( v_{i}\){:/nomarkdown} אל {::nomarkdown}\( v_{j}\){:/nomarkdown}.

למה זה עובד? ובכן, עבור {::nomarkdown}\( A^{0}\){:/nomarkdown} זה ברור מההגדרה שנתתי: מסלול באורך 0 חייב להתחיל ולהסתיים באותו צומת, ויש בדיוק 1 כזה. זה מתאים בדיוק לכך שעל האלכסון הראשי של {::nomarkdown}\( A^{0}\){:/nomarkdown} יש 1 ובשאר הכניסות יש 0.

עבור {::nomarkdown}\( A^{1}\){:/nomarkdown} זה גם ברור: כל קשת {::nomarkdown}\( v\to u\){:/nomarkdown} מגדירה מסלול באורך 1 מ-{::nomarkdown}\( v\){:/nomarkdown} אל {::nomarkdown}\( u\){:/nomarkdown}, ולכן מספר המסלולים הכולל מ-{::nomarkdown}\( v\){:/nomarkdown} אל {::nomarkdown}\( u\){:/nomarkdown} באורך 1 הוא כמספר הקשתות מ-{::nomarkdown}\( v\){:/nomarkdown} אל {::nomarkdown}\( u\){:/nomarkdown}.

הכיף מתחיל עבור {::nomarkdown}\( A^{2}\){:/nomarkdown}, וכאן ההגדרה של כפל מטריצות מתגלה במלוא כוחה. מהו מסלול באורך 2? מסלול מהצורה {::nomarkdown}\( v\to u\to w\){:/nomarkdown} (הצמתים לא חייבים להיות שונים אלו מאלו בהכרח). אם אנחנו מתעניינים במספר המסלולים מ-{::nomarkdown}\( v\){:/nomarkdown} אל {::nomarkdown}\( w\){:/nomarkdown}, אז כל מסלול כזה נבנה באופן הבא: בחר צומת {::nomarkdown}\( u\){:/nomarkdown} שישמש בתור צומת האמצע; בחר קשת מ-{::nomarkdown}\( v\){:/nomarkdown} אל {::nomarkdown}\( u\){:/nomarkdown} (אם קיימת כזו), ואז בחר קשת מ-{::nomarkdown}\( u\){:/nomarkdown} אל {::nomarkdown}\( w\){:/nomarkdown} (אם קיימת כזו).

כמה מסלולים כאלו יש? אם קבענו את {::nomarkdown}\( u\){:/nomarkdown}, אז נותר לבחור קשת מ-{::nomarkdown}\( v\){:/nomarkdown} אל {::nomarkdown}\( u\){:/nomarkdown}, ולבחור קשת מ-{::nomarkdown}\( u\){:/nomarkdown} אל {::nomarkdown}\( w\){:/nomarkdown}, ושתי הבחירות הללו בלתי תלויות זו בזו, ולכן מספר האפשרויות הוא מכפלה של מספר האפשרויות לבחור קשת מ-{::nomarkdown}\( v\){:/nomarkdown} אל {::nomarkdown}\( u\){:/nomarkdown} במספר האפשרויות לבחור קשת מ-{::nomarkdown}\( u\){:/nomarkdown} אל {::nomarkdown}\( w\){:/nomarkdown} (זהו "עקרון הכפל" הקומבינטורי). כעת, לכל {::nomarkdown}\( u\){:/nomarkdown} שיכול לשמש כצומת ביניים אנחנו מקבלים מספר אפשרויות כלשהו, ולכן מספר האפשרויות הכולל הוא סכום כל האפשרויות על כל ה-{::nomarkdown}\( u\){:/nomarkdown}-ים האפשריים (זהו "עקרון החיבור" הקומבינטורי).

בואו נסמן את הצמתים במספרים כדי שיהיה לנו קצת יותר קל. נניח שאנחנו רוצים לדעת כמה מסלולים יש מ-{::nomarkdown}\( v_{i}\){:/nomarkdown} אל {::nomarkdown}\( v_{j}\){:/nomarkdown}, וש-{::nomarkdown}\( v_{r}\){:/nomarkdown} הוא צומת הביניים שלנו. אז יש {::nomarkdown}\( A_{ir}\){:/nomarkdown} קשתות מ-{::nomarkdown}\( v_{i}\){:/nomarkdown} אל {::nomarkdown}\( v_{r}\){:/nomarkdown}; {::nomarkdown}\( A_{rj}\){:/nomarkdown} קשתות מ-{::nomarkdown}\( v_{r}\){:/nomarkdown} אל {::nomarkdown}\( v_{j}\){:/nomarkdown}; ולכן {::nomarkdown}\( A_{ir}A_{rj}\){:/nomarkdown} מסלולים מ-{::nomarkdown}\( v_{i}\){:/nomarkdown} אל {::nomarkdown}\( v_{j}\){:/nomarkdown} שעוברים דרך {::nomarkdown}\( v_{r}\){:/nomarkdown}; ולכן {::nomarkdown}\( \sum_{r=1}^{n}A_{ir}A_{rj}\){:/nomarkdown} מסלולים בסך הכל מ-{::nomarkdown}\( v_{i}\){:/nomarkdown} אל {::nomarkdown}\( v_{j}\){:/nomarkdown}. אבל {::nomarkdown}\( \sum_{r=1}^{n}A_{ir}A_{rj}\){:/nomarkdown} ידידינו הוא <strong>בדיוק</strong> ההגדרה שלנו לכניסה ה-{::nomarkdown}\( ij\){:/nomarkdown} בכפל המטריצה {::nomarkdown}\( A\){:/nomarkdown} בעצמה, ולכן {::nomarkdown}\( A^{2}\){:/nomarkdown} אכן מקודד בדיוק את המסלולים מאורך 2 בין צמתים בגרף.

ההוכחה הכללית עבור {::nomarkdown}\( A^{t}\){:/nomarkdown} פשוטה באותה מידה, אם שמים לב לכך ש-{::nomarkdown}\( A^{t}=A^{t-1}A\){:/nomarkdown} ומשתמשים באינדוקציה כדי להניח ש-{::nomarkdown}\( A^{t-1}\){:/nomarkdown} כבר מקודד את מספר המסלולים מאורך {::nomarkdown}\( t-1\){:/nomarkdown} בין צמתים בגרף. במקרה זה, אפשר לחשוב על מסלול מאורך {::nomarkdown}\( t\){:/nomarkdown} בגרף מ-{::nomarkdown}\( v_{i}\){:/nomarkdown} אל {::nomarkdown}\( v_{j}\){:/nomarkdown} כאילו הוא מהצורה {::nomarkdown}\( v_{i}\rightarrow v_{r}\to v_{j}\){:/nomarkdown}, כאשר {::nomarkdown}\( v_{i}\rightarrow v_{r}\){:/nomarkdown} מייצג לא קשת אחת אלא מסלול שלם מאורך {::nomarkdown}\( t-1\){:/nomarkdown} מ-{::nomarkdown}\( v_{i}\){:/nomarkdown} אל {::nomarkdown}\( v_{r}\){:/nomarkdown}. שאר הניתוח זהה: מספר המסלולים מ-{::nomarkdown}\( v_{i}\){:/nomarkdown} אל {::nomarkdown}\( v_{j}\){:/nomarkdown} מאורך {::nomarkdown}\( t\){:/nomarkdown} שהצומת הלפני-אחרון בהם הוא {::nomarkdown}\( v_{r}\){:/nomarkdown} הוא כמספר המסלולים מאורך {::nomarkdown}\( t-1\){:/nomarkdown} מ-{::nomarkdown}\( v_{i}\){:/nomarkdown} אל {::nomarkdown}\( v_{r}\){:/nomarkdown} כפול מספר הקשתות מ-{::nomarkdown}\( v_{r}\){:/nomarkdown} אל {::nomarkdown}\( v_{j}\){:/nomarkdown}. סוף הסיפור.

אני לא יכול להתאפק כאן ולהזכיר מאוד בחטף נושא מתקדם טיפה יותר. נניח שהמטריצה {::nomarkdown}\( A\){:/nomarkdown} שלנו, במקום לקודד את <strong>מספר</strong> הקשתות, הייתה מקודדת <strong>הסתברות</strong> למעבר מ-{::nomarkdown}\( v_{i}\){:/nomarkdown} אל {::nomarkdown}\( v_{j}\){:/nomarkdown}? כלומר, הגרף שלנו היה כזה שבו אם אתם נמצאים בצומת מסוייים, אז בסיבוב הבא עליכם לזוז לצומת אחר (או להישאר במקום - זה נחשב כאילו זזתם מהצומת אל עצמו) והייתם בוחרים לאן לעבור בהסתברות קבועה מסויימת על בסיס המיקום הנוכחי שלכם. אם {::nomarkdown}\( A\){:/nomarkdown} הייתה המטריצה שמקודדת את ההסתברויות הללו, מה הייתה המשמעות של {::nomarkdown}\( A^{t}\){:/nomarkdown}? כמעט אותו דבר - {::nomarkdown}\( A_{ij}^{t}\){:/nomarkdown} הייתה ההסתברות שבה אם התחלתם מ-{::nomarkdown}\( v_{i}\){:/nomarkdown} וביצעתם {::nomarkdown}\( t\){:/nomarkdown} סיבובים, תגיעו אל {::nomarkdown}\( v_{j}\){:/nomarkdown}. לכן אם אנחנו יודעים איך מתנהגת {::nomarkdown}\( A^{t}\){:/nomarkdown} עבור ערכים גדולים מאוד של {::nomarkdown}\( t\){:/nomarkdown}, אנחנו יודעים מה ההתנהגות לאורך זמן של ההילוך האקראי הזה - לאיזה מקומות בגרף יותר סביר להגיע ולבלות בהם יותר זמן, וכדומה. הרעיון הזה עמד בבסיס אלגוריתם הדירוג של גוגל (מה שידוע על אלגוריתם הדירוג של גוגל, לפחות) כאשר הגרף הוא "האינטרנט" (ואתרים חשובים בו הם כאלו שאליהם ההילוך המקרי מגיע לעתים קרובות יותר) והניתוח של התנהגות {::nomarkdown}\( A^{t}\){:/nomarkdown} עבור ערכים גדולים של {::nomarkdown}\( t\){:/nomarkdown} אכן מערב לו עוד אלגברה לינארית שטרם הגעתי אליה (בפרט, את המושגים של ערכים עצמיים ווקטורים עצמיים).

אם כן, אנו רואים כאן שכפל מטריצות מקודד בתוכו סוג מסויים של פעולה יסודית למדי במתמטיקה, כזו שצצה לה בהקשרים שונים ומשונים (ותאמינו לי, עוד לא ראיתם כלום). אני מקווה שגם אלו מכם שעדיין לא התרגלו להגדרה המוזרה ילמדו לחבב אותה לאורך זמן; לטעמי, להתרגל לפעולה הזו ולטבעיות הרבה שלה היא צעד חשוב בדרך להבנה מהי מתמטיקה "אמיתית".
