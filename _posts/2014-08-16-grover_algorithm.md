---
id: 3169
title: "אלגוריתם גרובר"
date: 2014-08-16 11:16:03
layout: post
categories: 
  - תורת הסיבוכיות
tags: 
  - אלגוריתם גרובר
  - חישוב קוונטי
---
אלגוריתם גרובר הוא הדוגמה הראשונה שכדאי להראות כשמתחילים להראות אלגוריתמים בחישוב קוונטי, מכיוון שהוא פשוט יחסית, עובד בצורה מאוד אינטואיטיבית וציורית, ויש לו יתרון מוכח על אלגוריתמים קלאסיים שפותרים את אותה הבעיה. ומה הבעיה הזו? בעיה של <strong>חיפוש</strong> במבנה נתונים לא מסודר.

ברוב מבני הנתונים בעולם יש סדר וארגון כלשהם שמאפשרים לנו לחפש בהם איברים בצורה נוחה. דוגמה קלאסית היא מערך ממויין - במערך כזה, שבו אפשר להשוות כל זוג איברים והם ממויינים מהקטן אל הגדול, אפשר למצוא איבר בזמן {::nomarkdown}\( \log N\){:/nomarkdown} כאשר {::nomarkdown}\( N\){:/nomarkdown} הוא מספר האיברים הכולל במערך, באמצעות <strong>חיפוש בינארי</strong>. אבל מה קורה במערך בלי שום סדר וארגון? אין לנו ברירה אלא לבצע {::nomarkdown}\( N\){:/nomarkdown} שאילתות - לעבור איבר איבר ולבדוק אם הוא מתאים לקריטריון החיפוש שלנו. כלומר, זמן הריצה שלנו הוא {::nomarkdown}\( O\left(N\right)\){:/nomarkdown} האלגוריתם של גרובר פותר את הבעיה בזמן ריצה שהוא {::nomarkdown}\( O\left(\sqrt{N}\right)\){:/nomarkdown} - כלומר, יש לאלגוריתם זמן ריצה <strong>טוב יותר</strong> אסימפטוטית מהאלגוריתם הקלאסי הטוב ביותר שיכול להיות. זו המחשה ליתרון אמיתי של חישוב קוונטי על פני חישוב רגיל.

איך קורה הקסם הזה? איך אלגוריתם קוונטי מחפש במבנה נתונים לא מסודר כל כך מהר? התשובה היא שבדיוק כפי שמתואר חישוב קוונטי בספרי מדע פופולרי: האלגוריתם איכשהו מריץ את השאילתה "האם אתה האיבר שאני מחפש?" על כל אברי המערך בו זמנית, באמצעות הסתמכות על העובדה שהוא מחזיק מעין <strong>סופרפוזיציה</strong> של כל אברי המערך. אבל לעשות את זה, זה עדיין לא מספיק טוב - מדידה של הסופרפוזיציה הזו תניב את האיבר שאנחנו מחפשים רק בהסתברות נמוכה. לכן גרובר מבצע תהליך של <strong>הגברה</strong> - מניפולציה של המצב הקוונטי שחוזרת על עצמה שוב ושוב, ומבטיחה שאם האיבר שאנחנו מחפשים בכלל קיים במערך, אז לאט לאט ההסתברות שמדידה תחזיר אותו הולכת וגדלה. מספיק לחזור על התהליך הזה {::nomarkdown}\( O\left(\sqrt{N}\right)\){:/nomarkdown} פעמים כדי לקבל הסתברות מצויינת למצוא את האיבר שאנחנו מחפשים.

בפוסט המבוא שלי לנושא החישוב הקוונטי אמרתי ש"עדיין אין לנו הוכחה מתמטית שחישוב קוונטי הוא אכן חזק מבחינת סיבוכיות יותר מחישוב רגיל", מה שלכאורה נסתר על ידי האלגוריתם של גרובר, ולכן צריך להבהיר את הכוונה ב"חזק מבחינת סיבוכיות". בואו נדבר למשל על מכונות טיורינג - המודל הפשוט ביותר הוא <strong>חד סרטי</strong> אבל יש גם מודל <strong>דו סרטי</strong> ועוד שלל וריאציות. ההבדלים בין המודלים הללו מוסיפים כוח חישובי כלשהו; יש בעיות שהמודל הדו סרטי יפתור בזמן {::nomarkdown}\( T\){:/nomarkdown} אך למודל החד סרטי יידרש זמן {::nomarkdown}\( T^{2}\){:/nomarkdown} כדי לפתור, כלומר המודל הדו סרטי פותר את הבעיה בזמן ריצה שורש של זמן הריצה שנדרש למודל החד סרטי, בדיוק כמו השיפור של אלגוריתם גרובר.

ההבדלים הללו יכולים להיות חשובים בחיים האמיתיים, אבל בחיים האמיתיים יש אינסוף פרטי מימוש אחר שצריכים לדבר עליהם - מה שפותרים איתו בעיות הוא מחשב, ולא מכונת טיורינג, והמחשב מתבסס על מעבד, ובמעבד יש אופטימיזציות, ויש סט מורכב של פקודות לוגיות. ויש ענייני תזמון וניהול אנרגיה, ויש מטמון (Cache), ויש הרצת פקודות שלא על פי הסדר המתואר בתוכנית, ויש ניבוי של קפיצות בפקודות if ויש עוד אינסוף דברים שכולם קריטיים לחלוטין עבור תכנות בחיים האמיתיים. ואני לא רוצה שיתקבל רושם שגוי - אלו דברים <strong>ממש מגניבים</strong>, ובהחלט מתחשבים בהם במציאות. אבל כשאנחנו מתעסקים בסיבוכיות, כדי לא לטבוע בפרטים כאלו, אנחנו מנסים להתרחק מהכל ולדבר בצורה "נקיה" ככל האפשר.

ומכיוון שהמודל הדו סרטי והמודל החד סרטי שונים זה מזה מבחינת הסיבוכיות שלהם, אנחנו מאמצים רזולוציה שבה הם נראים אותו דבר. זה מה שמוביל להגדרה של "חישוב יעיל" ככזה שמתבצע בזמן <strong>פולינומי</strong>, ולהגדרת מחלקת הסיבוכיות {::nomarkdown}\( \mbox{P}\){:/nomarkdown}. גם הגדרת מחלקת הסיבוכיות של חישוב קוונטי יעיל, BQP, הונעה משיקולים דומים. מה שאמרתי בפוסט הראשון הוא שאין לנו הוכחה מתמטית לכך ש-{::nomarkdown}\( \mbox{P}\ne\mbox{BQP}\){:/nomarkdown} (הוכחה שכזו תהיה, למשל, הוכחה לכך שפירוק לגורמים לא ניתן לביצוע בזמן פולינומי; זאת מכיוון שנראה בהמשך את אלגוריתם שור שהוא אלגוריתם קוונטי יעיל לפירוק לגורמים). האלגוריתם של גרובר לא מהווה שיפור בסדר גודל מספיק כדי שיהיו לו השלכות של ממש על שאלת {::nomarkdown}\( \mbox{P}\ne\mbox{BQP}\){:/nomarkdown} המדוברת. אגב, באותה פסקה בפוסט המבוא אמרתי גם "יש דברים שאפשר להוכיח שבהם חישוב קוונטי עוזר לנו יותר מאשר בחישוב רגיל ואציג דוגמה אחת לפחות בפוסטים הבאים" - האלגוריתם של גרובר הוא בדיוק דוגמה שכזו.

בואו נעבור לניסוח קצת יותר פורמלי של הבעיה. אני מתאר את הבעיה בתור "חיפוש במסד נתונים", אבל אנחנו מעדיפים לשמור את "מסד הנתונים" הזה אבסטרקטי ככל הניתן כדי שהאלגוריתם לא יהיה תלוי בפרטים הטכניים שלו. האופן שבו אוהבים בתורת הסיבוכיות לבצע אבסטרקציות כאלו היא בעזרת <strong>אורקל</strong>. אורקל הוא פרוצדורה חישובית כלשהי שאנחנו מתייחסים אליה כאל "קופסה שחורה" - לא יודעים איך היא ממומשת, ומניחים שזמן הריצה שלה הוא זניח. האלגוריתם שלנו ימדד, בין היתר, על בסיס השאלה "כמה קריאות לאורקל ביצעת?"

במקרה שלנו אנחנו רוצים לייצג את אברי מסד הנתונים פשוט בתור מספרים מ-1 עד {::nomarkdown}\( N\){:/nomarkdown}, והאורקל יקבל כקלט מספר ויגיד האם המספר הזה הוא האיבר שאנחנו מחפשים. הנה דרך לפרמל את זה: נניח כי {::nomarkdown}\( N=2^{n}\){:/nomarkdown} עבור מספר טבעי {::nomarkdown}\( n\){:/nomarkdown} כלשהו, ונייצג כל איבר במסד הנתונים באמצעות סדרה של {::nomarkdown}\( n\){:/nomarkdown} ביטים (אז פורמלית אנחנו מתארים פה את המספרים מ-0 עד {::nomarkdown}\( N-1\){:/nomarkdown}). האורקל במקרה הנוכחי יהיה אופרטור קוונטי {::nomarkdown}\( O\){:/nomarkdown}, שלא מבצע מדידה אבל עושה את הדבר הבא: אם {::nomarkdown}\( \left\|x\right\rangle \){:/nomarkdown} הוא מצב קוונטי שאינו מייצג את האיבר שאנו מחפשים, אז {::nomarkdown}\( \left\|x\right\rangle \mapsto\left\|x\right\rangle \){:/nomarkdown}, ואם הוא כן מייצג את האיבר שאנו מחפשים, אז {::nomarkdown}\( \left\|x\right\rangle \mapsto-\left\|x\right\rangle \){:/nomarkdown}. פורמלית אפשר לדבר על פונקציה {::nomarkdown}\( f\left(x\right)\){:/nomarkdown} שמחזירה 1 על איברים שמתאימים לקריטריון החיפוש שלנו ו-0 אחרת, ואז {::nomarkdown}\( \left\|x\right\rangle \mapsto\left(-1\right)^{f\left(x\right)}\left\|x\right\rangle \){:/nomarkdown} הוא האופרטור.נחזור בסוף הפוסט לשאלה איך אפר להניח שיש לנו אורקל שמבצע כזה חישוב, אבל נעזוב את זה לבינתיים - העיקר הוא שיש לנו אינדיקטור כלשהו שמצביע על האיבר ה"נכון".

האלגוריתם מתחיל כשאנחנו נמצאים במצב של סופרפוזיציה סימטרית של כל המצבים האפשריים. אבל אין צורך להניח שזה המצב ההתחלתי; אפשר להגיד שהמצב ההתחלתי הוא {::nomarkdown}\( \left\|00\dots0\right\rangle \){:/nomarkdown} ושאנחנו עוברים למצב הסופרפוזיציה הסימטרית על ידי הפעלה של האופרטור {::nomarkdown}\( H\otimes H\otimes\dots\otimes H\){:/nomarkdown}. כזכור, {::nomarkdown}\( H\){:/nomarkdown} הוא שער קוונטי שפועל על קיוביט בודד באופן הבא: {::nomarkdown}\( \left\|0\right\rangle \mapsto\frac{\left\|0\right\rangle +\left\|1\right\rangle }{\sqrt{2}}\){:/nomarkdown} ו-{::nomarkdown}\( \left\|1\right\rangle \mapsto\frac{\left\|0\right\rangle -\left\|1\right\rangle }{\sqrt{2}}\){:/nomarkdown}. כעת, {::nomarkdown}\( H\otimes H\otimes\dots\otimes H\){:/nomarkdown} הוא אופרטור שפועל על כל {::nomarkdown}\( n\){:/nomarkdown} הקיוביטים של הרגיסטר הקוונטי שלנו; בפוסט הקודם לא הרשיתי משהו כזה אלא דרשתי ששער קוונטי יפעל על שלושה קיוביטים לכל היותר. האפקט הזה מושג על ידי <strong>שרשור</strong> {::nomarkdown}\( n\){:/nomarkdown} עותקים של {::nomarkdown}\( H\){:/nomarkdown}, שכל אחד פועל על קיוביט אחר (כלומר, בעצם אני מפעיל סדרתית את {::nomarkdown}\( H\otimes I\otimes\dots\otimes I\){:/nomarkdown} ואז {::nomarkdown}\( I\otimes H\otimes\dots\otimes I\){:/nomarkdown} וכן הלאה). בהמשך אני אניח שהעניין הזה ברור לכם וכשאציין אופרטור שפועל על כל הקיוביטים "בבת אחת" נבין שמדובר על שרשור של כמה שערים (למרות שאולי לא תמיד ברור <strong>איך</strong> להציג את האופרטור כשרשור כזה). מכיוון שזה מסורבל לכתוב {::nomarkdown}\( H\otimes H\otimes\dots\otimes H\){:/nomarkdown} אני אשתמש בסימון {::nomarkdown}\( H^{\otimes n}\){:/nomarkdown} שהוא למען האמת אינפורמטיבי יותר כי {::nomarkdown}\( n\){:/nomarkdown} מופיע בו במפורש.

כעת, בואו נסמן {::nomarkdown}\( \left\|\psi\right\rangle =H^{\otimes n}\left\|0\dots0\right\rangle =\frac{1}{\sqrt{N}}\sum_{x=0}^{N-1}\left\|x\right\rangle \){:/nomarkdown}. בעזרת {::nomarkdown}\( \left\|\psi\right\rangle \){:/nomarkdown} אפשר להגדיר אופרטור חדש: {::nomarkdown}\( 2\left\|\psi\right\rangle \left\langle \psi\right\|-I\){:/nomarkdown}. האם אפשר לממש את האופרטור הזה עם שערים קוונטיים? כן, ונדבר על זה בהמשך. עכשיו אפשר לשרשר את האופרטור הזה לאופרטור {::nomarkdown}\( O\){:/nomarkdown} של האורקל, ולקבל אופרטור {::nomarkdown}\( G=\left(2\left\|\psi\right\rangle \left\langle \psi\right\|-I\right)O\){:/nomarkdown}. עכשיו סוף סוף אפשר לתאר פורמלית את האלגוריתם של גרובר:
<ol>
	<li>התחילו עם הרגיסטר {::nomarkdown}\( R=\left\|0\dots0\right\rangle \){:/nomarkdown}.</li>
	<li>חשבו את {::nomarkdown}\( R\leftarrow H^{\otimes n}R\){:/nomarkdown}.</li>
	<li>בצעו במשך {::nomarkdown}\( \sqrt{N}\){:/nomarkdown} פעמים:
<ol>
	<li>{::nomarkdown}\( R\leftarrow G\left(R\right)\){:/nomarkdown}</li>
</ol>
</li>
	<li>מדדו את {::nomarkdown}\( R\){:/nomarkdown} והחזירו את התוצאה.</li>
</ol>
וזהו. בהסתברות טובה המדידה תיתן לנו {::nomarkdown}\( x\){:/nomarkdown} כך ש-{::nomarkdown}\( f\left(x\right)=1\){:/nomarkdown}. זה נראה כמו קסם, כמובן; עיקר הפוסט יוקדש לשאלה למה הקסם הזה עובד, אם כי את האינטואיציה כבר הסברתי.

אפשר להתחיל לנתח אלגברית את {::nomarkdown}\( G\){:/nomarkdown}, אבל הדרך המקובלת לנתח אותי היא בצורה <strong>גאומטרית</strong>. אני איום ונורא בגאומטריה ועדיין הצלחתי להבין את הרעיון הזה, אז בואו ותשתפו איתי פעולה. בואו נניח לצורך פשטות שקיים רק {::nomarkdown}\( a\){:/nomarkdown} יחיד כך ש-{::nomarkdown}\( f\left(a\right)=1\){:/nomarkdown}. נסתכל על הוקטורים {::nomarkdown}\(  \left\|\psi\right\rangle \){:/nomarkdown} ו-{::nomarkdown}\( \left\|a\right\rangle \){:/nomarkdown} - כנראה יעזור לכם לדמיין אותם במרחב כך ש-{::nomarkdown}\( \left\|a\right\rangle \){:/nomarkdown} שוכב על הרצפה, ואילו {::nomarkdown}\( \left\|\psi\right\rangle \){:/nomarkdown} נמצא בזווית כלשהי מעליו. בהתחלה {::nomarkdown}\( R\){:/nomarkdown} שלנו זהה ל-{::nomarkdown}\( \left\|\psi\right\rangle \){:/nomarkdown}. הרעיון הוא שבכל הפעלה של {::nomarkdown}\( G\){:/nomarkdown}, {::nomarkdown}\( R\){:/nomarkdown} הולך "להימשך" לכיוון {::nomarkdown}\( \left\|a\right\rangle \){:/nomarkdown} שעל הרצפה. אני גרוע בציורים תלת ממדיים אז הנה איור דו ממדי של "מבט מהצד" על מה שקורה:

<strong><a href="http://www.gadial.net/wp-content/uploads/2014/08/grover_operation.png"><img class="aligncenter size-full wp-image-3171" alt="grover_operation" src="http://www.gadial.net/wp-content/uploads/2014/08/grover_operation.png" width="450" height="545" /></a></strong>

אם כן, כל הפעלה של {::nomarkdown}\( G\){:/nomarkdown} <strong>מסובבת</strong> את {::nomarkdown}\( R\){:/nomarkdown} קצת בתוך המישור שנפרש על ידי {::nomarkdown}\( \left\|\psi\right\rangle \){:/nomarkdown} ו-{::nomarkdown}\( \left\|a\right\rangle \){:/nomarkdown}. נסובב מספיק, ו-{::nomarkdown}\( R\){:/nomarkdown} יהיה קרוב ל-{::nomarkdown}\( \left\|a\right\rangle \){:/nomarkdown} כך שמדידה של {::nomarkdown}\( R\){:/nomarkdown} תניב את {::nomarkdown}\( \left\|a\right\rangle \){:/nomarkdown} בהסתברות טובה. נסובב יותר מדי - ו-{::nomarkdown}\( R\){:/nomarkdown} יחלוף על פני {::nomarkdown}\( \left\|a\right\rangle \){:/nomarkdown} ויתחיל להתרחק ממנו, אז לסובב יותר מדי זה גם כן לא רעיון טוב.

בואו ננסה עכשיו להיות קצת יותר פורמליים. אני רוצה לדבר על גאומטריה וזוויות וכאלה. במרחבי מכפלה פנימית נהוג <strong>להגדיר</strong> זווית באמצעות המכפלה הפנימית: אם {::nomarkdown}\( a,b\){:/nomarkdown} הם וקטורים, אז מאי שוויון קושי שוורץ נובע ש-{::nomarkdown}\( \left\|\left\langle a,b\right\rangle \right\|\le\\|a\\|\\|b\\|\){:/nomarkdown}. זה אומר ש-{::nomarkdown}\( 0\le\frac{\left\|\left\langle a,b\right\rangle \right\|}{\\|a\\|\\|b\\|}\le1\){:/nomarkdown} ולכן יש למשוואה {::nomarkdown}\( \cos\alpha=\frac{\left\|\left\langle a,b\right\rangle \right\|}{\\|a\\|\\|b\\|}\){:/nomarkdown} פתרון יחיד עם {::nomarkdown}\( \alpha\in\left[0,\frac{\pi}{2}\right]\){:/nomarkdown}. ה-{::nomarkdown}\( \alpha\){:/nomarkdown} הזו מוגדרת להיות הזווית בין {::nomarkdown}\( a,b\){:/nomarkdown}. כדי שיתקבל {::nomarkdown}\( \alpha=\frac{\pi}{2}\){:/nomarkdown} צריך שיתקיים {::nomarkdown}\( \left\|\left\langle a,b\right\rangle \right\|=0\){:/nomarkdown}, כלומר ש-{::nomarkdown}\( a,b\){:/nomarkdown} יהיו אורתוגונליים.

כעת, מהו {::nomarkdown}\( \left\|\left\langle a,\psi\right\rangle \right\|\){:/nomarkdown}? ובכן, זה קל. {::nomarkdown}\( \left\|\psi\right\rangle =\frac{1}{\sqrt{N}}\sum_{x=0}^{N-1}\left\|x\right\rangle \){:/nomarkdown} ו-{::nomarkdown}\( \left\|a\right\rangle \){:/nomarkdown} הוא אחד מהאיברים בצירוף הלינארי הזה. מכיוון שהצירוף הזה הוא של בסיס אורתונורמלי, נקבל ש-{::nomarkdown}\( \left\|\left\langle a,\psi\right\rangle \right\|=\frac{1}{\sqrt{N}}\){:/nomarkdown}. זה מספר חיובי, ולכן {::nomarkdown}\( \alpha\ne\frac{\pi}{2}\){:/nomarkdown}, ומכאן שניתן לכתוב את {::nomarkdown}\( \alpha\){:/nomarkdown} כך: {::nomarkdown}\( \alpha=\frac{\pi}{2}-\theta\){:/nomarkdown} כאשר {::nomarkdown}\( \theta\){:/nomarkdown} היא זווית חיובית.

למה לטרוח כל כך עם הסימון המסורבל הזה? מכיוון ש-{::nomarkdown}\( \theta\){:/nomarkdown} מאפשרת לנו לדבר במדויק על "כמה סיבוב" מבצעת {::nomarkdown}\( G\){:/nomarkdown} - בכל פעם שבה היא מופעלת, היא מקטינה את הזווית ב-{::nomarkdown}\( 2\theta\){:/nomarkdown}. כלומר, אם הזווית בין {::nomarkdown}\( R\){:/nomarkdown} ובין {::nomarkdown}\( \left\|a\right\rangle \){:/nomarkdown} הייתה {::nomarkdown}\( \beta\){:/nomarkdown} בשלב מסויים של האלגוריתם, אז אחרי הפעלת {::nomarkdown}\( G\){:/nomarkdown} הזווית תהיה {::nomarkdown}\( \beta-2\theta\){:/nomarkdown}. זה אומר שאחרי {::nomarkdown}\( k\){:/nomarkdown} הפעלות של האלגוריתם נהיה בזווית {::nomarkdown}\( \frac{\pi}{2}-\left(2k+1\right)\theta\){:/nomarkdown}. נניח שהיעד שלנו הוא להגיע לזווית {::nomarkdown}\( \frac{\pi}{4}\){:/nomarkdown}, אז אנחנו רוצים שיתקיים {::nomarkdown}\( \frac{\pi}{2}-\left(2k+1\right)\theta=\frac{\pi}{4}\){:/nomarkdown}, כלומר {::nomarkdown}\( 2k+1=\frac{\pi}{4\theta}\){:/nomarkdown}, כלומר {::nomarkdown}\( k=\frac{\pi}{8\theta}=O\left(\frac{1}{\theta}\right)\){:/nomarkdown}. זווית {::nomarkdown}\( \frac{\pi}{4}\){:/nomarkdown} היא מספיק טובה לנו, כי פירושה הוא שהמכפלה הפנימית היא לפחות {::nomarkdown}\( \frac{1}{2}\){:/nomarkdown}, ולכן ההסתברות לקבל את {::nomarkdown}\( a\){:/nomarkdown} היא לפחות {::nomarkdown}\( \frac{1}{4}\){:/nomarkdown}, וזה מספיק טוב לנו (זה אומר שבתוחלת, נזדקק לארבע הפעלות של האלגוריתם כדי להשיג את הפתרון, וזה מצויין).

איך ה-{::nomarkdown}\( O\left(\frac{1}{\theta}\right)\){:/nomarkdown} מתבטא בפרמטרים של הבעיה? הפרמטר שלנו הוא {::nomarkdown}\( N\){:/nomarkdown}; מה הקשר ביניהם? אנחנו יודעים ש-{::nomarkdown}\( \cos\alpha=\frac{1}{\sqrt{N}}\){:/nomarkdown}, ואנחנו מכירים את הזהות הטריגונומטרית {::nomarkdown}\( \cos\left(\frac{\pi}{2}-x\right)=\sin x\){:/nomarkdown}, כלומר {::nomarkdown}\( \cos\alpha=\sin\theta\){:/nomarkdown} ולכן {::nomarkdown}\( \theta\ge\sin\theta=\frac{1}{\sqrt{N}}\){:/nomarkdown}. מכאן ש-{::nomarkdown}\( \frac{1}{\theta}\le\sqrt{N}\){:/nomarkdown} ולכן מספר ההפעלות של האלגוריתם שנדרשות לנו הוא אכן {::nomarkdown}\( O\left(\sqrt{N}\right)\){:/nomarkdown} המובטח.

רק מה, עדיין לא הבנו <strong>למה</strong> {::nomarkdown}\( G\){:/nomarkdown} מסובב את הוקטור בכל פעם בעוד {::nomarkdown}\( 2\theta\){:/nomarkdown} אל עבר {::nomarkdown}\( \left\|a\right\rangle \){:/nomarkdown}. כאן האינטואיציה הגאומטרית נכנסת לתמונה במלוא כוחה: הרעיון הוא שאת פעולת ה<strong>סיבוב</strong> הזו ניתן להציג בתור הרכבה של שתי פעולות <strong>שיקוף</strong>. קצת קשה (לטעמי) להרגיש אינטואיטיבית איך קורה הקסם הזה ששתי פעולות שיקוף שמבוצעות בזו אחר זו שקולות לפעולת סיבוב; כנראה הכי טוב שתעשו ניסויים בעצמכם כדי לקבל תחושה. אינטואיציה כלשהי אפשר בכל זאת לקבל מכך שהאיזומטריות היחידות במרחב הן סיבובים, שיקופים והזזות, ואם משקפים ביחס לראשית הצירים ראשית הצירים משתמרת (כך שאי אפשר לקבל הזזה) ושיקוף-של-שיקוף לא יכול להיות שיקוף בעצמו כי השיקוף השני "מתקן" את ההיפוך (כמו במראה) שהשיקוף הראשון יוצר. אז אנחנו חייבים לקבל סיבוב.

עוד אינטואיציה אפשר לקבל על ידי תמונה, באדיבות ויקיפדיה האנגלית:

<strong><a href="http://www.gadial.net/wp-content/uploads/2014/08/500px-Simx2rotOK.svg_.png"><img class="aligncenter size-full wp-image-3170" alt="500px-Simx2=rotOK.svg" src="http://www.gadial.net/wp-content/uploads/2014/08/500px-Simx2rotOK.svg_.png" width="500" height="500" /></a></strong>

בואו ניזכר לרגע איך אפשר לתאר שיקוף, פורמלית, ואז גם יהיה לנו קל לראות למה הכל יוצא כמו שאנחנו רוצים. ראשית, אני ארצה לדבר ספציפית על תיאור של שיקוף ב<strong>מישור</strong>, כלומר במרחב וקטורי ממימד 2. ה"בעיה" היא שהמרחב שלנו הוא ממימד {::nomarkdown}\( N\){:/nomarkdown}, אז מה עושים? מצטמצים לתת-מרחב: זה שנפרש על ידי {::nomarkdown}\( \left\|a\right\rangle \){:/nomarkdown} ו-{::nomarkdown}\( \left\|\psi\right\rangle \){:/nomarkdown} (הוקטור שאנחנו מחפשים והוקטור שמתאר סופרפוזיציה אחידה). בהמשך כל הוקטורים שאדבר עליהם יהיו שייכים לתת המרחב הזה.

כעת בואו נדבר על שיקוף במישור. שיקוף (כפי שאפשר לראות בתמונה) הוא תמיד <strong>ביחס לציר</strong> כלשהו. לוקחים נקודה. מעבירים אנך ממנה אל הציר, ואז ממשיכים את האנך הזה לצד השני באותו האורך - תוצאת השיקוף היא הנקודה שבקצה האנך הזה. אבל יש עוד דרך לחשוב על הפעולה הזו: ראשית, אל תחשבו על "נקודה" אלא על וקטור (כלומר, קו שמחבר את ראשית הצירים עם הנקודה); שנית, קחו את הוקטור ותחברו אליו את השיקוף שלו (תדביקו את הוקטור של השיקוף הזה על הנקודה) ותחברו אל השיקוף את הוקטור - תקבלו מעוין. אחד האלכסונים של המעוין הוא הישר שדרכו משקפים. מה אורכו? פעמיים ההיטל של הוקטור על הישר. אם כן, ראינו שלחבר את הוקטור עם השיקוף שלו נותן לנו את פעמיים ההיטל שלו. זה נותן לנו את המשוואה הכללית הבאה: אם {::nomarkdown}\( v\){:/nomarkdown} הוא וקטור, ואם {::nomarkdown}\( a\){:/nomarkdown} הוא וקטור יחידה בכיוון הישר שדרכו משקפים, אז {::nomarkdown}\( \mbox{Ref}\left(v\right)+v=2\left\langle v,a\right\rangle a\){:/nomarkdown}, כלומר {::nomarkdown}\( \mbox{Ref}\left(v\right)=2\left\langle v,a\right\rangle a-v\){:/nomarkdown}.

<strong><a href="http://www.gadial.net/wp-content/uploads/2014/08/reflection.png"><img class="aligncenter size-full wp-image-3172" alt="reflection" src="http://www.gadial.net/wp-content/uploads/2014/08/reflection.png" width="429" height="405" /></a></strong>

במילים אחרות, <strong>אופרטור השיקוף ביחס לציר</strong> {::nomarkdown}\( a\){:/nomarkdown}<strong> </strong>(כאשר {::nomarkdown}\( a\){:/nomarkdown} הוא וקטור יחידה)<strong> </strong>הוא האופרטור {::nomarkdown}\( 2\left\|a\right\rangle \left\langle a\right\|-I\){:/nomarkdown}. נראה מוכר? בוודאי! השתמשנו באופרטור {::nomarkdown}\( 2\left\|\psi\right\rangle \left\langle \psi\right\|-I\){:/nomarkdown}, כשהוא משורשר עם {::nomarkdown}\( O\){:/nomarkdown}, בבנייה של {::nomarkdown}\( G\){:/nomarkdown} שלנו. אם כן, אחת משתי הפעולות שמרכיבות את {::nomarkdown}\( G\){:/nomarkdown} היא שיקוף - במקרה הנוכחי, שיקוף ביחס לציר {::nomarkdown}\( \left\|\psi\right\rangle \){:/nomarkdown} שמתאר את הסופרפוזיציה האחידה.

מה עם {::nomarkdown}\( O\){:/nomarkdown}?

ובכן, הנה עוד דרך לחשוב על שיקופים. שיקוף הוא טרנספורמציה לינארית, ולכן מספיק לדעת איך הוא מתנהג על אברי בסיס של המרחב. כרגיל, נדבר על שיקוף ביחס לציר {::nomarkdown}\( a\){:/nomarkdown}. איך השיקוף פועל על {::nomarkdown}\( a\){:/nomarkdown} עצמו? ובכן, הוא לא מזיז אותו בכלל, כלומר {::nomarkdown}\( a\mapsto a\){:/nomarkdown}. לעומת זאת, איך השיקוף פועל על וקטור ש<strong>מאונך</strong> ל-{::nomarkdown}\( a\){:/nomarkdown}, נסמנו {::nomarkdown}\( b\){:/nomarkdown}? קל לראות שהסכום של {::nomarkdown}\( b\){:/nomarkdown} והשיקוף שלו יהיה 0, ולכן {::nomarkdown}\( b\mapsto-b\){:/nomarkdown}. ניתוח מדויק של זה יש <a href="http://www.gadial.net/2011/11/29/eigenvalues_intro/">בפוסט שלי על ערכים עצמיים</a>, שמשתמש בשיקוף בתור דוגמה - הערכים העצמיים הם 1 ו-{::nomarkdown}\( -1\){:/nomarkdown}, והוקטורים העצמיים הם הציר שדרכו משקפים והציר שמאונך לו.

ובכן, את האופרטור {::nomarkdown}\( O\){:/nomarkdown} הצגתי בדיוק באופן הזה: אם {::nomarkdown}\( x\){:/nomarkdown} הוא הוקטור שנותן {::nomarkdown}\( f\left(x\right)=1\){:/nomarkdown} אז {::nomarkdown}\( x\mapsto-x\){:/nomarkdown} ואילו אם {::nomarkdown}\( x\){:/nomarkdown} הוא כל וקטור בסיס אחר, אז {::nomarkdown}\( x\mapsto x\){:/nomarkdown}. תזכרו שאנחנו מדברים על המרחב שנפרש על ידי {::nomarkdown}\( \left\|\psi\right\rangle \){:/nomarkdown} ו-{::nomarkdown}\( \left\|a\right\rangle \){:/nomarkdown}; במרחב הזה, הוקטור העצמי של 1 הוא בדיוק {::nomarkdown}\( \sum_{x\ne a}\left\|x\right\rangle \){:/nomarkdown} (צירוף אחיד של כל הוקטורים במרחב, חוץ מ-{::nomarkdown}\( \left\|a\right\rangle \){:/nomarkdown}). אחרי נרמול נקבל את הוקטור {::nomarkdown}\( \left\|e\right\rangle =\frac{1}{\sqrt{N-1}}\sum_{x\ne a}\left\|x\right\rangle \){:/nomarkdown}.

אז הסכמנו ש-{::nomarkdown}\( G\){:/nomarkdown} מבצעת שתי פעולות שיקוף ולכן היא אכן מבצעת פעולת סיבוב. אבל סיבוב של כמה מעלות? ובכן, בתמונה מויקיפדיה שהבאתי למעלה מראים גם שהזווית שבה מסובבים היא פעמיים הזווית שבין הצירים שמשקפים ביחס אליהם. זה דורש הוכחה פורמלית, כמובן, אבל היא לא קשה במיוחד אלא בעיקר טכנית (אני לא חושב על משהו יותר מוצלח מאשר לכתוב את המטריצות המייצגות של הטרנספורמציות ולכפול אותן) ולכן אדלג עליה כאן. מה הזווית במקרה שלנו <strong>אמורה</strong> לצאת כבר ברור - {::nomarkdown}\( 2\theta\){:/nomarkdown}. אז רק נותר להסביר למה הזווית בין צירי השיקוף היא {::nomarkdown}\( \theta\){:/nomarkdown}.

נסמן {::nomarkdown}\( \cos\gamma=\left\|\left\langle e,\psi\right\rangle \right\|\){:/nomarkdown}. החישוב הוא קל למדי: {::nomarkdown}\( \left\|\left\langle e,\psi\right\rangle \right\|=\frac{1}{\sqrt{N}\sqrt{N-1}}\sum_{x\ne a}1=\sqrt{\frac{\left(N-1\right)^{2}}{N\left(N-1\right)}}=\sqrt{\frac{N-1}{N}}\){:/nomarkdown}. בואו ניזכר בזהות {::nomarkdown}\( \sin^{2}x+\cos^{2}x=1\){:/nomarkdown}, כלומר {::nomarkdown}\( \sin x=\sqrt{1-\cos^{2}x}\){:/nomarkdown}. נקבל: {::nomarkdown}\( \sin\gamma=\sqrt{1-\frac{N-1}{N}}=\frac{1}{\sqrt{N}}=\cos\alpha=\sin\theta\){:/nomarkdown} - הפלא, ופלא, קיבלנו בדיוק את התוצאה המבוקשת!

האם סיימנו? בוודאי שלא!

הצלחנו להבין למה האלגוריתם עובד, ולטעמי ההסבר הזה היה אלגנטי ונפלא ורק בשבילו כל סדרת הפוסטים הזו הייתה שווה. אבל עדיין לא הסברנו איך אפשר לממש את האלגוריתם! השתמשתי בשתי פעולות שיקוף, אבל עבור אף אחד מהן לא הסברתי למה בכלל סביר שנוכל להפעיל אותה ברמת החישוב הקוונטי, שבו מותר לנו להשתמש בשערים קוונטיים על לא יותר מדי קיוביטים בבת אחת. אני אסביר עכשיו את הרעיון הבסיסי, אבל עדיין לא אסביר בדיוק איך אפשר לבנות את השערים הקוונטיים הרלוונטיים - זה עניין לפוסט נפרד - אבל נבין אילו שערים בערך צריך.

נתחיל עם {::nomarkdown}\( 2\left\|\psi\right\rangle \left\langle \psi\right\|-I\){:/nomarkdown}. היצור הזה הוא שיקוף ביחס ל-{::nomarkdown}\( \left\|\psi\right\rangle \){:/nomarkdown}, ולכן כפי שכבר ראינו {::nomarkdown}\( \left\|\psi\right\rangle \){:/nomarkdown} הוא וקטור עצמי של האופרטור הזה עם ערך עצמי 1, ואילו כל {::nomarkdown}\( \left\|x\right\rangle \){:/nomarkdown} שניצב לו הוא וקטור עצמי עם ערך עצמי {::nomarkdown}\( -1\){:/nomarkdown}. הבעיה היא שהוקטורים הללו הם מסובכים והשערים הקוונטיים שלנו לא יודעים איך לפעול עליהם. אז משתמשים בהתחכמות הישנה ביותר בספר - <strong>מלכסנים</strong>. מבצעים שינוי בסיס. אם נכפול במטריצה {::nomarkdown}\( H^{\otimes n}\){:/nomarkdown}, נעביר את {::nomarkdown}\( \left\|\psi\right\rangle \){:/nomarkdown} לוקטור {::nomarkdown}\( \left\|00\dots0\right\rangle \){:/nomarkdown}, וכל וקטור שניצב ל-{::nomarkdown}\( \left\|\psi\right\rangle \){:/nomarkdown} יעבור לוקטור בסיס אחר של אפסים ואחדים, רק ש-1 יופיע בוקטור לפחות פעם אחת. כעת אפשר יהיה לתאר את הפעולה באופן הבא:

{::nomarkdown}\( \left\|00\dots0\right\rangle \mapsto-\left\|00\dots0\right\rangle\){:/nomarkdown}

{::nomarkdown}\( \left\|x\right\rangle \mapsto\left\|x\right\rangle \){:/nomarkdown} אם {::nomarkdown}\( \left\|x\right\rangle \ne\left\|00\dots0\right\rangle \){:/nomarkdown}

מבחינה אלגוריתמית קלאסית זה חישוב די פשוט: עבור ביט-ביט, ואם מצאת 1, החזר את הקלט המקורי; אחרת, בסיום, החזר את שלילת הקלט המקורי. איך מבצעים את זה בעולם הקוונטי? זה, כאמור, עניין לפוסט ייעודי בנושא.

אחרי שמבצעים את הפעולה הזו, צריך לחזור לבסיס המקורי - מבצעים את זה על ידי כפל נוסף ב-{::nomarkdown}\( H^{\otimes n}\){:/nomarkdown}. זה מסיים את התיאור של האופרטור {::nomarkdown}\( 2\left\|\psi\right\rangle \left\langle \psi\right\|-I\){:/nomarkdown}.

מה עם האופרטור {::nomarkdown}\( O\){:/nomarkdown}? על פניו אפשר לומר שהוא נתון על ידי אורקל וחסל, אבל ההנחה שיש אורקל שעושה בדיוק את מה שאנחנו רוצים - הטלה - היא הנחה קצת חזקה מדי. מה אם כל מה שהאורקל יודע לעשות, בהינתן {::nomarkdown}\( x\){:/nomarkdown}, הוא לחשב את {::nomarkdown}\( f\left(x\right)\){:/nomarkdown} ולשים לנו בקיוביט כלשהו? ובכן, "לשים בקיוביט" זה מונח בעייתי בחישוב קוונטי כי פירושו הוא "למחוק את התוכן הקודם של הקיוביט ולכתוב משהו חדש במקומו" וזו פעולה לא הפיכה, ולכן לא כזו שאפשר לממש. לכן תיאור יותר סביר של אורקל קוונטי הוא זה: המצב הקוונטי שלנו (החלקים ממנו שמעניינים אותנו) יהיה מצורה {::nomarkdown}\( \left\|x\right\rangle \left\|q\right\rangle \){:/nomarkdown} כאשר {::nomarkdown}\( \left\|q\right\rangle \){:/nomarkdown} הוא קיוביט בודד שהאורקל יודע להתעסק בו. מה שהאורקל עושה הוא לבצע את החישוב הבא:

{::nomarkdown}\( \left\|x\right\rangle \left\|q\right\rangle \mapsto\left\|x\right\rangle \left\|q\oplus f\left(x\right)\right\rangle \){:/nomarkdown}

כאשר {::nomarkdown}\( \oplus\){:/nomarkdown} היא פעולת ה-XOR ההפיכה. כלומר, האורקל מחשב את {::nomarkdown}\( f\left(x\right)\){:/nomarkdown} ואם {::nomarkdown}\( f\left(x\right)=0\){:/nomarkdown} לא נוגע ב-{::nomarkdown}\( q\){:/nomarkdown}; אחרת, אם {::nomarkdown}\( f\left(x\right)=1\){:/nomarkdown}, הוא הופך את וקטורי הבסיס בצירוף הלינארי שמגדיר את {::nomarkdown}\( \left\|q\right\rangle \){:/nomarkdown}, דהיינו {::nomarkdown}\( a\left\|0\right\rangle +b\left\|1\right\rangle \mapsto b\left\|0\right\rangle +a\left\|1\right\rangle \){:/nomarkdown}. זה, כאמור, הדבר הכי קרוב ל"חשב את {::nomarkdown}\( f\left(x\right)\){:/nomarkdown} וכתוב את התוצאה בקיוביט" שנוכל לצפות לו בחישוב קוונטי.

איך עוברים מזה אל האפקט של {::nomarkdown}\( O\){:/nomarkdown} שאנחנו רוצים, דהיינו {::nomarkdown}\( \left\|x\right\rangle \mapsto\left(-1\right)^{f\left(x\right)}\left\|x\right\rangle \){:/nomarkdown} ? ובכן, אנחנו יכולים להניח שאנחנו יודעים את הערך של {::nomarkdown}\( \left\|q\right\rangle \){:/nomarkdown} בתחילת החישוב או אפילו קובעים אותו; אז אפשר יהיה להפעיל אופרטור קוונטי שיעביר את {::nomarkdown}\( \left\|q\right\rangle \){:/nomarkdown} להיות {::nomarkdown}\( \frac{\left\|0\right\rangle -\left\|1\right\rangle }{\sqrt{2}}\){:/nomarkdown} (למשל, אם בהתחלה {::nomarkdown}\( \left\|q\right\rangle =\left\|0\right\rangle \){:/nomarkdown} אז נפעיל עליו NOT ולאחר מכן {::nomarkdown}\( H\){:/nomarkdown}).

כעת, מה קורה ל-{::nomarkdown}\( \left\|x\right\rangle \left(\frac{\left\|0\right\rangle -\left\|1\right\rangle }{\sqrt{2}}\right)\){:/nomarkdown} כשמפעילים עליו את האורקל? אם {::nomarkdown}\( f\left(x\right)=0\){:/nomarkdown} אז מקבלים את אותו מצב, כצפוי. אחרת, אם {::nomarkdown}\( f\left(x\right)=1\){:/nomarkdown}, הקיוביט של האורקל הופך ל-{::nomarkdown}\( \left(\frac{-\left\|0\right\rangle +\left\|1\right\rangle }{\sqrt{2}}\right)=-\left(\frac{\left\|0\right\rangle -\left\|1\right\rangle }{\sqrt{2}}\right)\){:/nomarkdown}, ולכן מקבלים {::nomarkdown}\( -\left\|x\right\rangle \left(\frac{\left\|0\right\rangle -\left\|1\right\rangle }{\sqrt{2}}\right)\){:/nomarkdown}, וזהו בדיוק האפקט שרצינו!

זה מסיים עם האלגוריתם של גרובר. עכשיו, בנוסף להיכרות עם אלגוריתם מגניב בפני עצמו, אני מקווה שאנחנו מבינים קצת יותר טוב את אופי הפעולות שאנחנו צריכים לבצע בחישוב קוונטי; בפוסט הבא נדון בשאלת המימוש שלהן.
