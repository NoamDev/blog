---
id: 193
title: "משפט אי השלמות הראשון של גדל - איך (בערך) מוכיחים אותו?"
date: 2009-05-10 02:19:35
layout: post
categories: 
  - חישוביות
  - לוגיקה
tags: 
  - הוכחות יפות
  - משפטי אי השלמות של גדל
---
<h2>הקדמה</h2>
הרעיון המפורסם ביותר בהוכחת <a href="http://www.gadial.net/?p=192">משפט אי השלמות הראשון של גדל</a> (איני חושב שאוכיח כאן את השני, לפחות לא כעת) הוא הרעיון של לכסון - שיטה ששימשה כבר את גאורג קנטור <a href="http://www.gadial.net/?p=52">בהוכחה שלו</a> לכך שעוצמת הממשיים אינה שווה לעוצמת הטבעיים. כמעט בכל תיאור של משפט גדל מזכירים את הדמיון שלו לפרדוקס השקרן (הפרדוקס שבו איש כרתים אומר "כל אנשי כרתים משקרים תמיד", ולכן לא ברור אם הוא אומר את האמת או משקר), ולעתים אף מגדילים לעשות ומסבירים עד כמה גאוני היה מצד גדל לחשוב על להשתמש בו - אך כאמור, קנטור כבר עשה זאת זמן מה קודם לכן. לדעתי, הגאונות האמיתית של גדל היא ברעיון, שכיום נראה אולי פשוט וברור לחלוטין - בפרט לבקיאים במדעי המחשב - להשתמש בנוסחאות שלכאורה מדברות רק על מספרים טבעיים כדי לתאר מערכות הוכחה, ולא סתם מערכות הוכחה אלא את אלו שבתוכן הנוסחאות הללו "חיות". ברעיון הזה אפשר להתחיל את תיאור ההוכחה של גדל.
<h2>מספור גדל</h2>
הבה ונזכור מהי הוכחה - סדרה של טענות, כשכל טענה היא סדרה של תווים מעל אלף-בית כלשהו של סימנים. לא כל סדרת תווים היא חוקית - יש כללים שקובעים אילו סדרות הן חוקיות (לסדרות כאלו, שמהוות טענה חוקית, לפעמים קוראים "Well formed formula" ומייד מקצרים ל-wff והופכים את יתר הטקסט לבלתי קריא) ואילו לא. מה שגדל מציע הוא לקודד כל טענה באמצעות מספר באופן הבא: ראשית, לכל תו באלף-בית נצמיד מספר טבעי - כך למשל "{::nomarkdown}\( \wedge\){:/nomarkdown}" שמסמל "וגם" יכול לקבל את המספר 3, בעוד "{::nomarkdown}\( x\){:/nomarkdown}" שהוא משתנה יכול לקבל 5 (יש אינסוף משתנים, אבל זו לא בעיה - כל משתנה יקבל מספר אחר. באופן כללי, אם {::nomarkdown}\( t\){:/nomarkdown} הוא סימן כלשהו, אז {::nomarkdown}\( g\left(t\right)\){:/nomarkdown} יהיה הערך שגדל מתאים לו.

עכשיו, בהינתן פסוק, למשל {::nomarkdown}\( x\wedge\neg z\){:/nomarkdown}, אפשר להתאים לו מספר באופן הבא: {::nomarkdown}\( 2^{g\left(x\right)}\cdot3^{g\left(\wedge\right)}\cdot5^{g\left(\neg\right)}\cdot7^{g\left(z\right)}\){:/nomarkdown}. כלומר, המספר שמותאם לפסוק הוא מכפלה של ראשוניים, כאשר החזקה של הראשוני ה-{::nomarkdown}\( k\){:/nomarkdown}-י במכפלה היא הערך המספרי שהותאם לתו ה-{::nomarkdown}\( k\){:/nomarkdown}-י באותו פסוק. השימוש בראשוניים נובע מכך שלכל מספר יש פירוק יחיד לראשוניים, כך שלא ייתכן ששתי מכפלות שונות של ראשוניים יתנו את אותו מספר, ולכן כל פסוק מקודד באופן ייחודי.

בימינו, הרעיון הזה נמצא בשימוש בכל מחשב, כל הזמן; הדוגמה הקלאסית שלו היא <a href="http://he.wikipedia.org/wiki/ASCII">קוד ASCII</a>, שבו מקודדים 256 תווים שונים באמצעות מספרים מ-0 ועד 255. כל מחרוזת של תווים מקודדת כעת באמצעות רצף של מספרים שכאלו, וכשמחשב פותח קובץ טקסט הוא קורא את המספר הגדול מאוד שמהווה את הקידוד, ומתרגם אותו חזרה לסדרת תווים. גדל לא הכיר מחשבים ואת שיטת הקידוד ASCII, כמובן; בזמנו הם כלל לא היו קיימים. איני יודע אם הוא המציא את רעיון הקידוד באופן כללי - אני מניח שלא, ובכל זאת, הקרדיט על הרעיון של קידוד טענות פורמליות שמדברות על מספרים באמצעות מספרים, מה שמאפשר לטענות לדבר "על עצמן" - הקרדיט הזה ניתן לגדל במלואו.

באופן דומה לזה שבו מקודדים פסוקים, אפשר לקודד הוכחות שלמות - פשוט קחו את 2 בחזקת הקידוד של הפסוק הראשון בהוכחה, כפול 3 בחזקת הקידוד של הפסוק השני בהוכחה, וכן הלאה. מכיוון שכל הוכחה היא סופית, זה עובד - ושוב, למי שמכיר קידודים במחשב בימינו כל הדיון הזה נשמע קצת מיותר, ושיטת הקידוד של גדל - קצת מסורבלת.
<h2>פונקציות רקורסיביות</h2>
המושג הבא שגדל מדבר עליו הוא <a href="http://he.wikipedia.org/wiki/%D7%A4%D7%95%D7%A0%D7%A7%D7%A6%D7%99%D7%94_%D7%A4%D7%A8%D7%99%D7%9E%D7%99%D7%98%D7%99%D7%91%D7%99%D7%AA_%D7%A8%D7%A7%D7%95%D7%A8%D7%A1%D7%99%D7%91%D7%99%D7%AA">פונקציות רקורסיביות</a>. בימינו, המשמעות המוכרת של "פונקציה רקורסיבית" היא של פונקציה בתוכנית מחשב שמבצעת קריאה לעצמה (איך זה אפשרי? בשביל מה זה טוב? זה עניין לפוסט אחר). גדל, כמובן, מתכוון למשהו קצת שונה - כפי שנראה, שם יותר מתאים לפונקציות הללו הוא למעשה "פונקציות ניתנות לחישוב" - למשל, לחישוב על ידי מחשב, או אלגוריתם, או <a href="http://he.wikipedia.org/wiki/%D7%9E%D7%9B%D7%95%D7%A0%D7%AA_%D7%98%D7%99%D7%95%D7%A8%D7%99%D7%A0%D7%92">מכונת טיורינג</a>, או אדם עם נייר ועט וסבלנות, אך זהו מושג שלא היה קיים בתקופת גדל; למרות שהרעיון של בניית פונקציות באופן רקורסיבי לא היה חדש, הפורמליזם המדוייק שגדל השתמש בו, והצליח לתפוס בצורה (כמעט) מדוייקת את הרעיון של "ניתן לחישוב", הוא (ככל שהצלחתי לברר) המצאה שלו, ואחד מהרעיונות המבריקים שבמאמר. אתאר כעת את הפורמליזם הזה.

באופן כללי, הדיון עוסק בפונקציות מהמספרים הטבעיים לטבעיים. כדי להקל על החיים, מרשים לפונקציה לקבל ולהחזיר <strong>סדרות סופיות</strong> של טבעיים, כלומר באופן כללי אנחנו מדברים על פונקציה {::nomarkdown}\( f:\mathbb{N}^{n}\to\mathbb{N}^{m}\){:/nomarkdown}. ההגיון הוא שכל דבר שניתן לחישוב ניתן לתאר (באמצעות קידוד מתאים) כחישוב על טבעיים - ואכן, זה גם מה שגדל עושה - מתרגם פונקציות על טענות והוכחות (למשל, פונקציה שמחזירה 1 רק אם הוכחה מסויימת היא תקפה) לפונקציות על מספרים טבעיים.

מגדירים את הפונקציות הרקורסיביות באינדוקציה - מתחילים מפונקציות בסיס פשוטות מאוד, ובונים באמצעותן פונקציות מורכבות יותר. פונקציות הבסיס הן:
<ol>
	<li> הפונקציה הקבועה אפס: {::nomarkdown}\( f\left(x_{1},\dots,x_{n}\right)=0\){:/nomarkdown} (לכל{::nomarkdown}\( n\){:/nomarkdown} טבעי, כלומר {::nomarkdown}\( f\left(x\right)=0\){:/nomarkdown}, וגם {::nomarkdown}\( f\left(x_{1},x_{2}\right)=0\){:/nomarkdown} וכו').</li>
	<li> פונקצית העוקב: {::nomarkdown}\( g\left(x\right)=x+1\){:/nomarkdown}.</li>
	<li> פונקצית ההטלה על הרכיב ה-{::nomarkdown}\( i\){:/nomarkdown}: {::nomarkdown}\( h_{i}\left(x_{1},\dots,x_{n}\right)=x_{i}\){:/nomarkdown}</li>
</ol>
כל אלו הן פונקציות פשוטות למדי. אם אתם יודעים לתכנת, תוכלו לתכנת אותן ללא קושי רב. אם כן, בינתיים הפונקציות מתאימות היטב להגדרה של "ניתן לחישוב". ומה הלאה?

דרך אחת לבנות פונקציות חדשות מהישנות היא הרכבה. הניסוח הפורמלי מעט מסורבל, ולכן קודם כל דוגמה למקרה פשוט: אם יש לנו שתי פונקציות רקורסיביות,{::nomarkdown}\( f\left(x\right),g\left(x\right)\){:/nomarkdown}, אז אפשר לבנות פונקציה חדשה שמסמלת קודם כל הפעלה של {::nomarkdown}\( g\){:/nomarkdown} ואחרי הפעלה של {::nomarkdown}\( f\){:/nomarkdown}. בכתיבה פורמלית,{::nomarkdown}\( h\left(x\right)=f\left(g\left(x\right)\right)\){:/nomarkdown}. די בבירור אם{::nomarkdown}\( f,g\){:/nomarkdown} ניתנות לחישוב, גם {::nomarkdown}\( h\){:/nomarkdown} ניתנת לחישוב (קודם כל מחשבים את {::nomarkdown}\( g\left(x\right)\){:/nomarkdown}, ואז מחשבים מה {::nomarkdown}\( f\){:/nomarkdown} מחזיר על התוצאה).

באופן כללי הניסוח מסורבל מעט יותר, כאמור: אם {::nomarkdown}\( g_{1}\dots g_{n}\){:/nomarkdown} כולן פונקציות רקורסיביות ב-{::nomarkdown}\( m\){:/nomarkdown} משתנים, ו-{::nomarkdown}\( f\){:/nomarkdown} היא פונקציה ב-{::nomarkdown}\( n\){:/nomarkdown} משתנים, אז אפשר להגדיר כך פונקציה {::nomarkdown}\( h\){:/nomarkdown} מ-{::nomarkdown}\( m\){:/nomarkdown}:{::nomarkdown}\( h\left(x_{1},\dots,x_{m}\right)=f\left(g_{1}\left(x_{1},\dots,x_{m}\right),\dots,g_{n}\left(x_{1},\dots,x_{m}\right)\right)\){:/nomarkdown}.

הבניה המרכזית והמעניינת ביותר, שנתנה לפונקציות את שמן, היא הרקורסיה. במשמעות ה"רגילה" של המילה, פונקציה רקורסיבית היא כזו שמוגדרת באמצעות עצמה, אך על קלט פשוט יותר. למשל, {::nomarkdown}\( f\left(n\right)=f\left(n-1\right)+f\left(n-2\right)\){:/nomarkdown} היא פונקציה רקורסיבית (שמגדירה את מספר פיבונאצ'י ה-{::nomarkdown}\( n\){:/nomarkdown}-י) כדי שיהיה טעם ברקורסיה, חייבים להיות מוגדרים לה "תנאי עצירה" - הגדרה מפורשת של ערכיה כאשר הקלט קטן דיו. עבור פיבונאצ'י, למשל, הגדרה אפשרית אחת היא {::nomarkdown}\( f\left(0\right)=0,f\left(1\right)=1\){:/nomarkdown}.

פורמלית, פעולת הרקורסיה מוגדרת כך. נניח שיש לנו פונקציה רקורסיבית (במובן של "ניתנת לחישוב") {::nomarkdown}\( f\left(y,z,x_{1},\dots,x_{n}\right)\){:/nomarkdown} ופונקציה רקורסיבית {::nomarkdown}\( g\left(x_{1},\dots,x_{n}\right)\){:/nomarkdown} (זוהי הפונקציה של "תנאי ההתחלה"), אז אפשר להגדיר פונקציה רקורסיבית חדשה {::nomarkdown}\( h\left(y,x_{1},\dots,x_{n}\right)\){:/nomarkdown} באופן הבא:

{::nomarkdown}\( h\left(0,x_{1},\dots,x_{n}\right) = g\left(x_{1},\dots,x_{n}\right) = h\left(n+1,x_{1},\dots,x_{n}\right) = f\left(n,h\left(n,x_{1},\dots,x_{n}\right),x_{1},\dots,x_{n}\right)\){:/nomarkdown}

אם כן, {::nomarkdown}\( h\left(n,x_{1},\dots,x_{n}\right)\){:/nomarkdown} פירושו "{::nomarkdown}\( h\){:/nomarkdown} עבור הערך {::nomarkdown}\( n\){:/nomarkdown} והפרמטרים הקבועים {::nomarkdown}\( x_{1},\dots,x_{n}\){:/nomarkdown}". כאשר הערך {::nomarkdown}\( n=0\){:/nomarkdown}, אז {::nomarkdown}\( h\){:/nomarkdown} פשוט מחזירה את תנאי ההתחלה, וכאשר הוא גדול יותר מחזירים את מה ש-{::nomarkdown}\( f\){:/nomarkdown} נותנת, שמתבסס על {::nomarkdown}\( n\){:/nomarkdown}, על {::nomarkdown}\( x_{1},\dots,x_{n}\){:/nomarkdown}, ועל הערך הקטן יותר של {::nomarkdown}\( h\){:/nomarkdown}.

זהו פורמליזם קצת מתוסבך, אבל עם קצת מחשבה אפשר להבין מה קורה בו, ולראות שזה די קל לתכנת גם דבר שכזה, ולכן גם פונקציות שנבנות כך הן ניתנות לחישוב.

רק אחרי גדל, כאשר מודלים פורמליים של אלגוריתמים (למשל, מכונת טיורינג) פותחו ניתן היה להוכיח פורמלית גם את הכיוון ההפוך - שהפונקציות הרקורסיביות הן <strong>כל</strong> מה שניתן לחישוב. איני מדייק כאן עד הסוף - מה שתיארתי עד כה נקרא בימינו "פונקציות רקורסיביות <strong>פרימיטיביות</strong>", שכן ניתן להוסיף עוד כלל בנייה אחד - כלל המינימיזציה - ולקבל מחלקה רחבה יותר של פונקציות, אך כאלו שאינן בהכרח מוגדרות לכל קלט. ארחיב על כך בפוסט נפרד, אך לעת עתה אין בכך צורך; די בכך שאומר שאפשר להוכיח שכל תוכנית מחשב שמקבלת כקלט סדרת מספרים טבעיים, עוצרת לכל קלט אפשרי ומוציאה כפלט סדרת מספרים טבעיים - כל תוכנית מחשב שכזו ניתן לתאר באמצעות פונקציה רקורסיבית. זו תוצאה די מפתיעה - הרבה יותר מפתיעה מאשר "מכונת טיורינג יכולה לחשב את כל מה שתוכנית מחשב יכולה" (מה שמעיד על כך שמכונת טיורינג היא פורמליזם <strong>טוב</strong>) - וההוכחה שלה אינה טריוויאלית.

בזמנו של גדל, כמובן, כל זה לא היה ידוע. זו הסיבה שבגללה השלב הבא בהוכחה שלו הוא כל כך טכני ומורכב. מה שגדל רוצה לעשות כעת הוא לבנות פונקציה רקורסיבית {::nomarkdown}\( B\left(x,y\right)\){:/nomarkdown} שמחזירה 1 אם המספר הטבעי {::nomarkdown}\( x\){:/nomarkdown} הוא קידוד של הוכחה עבור הטענה שמקודדת על ידי המספר{::nomarkdown}\( y\){:/nomarkdown} (למעשה, גדל מגדיר <strong>יחס</strong> ולא פונקציה, אך שני המושגים שקולים זה לזה ולא אתעמק בהבחנה הזו). אם אנחנו יודעים שקיימת פונקציה רקורסיבית עבור כל תוכנית מחשב, הקיום של {::nomarkdown}\( B\){:/nomarkdown} אינו מפתיע במיוחד - בהינתן {::nomarkdown}\( x,y\){:/nomarkdown}, זה עניין טכני ומכני בלבד לפענח את הקידוד של {::nomarkdown}\( x\){:/nomarkdown} ולקבל סדרה של טענות, ואז זה עניין טכני ומכני בלבד לבדוק שכל טענה בסדרה היא או אקסיומה או נובעת מקודמותיה, ושהפסוק האחרון בסדרה הוא מה ש-{::nomarkdown}\( y\){:/nomarkdown} מקודד; זה בדיוק המקום שבו נדרש ממערכת ההוכחה להיות אפקטיבית, כך שבדיקה שכזו תהיה אפשרית בכלל - אם המערכת לא הייתה אפקטיבית, ככל הנראה הפונקציה{::nomarkdown}\( B\){:/nomarkdown} המדוברת לא הייתה רקורסיבית (כמובן, עדיין ניתן היה <strong>להגדיר</strong> את {::nomarkdown}\( B\){:/nomarkdown} באופן מילולי; פשוט לא היינו יכולים לעשות בה את השימוש שגדל עושה אחר כך, ומצריך ממנה להיות רקורסיבית).

לרוע מזלו של גדל, נפנוף הידיים שלעיל מן הסתם לא היה קביל עבורו. התוצאה היא שהוא בונה את {::nomarkdown}\( B\){:/nomarkdown} באופן מפורש ומדוייק, תוך עבודה צמודה עם ההגדרות שלעיל של כללי הבניה של פונקציות רקורסיביות. הבנייה היא הדרגתית - בכל פעם הוא בונה פונקציות רקורסיביות יותר ויותר מורכבות, שעליהן ניתן לבנות פונקציות עוד יותר מורכבות, וכן הלאה, עד שבסופו של דבר, לאחר לא פחות מ-45 צעדים (שכל אחד מהם דורש רק שורה או שניים, אמנם) הוא מגיע אל {::nomarkdown}\( B\){:/nomarkdown} הנכספת. כאשר מוכיחים את משפט גדל לסטודנטים ללוגיקה, זה לרוב החלק בהוכחה שכולל הרבה נפנופי ידיים או הנחות לא מוכחות - ולדעתי בצדק, כי אין בבנייה הזו שום דבר מחכים לכשעצמה. גדל פשוט תכנת ב<a href="http://he.wikipedia.org/wiki/%D7%90%D7%A1%D7%9E%D7%91%D7%9C%D7%99">אסמבלי</a> של המתמטיקה (יותר מדוייק לומר "באסמבלי של תורת החישוביות"), לפני שהיו קיימות שפות עיליות. מבחינה טכנית זה מרשים מאוד, כמובן.
<h2>ייצוג הפונקציות הרקורסיביות</h2>
אוקיי, אז גדל הראה שאותה {::nomarkdown}\( B\left(x,y\right)\){:/nomarkdown} היא רקורסיבית. מה עכשיו? כעת גדל מגיע לפאנץ' ליין של השימוש בפונקציות רקורסיביות - הוא מראה שבתורה שאותה הוא "תוקף", אפשר לייצג את הפונקציות הללו. המשמעות המדוייק של הייצוג הזה היא מעט טכנית ולא אכנס אליה, ולכן לצורך העניין ניתן לחשוב על כך (באופן לא מדוייק לגמרי) כאילו ניתן להשתמש בפונקציות רקורסיביות בצורה חופשית בפסוקים של התורה, כאילו הן היו חלק מהשפה עצמה. גדל אמנם מראה זאת רק עבור תורה ספציפית - <a href="http://en.wikipedia.org/wiki/Principia_Mathematica">זו של ראסל וויטהד </a>- אבל בהמשך הוא מראה כי די בפעולות החיבור והכפל ה"סטנדרטיות": כדי שאפשר יהיה להגדיר את הפונקציות הרקורסיביות. זו נקודה מעניינת, ולכן אני רוצה להתעכב גם עליה.

פונקציה רקורסיבית בסיסית, כמו {::nomarkdown}\( f\left(x\right)=0\){:/nomarkdown} קל לייצג, כי יש לנו סימן עבור 0 בשפה; ובדומה, גם {::nomarkdown}\( f\left(x\right)=x+1\){:/nomarkdown} קל לייצוג כי יש לנו בשפה סימן עבור עוקב. גם הטלות והרכבות לא קשה לייצג - האתגר האמיתי הוא פעולת הרקורסיה (שהיא, כאמור, הפעולה עם ה"בשר" כאן). בנפנוף ידיים, מה שצריך לעשות כדי לייצג פונקציה שנבנתה ברקורסיה, הוא לבנות פסוק שאומר "קיימת סדרת ערכים, כך שהערך הראשון מתקבל מבסיס הרקורסיה, וכל ערך גדול יותר מתקבל מקודמו על ידי הפעלת פונקצית הרקורסיה, והערך האחרון הוא הפלט של הפונקציה" (קצת מזכיר הוכחה פורמלית, לא?). האתגר שבבניית פסוק שכזה הוא בדיוק בטענת ה"קיימת סדרה" - הרי בלוגיקה מסדר ראשון אין דרך לכמת קבוצות של איברים, וסדרה היא קבוצה שכזו. כל מה שניתן לעשות הוא לטעון טענות "קיים מספר", לא "קיימת סדרת מספרים". אז איך עוקפים את זה?

התשובה היא שכל עוד הסדרה היא <strong>סופית</strong>, אפשר לקודד אותה באמצעות מספר בודד, ואז כל מה שצריך לעשות כדי לדבר על איברים ספציפיים בסדרה הוא "לפתוח את הקידוד" ולהתייחס למקום המתאים. הרעיון הזה נשמע מאוד דומה לרעיון של קידוד גדל - ושוב, לא במקרה - ולצורך הביצוע שלו גדל שולף מהשרוול טריק מתמטי אחד או שניים ומגדיר את מה שמכונה "פונקצית ה-{::nomarkdown}\( \beta\){:/nomarkdown} של גדל". הפונקציה הזו מעניינת בכך שהיא ניתנת לייצוג באמצעות פעולות חיבור וכפל בלבד (אבל <strong>שתי</strong> הפעולות הללו הן הכרחיות, ולכן בלי פעולת כפל כל ההוכחה קורסת), והיא אכן מממשת בצורה מקסימה את רעיון ה"קידוד של כל הסדרות הסופיות". לא אתן כרגע תיאור מדוייק של הפונקציה, אך ייתכן שאקדיש לה פוסט בהמשך - רק אומר שהרעיון הבסיסי של הקידוד מתבסס על משפט עתיק יומין ויפה שכבר הזכרתי כאן - <a href="http://www.gadial.net/?p=88">משפט השאריות הסיני</a>.

אם כן, סיכום ביניים: גדל משתמש בפונקצית ה-{::nomarkdown}\( \beta\){:/nomarkdown} כדי להראות שכל הפונקציות הרקורסיביות ניתנות לייצוג בכל תורה אריתמטית. הוא כבר הראה שבכל תורה אפקטיבית, הפונקציה {::nomarkdown}\( B\left(x,y\right)\){:/nomarkdown} של "{::nomarkdown}\( x\){:/nomarkdown} היא הוכחה ל-{::nomarkdown}\( y\){:/nomarkdown}" היא רקורסיבית. משני אלו עולה שהיא ניתנת לייצוג בתורה שהיא אריתמטית ואפקטיבית. כעת הגענו לישורת האחרונה.
<h2>שובו של האלכסון</h2>
החלקים הטכניים של ההוכחה כבר פחות או יותר מאחורינו - כל מה שנותר הוא רעיון חדש אחד או שניים, שניתנים להבנה גם עבור מי שלא בקיא בפרטים הקטנים של מה שהלך עד כה. ראשית כל ננסה לתת את המוטביציה להגדרה החדשה. יש לנו כבר יכולת לומר "{::nomarkdown}\( x\){:/nomarkdown} הוא הוכחה ל-{::nomarkdown}\( y\){:/nomarkdown}" והיינו רוצים לבנות פסוק {::nomarkdown}\( G\){:/nomarkdown} שאומר "אין הוכחה עבורי". כעת, כל נוסחה {::nomarkdown}\( \varphi\){:/nomarkdown} מיוצגת, כזכור, על ידי מספר - זהו מספור גדל המדובר. נסמן את המספר הזה בתור {::nomarkdown}\( \left\|\varphi\right\|\){:/nomarkdown}. אם כן, מדוע לא לבנות את הפסוק הבא: {::nomarkdown}\( G=\forall x\left(\neg B\left(x,\left\|G\right\|\right)\right)\){:/nomarkdown}? כלומר, {::nomarkdown}\( G\){:/nomarkdown} הוא הפסוק שאומר "לא קיים {::nomarkdown}\( x\){:/nomarkdown} שהוא הוכחה עבורי" - זה יסיים את העניין.

לרוע המזל, ההפניה העצמית שאנו כל כך אוהבים פונה כאן כנגדנו. שימו לב איך <strong>הגדרתי</strong> את הפסוק {::nomarkdown}\( G\){:/nomarkdown}: חלק ממנו הוא {::nomarkdown}\( \left\|G\right\|\){:/nomarkdown}, שהוא מספר טבעי שמיוצג בתורה שלנו באמצעות הפעלות חוזרות ונשנות של פונקצית העוקב על 0 - כלומר, זו מחרוזת ארוכה ומסובכת. מצד שני,<strong> הערך המספרי</strong> שאותה מחרוזת מייצגת הוא משהו שכדי לחשב אותו עלינו כבר לדעת את <strong>כל</strong> הנוסחה {::nomarkdown}\( G\){:/nomarkdown}; במילים אחרות, ההגדרה שלנו היא מעגלית - כל עוד לא כתבנו במפורש את {::nomarkdown}\( G\){:/nomarkdown} אין משמעות ל-{::nomarkdown}\( \left\|G\right\|\){:/nomarkdown}, אבל מבלי שתהיה משמעות ל-{::nomarkdown}\( \left\|G\right\|\){:/nomarkdown} אי אפשר לכתוב את {::nomarkdown}\( G\){:/nomarkdown}! בקיצור, נתקענו, ואנו זקוקים לתעלול כדי לפתור את הבעיה. תעלול שכזה הוא בדיוק מה שגדל מספק; בסופו של דבר הוא יאפשר, בצורה עקיפה, להציב את {::nomarkdown}\( \left\|G\right\|\){:/nomarkdown} בתוך {::nomarkdown}\( G\){:/nomarkdown}.

ראשית, בואו נבהיר הגדרה חשובה אחת: "פסוק" פירושו של דבר שאין בו משתנים שאינם נופלים תחת כמת כלשהו. למשל, {::nomarkdown}\( \varphi=\forall x,y\left(x+y=y+x\right)\){:/nomarkdown} הוא פסוק; לעומת זאת, {::nomarkdown}\( \varphi^{\prime}=x+y&gt;0\){:/nomarkdown} אינו פסוק. ההבדל מהותי: ל-{::nomarkdown}\( \varphi\){:/nomarkdown} יש ערך אמת מוגדר, או שהוא נכון, או שלא. לעומת זאת, ערך האמת של {::nomarkdown}\( \varphi^{\prime}\){:/nomarkdown} תלוי בערכים הספציפיים של{::nomarkdown}\( x,y\){:/nomarkdown} ש"נציב" בו.

נניח לרגע שיש לנו נוסחה {::nomarkdown}\( \varphi\){:/nomarkdown} שמכילה בדיוק משתנה חופשי אחד {::nomarkdown}\( y\){:/nomarkdown}. אז {::nomarkdown}\( \varphi\left(\left\|\varphi\right\|\right)\){:/nomarkdown} הוא <strong>פסוק</strong> שמתקבל מלקיחת {::nomarkdown}\( \varphi\){:/nomarkdown} והצבת המספר {::nomarkdown}\( \left\|y\right\|\){:/nomarkdown} בכל מקום שבו כתוב {::nomarkdown}\( y\){:/nomarkdown} ב-{::nomarkdown}\( \varphi\){:/nomarkdown}. זכרו שבשפה שלנו ניתן לתאר כל מספר טבעי, על ידי הפעלה של פונקצית העוקב מספר סופי של פעמים, ולכן {::nomarkdown}\( \varphi\left(\left\|\varphi\right\|\right)\){:/nomarkdown} הוא פסוק חוקי בשפה. הפסוק הזה מכונה "<strong>הלכסון</strong> של {::nomarkdown}\( \varphi\){:/nomarkdown}", וכאמור - ערכו הוא אמת אם ורק אם כאשר מציבים את {::nomarkdown}\( \left\|\varphi\right\|\){:/nomarkdown} בתוך {::nomarkdown}\( \varphi\){:/nomarkdown} מקבלים אמת. אם כן, עקפנו במובן מה את הקושי של הצבת מספר גדל של נוסחה "בתוך עצמה" - אבל המחיר ששילמנו הוא בזה שמספר גדל של הפסוק {::nomarkdown}\( \varphi\left(\left\|\varphi\right\|\right)\){:/nomarkdown} שונה מזה של {::nomarkdown}\( \varphi\){:/nomarkdown}.

דוגמה טיפשית: נניח ש-{::nomarkdown}\( \varphi=\exists x\left(y&gt;x\wedge2\cdot y&lt;x\right)\){:/nomarkdown}. נניח שאחרי חישובים קשים מצאנו כי {::nomarkdown}\( \left\|\varphi\right\|=1231\){:/nomarkdown} (מספר מפוברק, כמובן). אז {::nomarkdown}\( \varphi\left(\left\|\varphi\right\|\right)=\exists x\left(1231&gt;x\wedge2\cdot1231&lt;x\right)\){:/nomarkdown}, וזהו פסוק שיש לו או ערך אמת, או ערך שקר. כאן אנחנו מתחילים לראות את ההתייחסות העצמית המדוברת של משפט גדל - אפשר לשאול את {::nomarkdown}\( \varphi\){:/nomarkdown}"מה אתה אומר על עצמך?". אלן טיורינג ישתמש בדיוק ברעיון הזה מספר שנים לאחר מכן, ולא במקרה, אלא בהשראת הרעיון הזה של גדל.

מה בעצם משמעות המילה "לכסון" כאן? הנה אינטואיציה. חשבו על טבלה שבה לכל נוסחה במשתנה אחד {::nomarkdown}\( \varphi\left(y\right)\){:/nomarkdown} יש שורה, ולכל מספר טבעי שמתאים לנוסחה שכזו יש עמודה. בעמודה {::nomarkdown}\( n\){:/nomarkdown} בשורה של {::nomarkdown}\( \varphi\){:/nomarkdown} יהיה 1 אם {::nomarkdown}\( \varphi\left(n\right)\){:/nomarkdown} מקבל ערך אמת, ו-0 אחרת. כעת, אם נסדר את הנוסחאות {::nomarkdown}\( \varphi\){:/nomarkdown} על פי סדר הגודל של מספרי גדל שלהם, הרי שהערכים של {::nomarkdown}\( \varphi\left(\left\|\varphi\right\|\right)\){:/nomarkdown} יהיו בדיוק האלכסון של הטבלה.

כאמור, גם הלכסון של {::nomarkdown}\( \varphi\){:/nomarkdown} הוא נוסחה, ולכן יש לו מספר גדל משל עצמו. זה פותח פתח להגדרת הפונקציה הבאה: {::nomarkdown}\( diag\left(n\right)=k\){:/nomarkdown} אם {::nomarkdown}\( k\){:/nomarkdown} הוא מספר גדל של הלכסון של הנוסחה {::nomarkdown}\( \varphi\){:/nomarkdown} שעבורה {::nomarkdown}\( \left\|\varphi\right\|=n\){:/nomarkdown}. כלומר, אם נתנו לנו {::nomarkdown}\( n\){:/nomarkdown} אנחנו "מפענחים" את הנוסחה {::nomarkdown}\( \varphi\){:/nomarkdown} שהוא מקודד, כותבים פורמלית את הנוסחה {::nomarkdown}\( \varphi\left(\left\|\varphi\right\|\right)\){:/nomarkdown} (שכאמור, שונה פיזית מהנוסחה {::nomarkdown}\( \varphi\left(y\right)\){:/nomarkdown} - סדרת הסמלים שמרכיבים אותה שונה, ולכן מספר גדל שלה יהיה שונה), מקודדים אותה בחזרה ומוציאים כפלט את המספר. ההסבר הזה הוא גם "אלגוריתם" לחישוב הפונקציה, ומכאן שהיא פונקציה רקורסיבית, ומכאן שהיא ניתנת לייצוג בתורה. בזאת סיימנו לדבר על הכלי החזק ביותר שבו נשתמש.

כעת נקשור את שני הרעיונות המרכזיים של גדל - הלכסון, והפונקציה {::nomarkdown}\( B\left(x,y\right)\){:/nomarkdown}. נגדיר את הנוסחה הבאה: {::nomarkdown}\( U\left(y\right)=\forall x\neg B\left(x,diag\left(y\right)\right)\){:/nomarkdown}. הנוסחה הזו אומרת "לא קיימת הוכחה לפסוק שמיוצג על ידי המספר{::nomarkdown}\( diag\left(y\right)\){:/nomarkdown}". אנחנו כבר ממש ממש שם, נשארה רק עוד הגדרה אחת, אחרונה, שהיא הטוויסט הסופי - מה שמקבלים כאשר מלכסנים את {::nomarkdown}\( U\){:/nomarkdown} עצמה.

אם כן, נגדיר {::nomarkdown}\( G=U\left(\left\|U\right\|\right)\){:/nomarkdown}. הנוסחה {::nomarkdown}\( G\){:/nomarkdown} הזו היא היעד הסופי שלנו - זה הפסוק שאינו ניתן להוכחה ועם זאת הוא נכון. ראשית, ברור שמדובר בפסוק, כי אין בו משתנים חופשיים. שנית, מה בעצם הוא אומר? הפסוק מקבל ערך אמת אם ורק אם הערך של {::nomarkdown}\( U\){:/nomarkdown} על {::nomarkdown}\( \left\|U\right\|\){:/nomarkdown} הוא אמת; אבל {::nomarkdown}\( U\){:/nomarkdown} מקבל ערך אמת על {::nomarkdown}\( \left\|U\right\|\){:/nomarkdown} אם ורק אם לא קיימת הוכחה לפסוק שמיוצג על ידי המספר {::nomarkdown}\( diag\left(\left\|U\right\|\right)\){:/nomarkdown}. אבל מה זה הפסוק הזה? נזכר בהגדרה: {::nomarkdown}\( diag\left(\left\|U\right\|\right)\){:/nomarkdown} הוא מספר גדל של הלכסון של {::nomarkdown}\( U\){:/nomarkdown}, כלומר של הפסוק {::nomarkdown}\( G=U\left(\left\|U\right\|\right)\){:/nomarkdown}. כלומר, בסיכומו של דבר קיבלנו ש-{::nomarkdown}\( G\){:/nomarkdown} מקבל ערך אמת אם ורק אם לא קיימת הוכחה לפסוק שמיוצג על ידי {::nomarkdown}\( G\){:/nomarkdown} - זהו הניסוח הפחות או יותר מדוייק לתיאור האינטואיטיבי של "{::nomarkdown}\( G\){:/nomarkdown} אומרת שאין לה הוכחה".

וואו. בכל פעם שבה אני מגיע לשלב הזה בהוכחה, אני צריך לעצור ולשאוף קצת אוויר. אף שהרעיון של לכסון אינו חדש, גדל בהחלט הביא אותו כאן לכדי שלמות.
<h2>מה עוד נשאר?</h2>
למרות שבנינו את {::nomarkdown}\( G\){:/nomarkdown}, עדיין לא סיימנו. הטיעון שנתתי לעיל, של "{::nomarkdown}\( G\){:/nomarkdown} אומרת שאין לה הוכחה" הוא טיעון בנפנופי ידיים - טיעון "סמנטי" שמתבסס על המשמעות שאני מייחס ל-{::nomarkdown}\( G\){:/nomarkdown}. עבור הוכחה פורמלית צריך להראות ממש שלא ניתן להוכיח את {::nomarkdown}\( G\){:/nomarkdown}. בסימון פורמלי, {::nomarkdown}\( \vdash\varphi\){:/nomarkdown} אומר "ניתן להוכיח את {::nomarkdown}\( \varphi\){:/nomarkdown}". אם כן, אנו רוצים להראות כי {::nomarkdown}\( \not\vdash G\){:/nomarkdown}. נניח אם כן כי {::nomarkdown}\( \vdash G\){:/nomarkdown}; כלומר, קיימת הוכחה של {::nomarkdown}\( G\){:/nomarkdown} במערכת שלנו, ולכן לאותה הוכחה קיים מספר גדל כלשהו, נניח {::nomarkdown}\( m\){:/nomarkdown}; מכאן שמתקיים {::nomarkdown}\( B\left(m,\left\|G\right\|\right)\){:/nomarkdown}, כלומר מתקיים {::nomarkdown}\( B\left(m,diag\left(\left\|U\right\|\right)\right)\){:/nomarkdown} (כל זה - על פי ההגדרות). כעת, לא ממש הסברתי עד הסוף מה זה אומר ש-{::nomarkdown}\( B\){:/nomarkdown}"מיוצגת" בתורה שלנו, אבל אחת מההשלכות של ה"ייצוג" הזה הוא שמתקיים {::nomarkdown}\( \vdash B\left(m,diag\left(\left\|U\right\|\right)\right)\){:/nomarkdown}.

מצד שני, {::nomarkdown}\( G=\forall x\neg B\left(x,diag\left(\left\|U\right\|\right)\right)\){:/nomarkdown} על פי הבניה שלנו, ולכן {::nomarkdown}\( \vdash\forall x\neg B\left(x,diag\left(\left\|U\right\|\right)\right)\){:/nomarkdown}; מכללי ההיסק הסטנדרטיים נובע ש-{::nomarkdown}\( \vdash\neg B\left(m,diag\left(\left\|U\right\|\right)\right)\){:/nomarkdown} (אם ניתן להוכיח שזה קורה לכל {::nomarkdown}\( x\){:/nomarkdown}, ניתן להוכיח שזה קורה ספציפתי עבור {::nomarkdown}\( x=m\){:/nomarkdown}). לכן קיבלנו שהמערכת שלנו מוכיחה משפט ושלילתו - סתירה לכך שהיא עקבית.

שימו לב למה שקרה כאן כרגע - היינו חייבים להתבסס על עקביות התורה. אם היא לא הייתה עקבית, הרי שכן היה ניתן להוכיח את פסוק גדל שלנו, ולכן הטענה שהוא טוען הייתה <strong>שגויה</strong>. מכאן שלא מדויק לומר שהפסוק {::nomarkdown}\( G\){:/nomarkdown} הוא "נכון" - יותר מדויק לומר ש<strong>אם</strong> המערכת שלנו עקבית, <strong>אז</strong> הפסוק נכון. ההבחנה הזו קריטית, מכיוון שלפעמים מנסים לטעון ש"אנחנו יותר חכמים מהמערכת הלוגית" כי אנחנו יודעים ש-{::nomarkdown}\( G\){:/nomarkdown} נכון בזמן שהיא לא יודעת זאת כי היא לא מסוגלת להוכיח זאת. דא עקא, אנחנו לא באמת יודעים ש-{::nomarkdown}\( G\){:/nomarkdown} נכון; "לדעת" ש-{::nomarkdown}\( G\){:/nomarkdown} נכון היה אומר שאנחנו יודעים שהמערכת שלנו היא עקבית, אבל אנחנו לא יודעים זאת!

אני לא רוצה לתת את הרושם הלא נכון - ה"הוכחה" שכתבתי פה היא לא יותר מאשר ערב רב של נפנופי ידיים לא מדויקים. הפרטים הטכניים של ההוכחה רבים ומורכבים יותר, וישנן נקודות עדינות רבות שלא הזכרתי או שאולי אף איני מכיר (או שם אליהן לב) בעצמי. בפרט, שימו לב שלא הוכחתי בכלל כי בתורה שלנו לא ניתן להוכיח את השלילה של {::nomarkdown}\( G\){:/nomarkdown}! (הסיבוך הטכני שמתקשר להוכחה הזו לא שווה את זה, במסגרת הפוסט הזה). עם זאת, אני מקווה שאת רוח ההוכחה ורעיונותיה המרכזיים עלה בידי להעביר.
