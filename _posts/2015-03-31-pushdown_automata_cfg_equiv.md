---
id: 3233
title: "שקילות אוטומט מחסנית ודקדוק חסר הקשר"
date: 2015-03-31 13:04:13
layout: post
categories: 
  - תורת הסיבוכיות
tags: 
  - אוטומט מחסנית
  - דקדוק חסר הקשר
  - שפות חסרות הקשר
  - שפות פורמליות
---
<a href="http://www.gadial.net/2015/03/22/pushdown_automata/">בפוסט הקודם</a> הצגתי את המודל של <strong>אוטומט מחסנית</strong>. המטרה הייתה להציג מודל של אוטומט שמחלקת השפות שמתאימה לו היא בדיוק מחלקת השפות חסרות ההקשר. לצורך זה, חשבתי על אלגוריתם פשוט לזיהוי שפה של דקדוק חסר הקשר כלשהו, ואז לקחתי מודל של אוטומט שמסוגל לממש בקלות את האלגוריתם הזה. בכך הוכחתי את הכיוון ה"קל" - שאוטומט מחסנית מקבל כל שפה חסרת הקשר. עכשיו הגיע הזמן לכיוון הקשה יותר - שהשפה של אוטומט מחסנית היא תמיד חסרת הקשר - דהיינו, שבהינתן אוטומט מחסנית {::nomarkdown}\( M\){:/nomarkdown} קיים דקדוק חסר הקשר {::nomarkdown}\( G\){:/nomarkdown} כך ש-{::nomarkdown}\( L\left(G\right)=L\left(M\right)\){:/nomarkdown}. זה קשה, כי אנחנו צריכים איכשהו "לסמלץ" אוטומט עם דקדוק, מה שנראה לא קשור בעליל במבט ראשון ואכן ידרוש מאיתנו בניה חכמה למדי - כנראה הדבר הכי מסובך שראינו עד כה בסדרת הפוסטים על שפות פורמליות, אבל עדיין לא משהו <strong>עד כדי כך</strong> מסובך, לא לדאוג.

בואו ניסגר מראש על הפורמליסטיקה. ניקח אוטומט מחסנית {::nomarkdown}\( M=\left(Q,\Sigma,\Gamma,q_{0},\bot,\delta,\emptyset\right)\){:/nomarkdown} עם קבוצת מצבים {::nomarkdown}\( Q\){:/nomarkdown}, א"ב קלט ומחסנית {::nomarkdown}\( \Sigma,\Gamma\){:/nomarkdown} בהתאמה, מצב התחלתי {::nomarkdown}\( q_{0}\){:/nomarkdown} וסימן תחתית מחסנית {::nomarkdown}\( \bot\){:/nomarkdown} ופונקציית מעברים {::nomarkdown}\( \delta\){:/nomarkdown}, כך ש-{::nomarkdown}\( \delta\left(q,\sigma,A\right)\){:/nomarkdown}, עבור {::nomarkdown}\( \sigma\in\Sigma\cup\left\{ \varepsilon\right\} \){:/nomarkdown} ו-{::nomarkdown}\( A\in\Gamma\){:/nomarkdown}, היא קבוצה של זוגות {::nomarkdown}\( \left(p,\beta\right)\){:/nomarkdown} שפירושם "במצב {::nomarkdown}\( q\){:/nomarkdown} אחרי קריאת {::nomarkdown}\( \sigma\){:/nomarkdown} ועם {::nomarkdown}\( A\){:/nomarkdown} בראש המחסנית אפשר לעבור למצב {::nomarkdown}\( p\){:/nomarkdown} ולדחוף {::nomarkdown}\( \beta\){:/nomarkdown} במקום {::nomarkdown}\( A\){:/nomarkdown}". קבוצת המצבים המקבלים תהיה ריקה כי אני אתעניין רק באוטומט שמקבל על ידי ריקון (לכל אוטומט שמקבל על ידי מצבים מקבלים יש אוטומט שקול שמקבל על ידי ריקון). כלומר, שפת האוטומט מוגדרת כך:

{::nomarkdown}\( L\left(M\right)=\left\{ w\in\Sigma^{*}\ \|\ \exists p\in Q:\left[q_{0},w,\bot\right]\vdash^{*}\left[p,\varepsilon,\varepsilon\right]\right\} \){:/nomarkdown}

כאשר {::nomarkdown}\( \left[q,w,\alpha\right]\){:/nomarkdown} היא <strong>קונפיגורציה</strong> של האוטומט שמתארת את המצב הנוכחי {::nomarkdown}\( q\){:/nomarkdown}, הקלט שנותר {::nomarkdown}\( w\){:/nomarkdown} ותוכן המחסנית {::nomarkdown}\( \alpha\){:/nomarkdown}, והסימן {::nomarkdown}\( \vdash^{*}\){:/nomarkdown} אומר "אפשר לעבור מהקונפיגורציה השמאלית לימנית ב-0 או יותר צעדים".

עכשיו, איך ניגשים לבניה שלנו? במבט ראשון זה נראה מפחיד ואין לנו מושג מאיפה להתחיל, כי דקדוק זה משהו שמייצר מילים על ידי כך שהוא משליך הרבה אותיות לפה ולשם ופתאום יש מילה מוגמרת, ולעומת זאת אוטומט עובר סדרתית על אותיות ועושה חישובים וכדומה. אבל בעצם, אם חושבים על זה, כבר ראינו משהו דומה - דקדוק שמסמלץ אוטומט סופי דטרמיניסטי. שם הרעיון היה כזה: משתני הדקדוק היו {::nomarkdown}\( Q\){:/nomarkdown}, הטרמינלים היו {::nomarkdown}\( \Sigma\){:/nomarkdown} ולכל מעבר {::nomarkdown}\( \delta\left(q,\sigma\right)=p\){:/nomarkdown} היה לנו את כלל הגזירה {::nomarkdown}\( q\to\sigma p\){:/nomarkdown}. כך הדקדוק יצר את המילה "אות אחרי אות" כשהסימן הימני ביותר בתבנית הפסוקית שבמהלך הבניה תמיד תיאר את המצב הנוכחי של האוטומט - בעצם, אם חושבים על זה, זה סוג של תיאור של ה<strong>קונפיגורציה</strong> שלו (רק בלי "מה שנשאר מהקלט").

אז למה לא לעשות בניה דומה עבור אוטומט מחסנית? הרי ההבדל היחיד הוא שעכשיו יש לנו גם מחסנית. למה לא לתאר את הקונפיגורציה הנוכחית של האוטומט בלי שארית הקלט בתור זוג {::nomarkdown}\( \left(q,\alpha\right)\){:/nomarkdown} כאשר {::nomarkdown}\( \alpha\in\Gamma^{*}\){:/nomarkdown} ולכל מעבר {::nomarkdown}\( \left(p,\beta\right)\in\delta\left(q,\sigma,A\right)\){:/nomarkdown} להוסיף את הגזירה הבאה בדקדוק: {::nomarkdown}\( \left(q,A\alpha\right)\to\sigma\left(p,\beta\alpha\right)\){:/nomarkdown}?

התשובה פשוטה מאוד - כי הדקדוק שנקבל יהיה בעל <strong>אינסוף משתנים</strong> - כי הרי יש לנו אינסוף זוגות {::nomarkdown}\( \left(q,\alpha\right)\){:/nomarkdown} עם {::nomarkdown}\( \alpha\in\Gamma^{*}\){:/nomarkdown} שהרי הגודל של המחסנית של האוטומט לא חסום. הכשלון הזה לא מפתיע במיוחד כי אם הוא היה מצליח, מה שהיינו בונים הוא <strong>דקדוק לינארי ימני</strong>, מה שהיה מוכיח שהשפה שלנו היא בכלל רגולרית, דהיינו היינו מוכיחים שכל שפה חסרת הקשר היא רגולרית, וזה בוודאי לא נכון. אם כן, אין לנו תקווה לדקדוק שיהיה <strong>עד כדי כך</strong> פשוט.

עדיין, מה שעשינו הוא התחלה טובה שתוביל אותנו בסופו של דבר אל הבניה שעובדת. בואו ננסה להציע לה תיקון נאיבי ונראה מה יקרה: מכיוון שהבעיה שלנו היא עם כך ש-{::nomarkdown}\( \alpha\){:/nomarkdown} הוא לא חסום באורכו, הנה הצעה: פשוט נפרוט אותו לפרוטות. נוסיף את כל {::nomarkdown}\( \Gamma\){:/nomarkdown} לקבוצת המשתנים של הדקדוק שלנו, ועכשיו תבנית פסוקית אופיינית תיראה, נאמר, כך: {::nomarkdown}\( aabqABB\){:/nomarkdown}. התבנית הזו אומרת "עד כה הסימולציה של האוטומט שלנו קראה את {::nomarkdown}\( aab\){:/nomarkdown}; עכשיו אנחנו במצב {::nomarkdown}\( q\){:/nomarkdown}; תוכן המחסנית הוא {::nomarkdown}\( ABB\){:/nomarkdown}". זה נראה מאוד מבטיח כי האוטומט פועל רק על פי התו העליון במחסנית, שממילא צמוד ל-{::nomarkdown}\( q\){:/nomarkdown}, אז נראה שאפשר לעשות כאן משהו.

למה הבניה הזו נכשלת? כי הדקדוק שלנו צריך להיות <strong>חסר הקשר</strong>. כאשר אני גוזר את המשתנה {::nomarkdown}\( q\){:/nomarkdown}, המשתנה לא יודע מי נמצא מימינו ומשמאלו והגזירה לא תהיה מושפעת מזה. במילים אחרות, אין ל-{::nomarkdown}\( q\){:/nomarkdown} דרך "להכיר" את ה-{::nomarkdown}\( A\){:/nomarkdown} שמימינו. תגידו, אוקיי - בואו נחבר את שניהם מראש לזוג, כלומר התבנית תיראה כך: {::nomarkdown}\( aab\left(q,A\right)BB\){:/nomarkdown}. זה טוב ויפה, אבל אחרי ש-{::nomarkdown}\( \left(q,A\right)\){:/nomarkdown} נגזר למשהו, איך אותו משהו יתחבר אל ה-{::nomarkdown}\( B\){:/nomarkdown}-ים שמשמאל?

בקיצור, גם זה לא יעבוד. אני לא יכול שיהיו לי משתנים שהם "מצב לבד" ו"אות מחסנית לבד" - אני חייב שהמשתנים שלי יכללו מידע גם עבור המצב וגם עבור האות במחסנית. איך נעשה את זה? בואו ננסה פשוט לחבר אותם לזוגות ונראה איך זה עובד בדוגמה שלעיל: {::nomarkdown}\( \left(q_{3},B\right)\){:/nomarkdown}{::nomarkdown}\( aab\left(q_{1},A\right)\left(q_{2},B\right)\){:/nomarkdown}. כאשר כאן {::nomarkdown}\( q_{1},q_{2},q_{3}\){:/nomarkdown} הם מצבים כלשהם. מה שאני מצפה מ-{::nomarkdown}\( \left(q_{1},A\right)\){:/nomarkdown} לגזור זה את "החלק במילה שעליו האוטומט רץ עד לשלב שבו הוא מגיע למצב {::nomarkdown}\( q_{2}\){:/nomarkdown} ובמחסנית נשארו רק {::nomarkdown}\( BB\){:/nomarkdown}", ומה שאני מצפה מ-{::nomarkdown}\( \left(q_{2},B\right)\){:/nomarkdown} לגזור זה את "החלק במילה שעליו האוטומט רץ עד לשלב שבו הוא מגיע למצב {::nomarkdown}\( q_{3}\){:/nomarkdown} ובמחסנית נשאר רק {::nomarkdown}\( B\){:/nomarkdown}" ו-{::nomarkdown}\( \left(q_{3},B\right)\){:/nomarkdown} אמור לגזור את "החלק המילה שעליו האוטומט רץ עד שהמחסנית מתרוקנת". משהו כאן עדיין לא עובד, אבל אני חושב שאנחנו כבר רואים שזה מתחמם ואנחנו מתקרבים לבניה שתעבוד.

הבעיה בבניה הנוכחית היא שהיא עדיין תלוית הקשר במובן מסויים - מה זאת אומרת, אני מצפה מ-{::nomarkdown}\( \left(q_{1},A\right)\){:/nomarkdown} לגזור את החלק במילה שעליו האוטומט רץ עד שהוא מגיע ל-{::nomarkdown}\( q_{2}\){:/nomarkdown} ובמחסנית יש {::nomarkdown}\( BB\){:/nomarkdown}? איך הוא יודע מ-{::nomarkdown}\( q_{2}\){:/nomarkdown} ומ-{::nomarkdown}\( BB\){:/nomarkdown}? כרגע הוא לא. אבל שימו לב - הוא בעצם לא באמת מתעניין ב-{::nomarkdown}\( BB\){:/nomarkdown}. אפשר לנסח את זה מחדש: {::nomarkdown}\( \left(q_{1},A\right)\){:/nomarkdown} אמור לגזור את החלק במילה שעליו האוטומט רץ עד שהוא מגיע ל-{::nomarkdown}\( q_{2}\){:/nomarkdown} והמחסנית מגיעה למצב שבו מה שהיה מתחת ל-{::nomarkdown}\( A\){:/nomarkdown} נחשף לראשונה. הקטע הזה עם ה"נחשף לראשונה" נראה לי כמו הדבר הכי מבלבל כאן, אז בואו נפרט קצת: על פי ההגדרה שלו, הדבר הראשון שהאוטומט עושה כשהוא מבצע צעד זה להסיר את {::nomarkdown}\( A\){:/nomarkdown} מהמחסנית. אבל מייד אחר כך הוא דוחף במקום {::nomarkdown}\( A\){:/nomarkdown} מילה {::nomarkdown}\( \beta\){:/nomarkdown} כלשהי. אם {::nomarkdown}\( \beta\){:/nomarkdown} היא המילה הריקה, אז מה שהיה מתחת ל-{::nomarkdown}\( A\){:/nomarkdown} נחשף; אחרת, {::nomarkdown}\( A\){:/nomarkdown} הוחלף על ידי תווים נוספים (אולי יותר מ-1) ומה שהיה קבור מתחת ל-{::nomarkdown}\( A\){:/nomarkdown} נשאר קבור ונצטרך לטפל בכל מה שמעליו לפני שנגיע אליו.

אם כן, לא באמת אכפת לנו מה-{::nomarkdown}\( BB\){:/nomarkdown}, אבל כן אכפת לנו מ-{::nomarkdown}\( q_{2}\){:/nomarkdown}. אבל כאן אין בעצם בעיה, כי {::nomarkdown}\( q_{2}\){:/nomarkdown} הוא מצב בודד ואפשר לזכור אותו - זו כבר לא סדרה בלתי חסומה של תווים. זה מוביל אותנו אל הרעיון שמאחורי הבניה האמיתית שבה נשתמש: המשתנים שלנו יהיו שלשות {::nomarkdown}\( \left(q,A,p\right)\){:/nomarkdown} כך שהמילים ששלשות כאלו גוזרות הן בדיוק המילים שמאפשרות לאוטומט לעבור מ-{::nomarkdown}\( q\){:/nomarkdown} אל {::nomarkdown}\( p\){:/nomarkdown} כאשר בהתחלה {::nomarkdown}\( A\){:/nomarkdown} בראש המחסנית ובסיום נחשף מה שהיה מתחתיו.

בואו נכתוב את זה בצורה פורמלית. אני רוצה לבנות את הדקדוק בצורה כזו שיתקיים הדבר הבא:

{::nomarkdown}\( \left(q,A,p\right)\Rightarrow^{*}w\iff\left[q,w,A\right]\vdash^{*}\left[p,\varepsilon,\varepsilon\right]\){:/nomarkdown}

כאן צד שמאל הוא גזירה בדקדוק, וצד ימין הוא חישוב של האוטומט. שימו לב לאופן הפשוט שבו כל הסיבוך של "הפעם הראשונה שבה מה שמתחת ל-{::nomarkdown}\( A\){:/nomarkdown} נחשף" מבוטא כאן - אני פשוט מתאר את החישוב כאילו הוא מתחיל ממחסנית שבה אין כלום מתחת ל-{::nomarkdown}\( A\){:/nomarkdown}, ובצעד האחרון המחסנית מתרוקנת. לא ייתכן שהמחסנית גם לפני הצעד האחרון כי אז האוטומט היה נתקע. לא קשה להוכיח שאם {::nomarkdown}\( \left[q,w,A\right]\vdash^{*}\left[p,\varepsilon,\varepsilon\right]\){:/nomarkdown} אז גם {::nomarkdown}\( \left[q,w,A\beta\right]\vdash^{*}\left[p,\varepsilon,\beta\right]\){:/nomarkdown} לכל {::nomarkdown}\( \beta\){:/nomarkdown} אפשרי, כך שאנחנו לא מגבילים את הכלליות בכך שאנחנו מדברים רק על מה שקורה שהמחסנית ריקה. מעכשיו, לצורך פשטות, אני אדבר על סדרת מעברים כזו פשוט בתור "מעברים שמרוקנים את {::nomarkdown}\( A\){:/nomarkdown}" למרות שפורמלית זה לא ממש נכון (כי {::nomarkdown}\( A\){:/nomarkdown} יכול לעוף במעבר הראשון אבל מה שמתחתיו לא ייחשף מייד, או ש-{::nomarkdown}\( A\){:/nomarkdown} יישאר למשך הרבה זמן, וכו').

אם אני אצליח לבנות דקדוק שאלו משתניו, זה מסיים כמעט מייד את ההוכחה - שימו לב כמה צד ימין של השקילות דומה להגדרת הקבלה באמצעות ריקון מחסנית. כדי לסיים את הבניה אני אוסיף לדקדוק משתנה התחלתי {::nomarkdown}\( S\){:/nomarkdown} (חייב להיות משתנה התחלתי וטרם ציינתי כזה) ולכל מצב {::nomarkdown}\( p\in Q\){:/nomarkdown} אוסיף את הגזירה {::nomarkdown}\( S\to\left(q_{0},\bot,p\right)\){:/nomarkdown}, וסיימנו: {::nomarkdown}\( w\in L\left(M\right)\){:/nomarkdown} אם ורק אם קיים {::nomarkdown}\( p\in Q\){:/nomarkdown} כך ש-{::nomarkdown}\( \left[q_{0},w,\bot\right]\vdash^{*}\left[p,\varepsilon,\varepsilon\right]\){:/nomarkdown}, כלומר אם ורק אם קיים {::nomarkdown}\( p\in Q\){:/nomarkdown} כך ש-{::nomarkdown}\( \left(q_{0},\bot,p\right)\Rightarrow^{*}w\){:/nomarkdown}, כלומר אם ורק אם {::nomarkdown}\( S\Rightarrow^{*}w\){:/nomarkdown} (למה? זה דורש טיפה נימוק), כלומר אם ורק אם {::nomarkdown}\( w\in L\left(G\right)\){:/nomarkdown}.

אז נשאר רק להבין איך לבנות את הדקדוק כך שהשקילות תתקיים. מה זה אומר "לבנות את הדקדוק"? את המשתנים כבר ציינתי - אלו כל השלשות {::nomarkdown}\( \left(q,A,p\right)\){:/nomarkdown}; רק נשאר להציג את כללי הגזירה שלהם. פורמלית, הדקדוק שלי הוא {::nomarkdown}\( G=\left(\left\{ S\right\} \cup Q\times\Gamma\times Q,\Sigma,S,P\right)\){:/nomarkdown} ורק נותר לי לתאר את {::nomarkdown}\( P\){:/nomarkdown}.

הבניה תתבסס, מן הסתם, על המעברים של האוטומט. אפשר לחלק את המעברים לשני סוגים: כאלו ש<strong>מפשטים</strong> לנו את הסיטואציה, וכאלו ש<strong>מסבכים</strong> אותה (או לכל הפחות משאירים אותה ללא שינוי), וזאת בהתאם לשאלה מה קורה למחסנית. צעד שמסיר את התו מהמחסנית ולא דוחף כלום במקומו עושה לנו את החיים פשוטים יותר; צעד שלא מקטין את המחסנית מסבך אותנו.

המקרה הראשון הוא מעבר מהצורה {::nomarkdown}\( \left(p,\varepsilon\right)\in\delta\left(q,\sigma,A\right)\){:/nomarkdown}. שימו לב מה מעבר כזה עושה: הוא מעביר אותנו מ-{::nomarkdown}\( q\){:/nomarkdown} אל {::nomarkdown}\( p\){:/nomarkdown} תוך שהוא מרוקן את {::nomarkdown}\( A\){:/nomarkdown} מהמחסנית - בדיוק מה שהמשתנה {::nomarkdown}\( \left(q,A,p\right)\){:/nomarkdown} בא לתאר. מכיוון שהמעבר הזה משתמש ב-{::nomarkdown}\( \sigma\){:/nomarkdown} לצורך כך (ייתכן ש-{::nomarkdown}\( \sigma\){:/nomarkdown} היא המילה הריקה), אז אנחנו מקבלים את הגזירה {::nomarkdown}\( \left(q,A,p\right)\to\sigma\){:/nomarkdown}.

ועכשיו לסיטואציה המסובכת - מעבר מהצורה {::nomarkdown}\( \left(p,B_{1}B_{2}\dots B_{n}\right)\in\delta\left(q,\sigma,A\right)\){:/nomarkdown}. כאן {::nomarkdown}\( A\){:/nomarkdown} הוחלף על ידי {::nomarkdown}\( B_{1}\dots B_{n}\){:/nomarkdown} ולכן כדי להשיג את האפקט של ריקון {::nomarkdown}\( A\){:/nomarkdown} מהמחסנית, אנחנו צריכים לרוקן את {::nomarkdown}\( B_{1},\dots,B_{n}\){:/nomarkdown}. זה מזמין את הגזירה הבאה:

{::nomarkdown}\( \left(q,A,q_{n+1}\right)\to\sigma\left(q_{1},B_{1},q_{2}\right)\left(q_{2},B_{2},q_{3}\right)\cdots\left(q_{n},B_{n},q_{n+1}\right)\){:/nomarkdown}

שמתארת את הסיפור הבא: קודם כל עברנו מ-{::nomarkdown}\( q\){:/nomarkdown} אל {::nomarkdown}\( q_{1}\){:/nomarkdown} תוך קריאת {::nomarkdown}\( \sigma\){:/nomarkdown} והחלפת {::nomarkdown}\( A\){:/nomarkdown} ב-{::nomarkdown}\( B_{1}\cdots B_{n}\){:/nomarkdown}; אחר כך נעבור מ-{::nomarkdown}\( q_{1}\){:/nomarkdown} אל {::nomarkdown}\( q_{2}\){:/nomarkdown} ונרוקן את {::nomarkdown}\( B_{1}\){:/nomarkdown} תוך כדי; מ-{::nomarkdown}\( q_{2}\){:/nomarkdown} נעבור אל {::nomarkdown}\( q_{3}\){:/nomarkdown} תוך ריקון {::nomarkdown}\( B_{2}\){:/nomarkdown} וכן הלאה, עד אשר נעבור מ-{::nomarkdown}\( q_{n}\){:/nomarkdown} אל {::nomarkdown}\( q_{n+1}\){:/nomarkdown} תוך ריקון {::nomarkdown}\( B_{n}\){:/nomarkdown}.

הכל טוב ויפה חוץ מדבר אחד - מי לכל הרוחות הם המצבים {::nomarkdown}\( q_{1},q_{2},\dots,q_{n+1}\){:/nomarkdown}? מאיפה הם באו? כל מי שהיו לי במעבר המקורי באוטומט היו {::nomarkdown}\( q,p\){:/nomarkdown}, ולאן {::nomarkdown}\( p\){:/nomarkdown} נעלם באמת?

אז בבירור {::nomarkdown}\( q_{1}=p\){:/nomarkdown}, אבל זה עדיין לא מסביר מיהם המצבים {::nomarkdown}\( q_{2},\dots,q_{n+1}\){:/nomarkdown}. התשובה היא ש<strong>אני לא יודע</strong>. המטרה של הגזירה של {::nomarkdown}\( \left(q,A,q_{n+1}\right)\){:/nomarkdown} היא לתאר את <strong>כל</strong> הריצות האפשריות שבהן יסירו את {::nomarkdown}\( B_{1}\cdots B_{n}\){:/nomarkdown} מהמחסנית, ואני לא יודע מה מצבי הביניים בהן יהיו. אז מה שאני עושה הוא <strong>לכסות את כל האפשרויות</strong>. כלומר, אני הולך להוסיף את הגזירה

{::nomarkdown}\( \left(q,A,q_{n+1}\right)\to\sigma\left(q_{1},B_{1},q_{2}\right)\left(q_{2},B_{2},q_{3}\right)\cdots\left(q_{n},B_{n},q_{n+1}\right)\){:/nomarkdown}

עבור <strong>כל </strong>בחירת ערכים אפשרית ל-{::nomarkdown}\( q_{2},\dots,q_{n+1}\){:/nomarkdown}. ומה קורה אם, למשל, אין דרך להגיע מ-{::nomarkdown}\( q_{1}\){:/nomarkdown} אל {::nomarkdown}\( q_{2}\){:/nomarkdown} תוך הסרת {::nomarkdown}\( B_{1}\){:/nomarkdown} עבור בחירה מסויימת של {::nomarkdown}\( q_{2}\){:/nomarkdown}? אין בעיה. אז הגזירה הזו "תיתקע" כי המשתנה {::nomarkdown}\( \left(q_{1},B_{1},q_{2}\right)\){:/nomarkdown} לא יצליח לגזור מילה טרמינלית. לא נורא - אני לא חייב שכל נסיון גזירה יצליח.

קרוב לודאי שחלק מכם תוהים עכשיו למה טרחתי לפצל את כללי הגזירה לשניים, כשבעצם יש לי רק כלל גזירה אחד בשני המקרים - ה"פשוט" וה"מסובך": הכלל {::nomarkdown}\( \left(q,A,q_{n+1}\right)\to\sigma\left(q_{1},B_{1},q_{2}\right)\left(q_{2},B_{2},q_{3}\right)\cdots\left(q_{n},B_{n},q_{n+1}\right)\){:/nomarkdown} עם האילוץ ש-{::nomarkdown}\( p=q_{1}\){:/nomarkdown}. המקרה ה"פשוט" מתקבל כאשר {::nomarkdown}\( n=0\){:/nomarkdown}. ובכן, אפשר לעשות את זה כך, אבל לדעתי זה פשוט מבלבל יותר ואני לא רואה בזה טעם. כדאי להזכיר למי ששכח או לא יודע שהרעיון במתמטיקה הוא להיות ברור; לא להיות מינימליסטי. מינימליזם הוא טוב אם הוא מפשט עניינים, אבל אני לא חושב שהוא מטרה בפני עצמה.

בואו נעבור עכשיו להוכחה חצי פורמלית לכך שהבניה עובדת. אני חושב שכאן מאוד מועיל לראות הוכחה כזו כי למרות שאני מקווה שכבר יש לנו אינטואיציה לא רעה לגבי מה הבניה הזו ומאיפה היא הגיעה, עדיין חסר משהו כדי להשתכנע שזה אכן עובד. כזכור, כל מה שנשאר לי להוכיח הוא את הטענה {::nomarkdown}\( \left(q,A,p\right)\Rightarrow^{*}w\iff\left[q,w,A\right]\vdash^{*}\left[p,\varepsilon,\varepsilon\right]\){:/nomarkdown}. זו טענת אם-ורק-אם כך שאני צריך להוכיח שני כיוונים. נטפל בכל אחד מהם בנפרד.

נתחיל מכך שנתון {::nomarkdown}\( \left(q,A,p\right)\Rightarrow^{*}w\){:/nomarkdown} ונוכיח ש-{::nomarkdown}\( \left[q,w,A\right]\vdash^{*}\left[p,\varepsilon,\varepsilon\right]\){:/nomarkdown}. כלומר, אם המשתנה {::nomarkdown}\( \left(q,A,p\right)\){:/nomarkdown} גוזר מילה כלשהי, אז המילה הזו מעבירה את האוטומט מ-{::nomarkdown}\( q\){:/nomarkdown} אל {::nomarkdown}\( p\){:/nomarkdown} תוך סילוק {::nomarkdown}\( A\){:/nomarkdown} מהמחסנית. נוכיח את זה באינדוקציה, וזו הזדמנות טובה לשאול את עצמנו - אינדוקציה על מה? כלל האצבע הוא זה - נסתכל על האובייקט שאת קיומו אנחנו מניחים וממנו אנחנו רוצים להסיק דברים, ונבצע אינדוקציה על מאפיין כלשהו שלו שהולך ונעשה מורכב יותר. כאן האובייקט הנתון הוא <strong>הגזירה</strong> של {::nomarkdown}\( w\){:/nomarkdown} מתוך המשתנה; הפרמטר יהיה אורך הגזירה. הבסיס הוא גזירה בת צעד אחד, וזה קל - בגזירה בת צעד אחד שגוזרת מילה טרמינלית ממשתנה, צעד הגזירה חייב להיות כזה שלא יוצר משתנים אלא רק טרמינלים, כלומר הוא חייב להיות גזירה מהצורה ה"פשוטה", {::nomarkdown}\( \left(q,A,p\right)\to\sigma\){:/nomarkdown}. מכאן אנחנו לומדים שני דברים: ש-{::nomarkdown}\( w=\sigma\){:/nomarkdown}, וש-{::nomarkdown}\( \left(p,\varepsilon\right)\in\delta\left(q,\sigma,A\right)\){:/nomarkdown}. מסקנה: {::nomarkdown}\( \left[q,w,A\right]=\left[q,\sigma,A\right]\vdash\left[p,\varepsilon,\varepsilon\right]\){:/nomarkdown}.

נעבור אל צעד האינדוקציה. כאן אנחנו מניחים שהטענה נכונה לכל גזירה מאורך קטן מ-{::nomarkdown}\( k\){:/nomarkdown} (עבור {::nomarkdown}\( k\ge2\){:/nomarkdown}) ומוכיחים עבור {::nomarkdown}\( \left(q,A,p\right)\Rightarrow^{k}w\){:/nomarkdown}. התעלול הוא לרוב לפרק את הגזירה לצעד ראשון או אחרון, ו"כל היתר" שעליהם אפשר להפעיל את הנחת האינדוקציה. כאן יהיה לנו נוח לפרק לפי הצעד הראשון, שחייב להיות גזירה מהצורה ה"מסובכת", כי אחרת נקבל מילה טרמינלית אחרי הצעד הראשון ולכן לא ייתכן שהגזירה היא בת שני צעדים או יותר.

כלומר, מתקיים {::nomarkdown}\( \left(q,A,p\right)\Rightarrow\sigma\left(p,B_{1},q_{2}\right)\left(q_{2},B_{2},q_{3}\right)\cdots\left(q_{n},B_{n},q_{n+1}\right)\Rightarrow^{*}w\){:/nomarkdown} וזה נובע מכך שבאוטומט קיים המעבר {::nomarkdown}\( \left(p,B_{1}B_{2}\dots B_{n}\right)\in\delta\left(q,\sigma,A\right)\){:/nomarkdown}. בגזירה שמתוארת כאן, כל אחד מהמשתנים מתישהו נגזר לגמרי למילה טרמינלית כלשהי; בואו נסמן אותן באופן הבא: {::nomarkdown}\( \left(q_{i},B_{i},q_{i+1}\right)\Rightarrow^{*}w_{i}\){:/nomarkdown}. המסקנה היא ש-{::nomarkdown}\( w=\sigma w_{1}\cdots w_{n}\){:/nomarkdown}, ושניתן להפעיל את הנחת האינדוקציה על כל גזירה מהצורה {::nomarkdown}\( \left(q_{i},B_{i},q_{i+1}\right)\Rightarrow^{*}w_{i}\){:/nomarkdown} (כי הן בנות פחות מ-{::nomarkdown}\( k\){:/nomarkdown} צעדים) ולקבל {::nomarkdown}\( \left[q_{i},w_{i},B\right]\vdash^{*}\left[q_{i+1},\varepsilon,\varepsilon\right]\){:/nomarkdown}.

עכשיו נחבר את כל אלו כדי לקבל הוכחה לכך ש-{::nomarkdown}\( \left[q,w,A\right]\vdash^{*}\left[p,\varepsilon,\varepsilon\right]\){:/nomarkdown}:

{::nomarkdown}\( \left[q,w,A\right]=\left[q,\sigma w_{1}\cdots w_{n},A\right]\vdash\left[p,w_{1}\cdots w_{n},B_{1}\dots B_{n}\right]\vdash^{*}\){:/nomarkdown}

{::nomarkdown}\( \vdash^{*}\left[q_{2},w_{2}\cdots w_{n},B_{2}\cdots B_{n}\right]\vdash^{*}\left[q_{n},w_{n},B_{n}\right]\vdash^{*}\left[q_{n+1},\varepsilon,\varepsilon\right]\){:/nomarkdown}

וקיבלנו את המבוקש. זה מסיים את הכיוון הזה של ההוכחה.

הכיוון השני דומה באופיו אבל אני אנפנף בו קצת יותר בידיים. הפעם נתון לי {::nomarkdown}\( \left[q,w,A\right]\vdash^{*}\left[p,\varepsilon,\varepsilon\right]\){:/nomarkdown} ואני רוצה להוכיח ש-{::nomarkdown}\( \left(q,A,p\right)\Rightarrow^{*}w\){:/nomarkdown} - ושוב, אעשה זאת באינדוקציה, הפעם על אורך החישוב באוטומט. אם החישוב הוא בן צעד בודד, אז הצעד הזה חייב להיות מהצורה {::nomarkdown}\( \left(p,\varepsilon\right)\in\delta\left(q,\sigma,A\right)\){:/nomarkdown} (אחרת לא היה אפשר לרוקן את {::nomarkdown}\( A\){:/nomarkdown} מהמחסנית) ו-{::nomarkdown}\( w=\sigma\){:/nomarkdown}. מסקנה: בדקדוק שבנינו קיים הכלל {::nomarkdown}\( \left(q,A,p\right)\rightarrow\sigma\){:/nomarkdown} וקיבלנו ש-{::nomarkdown}\( \left(q,A,p\right)\Rightarrow^{*}\sigma=w\){:/nomarkdown}. יופי, זה היה קל.

עכשיו לצעד: נניח שהטענה נכונה לכל חישוב מאורך קטן מ-{::nomarkdown}\( k\){:/nomarkdown}. ונוכיח עבור חישוב באורך {::nomarkdown}\( k\){:/nomarkdown} כאשר {::nomarkdown}\( k\ge2\){:/nomarkdown}. אם {::nomarkdown}\( \left[q,w,A\right]\vdash^{k}\left[p,\varepsilon,\varepsilon\right]\){:/nomarkdown} אז נוח לפרק על פי הצעד הראשון, שחייב להיות כזה ש<strong>לא</strong> מרוקן את המחסנית (אחרת לא היה אחריו עוד צעד). כלומר, הצעד הראשון משתמש במעבר מהצורה {::nomarkdown}\( \left(q_{1},B_{1}B_{2}\dots B_{n}\right)\in\delta\left(q,\sigma,A\right)\){:/nomarkdown}, ולכן החישוב מתחיל כך: {::nomarkdown}\( \left[q,w,A\right]\vdash\left[q_{1},w^{\prime},B_{1}\cdots B_{n}\right]\){:/nomarkdown}, כאשר {::nomarkdown}\( w=\sigma w^{\prime}\){:/nomarkdown}. כאן מגיע נפנוף הידיים.

מה שאני אומר הוא זה: אני יודע שמהקונפיגורציה {::nomarkdown}\( \left[q_{1},w^{\prime},B_{1}\cdots B_{n}\right]\){:/nomarkdown} החישוב נמשך עד שהוא מסתיים בקונפיגורציה {::nomarkdown}\( \left[p,\varepsilon,\varepsilon\right]\){:/nomarkdown}. בפרט, המחסנית ריקה בסוף וסיימנו לקרוא את כל {::nomarkdown}\( w^{\prime}\){:/nomarkdown}. מכיוון שהמחסנית ריקה, היה חייב להיות רגע שבו {::nomarkdown}\( B_{2}\){:/nomarkdown} נחשף לראשונה (כלומר, בניסוח הלא פורמלי שהשתמשתי בו עד כה, רגע שבו "{::nomarkdown}\( B_{1}\){:/nomarkdown} מוסר מהמחסנית"). וכמו כן חייב להיות רגע שבו {::nomarkdown}\( B_{3}\){:/nomarkdown} נחשף, וכן הלאה, עד הרגע האחרון, שבו המחסנית מתרוקנת.

אם כן, אני אפרק את {::nomarkdown}\( w^{\prime}\){:/nomarkdown} בהתאם לרגעים הללו: {::nomarkdown}\( w_{1}\){:/nomarkdown} הוא כל מה שהאוטומט קרא עד לרגע שבו {::nomarkdown}\( B_{2}\){:/nomarkdown} נחשף, ו-{::nomarkdown}\( w_{2}\){:/nomarkdown} הוא כל מה שהאוטומט קרא עד לרגע שבו {::nomarkdown}\( B_{3}\){:/nomarkdown} נחשף, וכן הלאה. כמו כן, אני אקרא בשם {::nomarkdown}\( q_{2}\){:/nomarkdown} למצב שאליו מגיעים בדיוק כש-{::nomarkdown}\( B_{2}\){:/nomarkdown} נחשף, וכן הלאה. שימו לב לכך ש-{::nomarkdown}\( w^{\prime}=w_{1}\cdots w_{n}\){:/nomarkdown}.

אם כן, הסימונים שנתתי מתארים את הסיטואציה הבאה: {::nomarkdown}\( \left[q_{i},w_{i}w_{i+1}\cdots w_{n},B_{i}B_{i+1}\cdots B_{n}\right]\vdash^{*}\left[q_{i+1},w_{i+1}\cdots w_{n},B_{i+1}\cdots B_{n}\right]\){:/nomarkdown}. כעת לנפנוף הידיים האחרון: מכיוון שבחישוב הזה אין ל-{::nomarkdown}\( w_{i+1}\cdots w_{n}\){:/nomarkdown} שום השפעה (כי עוד לא הגענו לחלק הזה בקלט) וכמו כן גם ל-{::nomarkdown}\( B_{i+1}\cdots B_{n}\){:/nomarkdown} אין שום השפעה (כי האוטומט לא רואה אותם בשום שלב של החישוב - כאן קריטית לגמרי העובדה שאני מסיים את החלק הזה של החישוב בדיוק כאשר {::nomarkdown}\( B_{i+1}\){:/nomarkdown} נחשף <strong>לראשונה</strong>), הרי שאפשר פשוט להתעלם מהם - כלומר, מתקיים {::nomarkdown}\( \left[q_{i},w_{i},B_{i}\right]\vdash^{*}\left[q_{i+1},\varepsilon,\varepsilon\right]\){:/nomarkdown}. וזה מצויין עבורי, כי על הדבר הזה אפשר להשתמש בהנחת האינדוקציה - הוא מהצורה המתאימה (אני מסיים בקונפיגורציה שבה הקלט שנותר והמחסנית שניהם ריקים) והוא מתאר חישוב באורך קטן מ-{::nomarkdown}\( k\){:/nomarkdown} (כי הוא חלק מחישוב באורך {::nomarkdown}\( k\){:/nomarkdown} בלי הצעד הראשון של אותו חישוב). קיבלנו ש-{::nomarkdown}\( \left(q_{i},B_{i},q_{i+1}\right)\Rightarrow^{*}w_{i}\){:/nomarkdown} לכל {::nomarkdown}\( 1\le i\le n\){:/nomarkdown}.

כעת אפשר לסיים על ידי הצגת גזירה של {::nomarkdown}\( w\){:/nomarkdown}:

{::nomarkdown}\( \left(q,A,p\right)\Rightarrow\sigma\left(q_{1},B_{1},q_{2}\right)\cdots\left(q_{n},B_{n},q_{n+1}\right)\Rightarrow^{*}\sigma w_{1}w_{2}\cdots w_{n}=\sigma w^{\prime}=w\){:/nomarkdown}

וזה מסיים את הכיוון השני של ההוכחה, ואת ההוכחה כולה.

לסיכום, עכשיו יש לנו שתי דרכים שונות לתאר בהן שפות חסרות הקשר - או על ידי דקדוק, או על ידי אוטומט. באופן לא מפתיע, אני הולך להמשיך להשתמש בדקדוקים רוב הזמן כי זה יותר נוח, אבל פה ושם יש דברים שאוטומט יותר נוח עבורם וטוב שיש לנו בחירה. בפרט, כשאתם נתקלים בשפה ותוהים בינכם לבין עצמכם אם היא חסרת הקשר או לא (ולמי מאיתנו זה לא קרה?), הרבה פעמים במקום לנסות להמציא דקדוק עבור השפה נוח לחשוב בצורה "אלגוריתמית" על האופן שבו אוטומט מחסנית יקבל אותה.
