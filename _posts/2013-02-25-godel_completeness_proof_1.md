---
id: 2363
title: "משפט השלמות של גדל, ההוכחה (חלק א')"
date: 2013-02-25 22:52:55
layout: post
categories: 
  - לוגיקה
tags: 
  - לוגיקה מסדר ראשון
  - משפט השלמות של גדל
---
ב<a href="http://www.gadial.net/2013/02/23/first_order_logic_proof_system/">פוסט הקודם</a> הצגתי מערכת הוכחה ללוגיקה מסדר ראשון, והפעם אני רוצה להתחיל את ההוכחה שהמערכת הזו היא שלמה ונאותה. למעשה, אני הולך לדלג על הוכחת הנאותות כי די כיסיתי אותה בפוסט הקודם - שכנעתי אתכם (אני מקווה) שהאקסיומות של המערכת הן אמיתות לוגיות, ושכללי ההיסק משמרים נביעה לוגית, ומכאן ההוכחה היא שגרתית. אם כן, החלק המעניין פה הוא הוכחת השלמות. משפט השלמות הוכח במקור על ידי קורט גדל בשנת 1930 ולכן הוא נקרא "משפט השלמות של גדל" (עם זאת, ההוכחה שאראה היא לא של גדל אלא של הנקין מ-1949); צריך כמובן להיזהר ולא לבלבל את זה עם משפטי אי השלמות של גדל שהוכחו ב-1931 ומדברים על סוג שונה של שלמות. משפטי אי השלמות מדברים על אי-שלמות של <strong>תורות</strong>: על כך שאם קבוצה של פסוקים {::nomarkdown}\( \Phi\){:/nomarkdown} בלוגיקה מסדר ראשון מקיימת אי-אילו תכונות, אז קיים פסוק {::nomarkdown}\( \varphi\){:/nomarkdown}כך ש-{::nomarkdown}\( \Phi\not\vdash\varphi\){:/nomarkdown} וגם {::nomarkdown}\( \Phi\not\vdash\neg\varphi\){:/nomarkdown} - כלומר, {::nomarkdown}\( \Phi\){:/nomarkdown} לא מוכיחה לא אותו ואת שלילתו. משפט השלמות מדבר על שלמות של <strong>מערכת ההוכחה</strong>, והוא אומר שאם {::nomarkdown}\( \Phi\models\varphi\){:/nomarkdown} עבור {::nomarkdown}\( \Phi,\varphi\){:/nomarkdown} כלשהם, אז {::nomarkdown}\( \Phi\vdash\varphi\){:/nomarkdown} - כלומר, כל מה שנובע לוגית גם יכיח.

משטיפלנו בבלבול הזה אפשר לגשת לעבודה. בואו נתחיל בלהיזכר באופן שבו הוכחנו את משפט השלמות עבור תחשיב הפסוקים, כי הרעיון הבסיסי עדיין עובד גם כאן: הוכחנו טענה שנראית ממבט ראשון שונה לגמרי - שאם קבוצה {::nomarkdown}\( \Phi\){:/nomarkdown} היא עקבית, אז קיים לה מודל, כאשר "עקבית" פירושו שהיא אינה מוכיחה דבר והיפוכו. הטענה הזו גוררת מיידית את משפט השלמות באופן הבא: נניח כי {::nomarkdown}\( \Phi\models\varphi\){:/nomarkdown} ונניח בשלילה ש-{::nomarkdown}\( \Phi\cup\left\{ \neg\varphi\right\} \){:/nomarkdown} עקבית, אז קיים ל-{::nomarkdown}\( \Phi\cup\left\{ \neg\varphi\right\} \){:/nomarkdown} מודל {::nomarkdown}\( \mathcal{M}\){:/nomarkdown}, ובפרט {::nomarkdown}\( \mathcal{M}\models\Phi\){:/nomarkdown} ולכן {::nomarkdown}\( \mathcal{M}\models\varphi\){:/nomarkdown} (זו המשמעות של הטענה ש-{::nomarkdown}\( \varphi\){:/nomarkdown} נובע לוגית מ-{::nomarkdown}\( \Phi\){:/nomarkdown}). מצד שני, {::nomarkdown}\( \mathcal{M}\models\neg\varphi\){:/nomarkdown} וזו סתירה (בהינתן מודל ופסוק, ערך האמת של הפסוק נקבע בצורה יחידה והוא תמיד הפוך מזה של שלילתו). לכן נובע ש-{::nomarkdown}\( \Phi\cup\left\{ \neg\varphi\right\} \){:/nomarkdown} אינה עקבית, ומכך נובע ש-{::nomarkdown}\( \Phi\vdash\varphi\){:/nomarkdown}. את השלב האחרון ("משפט ההוכחה בדרך השלילה") הוכחתי עבור תחשיב הפסוקים וההוכחה תקפה באותה מידה גם בלוגיקה מסדר ראשון, עד כדי נקודה קטנה אך מהותית: המשפט הזה מתבסס על מה שנקרא <strong>משפט הדדוקציה</strong>, וההוכחה של משפט הדדוקציה ללוגיקה מסדר ראשון דורשת עוד טיפה עבודה.

משפט הדדוקציה אומר, כזכור, שאם {::nomarkdown}\( \Phi\cup\left\{ \alpha\right\} \vdash\beta\){:/nomarkdown} אז {::nomarkdown}\( \Phi\vdash\alpha\to\beta\){:/nomarkdown}. בתחשיב הפסוקים ראינו כיצד להוכיח זאת במקרה שבו {::nomarkdown}\( \beta\){:/nomarkdown} היא אקסיומה, הנחה מתוך {::nomarkdown}\( \Phi\){:/nomarkdown}, {::nomarkdown}\( \alpha\){:/nomarkdown} בעצמה, או מתקבלת על ידי MP מפסוקים שעבורם אנו כבר יודעים שמשפט הדדוקציה נכון. עם זאת, בלוגיקה מסדר ראשון צריך גם להתייחס למקרה שבו {::nomarkdown}\( \beta\){:/nomarkdown} מתקבלת מהפעלת GEN, כלומר {::nomarkdown}\( \beta=\forall x\gamma\){:/nomarkdown} כאשר {::nomarkdown}\( \gamma\){:/nomarkdown} כבר מקיימת את משפט הדדוקציה, כלומר {::nomarkdown}\( \Phi\vdash\alpha\to\gamma\){:/nomarkdown}.

אם כן, מה עושים? למרבה המזל, יש לנו תבנית אקסיומה שנבחרה בדיוק כדי להתמודד עם הסיטואציה הזו - תבנית אקסיומה מס' 5, {::nomarkdown}\( \forall x\left(\varphi\to\psi\right)\to\left(\varphi\to\forall x\psi\right)\){:/nomarkdown}. הדרישה של תבנית האקסיומה הזו היא ש-{::nomarkdown}\( x\){:/nomarkdown} לא יהיה משתנה חופשי ב-{::nomarkdown}\( \varphi\){:/nomarkdown}. במקרה שלנו {::nomarkdown}\( \varphi\){:/nomarkdown} הוא {::nomarkdown}\( \alpha\){:/nomarkdown}, והרי {::nomarkdown}\( \beta\){:/nomarkdown} מתקבל על ידי הוכחה מ-{::nomarkdown}\( \Phi\cup\left\{ \alpha\right\} \){:/nomarkdown} ודרשתי במפורש שאם GEN יופעל, אז זה יהיה רק עם משתנה שאינו מופיע חופשי ב-{::nomarkdown}\( \Phi\cup\left\{ \alpha\right\} \){:/nomarkdown}, ומכאן ש-{::nomarkdown}\( x\){:/nomarkdown} אינו חופשי ב-{::nomarkdown}\( \alpha\){:/nomarkdown}. לכן אפשר לכתוב את ההוכחה הפורמלית הבאה:
<ol>
	<li>{::nomarkdown}\( \alpha\to\gamma\){:/nomarkdown} (הנחה).</li>
	<li>{::nomarkdown}\( \forall x\left(\alpha\to\gamma\right)\){:/nomarkdown} (GEN על 1 עם משתנה שאינו מופיע חופשי ב-{::nomarkdown}\( \Phi\){:/nomarkdown})</li>
	<li>{::nomarkdown}\( \forall x\left(\alpha\to\gamma\right)\to\left(\alpha\to\forall x\gamma\right)\){:/nomarkdown} (תבנית אקסיומה 5).</li>
	<li>{::nomarkdown}\( \alpha\to\forall x\gamma\){:/nomarkdown} (MP על 2,3).</li>
</ol>
וקיבלנו בדיוק את {::nomarkdown}\( \alpha\to\beta\){:/nomarkdown} כפי שרצינו. זה מסיים את ההעברה של המשפטים מתחשיב הפסוקים ללוגיקה מסדר ראשון ומאפשר לנו להתמקד בעיקר.

אם כן, מעתה היעד שלנו הוא להוכיח שלקבוצה עקבית {::nomarkdown}\( \Phi\){:/nomarkdown} של פסוקים קיים מודל. בתחשיב הפסוקים "מודל" היה דבר פשוט למדי - השמה של ערכי אמת לכל המשתנים, וחסל. בלוגיקה מסדר ראשון מודל הוא עסק מסובך הרבה יותר - צריך להגדיר עולם שהוא קבוצה כלשהי של איברים, ולכל הסימנים במילון של {::nomarkdown}\( \Phi\){:/nomarkdown} צריך להתאים יחסים, פונקציות וקבועים מתוך העולם. על פניו בכלל לא ברור <strong>מאיפה</strong> אנחנו הולכים להמציא את העולם הזה. כאן נכנס לתמונה התעלול הראשון: האיברים של העולם שלנו יהיו (בערך - אני משקר כאן כרגע) הקבועים של המילון של {::nomarkdown}\( \Phi\){:/nomarkdown}. אלא שזה נשמע על פניו מטופש - מה אם במילון אין בכלל קבועים?

ובכן, בתחשיב הפסוקים האופן שבו התמודדנו עם בעיית ה"ממש לא ברור לי מאיפה להתחיל" היה לקחת את קבוצת הפסוקים שלנו ו<strong>להרחיב</strong> אותה כך שנקבל קבוצה שבה יהיה לנו מעט מאוד חופש פעולה - קבוצה כזו שאם קיים לה מודל, אז די ברור לנו איך הוא <strong>חייב</strong> להיראות. צמצום חופש הבחירה עזר לנו מאוד. אותו הדבר יקרה גם כאן - אנחנו ניקח את {::nomarkdown}\( \Phi\){:/nomarkdown} ונרחיב אותה, אבל גם ניקח אתצ {::nomarkdown}\( \tau\){:/nomarkdown}, המילון של {::nomarkdown}\( \Phi\){:/nomarkdown}, ונרחיב גם אותו על ידי הוספה של המון סימני קבועים. אחרי שנקבל את {::nomarkdown}\( \Phi\){:/nomarkdown} המורחבת מעל המילון המורחב כבר יהיה די ברור איך המודל חייב להיראות, וכל מה שיישאר הוא לטפל בפרטים הטכניים.

מה שנרצה לעשות הוא להרחיב את אוסף הקבועים של {::nomarkdown}\( \tau\){:/nomarkdown} ואת {::nomarkdown}\( \Phi\){:/nomarkdown} כך שהם יקיימו את התכונה הבאה: ש-{::nomarkdown}\( \Phi\){:/nomarkdown} המורחבת תוכל להוכיח שלכל נוסחה {::nomarkdown}\( \varphi\left(x\right)\){:/nomarkdown} עם משתנה חופשי יחיד {::nomarkdown}\( x\){:/nomarkdown}, אם {::nomarkdown}\( \exists x\varphi\left(x\right)\){:/nomarkdown} מתקיים אז קיים קבוע ש"מוכיח" את זה, כלומר יש קבוע {::nomarkdown}\( c\){:/nomarkdown} כך ש-{::nomarkdown}\( \varphi\left(c\right)\){:/nomarkdown} מתקיים. פורמלית אנו אומרים שקבוצת סימני קבועים {::nomarkdown}\( C\){:/nomarkdown} היא קבוצת <strong>עדים</strong> עבור {::nomarkdown}\( \Phi\){:/nomarkdown} אם לכל נוסחה {::nomarkdown}\( \varphi\left(x\right)\){:/nomarkdown} עם משתנה חופשי יחיד קיים {::nomarkdown}\( c\in C\){:/nomarkdown} כך שמתקיים

{::nomarkdown}\( \Phi\vdash\exists x\varphi\left(x\right)\to\varphi\left(c\right)\){:/nomarkdown}

כאן {::nomarkdown}\( \varphi\left(c\right)\){:/nomarkdown} פירושו מה שמקבלים כאשר מציבים ב-{::nomarkdown}\( \varphi\){:/nomarkdown} את הקבוע {::nomarkdown}\( c\){:/nomarkdown} במקום {::nomarkdown}\( x\){:/nomarkdown}.

אז כמו בתחשיב הפסוקים, יש לנו שני שלבים: שלב ההרחבה של {::nomarkdown}\( \Phi\){:/nomarkdown} ו-{::nomarkdown}\( \tau\){:/nomarkdown}, ושלב ההוכחה שלתורה המורחבת יש מודל. מכיוון שמודל לתורה המורחבת מעל המילון המורחב הוא עדיין מודל גם לתורה המקורית מעל המילון המקורי, זה יסיים את ההוכחה.

למרות שמבחינה מעשית שלב ההרחבה קודם לשלב בניית המודל, אני מעדיף לבצע אותם בסדר הפוך, מכיוון ששלב ההרחבה בעייתי יותר טכנית מסיבות שאתאר בהמשך, והרעיון היפה המרכזי בהוכחה נמצא בשלב בניית המודל. אם כן, אני מניח כרגע שנתונה לי תורה (קבוצת פסוקים עקבית) {::nomarkdown}\( \Phi\){:/nomarkdown} מעל מילון {::nomarkdown}\( \tau\){:/nomarkdown} כך שמתקיימות שתי התכונות הבאות:
<ol>
	<li>{::nomarkdown}\( \Phi\){:/nomarkdown} עקבית מקסימלית, במובן זה שהוספת כל פסוק ל-{::nomarkdown}\( \Phi\){:/nomarkdown} יהפוך את {::nomarkdown}\( \Phi\){:/nomarkdown} ללא-עקבית.</li>
	<li>קיימת קבוצת עדים {::nomarkdown}\( C\){:/nomarkdown} עבור {::nomarkdown}\( \Phi\){:/nomarkdown}, כלומר לכל נוסחה {::nomarkdown}\( \varphi\left(x\right)\){:/nomarkdown} עם משתנה חופשי יחיד {::nomarkdown}\( x\){:/nomarkdown} קיים קבוע {::nomarkdown}\( c\in C\){:/nomarkdown} כך ש-{::nomarkdown}\( \Phi\vdash\exists x\varphi\left(x\right)\to\varphi\left(c\right)\){:/nomarkdown}.</li>
</ol>
בואו נבנה ל-{::nomarkdown}\( \Phi\){:/nomarkdown} מודל {::nomarkdown}\( \mathcal{M}\){:/nomarkdown}. מודל כולל <strong>עולם</strong> שהוא קבוצה של איברים, ו<strong>פרשנויות</strong> לסימני היחס, הפונקציות והקבועים של {::nomarkdown}\( \tau\){:/nomarkdown}. הרעיון האינטואיטיבי הוא לעשות את הדבר הבא: להגדיר את העולם להיות שווה לקבוצת הקבועים של {::nomarkdown}\( \tau\){:/nomarkdown}, כלומר לקחת את האובייקט ה<strong>סינטקטי</strong> של סימני קבועים, ולהגדיר את המודל <strong>באמצעותו</strong>. אחר כך, בהינתן סימן יחס {::nomarkdown}\( R\left(x,y\right)\){:/nomarkdown} (נניח לצורך הדוגמה שהוא דו-מקומי) להגדיר יחס {::nomarkdown}\( R^{\mathcal{M}}\left(x,y\right)\){:/nomarkdown} במודל על ידי כך שלכל שני איברים {::nomarkdown}\( c,d\){:/nomarkdown} של העולם, {::nomarkdown}\( \left(c,d\right)\in R^{\mathcal{M}}\){:/nomarkdown} אם ורק אם הפסוק {::nomarkdown}\( R\left(c,d\right)\){:/nomarkdown} יכיח מתוך {::nomarkdown}\( \Phi\){:/nomarkdown}. זה הרעיון, והוא פשוט ומבריק ויפהפה. כמובן שהפרטים הטכניים קצת מסתבכים עכשיו.

ההוכחה מתפצלת כאן למעשה לשתי אפשרויות, בהתאם לשאלה אם הגדרנו לוגיקה מסדר ראשון עם סימן השוויון או בלעדיו. אני בחרתי להגדיר עם; כפי שנראה, זה גורם לנו לאי-אלו קשיים, אבל אסביר בהמשך אילו קשיים היו נוצרים אם הייתי בוחר לעבוד בלעדיו (זה היה מוביל לבניית מודל שמרגיש לי מלאכותי יותר).

אז נניח שאנחנו עובדים בלוגיקה עם סימן השוויון. הנה הבעיה - הביטו לרגע בפסוק {::nomarkdown}\( c=d\){:/nomarkdown} כאשר {::nomarkdown}\( c,d\){:/nomarkdown} הם שני איברים של {::nomarkdown}\( C\){:/nomarkdown}. נניח שהוא יכיח מתוך {::nomarkdown}\( \Phi\){:/nomarkdown} (וזה בהחלט יכול לקרות). פירוש הדבר הוא ש<strong>אסור</strong> לנו להגדיר את {::nomarkdown}\( c,d\){:/nomarkdown} בתור איברים שונים בעולם של {::nomarkdown}\( \mathcal{M}\){:/nomarkdown}, כי אז הפסוק {::nomarkdown}\( c=d\){:/nomarkdown} לא יהיה ספיק במודל הזה (ומכיוון שמערכת ההוכחה שלנו נאותה, ינבע מכך ש-{::nomarkdown}\( \mathcal{M}\){:/nomarkdown} אינו מודל של {::nomarkdown}\( \Phi\){:/nomarkdown}). הבעיה הזו מכריחה אותנו להגדיר את העולם של {::nomarkdown}\( \mathcal{M}\){:/nomarkdown} באופן קצת יותר מחוכם. מה שנעשה הוא להגדיר <strong>יחס שקילות</strong> על אברי {::nomarkdown}\( C\){:/nomarkdown}, כך ש-{::nomarkdown}\( c\equiv d\){:/nomarkdown} אם ורק אם {::nomarkdown}\( \Phi\vdash c=d\){:/nomarkdown}. כלומר, אנחנו אומרים שכל הקבועים של {::nomarkdown}\( C\){:/nomarkdown} ש-{::nomarkdown}\( \Phi\){:/nomarkdown} "מוכיחה שהם שווים" יהיו שקולים האחד לשני.

צריך להוכיח שהיחס הזה הוא אכן יחס שקילות. לצורך כך נצטרך להוכיח דברים על יחס השוויון, אז בואו ניזכר באקסיומות שהיו קשורות אליו והכנסנו למערכת ההוכחה שלנו:
<ol>
	<li>{::nomarkdown}\( x=x\){:/nomarkdown}</li>
	<li>{::nomarkdown}\( x=y\to t=s\){:/nomarkdown} כאשר {::nomarkdown}\( s\){:/nomarkdown} מתקבל מ-{::nomarkdown}\( t\){:/nomarkdown} על ידי החלפת מופע אחד או יותר של {::nomarkdown}\( x\){:/nomarkdown} ב-{::nomarkdown}\( y\){:/nomarkdown}.</li>
	<li>{::nomarkdown}\( x=y\to\left[\varphi\to\psi\right]\){:/nomarkdown} כאשר {::nomarkdown}\( \psi\){:/nomarkdown} מתקבל מ-{::nomarkdown}\( \varphi\){:/nomarkdown} על ידי החלפת מופע אחד או יותר של {::nomarkdown}\( x\){:/nomarkdown} ב-{::nomarkdown}\( y\){:/nomarkdown}.</li>
</ol>
בואו נתחיל. ראשית, אם {::nomarkdown}\( c\in C\){:/nomarkdown} כלשהו צריך להראות ש-{::nomarkdown}\( \Phi\vdash c=c\){:/nomarkdown}. הנה הוכחה פורמלית:
<ol>
	<li>{::nomarkdown}\( x=x\){:/nomarkdown} (אקסיומת שוויון מס' 1)</li>
	<li>{::nomarkdown}\( x=x\to c=c\){:/nomarkdown} (אקסיומת שוויון מס' 2 עם {::nomarkdown}\( t=s=c\){:/nomarkdown})</li>
	<li>{::nomarkdown}\( c=c\){:/nomarkdown} (MP על 1,2).</li>
</ol>
עכשיו, אם {::nomarkdown}\( c,d\in C\){:/nomarkdown} הם איברים כלשהם כך ש-{::nomarkdown}\( \Phi\vdash c=d\){:/nomarkdown} צריך להוכיח שגם {::nomarkdown}\( \Phi\vdash d=c\){:/nomarkdown}:
<ol>
	<li>{::nomarkdown}\( x=y\to\left(x=x\to y=x\right)\){:/nomarkdown} (אקסיומת שוויון מס' 3 עם {::nomarkdown}\( \varphi=\left(x=x\right)\){:/nomarkdown} ו-{::nomarkdown}\( \psi=\left(y=x\right)\){:/nomarkdown}).</li>
	<li>{::nomarkdown}\( \forall x\forall y\left(x=y\right)\to\left(x=x\to y=x\right)\){:/nomarkdown} (Gen על 1).</li>
	<li>{::nomarkdown}\( \left[\forall x\forall y\left(x=y\right)\to\left(x=x\to y=x\right)\right]\to\left[\left(c=d\right)\to\left(c=c\to d=c\right)\right]\){:/nomarkdown} (תבנית אקסיומה 4)</li>
	<li>{::nomarkdown}\( c=d\to\left(c=c\to d=c\right)\){:/nomarkdown} (MP על 2,3).</li>
	<li>{::nomarkdown}\( c=d\){:/nomarkdown} (יכיח מ-{::nomarkdown}\( \Phi\){:/nomarkdown}).</li>
	<li>{::nomarkdown}\( c=c\to d=c\){:/nomarkdown} (MP על 4,5).</li>
	<li>{::nomarkdown}\( c=c\){:/nomarkdown} (יכיח מ-{::nomarkdown}\( \Phi\){:/nomarkdown}).</li>
	<li>{::nomarkdown}\( d=c\){:/nomarkdown} (MP על 6,7).</li>
</ol>
זה היה מבעית למדי, מה שמעלה את החשש שהוכחת טרנזיטיביות תהיה גרועה עוד יותר. נניח ש-{::nomarkdown}\( c,d,e\in C\){:/nomarkdown} מקיימים {::nomarkdown}\( \Phi\vdash c=d\){:/nomarkdown} וגם {::nomarkdown}\( \Phi\vdash d=e\){:/nomarkdown}, אז צריך להוכיח ש-{::nomarkdown}\( \Phi\vdash c=e\){:/nomarkdown}. כפי שאולי הבנתם מההוכחה הקודמת, מספיק להוכיח ש-{::nomarkdown}\( x=y\to\left(y=z\to x=z\right)\){:/nomarkdown} כדי לסיים, אבל זו הרי בדיוק אקסיומת שוויון מס' 3 עם {::nomarkdown}\( \varphi=\left(x=z\right)\){:/nomarkdown} ו-{::nomarkdown}\( \psi=\left(y=z\right)\){:/nomarkdown}, כך שאחסוך מכם את המשך ההוכחה המפלצתית. זה מוכיח לנו שהיחס שהגדרתי לעיל הוא אכן יחס שקילות, ולכן אפשר לדבר על <strong>מחלקות השקילות</strong> שלו. כזכור, אם {::nomarkdown}\( c\in C\){:/nomarkdown} הוא איבר כלשהו, אז מסמנים {::nomarkdown}\( \left[c\right]=\left\{ d\in C\ \|\ c\equiv d\right\} \){:/nomarkdown}. הקבוצה {::nomarkdown}\( \left[c\right]\){:/nomarkdown} נקראת <strong>מחלקת השקילות</strong> של {::nomarkdown}\( c\){:/nomarkdown} ולא קשה לראות ש-{::nomarkdown}\( C\){:/nomarkdown} מתפרקת לאיחוד זר של מחלקות שקילות של איברים בה.

כעת אפשר להתחיל את הגדרת המודל {::nomarkdown}\( \mathcal{M}\){:/nomarkdown}. ראשית נגדיר את העולם שלו: {::nomarkdown}\( D^{\mathcal{M}}=\left\{ \left[c\right]\ \|\ c\in C\right\} \){:/nomarkdown}. כעת נותר לתת פרשנויות לסימני היחס, הקבועים והפונקציות.

נתחיל מסימני היחס. יהא {::nomarkdown}\( R\left(x_{1},\dots,x_{n}\right)\in\tau\){:/nomarkdown} סימן יחס {::nomarkdown}\( n\){:/nomarkdown}-מקומי. נגדיר יחס {::nomarkdown}\( R^{\mathcal{M}}\subseteq\left(D^{\mathcal{M}}\right)^{n}\){:/nomarkdown} באופן הבא: לכל {::nomarkdown}\( c_{1},\dots,c_{n}\in C\){:/nomarkdown}, {::nomarkdown}\( \left(\left[c_{1}\right],\dots,\left[c_{n}\right]\right)\in R^{\mathcal{M}}\){:/nomarkdown} אם ורק אם {::nomarkdown}\( \Phi\vdash R\left(c_{1},\dots,c_{n}\right)\){:/nomarkdown}. זו הגדרה שנראית הגיונית, אבל כמו כל הגדרה שמערבת מחלקות שקילות, יש סכנה שהיא <strong>לא מוגדרת היטב</strong>. למה הכוונה? ייתכן שיש {::nomarkdown}\( d_{1},\dots,d_{n}\in C\){:/nomarkdown} כך ש-{::nomarkdown}\( \left[c_{i}\right]=\left[d_{i}\right]\){:/nomarkdown} (כלומר, מחלקת השקילות של {::nomarkdown}\( c_{i}\){:/nomarkdown} ו-{::nomarkdown}\( d_{i}\){:/nomarkdown} זהות, לכל {::nomarkdown}\( 1\le i\le n\){:/nomarkdown}) ועם זאת {::nomarkdown}\( \Phi\vdash R\left(c_{1},\dots,c_{n}\right)\){:/nomarkdown} אבל {::nomarkdown}\( \Phi\not\vdash R\left(d_{1},\dots,d_{n}\right)\){:/nomarkdown}, מה שאומר שההחלטה אם {::nomarkdown}\( \left(\left[c_{1}\right],\dots,\left[c_{n}\right]\right)\in R^{\mathcal{M}}\){:/nomarkdown} אינה תלויה במחלקות השקילות בלבד אלא ממש ב<strong>נציגים</strong> שאנחנו בוחרים להן, ואסור לנו לעשות את זה - אנחנו חייבים לקבוע באופן חד משמעי עבור כל מחלקת שקילות מה יקרה איתה.

במקרה שלנו אין בעיה אמיתית שכזו. נניח ש-{::nomarkdown}\( \Phi\vdash R\left(c_{1},\dots,c_{n}\right)\){:/nomarkdown} וכמו כן ש-{::nomarkdown}\( c_{1}\equiv d_{1}\){:/nomarkdown}, כלומר {::nomarkdown}\( \Phi\vdash c_{1}=d_{1}\){:/nomarkdown}. אז מהאקסיומה {::nomarkdown}\( x=y\to R\left(x,c_{2},\dots,c_{n}\right)=R\left(y,c_{2},\dots,c_{n}\right)\){:/nomarkdown} אפשר לקבל חיש קל ש-{::nomarkdown}\( \Phi\vdash R\left(d_{1},\dots,c_{n}\right)\){:/nomarkdown} וכך להחליף בהדרגתיות את כל ה-{::nomarkdown}\( c\){:/nomarkdown}-ים ב-{::nomarkdown}\( d\){:/nomarkdown}-ים. עם זאת, חשוב היה לי להדגיש שזו נקודה שיש לשים לב אליה במהלך ההגדרה, וזה חלק מהסיבוך הנוסף שנגרם לנו מכך שהלוגיקה מסדר ראשון שלנו כוללת שוויון.

נעבור לקבועים. מפתה להגיד שלכל סימן קבוע {::nomarkdown}\( c\in\tau\){:/nomarkdown}, נגדיר את הפרשנות שלו להיות {::nomarkdown}\( c^{\mathcal{M}}=\left[c\right]\){:/nomarkdown}, וזה אכן הרעיון הכללי, אבל זה <strong>לא מספיק</strong>. הבעיה היא שאולי יש סימני קבועים שבכלל לא שייכים ל-{::nomarkdown}\( C\){:/nomarkdown}. הפואנטה היא שגם במקרה זה, הפרשנות שנותנים לסימנים הללו <strong>חייבת</strong> להיות זהה לפרשנות שנותנים לפחות לאחד מהקבועים. למה? או, זו הזדמנות לראות את עניין ה"{::nomarkdown}\( C\){:/nomarkdown} היא קבוצת עדים" בפעולה.

נניח ש-{::nomarkdown}\( d\in\tau\){:/nomarkdown} הוא סימן קבוע כלשהו. אז אנחנו יודעים שהפסוק הבא הוא אמת לוגית: {::nomarkdown}\( \exists x\left(x=d\right)\){:/nomarkdown}. עכשיו, {::nomarkdown}\( \Phi\){:/nomarkdown} היא קבוצה עקבית מקסימלית, מה שאומר (ואת זה אנחנו יודעים עוד מתחשיב הפסוקים) שלכל פסוק היא מוכיחה אותו או את שלילתו (אחרת היה אפשר להוסיף את הפסוק אליה ולקבל קבוצה גדולה יותר שעדיין עקבית). בגלל נאותות מערכת ההוכחה לא ייתכן שהיא תוכיח דבר שהוא סתירה לוגית, ולכן {::nomarkdown}\( \Phi\vdash\exists x\left(x=d\right)\){:/nomarkdown}, ומכיוון ש-{::nomarkdown}\( C\){:/nomarkdown} היא קבוצת עדים, אז קיים {::nomarkdown}\( c\in C\){:/nomarkdown} כך ש-{::nomarkdown}\( \Phi\vdash\exists x\left(x=d\right)\to\left(c=d\right)\){:/nomarkdown}, ומשילוב שני אלו נקבל ש-{::nomarkdown}\( \Phi\vdash c=d\){:/nomarkdown}, וקיבלנו את מה שצריכה להיות הפרשנות של {::nomarkdown}\( d\){:/nomarkdown}: {::nomarkdown}\( d^{\mathcal{M}}=\left[c\right]\){:/nomarkdown}. גם כאן, התהליך היה מוגדר היטב: אם במקום {::nomarkdown}\( c\){:/nomarkdown} היינו מוצאים עד אחר, היינו מקבלים גם עבורו שהוא שווה ל-{::nomarkdown}\( d\){:/nomarkdown} ומהטרנזיטיביות שכבר ראינו של השוויון היינו מקבלים ש-{::nomarkdown}\( \Phi\){:/nomarkdown} מוכיחה את הפסוק שאומר ששני העדים שווים ולכן מחלקת השקילות שלהם שווה.

בפונקציות מטפלים באופן דומה. אם {::nomarkdown}\( f\left(x_{1},\dots,x_{n}\right)\in\tau\){:/nomarkdown} הוא סימן פונקציה {::nomarkdown}\( n\){:/nomarkdown} מקומי, ואנחנו צריכים להגדיר את {::nomarkdown}\( f^{\mathcal{M}}\left(\left[c_{1}\right],\dots,\left[c_{n}\right]\right)\){:/nomarkdown} אז נתבונן בפסוק {::nomarkdown}\( \exists x\left(f\left(c_{1},\dots,c_{n}\right)=x\right)\){:/nomarkdown}, ניקח עד {::nomarkdown}\( c\){:/nomarkdown} עבורו ונגדיר {::nomarkdown}\( f^{\mathcal{M}}\left(\left[c_{1}\right],\dots,\left[c_{n}\right]\right)=\left[c\right]\){:/nomarkdown}. גם פה צריך להוכיח שהכל מוגדר היטב אבל נדמה לי שכבר הבנתם את הרעיון. זה מסיים את הגדרת המודל {::nomarkdown}\( \mathcal{M}\){:/nomarkdown}.

כמובן שהגדרת המודל היא רק חלק מהעבודה, עכשיו צריך גם להוכיח שהמודל "עובד", כלומר שהוא מספק כל פסוק ב-{::nomarkdown}\( \Phi\){:/nomarkdown}. איך נראים פסוקים באופן כללי? ובכן, פסוק הוא נוסחה שאין בה משתנים חופשיים. אז אפשר להתחיל מנוסחאות שאין בהן משתנים בכלל - כל שמות העצם שמופיעים בהן מורכבים רק מקבועים וסימני פונקציות. פסוק בסיסי מסוג זה חייב לכלול יחס (שם עצם לבדו אינו פסוק; פסוק מורכב מיחסים על שמות עצם, שמעורבבים האחד עם השני עם קשרים וכמתים). אז ראשית כל יש לנו פסוקים מהצורה

{::nomarkdown}\( t_{1}=t_{2}\in\Phi\){:/nomarkdown}

כאשר {::nomarkdown}\( t_{1},t_{2}\){:/nomarkdown} שמות עצם שאינם כוללים משתנים. אנחנו רוצים לחשב את הערך של שני שמות העצם הללו במודל ולראות שהוא זהה. לא ממש ברור איך לעשות את זה באופן ישיר, אבל קל לעשות את זה באופן עקיף: נסתכל על הפסוק {::nomarkdown}\( \exists x\left(t_{1}=x\right)\){:/nomarkdown} ונקבל, כרגיל, שיש {::nomarkdown}\( c\in C\){:/nomarkdown} כך ש-{::nomarkdown}\( t_{1}=c\in\Phi\){:/nomarkdown}. בדומה נקבל ש-{::nomarkdown}\( t_{2}=d\in\Phi\){:/nomarkdown} עבור {::nomarkdown}\( d\in C\){:/nomarkdown} כלשהו, וכבר ראינו שאפשר להוכיח טרנזיטיביות, כלומר ש-{::nomarkdown}\( c=d\in\Phi\){:/nomarkdown} ולכן {::nomarkdown}\( \left[c\right]=\left[d\right]\){:/nomarkdown} וזהו הערך שהמודל מעניק לשני שמות העצם {::nomarkdown}\( t_{1},t_{2}\){:/nomarkdown} כך שבמקרה הזה טיפלנו.

כעת, הסוג הנוסף של פסוק בסיסי הוא פסוק מהצורה

{::nomarkdown}\( R\left(t_{1},\dots,t_{n}\right)\in\Phi\){:/nomarkdown}

כאשר {::nomarkdown}\( R\){:/nomarkdown} סימן יחס כלשהו ו-{::nomarkdown}\( t_{1},\dots,t_{n}\){:/nomarkdown} שמות עצם כלשהם שאינם כוללים משתנים. כמקודם, מוצאים {::nomarkdown}\( c_{1},\dots,c_{n}\){:/nomarkdown} כך ש-{::nomarkdown}\( t_{i}=c_{i}\in\Phi\){:/nomarkdown} ומכאן נוכל להוכיח ש-{::nomarkdown}\( R\left(c_{1},\dots,c_{n}\right)\in\Phi\){:/nomarkdown}, מה שיגרור ש-{::nomarkdown}\( \left(\left[c_{1}\right],\dots,\left[c_{n}\right]\right)\in R^{\mathcal{M}}\){:/nomarkdown}, מה שמסיים את המקרה הזה. כדאי לשים לב שבגלל ש-{::nomarkdown}\( \Phi\){:/nomarkdown} עקבית מקסימלית הרי שבשני המקרים הוכחנו יותר מאשר את מה שרצינו - הוכחנו גם שאם {::nomarkdown}\( t_{1}=t_{2}\notin\Phi\){:/nomarkdown} אז הערכים שהמודל מעניק לשמות העצם הללו שונים (אחרת אפשר היה להוסיף את {::nomarkdown}\( t_{1}=t_{2}\){:/nomarkdown} ל-{::nomarkdown}\( \Phi\){:/nomarkdown} מבלי לפגוע בעקביות) וכך גם עבור ה-{::nomarkdown}\( R\){:/nomarkdown}-ים. זה יועיל לנו בהמשך.

כעת אפשר להמשיך באינדוקציה על מבנה יתר הפסוקים הקיימים. לכל פסוק {::nomarkdown}\( \varphi\){:/nomarkdown} נרצה להראות ש-{::nomarkdown}\( \mathcal{M}\models\varphi\){:/nomarkdown} אם ורק אם {::nomarkdown}\( \varphi\in\Phi\){:/nomarkdown}. נתחיל עם פסוקים מהצורה {::nomarkdown}\( \neg\varphi\){:/nomarkdown} כאשר {::nomarkdown}\( \varphi\){:/nomarkdown} הוא פסוק שעליו כבר הוכחנו את הטענה. אז מכיוון ש-{::nomarkdown}\( \Phi\){:/nomarkdown} עקבית מקסימלית, {::nomarkdown}\( \neg\varphi\in\Phi\){:/nomarkdown} אם ורק אם {::nomarkdown}\( \varphi\notin\Phi\){:/nomarkdown} אם ורק אם {::nomarkdown}\( \mathcal{M}\not\models\varphi\){:/nomarkdown}, אם ורק אם {::nomarkdown}\( \mathcal{M}\models\varphi\){:/nomarkdown}. זה היה קל.

עבור פסוק מהצורה {::nomarkdown}\( \varphi\to\psi\){:/nomarkdown} הנימוק ארוך יותר אבל לא באמת מסובך יותר. מכיוון שלמשהו כמו {::nomarkdown}\( \varphi\to\psi\){:/nomarkdown} יש רק השמה לא מספקת אחת, יהיה קל יותר להוכיח ש-{::nomarkdown}\( \varphi\to\psi\notin\Phi\){:/nomarkdown} אם ורק אם {::nomarkdown}\( \mathcal{M}\models\varphi\){:/nomarkdown} וגם {::nomarkdown}\( \mathcal{M}\not\models\psi\){:/nomarkdown}. אם כן, {::nomarkdown}\( \varphi\to\psi\notin\Phi\){:/nomarkdown} אם ורק אם {::nomarkdown}\( \neg\left(\varphi\to\psi\right)\in\Phi\){:/nomarkdown}. כעת, תעלול: הבה ונסתכל על הפסוקים {::nomarkdown}\( \neg\left(\varphi\to\psi\right)\to\varphi\){:/nomarkdown} ו-{::nomarkdown}\( \neg\left(\varphi\to\psi\right)\to\neg\psi\){:/nomarkdown}. בדיקה ישירה תראה לנו שהם טאוטולוגיות, ולכן יכיחים מ-{::nomarkdown}\( \Phi\){:/nomarkdown} בלי הנחות כלל, רק על ידי אקסיומות 1-3 ו-MP. לכן נקבל ש-{::nomarkdown}\( \Phi\vdash\varphi\){:/nomarkdown} ו-{::nomarkdown}\( \Phi\vdash\neg\psi\){:/nomarkdown}, מה שקורה אם ורק אם {::nomarkdown}\( \mathcal{M}\models\varphi\){:/nomarkdown} וגם {::nomarkdown}\( \mathcal{M}\not\models\psi\){:/nomarkdown}, כנדרש.

מה נותרו? כמתים. יהיה יותר פשוט רעיונית לטפל ב-{::nomarkdown}\( \exists\){:/nomarkdown}; הטיפול ב-{::nomarkdown}\( \forall\){:/nomarkdown} יהיה זהה מכיוון ש-{::nomarkdown}\( \exists x\varphi\left(x\right)\){:/nomarkdown} שקול לפסוק {::nomarkdown}\( \neg\forall x\neg\varphi\left(x\right)\){:/nomarkdown}.

אם כן, נוכיח ש-{::nomarkdown}\( \exists x\varphi\left(x\right)\in\Phi\){:/nomarkdown} אם ורק אם {::nomarkdown}\( \mathcal{M}\models\exists x\varphi\left(x\right)\){:/nomarkdown}. הבעיה היא ש-{::nomarkdown}\( \varphi\left(x\right)\){:/nomarkdown} הוא לא פסוק, כי {::nomarkdown}\( x\){:/nomarkdown} חופשי בו, ולכן אי אפשר להשתמש עליו בהנחת האינדוקציה והכל קורס, <strong>אלמלא</strong> היה לנו את התכונה המוזרה והכל כך לא ברורה במבט ראשון של "עד להוכחה". בגלל ש-{::nomarkdown}\( C\){:/nomarkdown} היא קבוצת עדים, אז קיים קבוע {::nomarkdown}\( c\){:/nomarkdown} כך ש-{::nomarkdown}\( \Phi\vdash\exists x\varphi\left(x\right)\to\varphi\left(c\right)\){:/nomarkdown}, ולכן {::nomarkdown}\( \varphi\left(c\right)\in\Phi\){:/nomarkdown} ו-{::nomarkdown}\( \varphi\left(c\right)\){:/nomarkdown} הוא פסוק כך שהנחת האינדוקציה פועלת עליו, ו-{::nomarkdown}\( \mathcal{M}\models\varphi\left(c\right)\){:/nomarkdown}, כלומר {::nomarkdown}\( \mathcal{M}\models\exists x\varphi\left(x\right)\){:/nomarkdown} (פורמלית: אם {::nomarkdown}\( z\){:/nomarkdown} היא השמה כלשהי, אז {::nomarkdown}\( \mathcal{M}\models_{z\left[x\leftarrow\left[c\right]\right]}\varphi\left(x\right)\){:/nomarkdown} ולכן {::nomarkdown}\( \mathcal{M}\models_{z}\exists x\varphi\left(x\right)\){:/nomarkdown}). הטיעון עובד באותו האופן בכיוון השני עד שמגיעים לכך ש-{::nomarkdown}\( \varphi\left(c\right)\in\Phi\){:/nomarkdown} ורוצים להסיק מכך ש-{::nomarkdown}\( \exists x\varphi\left(x\right)\in\Phi\){:/nomarkdown}; את זה עושים באמצעות הפסוק {::nomarkdown}\( \varphi\left(c\right)\to\exists x\varphi\left(x\right)\){:/nomarkdown} שיכיח מ-{::nomarkdown}\( \Phi\){:/nomarkdown}. אם אתם תוהים למה הוא יכיח, הנה הוכחה פורמלית:
<ol>
	<li>{::nomarkdown}\( \forall x\neg\varphi\left(x\right)\to\neg\varphi\left(c\right)\){:/nomarkdown} (תבנית אקסיומה 4).</li>
	<li>{::nomarkdown}\( \left[\forall x\neg\varphi\left(x\right)\to\neg\varphi\left(c\right)\right]\to\left[\neg\neg\varphi\left(c\right)\to\neg\forall x\neg\varphi\left(x\right)\right]\){:/nomarkdown} (תבנית אקסיומה 3).</li>
	<li>{::nomarkdown}\( \neg\neg\varphi\left(c\right)\to\neg\forall x\neg\varphi\left(x\right)\){:/nomarkdown} (MP על 1,2).</li>
	<li>{::nomarkdown}\( \neg\neg\varphi\left(c\right)\to\exists x\varphi\left(x\right)\){:/nomarkdown} (סתם שינוי סימון שיהיה קריא).</li>
	<li>{::nomarkdown}\( \left[\neg\neg\varphi\left(c\right)\to\exists x\varphi\left(x\right)\right]\to\left[\varphi\left(c\right)\to\exists x\varphi\left(x\right)\right]\){:/nomarkdown} (טאוטולוגיה של תחשיב הפסוקים: {::nomarkdown}\( \left(\neg\neg A\to B\right)\to\left(A\to B\right)\){:/nomarkdown}).</li>
	<li>{::nomarkdown}\( \varphi\left(c\right)\to\exists x\varphi\left(x\right)\){:/nomarkdown} (MP על 4,5).</li>
</ol>
וזה <strong>מסיים את ההוכחה</strong>! רק שכמובן, זה לא מסיים את הוכחת משפט השלמות של גדל; זה מסיים את ההוכחה לכך שאם יש לנו תורה {::nomarkdown}\( \Phi\){:/nomarkdown} שהיא עקבית מקסימלית וקיימת לה קבוצת עדים, אז יש לה מודל. עוד נשאר לנו להוכיח שכל תורה עקבית אפשר להרחיב לתורה שכזו, ואת זה נעשה בפוסט הבא.

כעת אפשר לחשוב על האופן שבו ההוכחה מתקלקלת (או הופכת לפשוטה יותר) אם שוויון הוא לא חלק מהלוגיקה שלנו. כדאי להעיר שאנחנו <strong>רוצים</strong> שוויון בלוגיקה שלנו מהרבה סיבות ולכן גם אם הוספת שוויון רק מקשה עלינו חבל לוותר עליו. עדיין, מבחינה רעיונית אולי פשוט יותר להציג קודם כל את ההוכחה עבור לוגיקה ללא שוויון כדי להימנע מיחסי שקילות ואקשן שכזה; מצד שני, במקרה הזה לא מספיק לבנות את המודל מתוך הקבועים של {::nomarkdown}\( C\){:/nomarkdown} - <strong>כל שם עצם</strong> של השפה שלנו יהיה חייב להיות איבר בעולם של המודל. לי זה מרגיש מעט יותר מלאכותי, כאמור, אבל כל אחד ואיך שנוח לו. גם כך וגם כך הרעיון הזה, של בניה של המודל (האובייקט הסמנטי) מתוך השפה עצמה (האובייקט הסינטקטי) הוא אחד מהרעיונות החביבים עלי במתמטיקה.
