---
id: 980
title: "מעגלים בוליאניים - מה זה בכלל?"
date: 2011-01-18 16:07:00
layout: post
categories: 
  - תורת הסיבוכיות
tags: 
  - מודלים חישוביים
  - מעגלים בוליאניים
  - פרוייקט "תוצאות מפתיעות בסיבוכיות"
  - שאלת P=NP
  - תורת הסיבוכיות
---
אני מתחיל את פרוייקט "<a href="http://www.gadial.net/?p=914">תוצאות מפתיעות בסיבוכיות</a>" עם תיאור של משפט ברינגטון, שכמו רוב המשפטים בסיבוכיות הוא יחסי - אומר ששתי מחלקות סיבוכיות בעלות הגדרה שונה הן זהות - ועל כן נשמע לקורא מבחוץ כמו "ג'יבריש ג'יבריש בלה בלה שווה לבלה בלה ג'יבריש ג'יבריש". אין מנוס, לפני שמציגים את המשפט, להציג את מחלקות הסיבוכיות המתאימות ולמה הן מעניינות. מילת אזהרה כללית: למרות שאני מייעד את הפוסטים הללו לכל קוראי הבלוג, אני בהחלט עשוי לזרוק פה ושם מושגים שנראים לי ברורים ולקורא לא. במקרה כזה אפשר לשאול שאלה בתגובות, אפשר לחפש בפוסטים ישנים יותר בבלוג, ואפילו להיעזר בויקיפדיה.

באופן כללי, <strong>מחלקת סיבוכיות</strong> היא אוסף של פונקציות שניתן לחשב בעזרת מודל חישובי מסויים שעל כמות המשאבים שלו יש מגבלה כלשהי. המודל הקלאסי נקרא <a href="http://www.gadial.net/?p=62">מכונת טיורינג</a> והמגבלה הקלאסית עליו היא זמן ריצה פולינומי (שניתן לחסום על ידי פולינום). אנחנו לא הולכים לדבר על המודל הזה. הפעם אני הולך לדבר על מודל שונה למדי - <strong>מעגלים בוליאניים</strong> (Boolean Circuits).

ראשית, המטרה שלנו. אנחנו הולכים לדבר רק על פונקציות בוליאניות - כאלו שמקבלות קלט שהוא סדרה של 0 ו-1, ומוציאות פלט שהוא ביט בודד - או 0 או 1. פורמלית, {::nomarkdown}\( f:\left\{ 0,1\right\} ^{n}\to\left\{ 0,1\right\} \){:/nomarkdown}. בהקשר של מדעי המחשב מספיק לדבר על פונקציות כאלו כי כל פונקציה אחרת שניתן לחשב במחשב ניתנת לתיאור באמצעות פונקציות בוליאניות. על ערכים בוליאניים אוהבים להגדיר פעולות של "וגם" ו"או", מתוך מחשבה על ערך 1 כמייצג "אמת" וערך 0 כמייצג "שקר". אם {::nomarkdown}\( x,y\){:/nomarkdown} הם שני ביטים, אז {::nomarkdown}\( x\wedge y\){:/nomarkdown} ({::nomarkdown}\( x\){:/nomarkdown} וגם {::nomarkdown}\( y\){:/nomarkdown}) הוא 1 אם ורק אם {::nomarkdown}\( x=y=1\){:/nomarkdown}, אחרת הוא 0; ואילו {::nomarkdown}\( x\vee y\){:/nomarkdown} ({::nomarkdown}\( x\){:/nomarkdown} או {::nomarkdown}\( y\){:/nomarkdown}) הוא 0 אם ורק אם {::nomarkdown}\( x=y=0\){:/nomarkdown} ואחרת הוא 1. ה"או" הזה קצת שונה מהמשמעות שלו בחיי היום יום, כי הוא יכול לקבל "אמת" גם אם שני המשתנים קיבלו "אמת" ("או שאלך לים או שאקרא ספר" נשמע כאילו הוא אומר "אעשה אחד משני אלו אך לא את שניהם בו זמנית"). יש אופרטור אחר, Exclusive Or, או בשמו המקוצר XOR, ובסימון {::nomarkdown}\( x\oplus y\){:/nomarkdown}, שמקבל 1 אם ורק אם בדיוק אחד משני המשתנים מכיל 1, שממדל את ה"או" היומיומי. כמו כן יש אופרטור שלילה שפועל רק על משתנה יחיד: {::nomarkdown}\( \neg x\){:/nomarkdown} הוא 1 אם ורק אם {::nomarkdown}\( x\){:/nomarkdown} היה 0.

אלו פונקציות בסיסיות, אבל אפשר להגדיר פונקציות מורכבות יותר על הרבה יותר ביטים. החל ממשהו מטופש כמו {::nomarkdown}\( f\left(x_{1},\dots,x_{n}\right)=\bigwedge x_{i}\){:/nomarkdown} שמקבל 1 אם ורק אם כל {::nomarkdown}\( n\){:/nomarkdown} הקלטים הם 1, עבור בדברים יותר מתוחכמים כמו {::nomarkdown}\( \mbox{MAJORITY}\left(x_{1},\dots,x_{n}\right)\){:/nomarkdown} שמקבלת 1 אם ורק אם רוב הביטים בקלט הם 1, וכלה בדברים ממש מתוחכמים כמו הפונקציה שמוציאה 1 רק אם הביטים של הקלט שלה, כשמפרשים אותם על ידי קידוד כלשהו בתור גרף, מייצגים גרף שמכיל מעגל המילטוני. למעשה, אפשר לכמת ולהגיד בדיוק כמה פונקציות יש מ-{::nomarkdown}\( n\){:/nomarkdown} ביטים אל שני ביטים: {::nomarkdown}\( 2^{2^{n}}\){:/nomarkdown}. כבר עבור ערכים לא גדולים של {::nomarkdown}\( n\){:/nomarkdown} המספר הזה הוא עצום - יש עושר רב של פונקציות בינאריות. השאלה שאנו שואלים את עצמנו היא - אילו פונקציות ניתן לתאר באמצעות שימוש בפונקציות בסיסיות ופשוטות בלבד, ובאופן חסכוני במשאבים?

כאן נכנסים המעגלים הבוליאניים לתמונה. ההשראה לשימוש בהם בתורת הסיבוכיות הכל כך תיאורטית הגיעה ישירות מהשימוש בהם כדי לתאר (מודל מופשט של) חומרה. שערים לוגיים הם הבסיס למחשב אמיתי; אם כן, למה לא להשתמש בהם כדי לתאר חישובים? כתמיד בתורת הסיבוכיות, צריך לזכור מה המטרה שלנו. היא איננה להציג מעגלים לחישוב של כל מני פונקציות מגניבות - כשמדעני מחשב מנסים <strong>לפתור</strong> בעיה הם עושים את זה תמיד במודל מופשט ככל העניין, ורק בסוף מתחילים לשאול את עצמם האם ניתן "לתרגם" את הפתרון למודלים פשוטים וקונקרטיים יותר - המטרה היא בדיוק ההפך, להראות ש<strong>אי אפשר</strong> לפתור בעיות מסויימות. שהמודל של מעגלים בוליאניים הוא חלש במידה מסויימת, וכפועל יוצא מכך - שיש בעיות שהן קשות <strong>אינהרנטית</strong>, ובאף מודל מציאותי לא ניתן יהיה לפתור אותן. בתחילת שנות השבעים, שהמעגלים הבוליאניים נכנסו לתמונה כמודל חישוב אלטרנטיבי למודל הסטנדרטי של מכונת טיורינג, התקווה הייתה שבגלל הפשטות הרבה שלהם והאופי הקונקרטי יותר שלהם, יהיה קל יותר להוכיח חסמים תחתונים עבורם מאשר עבור מכונת טיורינג. התקווה הזו התבדתה למדי במהלך השנים כשהתברר עד כמה הוכחת חסמים תחתונים אפילו עבור המודל הזה היא קשה. תוצאה מפורסמת ביותר בהקשר הזה היא זו של רזבורוב ורודיץ' מ-94, שהראתה כי "<a href="http://en.wikipedia.org/wiki/Natural_proof">הוכחות טבעיות</a>" (לא אכנס כרגע להסבר של המושג) לא מסוגלות להוכיח חסמים תחתונים עבור מעגלים בוליאניים. ובניסוח יומיומי: יש הוכחה מתמטית לכך שיהיה מאוד, מאוד קשה להוכיח חסמים תחתונים על מעגלים בוליאניים. מכיוון שאחד מהיעדים הבסיסיים של חסמים תחתונים על מעגלים בוליאניים הוא להוכיח ש-{::nomarkdown}\( \mbox{P}\ne\mbox{NP}\){:/nomarkdown}, זוהי <a href="http://www.gadial.net/?p=716">עוד דוגמה</a> לכך ששאלת {::nomarkdown}\( \mbox{P}\ne\mbox{NP}\){:/nomarkdown} היא שאלה קשה בצורה יוצאת דופן, וגם פתרונה כנראה יצטרך להיות יוצא דופן - גישה שונה לגמרי למושג הסיבוכיות ולאופן שבו מוכיחים חסמים תחתונים לגביו.

בואו נעבור להגדרה של מעגל בוליאני - מה זה בכלל? כרגיל בעניינים כאלו, תמונה אחת שווה אלף מילים:

<strong><a href="http://www.gadial.net/wp-content/uploads/2011/01/Boolean-Circuit.png"><img class="alignnone size-medium wp-image-982" title="Boolean Circuit" src="http://www.gadial.net/wp-content/uploads/2011/01/Boolean-Circuit-224x300.png" alt="" width="224" height="300" /></a>
</strong>

פורמלית, מעגל בוליאני הוא גרף מכוון וחסר מעגלים (מהו המושג הזה? יש לי <a href="http://www.gadial.net/?p=125">פוסטים על גרפים</a>, אבל אני מקווה שגם מבט בתמונה מספיק כדי להבהיר את זה), שכל צומת "כניסה" שלו (צומת שאין קשתות שנכנסות אליו) מסומן במשתנה, כל צומת פנימי שלו מסומן ב-{::nomarkdown}\( \wedge\){:/nomarkdown} או ב-{::nomarkdown}\( \vee\){:/nomarkdown} או ב-{::nomarkdown}\( \neg\){:/nomarkdown}, וכל צומת שאין ממנו קשתות יוצאות נחשב צומת פלט. כדי לפשט את העניינים מניחים שיש רק צומת פלט יחיד, אבל רוב מה שמדברים עליו עובד גם עבור מספר צמתי פלט (שמאפשרים לדבר על פונקציות שמוציאות כפלט יותר מביט בודד). לצמתי {::nomarkdown}\( \neg\){:/nomarkdown} יכולה להיכנס רק קשת בודדה, אבל לצמתי {::nomarkdown}\( \wedge\){:/nomarkdown} ו-{::nomarkdown}\( \vee\){:/nomarkdown} יכול להיכנס מספר קשתות כלשהו, אם כי עוד מעט נגיד למה כן צריך להגביל את זה לפעמים.

בהינתן השמה כלשהי למשתנים, כלומר סדרה של 0 ו-1 לכל אחד מהמשתנים שבצמתי הכניסה של המעגל, הערך של צומת הפלט נקבע באופן הבא: כל צומת שטרם קבענו את ערכו אבל כן קבענו את ערכם של כל הבנים שלו - הצמתים שיש קשת מהם <strong>אליו</strong> - הערך שלו מחושב בהתאם לערך הבנים ולסימן שלו. למשל, צומת שמסומן ב-{::nomarkdown}\( \wedge\){:/nomarkdown} מקבל את הערך 1 אם ורק אם כל בניו קיבלו 1, ואחרת הוא מקבל 0. זה הכל. פלט המעגל על ההשמה הוא ערך של צומת הפלט. בדרך כלל מסמנים מעגל ב-{::nomarkdown}\( C\){:/nomarkdown} ואת הערך שלו על השמה מסויימת {::nomarkdown}\( x\){:/nomarkdown} ב-{::nomarkdown}\( C\left(x\right)\){:/nomarkdown} (כאן צריך לחשוב על {::nomarkdown}\( x\){:/nomarkdown} כעל מחרוזת ביטים שאורכה כמספר המשתנים של המעגל).

עכשיו משהמודל הבסיסי הובהר, הגיע הזמן להניח את הקלפים על השולחן ולהתייחס לאספקט שבמבט ראשון נראה מוזר ובעייתי של מעגלים, אל מול מכונות טיורינג. מכונת טיורינג היא מה שנקרא "מודל חישוב יוניפורמי" (למה "יוניפורמי" ולא המילה העברית הנאה "אחיד"? אין לי תשובה טובה יותר מ"ככה"). המשמעות של יוניפורמיות כאן היא שאותה המכונה מתמודדת עם קלטים מכל גודל שהוא. אין לי בעיה לבנות מכונת טיורינג בודדת לחישוב הפונקציה {::nomarkdown}\( \mbox{MAJORITY}\){:/nomarkdown} שהזכרתי קודם, והיא תדע להתמודד עם קלטים מגודל {::nomarkdown}\( n\){:/nomarkdown} לכל {::nomarkdown}\( n\){:/nomarkdown} טבעי שרק תרצו. לעומת זאת, מעגל בוליאני בנוי מראש עבור {::nomarkdown}\( n\){:/nomarkdown} ספציפי; עבור {::nomarkdown}\( n\){:/nomarkdown}-ים אחרים נזדקק למעגלים אחרים. אולי כולם ייראו דומים אחד לשני, אבל הם לא יהיו אותו מעגל - בפרט, הגודל שלהם יהיה שונה (ולו רק בגלל שיצטרכו להיות בהם יותר צמתי קלט).

אפשר היה לעקוף את הקושי הזה ולהגיד שמראש אנחנו רוצים לדבר רק על {::nomarkdown}\( n\){:/nomarkdown} קונקרטי אחד וחסל. אלא מה, כל מהותה של תורת הסיבוכיות הוא לעסוק בחסמים <strong>אסימפטוטיים</strong> על סיבוכיות - כלומר, לשאול שאלות כמו "עבור {::nomarkdown}\( n\){:/nomarkdown}-ים הולכים וגדלים, כמה מהר יגדל זמן החישוב שנדרש למכונת טיורינג כדי להתמודד עם קלט בגודל {::nomarkdown}\( n\){:/nomarkdown} כשהיא מנסה לחשב את הפונקציה הזו והזו?". לכן כשמדברים על בעיה חישובית שאנו רוצים לפתור באמצעות מעגלים, אנחנו לא מדברים על פונקציה {::nomarkdown}\( f\){:/nomarkdown} בודדת שאנו רוצים לחשב אלא על <strong>משפחת</strong> פונקציות {::nomarkdown}\( f_{1},f_{2},\dots,f_{n},\dots\){:/nomarkdown} כאשר {::nomarkdown}\( f_{n}\){:/nomarkdown} היא פונקציה על {::nomarkdown}\( n\){:/nomarkdown} קלטים. מן הסתם בדרך כלל כל הפונקציות {::nomarkdown}\( f_{n}\){:/nomarkdown} הללו יהיו דומות זו לזו באופיין - אבל הן לא זהות, כי מספר הקלטים שלהן שונה. בהתאם לכך, לא ניתן יהיה להציג מעגל בודד שמטפל בכל משפחת הפונקציות, אלא <strong>משפחת</strong> מעגלים {::nomarkdown}\( C_{1},C_{2},\dots,C_{n},\dots\){:/nomarkdown} כך שהמעגל {::nomarkdown}\( C_{n}\){:/nomarkdown} מחשב את הפונקציה {::nomarkdown}\( f_{n}\){:/nomarkdown}. לכאורה זה רעיון פשוט ומובן, ולא ברור למה אני מייחס לו כל כך הרבה חשיבות, עד שמתברר עד כמה החוסר-יוניפורמיות הזה גורם לתופעות מוזרות. הנה הדוגמה הקלאסית לעניין. שפה <strong>אונרית</strong> היא קבוצה של מילים (מילה, לצורך העניין, היא רצף של ביטים) שכל המילים בה הן סדרה של 1-ים, כלומר 0 לא מופיע בכלל. מה שמאפיין את המילים בשפה, אם כן, הוא רק האורך שלהן. לכל {::nomarkdown}\( n\){:/nomarkdown}, אחד משניים: או ש-{::nomarkdown}\( 1^{n}\){:/nomarkdown} (סדרה של {::nomarkdown}\( n\){:/nomarkdown} פעמים 1) מופיע בשפה, או שלא. זה אומר שלכל שפה אונרית קיימת משפחת מעגלים ש"מזהה" אותה (מוציאה 1 על מילים ששייכות לשפה ו-0 על מילים שלא). למה? כי קל לבנות מעגל שמוציא 1 על הקלט {::nomarkdown}\( 1^{n}\){:/nomarkdown} - פשוט מבצעים {::nomarkdown}\( \wedge\){:/nomarkdown} על כל ביטי הקלט. גם קל לבנות מעגל שמוציא {::nomarkdown}\( 0\){:/nomarkdown} על כל הקלטים - למשל {::nomarkdown}\( x_{1}\wedge\neg x_{1}\){:/nomarkdown}. לכן לכל {::nomarkdown}\( n\){:/nomarkdown} קיים מעגל, ומעגל <strong>קטן ופשוט</strong> שעונה את התשובה הנכונה לכל המילים מאורך {::nomarkdown}\( n\){:/nomarkdown}. אבל זה לחלוטין לא המצב עם מכונות טיורינג - קיימות שפות אונרית שמכונת טיורינג לא יכולה לזהות (כלומר, לעצור ולומר "כן" או "לא, בהתאם לשייכות המילה לשפה או לא). זה נובע מכך שבכלל קיימות שפות <strong>כלשהן</strong> שמכונת טיורינג לא יכולה לזהות, ואפשר לקודד שפות כאלו בעזרת מילים אונריות (איך? תרגיל). בקיצור, המודל הלא-יוניפורמי של מעגלים מסוגל לעשות דברים שמכונת טיורינג לא מסוגלת (זה לא אומר שהוא חזק יותר - אם המעגלים מוגבלים, ונראה דוגמאות להגבלות בקרוב, יהיו דברים שמכונת טיורינג יכולה לעשות ומעגלים לא).

אז איך פותרים את ה"בעיה" הזו? אפשר להצטמצם לדיון על משפחות <strong>יוניפורמיות</strong> של מעגלים - אלו משפחות מעגלים שאפשר לייצר באופן אלגוריתמי. כלומר, יש מכונת טיורינג שעל קלט {::nomarkdown}\( n\){:/nomarkdown} מייצרת את המעגל {::nomarkdown}\( C_{n}\){:/nomarkdown} המתאים. זה חיש קל פותר אותנו מאנומליות כמו שיש לעיל. עם זאת, לרוב אין צורך ביוניפורמיות הזו ולכן לא טורחים לדרוש אותה. הסיבה לכך היא שאין בעיה עם זה שמעגלים יהיו מסוגלים לקבל שפות שמכונת טיורינג לא, כל עוד השפות המעניינות באמת לא שם. אם ניתן יהיה להוכיח שמעגלים <strong>לא מסוגלים</strong> לעשות דבר מה, וינבע מכך שגם מכונות טיורינג לא יכולות לעשות זאת, למי אכפת שמעגלים מסוגלים לפתור כמה דברים שמכונות טיורינג לא?

הסיפור לא נגמר כאן - אפשר גם להתאים את המודל של מכונת טיורינג כדי שימדל "חוסר יוניפורמיות" שכזה. המודל המתאים הוא של "מכונות שמקבלות עצה". על קצה המזלג, הרעיון הוא שלכל מספר טבעי {::nomarkdown}\( n\){:/nomarkdown} תותאם מחרוזת של "עצה" {::nomarkdown}\( a_{n}\){:/nomarkdown}, ומכונת טיורינג שמתמודדת עם קלט {::nomarkdown}\( x\){:/nomarkdown} מאורך {::nomarkdown}\( n\){:/nomarkdown} תקבל, פרט ל-{::nomarkdown}\( x\){:/nomarkdown}, גם את {::nomarkdown}\( a_{n}\){:/nomarkdown} ותוכל להיעזר בו במהלך החישוב. אם אתם אוהבים את הדברים הללו קחו כמה דקות לחשוב למה השינוי הזה אכן מתאים בול לסיטואציה של מעגלים לא יוניפורמיים (ואם אתם ממש שוחים בחומר, נסו לחשוב איך עניין העצה שונה מעניין הזיהוי-יעיל שמגדיר את {::nomarkdown}\( \mbox{NP}\){:/nomarkdown}). למכונות שמקבלות עצה יש יתרון נוסף, והוא שניתן להשתעשע עם הגודל של העצה ולדרוש עליו חסמים שונים ומשונים ולראות מה מקבלים (למשל, מה אפשר לעשות עם ביט בודד של עצה? די הרבה, מסתבר - בפרט להכריע כל שפה אונרית בשיטה שתיארתי לעיל). בדרך כלל דורשים שגודל העצה יהיה פולינומי ב-{::nomarkdown}\( n\){:/nomarkdown}, ולמחלקת השפות שאפשר להכריע עם מכונות שמקבלות עצה וזמן הריצה שלהן הוא פולינומי קוראים {::nomarkdown}\( \mbox{P}/\mbox{poly}\){:/nomarkdown} (מה שמשמאל ללוכסן מייצג את סוג המכונה, ומה שמימין ללוכסן מציין את גודל העצה). זו גם בדיוק מחלקת השפות שאפשר להכריע עם מעגלים בוליאניים שגודלם פולינומי ב-{::nomarkdown}\( n\){:/nomarkdown}, ולכן השם המוזר והלכאורה לא קשור {::nomarkdown}\( \mbox{P}/\mbox{poly}\){:/nomarkdown} צץ לרוב כשמתחילים לדבר על מעגלים.

בואו נעבור עכשיו לדבר על ההגבלות שמשיתים על מעגלים בוליאניים. כבר רמזתי שמגבילים את גודל המעגל, כלומר את מספר השערים שבו, וזה טבעי לגמרי - אם אתם בונים מעגל חשמלי אמיתי לחישוב פונקציה, תרצו להשתמש בכמה שפחות שערים מכיוון שהם תופסים מקום, צורכים חשמל ומייצרים חום. אבל אני רוצה לדבר גם על הגבלה אחרת - <strong>עומק</strong> המעגל. עומק המעגל הוא אורך המסלול הארוך ביותר בו - מסלול משערי הכניסה אל שער הפלט. אפשר לחשוב על האורך הזה בתור ה<strong>זמן</strong> שלוקח למעגל לבצע את החישוב שלו, בעוד שעל כמות השערים אפשר לחשוב בתור ה<strong>זכרון</strong> שנדרש לו לצורך החישוב (זה לא מדויק אבל זו אנלוגיה טובה מספיק שתעזור לי בהמשך). במובן הזה אפשר לחשוב על מעגל כאילו הוא מסמלץ חישוב <strong>מקבילי</strong>: כל השערים במרחק 1 משער הכניסה מבצעים את החישוב שלהם "בו זמנית", את תוצאות החישוב הם מעבירים לשערים שבמרחק 2 (ואף לשערים מרוחקים יותר), אלו מעבדים את המידע ומעבירים אותו קדימה וכן הלאה. העניין הוא בכך ששער במרחק {::nomarkdown}\( n\){:/nomarkdown} מהכניסה לא תלוי בשום צורה בפלט של שערים אחרים שבמרחק {::nomarkdown}\( n\){:/nomarkdown} מהכניסה, ולכן כל השערים במרחק {::nomarkdown}\( n\){:/nomarkdown} מהכניסה יכולים לבצע את החישוב שלהם בו זמנית.

וכאן מתחיל להתברר לנו שצריך לחזק קצת את המגבלות שלנו אחרת לא נצליח לתאר שום דבר מעניין. נתחיל מכך שכל פונקציה בוליאנית - <strong>כל</strong> פונקציה - ניתן לחשב עם מעגל שעומקו המביך הוא 2. הסיבה לכך היא שכל פונקציה בוליאנית ניתן לתאר בצורה <strong>קנונית</strong>: לתאר אותה בתור {::nomarkdown}\( \vee\){:/nomarkdown} אחד גדול על המון {::nomarkdown}\( \wedge\){:/nomarkdown}-ים. מה הרעיון? אם {::nomarkdown}\( f\){:/nomarkdown} היא פונקציה בוליאנית, אפשר לחלק את הקלטים בעולם לשניים - אלו שמחזירים 0 ואלו שמחזירים 1. אז אפשר לתאר את הפונקציה בתור "החזירי אחד אם הקלט שלך הוא {::nomarkdown}\( a\){:/nomarkdown}, או אם הוא {::nomarkdown}\( b\){:/nomarkdown}, או אם הוא {::nomarkdown}\( c\){:/nomarkdown}, או..." כש-{::nomarkdown}\( a,b,c\){:/nomarkdown} וכדומה כולן סדרות ביטים שעבורן {::nomarkdown}\( f\){:/nomarkdown} מקבלת 1. את זה מתארים בתור {::nomarkdown}\( \vee\){:/nomarkdown}. כדי לתאר את "הקלט {::nomarkdown}\( x\){:/nomarkdown} שווה ל-{::nomarkdown}\( a\){:/nomarkdown}" צריך בעצם להגיד משהו בסגנון "הביט הראשון של {::nomarkdown}\( x\){:/nomarkdown} שווה לביט הראשון של {::nomarkdown}\( a\){:/nomarkdown}, <strong>וגם</strong> הביט השני של {::nomarkdown}\( x\){:/nomarkdown} שווה לביט השני של {::nomarkdown}\( a\){:/nomarkdown}, וגם..." - את זה מתארים בתור {::nomarkdown}\( \wedge\){:/nomarkdown}. זה הכל. לצורה הקנונית המתקבלת קוראים DNF.

בתור דוגמה, הנה דרך לתאר את {::nomarkdown}\( \oplus\){:/nomarkdown} כ-DNF. כזכור, זו פונקציה שמקבלת 1 אם ורק אם שני הקלטים (שנסמן כ-{::nomarkdown}\( x_{1},x_{2}\){:/nomarkdown}) שונים זה מזה. כלומר, הקלט הוא {::nomarkdown}\( 01\){:/nomarkdown} או {::nomarkdown}\( 10\){:/nomarkdown}. הצורה הנורמלית המתאימה היא {::nomarkdown}\( \left(x_{1}\wedge\neg x_{2}\right)\vee\left(\neg x_{1}\wedge x_{2}\right)\){:/nomarkdown}.

אם כן, יש לנו כאן מעגל מעומק 2: בשכבה הראשונה יהיו לנו שערי {::nomarkdown}\( \wedge\){:/nomarkdown} עבור כל ההשמות שנותנות 1, ובשכבה השניה יהיה לנו שער בודד, שער הפלט, עם {::nomarkdown}\( \vee\){:/nomarkdown} עליו. אז למה הסתבכנו כל כך עד כה? הסיבה היא שהמעגל שלנו אולי לא עמוק, אבל הוא מאוד לא יעיל: עבור רוב הפונקציות, מספר שערי ה-{::nomarkdown}\( \wedge\){:/nomarkdown} שנזדקק להם הוא <strong>אקספוננציאלי</strong> ב-{::nomarkdown}\( n\){:/nomarkdown}, כי יהיה מספר אקספוננציאלי ב-{::nomarkdown}\( n\){:/nomarkdown} של קלטים עליהם {::nomarkdown}\( f\){:/nomarkdown} מחזירה 1. בעצם אמרנו שאם יש לנו המון, המון מעבדים, אז אפשר לחשב כל פונקציה מהר. טוב ויפה, אבל אז המודל שלנו לא ריאליסטי; אנחנו רוצים לבדוק מה מעגלים יכולים לבצע גם בזמן יעיל וגם בזכרון יעיל. לכן מראש בכל הדיון שלנו מגבילים את גודל המעגלים להיות <strong>פולינומי</strong>, ואז כל הבניה שהצגנו לא שווה כלום, ועבור רוב הפונקציות לא נצליח למצוא מעגל מעומק 2, או אפילו מעומק קבוע.

חישוב מקבילי הוא מעניין רק אם הוא משיג שיפורים משמעותיים בזמן הריצה אל מול חישובים לא מקביליים. אם חישוב לא מקבילי יעיל הוא כזה שזמן הריצה שלו הוא פולינומי, אין טעם לקרוא גם לחישוב מקבילי "יעיל" אם זמן הריצה שלו פולינומי; לעומת זאת, זמן ריצה <strong>לוגריתמי</strong> זה כבר משהו מרשים. גם לוגריתמי-בריבוע זה עדיין טוב, ובאופן כללי זמן ריצה פולי-לוגריתמי (שהוא פולינום, אבל לא ב-{::nomarkdown}\( n\){:/nomarkdown} אלא ב-{::nomarkdown}\( \log n\){:/nomarkdown} - למשל {::nomarkdown}\( \log^{7}n+3\log^{3}n+7\){:/nomarkdown} הוא דוגמה לפולינום ב-{::nomarkdown}\( \log n\){:/nomarkdown}) הוא זמן ריצה מקבילי טוב. כמובן, ככל שהחזקה של הלוגריתם גבוהה יותר כך החישוב טוב פחות. זה מוביל אותנו להגדרה הבאה: {::nomarkdown}\( \mbox{AC}^{k}\){:/nomarkdown} הוא אוסף כל הפונקציות שניתן לחשב על ידי מעגל בוליאני (בעצם משפחת מעגלים בוליאניים אבל כבר הבנתם את העיקרון) מגודל פולינומי ב-{::nomarkdown}\( n\){:/nomarkdown} ובעומק שהוא {::nomarkdown}\( O\left(\log^{k}n\right)\){:/nomarkdown}. כך למשל {::nomarkdown}\( \mbox{AC}^{0}\){:/nomarkdown} הוא הפונקציות שניתן לחשב על ידי מעגל מגודל פולינומי ועומק קבוע; {::nomarkdown}\( \mbox{AC}^{1}\){:/nomarkdown} הוא הפונקציות שניתן לחשב על ידי מעגל פולינומי מעומק לוגריתמי, וכן הלאה. ב-{::nomarkdown}\( \mbox{AC}\){:/nomarkdown} מסמנים את איחוד כל המחלקות הללו.

גם המחלקה {::nomarkdown}\( \mbox{AC}\){:/nomarkdown} היא לא ריאליסטית עד הסוף, מהטעם הפשוט שלשערי ה-{::nomarkdown}\( \wedge\){:/nomarkdown} ו-{::nomarkdown}\( \vee\){:/nomarkdown}יכולים להיכנס כמה קלטים שרק נרצה. בפועל, לחשב {::nomarkdown}\( \wedge\){:/nomarkdown} של 100 קלטים לוקח יותר זמן מלחשב {::nomarkdown}\( \wedge\){:/nomarkdown} של 2 כאלו. לכן מוגדרת מחלקה מקבילה ל-{::nomarkdown}\( \mbox{AC}\){:/nomarkdown}, שנקראת {::nomarkdown}\( \mbox{NC}\){:/nomarkdown}. {::nomarkdown}\( \mbox{NC}^{k}\){:/nomarkdown} זהה ל-{::nomarkdown}\( \mbox{AC}^{k}\){:/nomarkdown} בהגדרתו פרט לכך שדורשים שלשערי {::nomarkdown}\( \wedge,\vee\){:/nomarkdown} ייכנסו ביטים משני שערים בדיוק (מה שמכונה Fan-in 2). זו לא מגבלה עד כדי כך חמורה: אפשר לסמלץ שער {::nomarkdown}\( \vee\){:/nomarkdown} שנכנסים אליו המוני קלטים באמצעות סדרה של שערי {::nomarkdown}\( \vee\){:/nomarkdown} שפועלים הדרגתית על זוגות מתוך הקלטים הללו. דבר כזה יוצר ניפוח לוגריתמי בעומק של המעגל (כי כל צעד קבוע מוחלף על ידי סדרת צעדים שגודלה עשוי להיות פולינומי) ומכאן מתקבלת סדרת ההכלות הבאה: {::nomarkdown}\( \mbox{NC}^{0}\subseteq\mbox{AC}^{0}\subseteq\mbox{NC}^{1}\subseteq\mbox{AC}^{1}\subseteq\mbox{NC}^{2}\subseteq\dots\){:/nomarkdown}. כדי לראות שכן יש הבדל כלשהו שימו לב ש-{::nomarkdown}\( \mbox{NC}^{0}\){:/nomarkdown} מכיל רק פונקציות שתלויות במספר קבוע (שאינו תלוי ב-{::nomarkdown}\( n\){:/nomarkdown}) של ביטים מהקלט שלהן, בעוד שב-{::nomarkdown}\( \mbox{AC}^{0}\){:/nomarkdown} זה לא כך.

המחלקה {::nomarkdown}\( \mbox{AC}^{0}\){:/nomarkdown} מעניינת במיוחד מכיוון שהיא שדה הקרב שבו תורת הסיבוכיות נחלה את אחד מנצחונותיה הגדולים עד כה - הוכחה לכך שהפונקציה {::nomarkdown}\( \oplus\){:/nomarkdown} (כשהיא מוגדרת על {::nomarkdown}\( n\){:/nomarkdown} משתנים ולא רק שניים - אפשר לחשוב עליה כאילו היא מבצעת חיבור מודולו 2) לא שייכת ל-{::nomarkdown}\( \mbox{AC}^{0}\){:/nomarkdown} (ולכן גם פונקציות מסובכות יותר רבות אחרות לא - כל מה שאפשר היה להשתמש בו כדי לחשב גם את {::nomarkdown}\( \oplus\){:/nomarkdown}). זו דוגמה לסוג החסמים התחתונים שאחריהם תורת הסיבוכיות מחפשת - הוכחה שיש בעיות קונקרטיות שהן קשות עד כדי כך שפשוט לא ניתן לפתור אותן עם מעגל בוליאני מעומק קבוע. לרוע המזל, זה פחות או יותר כל מה שאפשר לומר על {::nomarkdown}\( \mbox{AC}\){:/nomarkdown} ו-{::nomarkdown}\( \mbox{NC}\){:/nomarkdown} מבחינת חסמים תחתונים קונקרטיים, לפחות כיום. ישנן עוד מספר תוצאות מעניינות על מעגלים, אך הן מתייחסות למקרים עוד יותר ספציפיים שלא מעגלים שלא אכנס אליהן כרגע. הקרב עודנו בעיצומו, גם בימים אלו, אבל לתחושתי המאוד בלתי מלומדת, עיקר התקווה כיום הוא במציאת מודל חדש שיוכל להתמודד עם הבעיות ה"גדולות", ופחות בכך שמעגלים - מעניינים וחשובים בפני עצמם כמו שהם - יהיו מה שיוביל להתמודדות הזו.

בפוסט הבא נתאר מהן תוכניות מתפצלות ונחזור, הפעם באופן יותר פורמלי ומדויק, על מהו משפט ברינגטון.
