---
id: 3242
title: "בעיות הכרעה עבור שפות פורמליות"
date: 2015-04-29 15:09:03
layout: post
categories: 
  - תורת הסיבוכיות
tags: 
  - בעיית ההתאמה של פוסט
  - שפות פורמליות
---
כל מה שעשיתי עד כה בפוסטים על שפות פורמליות היה, במובן מסויים, "בתוך" המודלים שהצגתי - זה של אוטומט סופי עבור שפות רגולריות, וזה של דקדוקים חסרי הקשר ואוטומטי מחסנית עבור שפות חסרות הקשר. כל הדברים שעשיתי נעשו בעזרת המודלים הללו. אבל זה לא מה שקורה בעולם האמיתי - בעולם האמיתי, כשאנחנו באים להתעסק עם שפה רגולרית, אנחנו עושים את זה באמצעות שפת התכנות החביבה עלינו, מה שאומר שיש לנו יכולת להשתמש באלגוריתמים כלליים (בלשון פורמלית תיאורטית - יש לנו <strong>מכונת טיורינג</strong>). האוטומט הסופי הוא עבורנו דרך<strong> לייצג</strong> את השפה, ואנחנו מסוגלים להריץ אלגוריתמים ומניפולציות <strong>עליו</strong> כדי להפיק מידע על השפה. בדברים הללו אנחנו הולכים להתעסק בפוסט הזה.

נניח ש-{::nomarkdown}\( L\){:/nomarkdown} היא שפה פורמלית כלשהי (רגולרית או חסרת הקשר), אז הנה דברים שמעניין אותנו לדעת. האם {::nomarkdown}\( L\){:/nomarkdown} ריקה? האם {::nomarkdown}\( L\){:/nomarkdown} אינסופית? האם מילה {::nomarkdown}\( w\){:/nomarkdown} ספציפית שייכת ל-{::nomarkdown}\( L\){:/nomarkdown}? ונניח שנתונה שפה גם {::nomarkdown}\( L^{\prime}\){:/nomarkdown}, האם {::nomarkdown}\( L=L^{\prime}\){:/nomarkdown}?

לפני שניגשים לפתור את הבעיות הללו צריך להבין איך {::nomarkdown}\( L\){:/nomarkdown} נתונה לנו בכלל. קלטים, במחשב, הם בסך הכל סדרה סופית של ביטים, שאנחנו מפענחים בצורה מסויימת. אנחנו צריכים ייצוג שהמחשב יודע לעבוד איתו, ולכן ייצוג של שפה באמצעות תיאור מילולי לא פורמלי ("{::nomarkdown}\( L\){:/nomarkdown} היא שפת כל המילים מאורך זוגי מעל {::nomarkdown}\( \left\{ a,b\right\} \){:/nomarkdown}") יהיה משהו שלמחשב יהיה קשה מאוד לעבוד איתו. אז בדרך כלל אנחנו מניחים שאם {::nomarkdown}\( L\){:/nomarkdown} רגולרית היא נתונה לנו בעזרת אוטומט סופי {::nomarkdown}\( A\){:/nomarkdown} (שמיוצג באופן דומה לזה שמייצגים בו גרף במחשב), ואם היא חסרת הקשר היא נתונה בעזרת דקדוק חסר הקשר {::nomarkdown}\( G\){:/nomarkdown}. אפשר כמובן גם להציע דרכי תיאור אחרות, למשל ביטוי רגולרי; אבל אנחנו יודעים שאפשר להמיר כל ביטוי רגולרי לאוטומט מתאים, אז על פניו אנחנו לא מגבילים את הכלליות (כמובן שיש שאלה של סיבוכיות ההמרה של הביטוי הרגולרי לאוטומט וכדומה אבל לא אכנס לזה הפעם).

אני אנסה עכשיו לתת סיפור קונקרטי על משהו ספציפי אחד שיתן לנו תחושה כללית של למה מעניין לדבר על בעיות הכרעה, ומה הסכנות שצריך להיות מודעים להן. אני רוצה לדבר ספציפית על בעיית הריקנות של שפות רגולריות, בהקשר של <strong>אימות חומרה</strong>. אחת מהגישות שבהן נוקטים באימות חומרה היא מה שנקרא "בדיקות מודל" (Model Checking). בשיטה הזו, לוקחים רכיב חומרה כלשהו וממירים אותו לאוטומט סופי דטרמיניסטי; ה"מצבים" של האוטומט הם כל ההשמות האפשריות לרגיסטרים של רכיב החומרה (רגיסטר כאן הוא יחידת זכרון כלשהי שנמצאת בתוך הרכיב). ה"אותיות" שאותן קוראים הן ההשמות האפשריות לקלטים לרכיב החומרה הזה. אני לא אכנס להסברים יותר מפורטים כי זה ראוי לפוסט משל עצמו; השורה התחתונה היא שבסופו של דבר יש לנו ייצוג כלשהו של אוטומט שהמצבים שלו מתאימים למצבים שבהם הרכיב יכול להיות. עכשיו, אנחנו לרוב רוצים לבדוק תכונה כלשהי של הרכיב - למשל, "אם התקבל סיגנל של "בקשה", אז אחרי שלושה מחזורי שעון לכל היותר ייפלט סיגנל של "אישור". אחת הדרכים לעשות זאת היא כך: כותבים את הדרישה באמצעות לוגיקה פורמלית (נהוג להשתמש בסוג מסויים של לוגיקה טמפורלית לשם כך; זה נושא מעניין מאוד, כאמור). את הפסוק הלוגי הזה ממירים לאוטומט קטן שמצליח לתאר אותו בצורה כלשהי, ובונים מכפלה של האוטומט הקטן הזה יחד עם האוטומט שמתאר את כל המערכת. בסופו של דבר מתקבל אוטומט עם מצב מקבל יחיד, שכניסה אליו פירושו שהתכונה <strong>מופרת</strong>. עכשיו אנחנו לוקחים את האוטומט הזה ומריצים עליו בדיקת ריקנות. אם השפה של האוטומט ריקה, זה אומר שלא משנה מה הקלטים שהמעגל מקבל, התכונה שאנחנו בודקים לא מופרת בו; ואם השפה לא ריקה, אז כל מילה בה מהווה דוגמה נגדית לנכונות של התכונה, שעוזרת למתכנני המעגל להבין מה השתבש ומה לתקן.

זו דוגמה יפה מאוד, לטעמי, אבל היא גם שקר גדול, כי אלגוריתם הריקנות שאראה בהמשך לא יכול לטפל בה ביעילות. העניין הוא שהאוטומטים שנבנים באימות חומרה הם <strong>גדולים</strong>. ממש ממש גדולים. במובן זה שאוטומט עם {::nomarkdown}\( 2^{100}\){:/nomarkdown} מצבים הוא משהו לא חריג ואפילו לא גדול במיוחד. מן הסתם הייצוג שלנו של האוטומטים הללו הוא קומפקטי בצורה כלשהי, אבל אלגוריתמים שזמן הריצה שלהם הוא, למשל, לינארי במספר מצבי האוטומט יהיו חסרי ערך עבור אוטומט כזה. לכן משתמשים בשיטות אחרות, שהן יותר היוריסטיות באופיין ולא תמיד עובדות, אבל בפועל מספקות תוצאות טובות. אני לא הולך לדבר על זה בכלל בפוסט הזה.

אוקיי, בואו נעבור עכשיו לפתרון בעיות.

אם {::nomarkdown}\( A\){:/nomarkdown} הוא אוטומט סופי דטרמיניסטי ונתונה לנו מילה כלשהי {::nomarkdown}\( w\){:/nomarkdown}, אז אין דבר קל יותר מלבדוק אם {::nomarkdown}\( w\in L\left(A\right)\){:/nomarkdown}: פשוט מבצעים סימולציה של ריצת {::nomarkdown}\( A\){:/nomarkdown} על {::nomarkdown}\( w\){:/nomarkdown} ובודקים אם הגענו למצב מקבל. אם {::nomarkdown}\( A\){:/nomarkdown} אינו דטרמיניסטי אפשר לבצע לו דטרמיניזציה (להמיר אותו לאוטומט דטרמיניסטי; אדבר בפוסט אחר על איך עושים את זה יעיל יחסית), אבל גם אפשר להריץ אותו כמו שהוא על המילה, כשבמקום לזכור את המצב שבו אנחנו נמצאים כרגע, אנחנו זוכרים את קבוצת המצבים שבהם אנחנו נמצאים כרגע בכל הריצות האפשריות של האוטומט. כבר דיברתי על זה בשעתו.

עבור דקדוק חסר הקשר {::nomarkdown}\( G\){:/nomarkdown} המצב קשה הרבה יותר. דקדוק שכזה הוא אי-דטרמיניסטי בצורה הרבה פחות נוחה - אם ננסה לבצע את כל הריצות האפשריות שלו ביחד נצטרך לזכור כמות הולכת וגדלה של דברים ונסתבך חיש קל. בעיה דומה תהיה גם אם ננסה לבצע את כל הריצות של אוטומט מחסנית - כמות התכנים האפשריים של המחסנית תלך ותגדל באופן לא בהכרח חסום. אז צריך לעשות משהו אחר. המשהו האחר הכללי הסטנדרטי נקרא אלגוריתם CYK ואתאר אותו בהמשך הפוסט, אחרי שנסיים עם הדברים הפשוטים.

נעבור אל בעיית הריקנות. כשחושבים על אוטומט בתור גרף, זו בעיה פשוטה למדי, כל עוד מספר מצבי האוטומט הוא סביר - אנחנו פשוט מבצעים אלגוריתם חיפוש רגיל בגרף (DFS או BFS) החל מהמצב ההתחלתי של האוטומט ובודקים אם אפשר להגיע אל מצב מקבל כלשהו. כאמור, אם יש יותר מדי מצבים באוטומט מכדי שאפשר יהיה לנקוט בגישה הזו אנחנו נזקקים לשיטות היוריסטיות מחוכמות יותר שלא אדבר עליהן פה.

ומה קורה בדקדוקים? המצב לא שונה בהרבה. האתגר פה הוא למצוא <strong>משתנים טרמינליים</strong> - משתנים שגוזרים מילה טרמינלית. למשתנים כאלו יש הגדרה רקורסיבית פשוטה: {::nomarkdown}\( A\){:/nomarkdown} הוא טרמינלי אם קיים כלל גזירה {::nomarkdown}\( A\to\alpha\){:/nomarkdown} כך ש-{::nomarkdown}\( \alpha\){:/nomarkdown} מורכבת כולה מטרמינלים וממשתנים טרמינליים. הגדרה כזו נותנת לנו מייד אלגוריתם איטרטיבי למציאת כל המשתנים הטרמינליים: מתחזקים קבוצה {::nomarkdown}\( X\){:/nomarkdown} של משתנים טרמינליים, שבהתחלה היא ריקה; בכל איטרציה עוברים על כל הגזירות {::nomarkdown}\( A\to\alpha\){:/nomarkdown} בדקדוק ובודקים אם {::nomarkdown}\( \alpha\in\left(X\cup T\right)^{*}\){:/nomarkdown}. אם כן, מוסיפים את {::nomarkdown}\( A\){:/nomarkdown} ל-{::nomarkdown}\( X\){:/nomarkdown}. ממשיכים כך עד שמגיעים לאיטרציה שבה לא התווסף כלום ל-{::nomarkdown}\( X\){:/nomarkdown}, ואז מסיימים. עכשיו, כדי לבדוק אם שפת הדקדוק ריקה, פשוט בודקים אם {::nomarkdown}\( S\){:/nomarkdown} טרמינלי או לא.

נעבור לבעיית האינסופיות. מתי שפה של אוטומט היא אינסופית? ובכן, ברור שאם יש בשפה מילה שאפשר "לנפח" על פי למת הניפוח לשפות רגולריות אז השפה אינסופית כי היא כוללת את אינסוף הניפוחים של המילה. מתי מילה כזו קיימת באוטומט? כאשר יש ריצה על מילה ששייכת לשפה שמגיעה לאותו מצב פעמיים. אם ננסה לזקק מזה את המהות, נגיע לאבחנה הבאה: אם קיים בגרף של האוטומט מעגל שהוא מצד אחד ישיג מתוך המצב ההתחלתי, ומצב שני יש מצב מקבל שישיג ממנו - אז שפת האוטומט אינסופית. קל לראות שגם הכיוון ההפוך נכון, כי אם שפת האוטומט אינסופית יש בה מילים גדולות כרצוננו, ולכן תהיה מילה שאפשר להפעיל עליה את למת הניפוח.

עבור דקדוקים חסרי הקשר הסיטואציה דומה, אבל צריך להיות קצת יותר זהירים. אנחנו עדיין רוצים, באופן בסיסי, לחפש מעגל בגרף. נבנה גרף שצמתיו הם המשתנים של הדקדוק ויש קשת מ-{::nomarkdown}\( A\){:/nomarkdown} אל {::nomarkdown}\( B\){:/nomarkdown} אם קיימת בדקדוק גזירה {::nomarkdown}\( A\to\alpha B\beta\){:/nomarkdown}. מעגל בגרף הזה פירושו שיש לנו משתנה שגוזר את עצמו: {::nomarkdown}\( A\Rightarrow^{*}\gamma A\delta\){:/nomarkdown}. אבל גם אם מצאנו סיטואציה כזו, זה עדיין לא מבטיח לנו אינסוף מילים בשפה - אנחנו צריכים לדעת ש-{::nomarkdown}\( A\){:/nomarkdown} מסוגל לגזור מילה טרמינלית (אחרת חישוב ש-{::nomarkdown}\( A\){:/nomarkdown} משתתף בו לא הולך לייצר מילים בכלל), וש-{::nomarkdown}\( \left\|\gamma\delta\right\|\ge1\){:/nomarkdown} (אחרת {::nomarkdown}\( A\){:/nomarkdown} עשוי לגזור את עצמו שוב ושוב, אבל זה החישוב איתו ייצר רק מילה אחת). כדי להבטיח את אלו, אנחנו מראש מבטיחים שהדקדוק שלנו הוא "נקי" - מעיפים ממנו משתנים טרמינליים, וגם מסלקים ממנו כללי יחידה כמו {::nomarkdown}\( A\to B\){:/nomarkdown} וכללים מהצורה {::nomarkdown}\( A\to\varepsilon\){:/nomarkdown}, כך שאנו מבטיחים שכל גזירה {::nomarkdown}\( A\to\alpha B\beta\){:/nomarkdown} היא כזו שגם מייצרת מסביב ל-{::nomarkdown}\( B\){:/nomarkdown} משהו שהולך להפוך לטרמינלים בסופו של דבר. זו המחשה טובה לכך שנוח הרבה יותר להפעיל אלגוריתמים אם אפשר להניח שהדקדוק שפועלים עליו עבר פישוט מתאים.

בואו נעבור עכשיו למי שהיא אולי הבעיה המרתקת ביותר מבין כל בעיות ההכרעה שאדבר עליהן בפוסט הזה - בעיית השקילות. נתונים שני אוטומטים {::nomarkdown}\( A_{1},A_{2}\){:/nomarkdown} ואנחנו רוצים לדעת האם {::nomarkdown}\( L\left(A_{1}\right)=L\left(A_{2}\right)\){:/nomarkdown}. זה לחלוטין לא טריוויאלי. חשבו על סיטואציה שבה אנחנו רוצים לבנות רכיב חומרה; מצד אחד, יש לנו מודל {::nomarkdown}\( A_{1}\){:/nomarkdown} מאוד פשוט של הרכיב שמתאר את הפונקציה שהוא צריך לחשב, אבל ייתכן מאוד שמכל בחינה מעשית, המימוש של הרכיב הוא מאוד לא יעיל (מבחינת מספר שערים; מיקום שערים; צריכת חשמל; זמן ביצוע החישוב ועוד אינסוף שיקולים מורכבים שמהנדסי חומרה חייבים להתחשב בהם). מצד שני, יש לנו מימוש בפועל {::nomarkdown}\( A_{2}\){:/nomarkdown} שמהנדס חומרה עבד עליו מאוד קשה, אבל לכו תדעו עד אם הוא לא פספס משהו ואם אין באגים וכדומה. ועכשיו תחשבו שבלחיצת כפתור היה אפשר לבדוק אם {::nomarkdown}\( A_{1}\){:/nomarkdown} שקול ל-{::nomarkdown}\( A_{2}\){:/nomarkdown}. זה סוג הקושי שמדובר עליו כאן. עבור תוכניות מחשב כלליות זה פשוט לא עובד - אין אלגוריתם שמסוגל לבדוק אם שתי תוכניות מחשב הן שקולות. אבל עבור אוטומטים זה כן עובד, ואפילו עובד בצורה פשוטה להחריד, מבחינה רעיונית (מבחינת החישוב - שוב, זה ייקח יותר מדי זמן בפועל בסיטואציות אמיתיות של בדיקת רכיבי חומרה, אבל זה לא אומר שזה לא מועיל בהקשרים אחרים).

איך אנחנו עושים את הקסם הזה? פשוט מאוד - רדוקציה לבעיה של בדיקת ריקנות. אם {::nomarkdown}\( L_{1}=L\left(A_{1}\right)\){:/nomarkdown} ו-{::nomarkdown}\( L_{2}=L\left(A_{2}\right)\){:/nomarkdown}, נבנה אוטומט עבור <strong>ההפרש הסימטרי</strong> של {::nomarkdown}\( L_{1}\){:/nomarkdown} ו-{::nomarkdown}\( L_{2}\){:/nomarkdown} - אוסף המילים ששייכות לשפה אחת אבל לא לשניה. מן הסתם ההפרש הסימטרי ריק אם ורק אם השפות שוות. פורמלית, ההפרש הסימטרי הוא {::nomarkdown}\( \left(L_{1}\backslash L_{2}\right)\cup\left(L_{2}\backslash L_{1}\right)=\left(L_{1}\cap\overline{L_{2}}\right)\cup\left(L_{2}\cap\overline{L_{1}}\right)\){:/nomarkdown}, ואלו תכונות סגור; בפועל פשוט בונים אוטומט מכפלה עם מצבים מקבלים {::nomarkdown}\( \left(F_{1}\times\left(Q_{2}\backslash F_{2}\right)\right)\cup\left(\left(Q_{1}\backslash F_{1}\right)\times F_{2}\right)\){:/nomarkdown}.

האם אפשר לעשות משהו דומה עבור שפות חסרות הקשר? ובכן, התשובה היא חד משמעית <strong>לא</strong>. לא קיים אלגוריתם שבודק שקילות של שני דקדוקים חסרי הקשר. אבל למה? איך מוכיחים את זה? כאן אני חייב לגלוש קצת לתורה של בעיות לא כריעות. ספציפית, אני אציג בעיה לא כריעה אחת שבעזרתה אוכיח שהבעיות הקשורות לדקדוקים אינן כריעות. הבעיה הזו נקראת "בעיית ההתאמה של פוסט" ובקיצור PCP ויש לי עליה <a href="http://www.gadial.net/2014/04/14/post_correspondence_problem/">פוסט ייעודי</a> שגם מוכיח שהיא לא כריעה. בפוסט הזה לא רק שלא אוכיח שהבעיה הזו לא כריעה, אלא גם לא אכנס לתיאור עמוק שלה, אלא ההפך - אציג ניסוח שקול שלה שהוא מאוד פשוט אבל עושה שימוש בטרמינולוגיה שאנחנו כבר מכירים ולא הנחתי אותה בפוסט ההוא. בניסוח שלי, בעיית ההתאמה של פוסט היא הדבר הבא: נתון לנו אלפבתים סופיים {::nomarkdown}\( \Sigma\){:/nomarkdown} ו-{::nomarkdown}\( \Delta\){:/nomarkdown} ונתונים שני הומומורפיזמים {::nomarkdown}\( h:\Sigma\to\Delta^{*}\){:/nomarkdown} ו-{::nomarkdown}\( g:\Sigma\to\Delta^{*}\){:/nomarkdown}. השאלה: האם קיימת מילה {::nomarkdown}\( w\in\Sigma^{*}\){:/nomarkdown} כך ש-{::nomarkdown}\( h\left(w\right)=g\left(w\right)\){:/nomarkdown}? וזו, כאמור, בעיה לא כריעה.

כעת, בואו נתעסק בבעיה הבאה: נתונות שתי שפות חסרות הקשר {::nomarkdown}\( L_{1},L_{2}\){:/nomarkdown} (נתונות באמצעות דקדוקים, כרגיל). האם {::nomarkdown}\( L_{1}\cap L_{2}=\emptyset\){:/nomarkdown}? כלומר, האם יש מילה משותפת כלשהי לשתי השפות? אני אראה שאם אנחנו יודעים לפתור את הבעיה הזו באופן כללי, אז אנו גם יודעים לפתור את PCP. הרדוקציה היא פשוטה מאוד, למעשה - קחו רגע וראו אם תצליחו לחשוב עליה.

האלפבית שמעליו השפות שלו יוגדר יסומן בתור {::nomarkdown}\( \Gamma=\Sigma\cup\Delta\){:/nomarkdown}, כלומר הוא כולל גם את האותיות של {::nomarkdown}\( \Sigma\){:/nomarkdown} וגם של {::nomarkdown}\( \Delta\){:/nomarkdown}, ואני אניח בלי הגבלת הכלליות ש-{::nomarkdown}\( \Sigma\cap\Delta=\emptyset\){:/nomarkdown}. עכשיו, אגדיר {::nomarkdown}\( L_{1}=\left\{ w\#w^{R}\ \|\ w\in\Gamma^{*}\right\} \){:/nomarkdown} (אני מניח ש-{::nomarkdown}\( \#\notin\Gamma\){:/nomarkdown}) - מה שנקרא "שפת ראי מסומנת". קל לראות שזו שפה חסרת הקשר - כללי הדקדוק הם פשוט {::nomarkdown}\( \left\{ S\to\sigma S\sigma\ \|\ \sigma\in\Gamma\right\} \cup\left\{ S\to\#\right\} \){:/nomarkdown}. עכשיו, נגדיר את {::nomarkdown}\( L_{2}\){:/nomarkdown} כך: {::nomarkdown}\( L_{2}=\left\{ u^{R}h\left(u\right)\#\left(v^{R}g\left(v\right)\right)^{R}\ \|\ u,v\in\Sigma^{*}\right\} \){:/nomarkdown}. גם זו שפה חסרת הקשר, וקל לראות את זה עם תכונות סגור. ראשית, {::nomarkdown}\( L=\left\{ w^{R}w^{\prime}\ \|\ w\in\Sigma^{*}\right\} \){:/nomarkdown} היא שפה חסרת הקשר עם דקדוק {::nomarkdown}\( S\to\sigma S\sigma^{\prime}\|\varepsilon\){:/nomarkdown}. שנית, נפעיל על {::nomarkdown}\( L\){:/nomarkdown} הומומורפיזם שעל אותיות ללא תג מחזיר את עצמן, ועל אותיות עם תג מחזיר את מה ש-{::nomarkdown}\( h\){:/nomarkdown} מחזירה על האות ללא תג, ונקבל את השפה {::nomarkdown}\( \left\{ w^{R}h\left(w\right)\ \|\ w\in\Sigma^{*}\right\} \){:/nomarkdown}. לבסוף נשרשר עם השפה הזו עם השפה שמכילה רק את {::nomarkdown}\( \#\){:/nomarkdown} ואת זה עם השפה שעליה עשינו את אותו תעלול רק עם {::nomarkdown}\( g\){:/nomarkdown}.

קחו רגע לשכנע את עצמכם שאכן {::nomarkdown}\( L_{1}\cap L_{2}\ne\emptyset\){:/nomarkdown} אם ורק אם קיים {::nomarkdown}\( w\){:/nomarkdown} כך ש-{::nomarkdown}\( h\left(w\right)=g\left(w\right)\){:/nomarkdown}; זה מסיים את ההוכחה.

עכשיו, בעזרת כללי דה-מורגן נקבל ש-{::nomarkdown}\( L_{1}\cap L_{2}\ne\emptyset\){:/nomarkdown} אם ורק אם {::nomarkdown}\( \overline{L_{1}}\cup\overline{L_{2}}\ne\Sigma^{*}\){:/nomarkdown}. באופן כללי דבר כזה לא יעזור לנו במיוחד, כי זה ש-{::nomarkdown}\( L_{1},L_{2}\){:/nomarkdown} הן חסרות הקשר לא אומר שגם המשלימות שלהן כאלו, אבל במקרה שלנו זה דווקא נכון. אולי הדרך הקלה ביותר לראות זאת היא באמצעות האבחנה שאת {::nomarkdown}\( L_{1},L_{2}\){:/nomarkdown} אפשר לקבל עם אוטומט מחסנית דטרמיניסטי (מושג שטרם הגדרתי), אבל אפשר גם סתם לחשוב כמה דקות על איך לבנות אוטומטי מחסנית שמקבלים את {::nomarkdown}\( \overline{L_{1}},\overline{L_{2}}\){:/nomarkdown}.

המסקנה? אם {::nomarkdown}\( \overline{L_{1}},\overline{L_{2}}\){:/nomarkdown} הן חסרות הקשר כך גם {::nomarkdown}\( \overline{L_{1}}\cup\overline{L_{2}}\){:/nomarkdown}, ולכן קיבלנו שהבעיה הבאה אינה כריעה: בהינתן שפה חסרת הקשר {::nomarkdown}\( L\){:/nomarkdown}, יש לבדוק האם {::nomarkdown}\( L=\Sigma^{*}\){:/nomarkdown}. הבעיה הזו מכונה "בעיית האוניברסליות". העובדה שהיא לא כריעה מראה מייד שגם בדיקת שקילות של דקדוקים היא בעיה לא כריעה - כי אם בהינתן {::nomarkdown}\( G_{1},G_{2}\){:/nomarkdown} היינו יכולים לבדוק האם {::nomarkdown}\( L\left(G_{1}\right)=L\left(G_{2}\right)\){:/nomarkdown} היינו פותרים את בעיית האוניברסליות על ידי בדיקת שקילות לדקדוק שאנחנו יודעים שמייצר את {::nomarkdown}\( \Sigma^{*}\){:/nomarkdown}. בעיה נוספת שמייד רואים שהיא לא כריעה היא בעיית ההכלה: בהינתן {::nomarkdown}\( L_{1},L_{2}\){:/nomarkdown}, אם הייתה לנו דרך לבדוק האם {::nomarkdown}\( L_{1}\subseteq L_{2}\){:/nomarkdown} היינו יכולים לפתור את בעיית האוניברסליות על ידי בדיקה האם {::nomarkdown}\( \Sigma^{*}\subseteq L\){:/nomarkdown} (או לחילופין, היינו יכולים לבדוק האם {::nomarkdown}\( L_{1}=L_{2}\){:/nomarkdown} על ידי בדיקה האם {::nomarkdown}\( L_{1}\subseteq L_{2}\){:/nomarkdown} וגם {::nomarkdown}\( L_{2}\subseteq L_{1}\){:/nomarkdown}).

חוב אחד שלי שעדיין נשאר מפוסט קודם הוא השאלה האם בהינתן דקדוק {::nomarkdown}\( G\){:/nomarkdown} ניתן לקבוע אם הוא חד משמעי, או שקיימת מילה שקיימים לה שני עצי גזירה. בעיית ההתאמה של פוסט יכולה להיפתר גם על ידי אלגוריתם כזה: בהינתן {::nomarkdown}\( h,g\){:/nomarkdown} נבנה את הדקדוק {::nomarkdown}\( G\){:/nomarkdown} הבא: {::nomarkdown}\( S\to A\|B\){:/nomarkdown} ו-{::nomarkdown}\( A\to\sigma Ah\left(\sigma\right)\|\varepsilon\){:/nomarkdown} ו-{::nomarkdown}\( B\to\sigma Bg\left(\sigma\right)\|\varepsilon\){:/nomarkdown}. הדקדוק הזה מייצר מילים מהצורה {::nomarkdown}\( w^{R}h\left(w\right)\){:/nomarkdown} ו-{::nomarkdown}\( w^{R}g\left(w\right)\){:/nomarkdown}. כל מילה מהצורה {::nomarkdown}\( w^{R}h\left(w\right)\){:/nomarkdown} נוצרת בצורה יחידה (ה-{::nomarkdown}\( w^{R}\){:/nomarkdown} שבהתחלה מבטיח את זה) וכך גם עבור {::nomarkdown}\( w^{R}g\left(w\right)\){:/nomarkdown}; לכן הסיכוי היחיד של הדקדוק להיות רב-משמעי הוא שיתקיים {::nomarkdown}\( w^{R}h\left(w\right)=w^{R}g\left(w\right)\){:/nomarkdown} עבור {::nomarkdown}\( w\){:/nomarkdown} כלשהו, מה שגורר {::nomarkdown}\( h\left(w\right)=g\left(w\right)\){:/nomarkdown}.

אם כן, אלו היו שלל בעיות הכרעה לא כריעות, וכעת אני רוצה לחזור ולסיים בנימה אופטימית - אלגוריתם CYK שבודק בהינתן {::nomarkdown}\( w\){:/nomarkdown} האם {::nomarkdown}\( w\in L\){:/nomarkdown} עבור שפה חסרת הקשר {::nomarkdown}\( L\){:/nomarkdown} כלשהי.

נתחיל מזה שלא סתם לוקחים דקדוק כלשהו עבור {::nomarkdown}\( L\){:/nomarkdown} - לוקחים דקדוק {::nomarkdown}\( G\){:/nomarkdown} בצורה הנורמלית של חומסקי, שכבר הזכרתי בעבר ואזכיר שוב - בצורה הנורמלית הזו כל כללי הגזירה בדקדוק הם מהצורה {::nomarkdown}\( A\to a\){:/nomarkdown} או {::nomarkdown}\( A\to BC\){:/nomarkdown}. לכל שפה חסרת הקשר {::nomarkdown}\( L\){:/nomarkdown} קיים דקדוק בצורה הנורמלית של חומסקי שמקיים {::nomarkdown}\( L\left(G\right)=L\backslash\left\{ \varepsilon\right\} \){:/nomarkdown} (כלומר, אם המילה הריקה הייתה שייכת ל-{::nomarkdown}\( L\){:/nomarkdown}, אז הדקדוק לא ידע לייצר אותה כי הצורה הנורמלית של חומסקי לא מאפשרת את זה). זה אומר שאם אנחנו רוצים לבדוק אם {::nomarkdown}\( \varepsilon\in L\){:/nomarkdown} צריך לבדוק באמצעות אלגוריתם אחר, אבל זה יחסית קל (זה שקול לבדיקה האם המשתנה {::nomarkdown}\( S\){:/nomarkdown} <strong>אפיס</strong>, כלומר יש לו סדרת גזירה שמסתיימת ב-{::nomarkdown}\( \varepsilon\){:/nomarkdown}, וזו בדיקה דומה לבדיקה האם משתנה הוא טרמינלי).

אם כן, אנו מניחים ש-{::nomarkdown}\( w\){:/nomarkdown} הוא מאורך 1 לפחות. והנה הרעיון של האלגוריתם: אם {::nomarkdown}\( A\Rightarrow^{*}w\){:/nomarkdown} אז מתקיים בדיוק אחד משני דברים - או ש-{::nomarkdown}\( \left\|w\right\|\){:/nomarkdown} מאורך 1 וקיימת גזירה {::nomarkdown}\( A\to w\){:/nomarkdown} בדקדוק; או שקיים פירוק {::nomarkdown}\( w=uv\){:/nomarkdown} וגזירה {::nomarkdown}\( A\to BC\){:/nomarkdown} כך ש-{::nomarkdown}\( B\Rightarrow^{*}u\){:/nomarkdown} וגם {::nomarkdown}\( C\Rightarrow^{*}v\){:/nomarkdown}. על בסיס האבחנה הזו אפשר לתת אלגוריתם רקורסיבי שבודק את התנאי הזה, על ידי בדיקת כל הפירוקים האפשריים של {::nomarkdown}\( w\){:/nomarkdown} מהצורה {::nomarkdown}\( w=uv\){:/nomarkdown}, ועם תנאי עצירה עבור הסיטואציה שבה {::nomarkdown}\( \left\|w\right\|=1\){:/nomarkdown}.

רק מה, האלגוריתם הרקורסיבי הזה עשוי לעשות עבודה כפולה, ולא מעט ממנה. לכן אנחנו נוקטים בגישה שמכונה <strong>תכנון דינמי</strong>, והיא בעצם שם מפוצץ ל"תזכור את תוצאות חישובי הביניים שלך ותשתמש בהן שוב אם צריך". לצורך כך, בואו נניח ש-{::nomarkdown}\( w=\sigma_{1}\sigma_{2}\dots\sigma_{n}\){:/nomarkdown}. כעת אפשר לתאר תת-מילים של {::nomarkdown}\( w\){:/nomarkdown} באמצעות שני מספרים טבעיים - האורך שלה {::nomarkdown}\( l\){:/nomarkdown}, והאינדקס שבו היא מתחילה {::nomarkdown}\( i\){:/nomarkdown}. כעת אגדיר משתנים בוליאניים {::nomarkdown}\( P_{l,i}^{\left(A\right)}\){:/nomarkdown} שהרעיון הוא שהם יקבלו "אמת" אם ורק אם {::nomarkdown}\( A\Rightarrow^{*}\sigma_{i}\sigma_{i+1}\dots\sigma_{i+\left(l-1\right)}\){:/nomarkdown}. אם {::nomarkdown}\( S\){:/nomarkdown} הוא המשתנה ההתחלתי של הדקדוק, הרי שהשאלה האם {::nomarkdown}\( w\in L\){:/nomarkdown} זהה לשאלה אם {::nomarkdown}\( P_{n,1}^{\left(S\right)}\){:/nomarkdown} הוא "אמת", אז מה שאנחנו רוצים הוא אלגוריתם לחישוב ה-{::nomarkdown}\( P\){:/nomarkdown}-ים הללו.

לא אתן כאן פסאודו-קוד מלא של האלגוריתם (אבל למי שזה מעניין אותו אני ממליץ לתכנת אותו), אבל הרעיון הכללי פשוט: ראשית נותנים את הערך "שקר" לכל ה-{::nomarkdown}\( P\){:/nomarkdown}-ים. כעת עוברים על כל הגזירות מהצורה {::nomarkdown}\( A\to a\){:/nomarkdown} בדקדוק ומשנים את {::nomarkdown}\( P_{1,i}^{\left(A\right)}\){:/nomarkdown} ל"אמת" לכל אינדקס {::nomarkdown}\( i\){:/nomarkdown} כך ש-{::nomarkdown}\( \sigma_{i}=a\){:/nomarkdown}. זה תנאי ההתחלה שלנו.

עכשיו, לכל {::nomarkdown}\( 1&lt;r\le n\){:/nomarkdown} באופן סדרתי, ולכל משתנה {::nomarkdown}\( A\){:/nomarkdown}, ולכל {::nomarkdown}\( 1\le i\le n-r\){:/nomarkdown} אנחנו רוצים לחשב מהו {::nomarkdown}\( P_{r,i}^{\left(A\right)}\){:/nomarkdown} - כלומר, האם {::nomarkdown}\( A\){:/nomarkdown} יודע לגזור את תת-המילה {::nomarkdown}\( \sigma_{i}\sigma_{i+1}\dots\sigma_{i+\left(r-1\right)}\){:/nomarkdown}. לצורך כך אנחנו עוברים על כל הגזירות מהצורה {::nomarkdown}\( A\to BC\){:/nomarkdown} של המשתנה {::nomarkdown}\( A\){:/nomarkdown}; כעת, לכל אינדקס {::nomarkdown}\( i\le j&lt;n-r\){:/nomarkdown} אנחנו בודקים האם שני המשתנים {::nomarkdown}\( P_{j-i+1,i}^{\left(B\right)}\){:/nomarkdown} ו-{::nomarkdown}\( P_{n-r-j,j+1}^{\left(C\right)}\){:/nomarkdown} הם "אמת" בו זמנית - אם כן, אז הופכים את {::nomarkdown}\( P_{r,i}^{\left(A\right)}\){:/nomarkdown} לאמת בעצמו. זה הסוף.

מה הסיבוכיות של האלגוריתם? מכיוון שכל {::nomarkdown}\( P\){:/nomarkdown} מחושב בדיוק פעם אחת, הקריאה ה"רקורסיבית" שדיברתי עליה לא באה לידי ביטוי באלגוריתם כלל (האלגוריתם הוא למעשה איטרטיבי, לא רקורסיבי). זה אומר שצריך בעיקר לבדוק כמה לולאות יש בו. שאלה אחרת היא <strong>ביחס למה</strong> מודדים את הסיבוכיות - כאן יש שני גורמים שונים. אחד הוא אורך המילה {::nomarkdown}\( w\){:/nomarkdown}, שסימנו {::nomarkdown}\( n\){:/nomarkdown}, והשני הוא גודל הדקדוק {::nomarkdown}\( \left\|G\right\|\){:/nomarkdown} (למשל, מספר כללי הגזירה שלו).

ובכן, אנחנו עוברים על כל ה"רמות" של ה-{::nomarkdown}\( P\){:/nomarkdown}-ים, החל מ-{::nomarkdown}\( r=1\){:/nomarkdown} ועד {::nomarkdown}\( r=n\){:/nomarkdown}, כך שזו לולאה אחת מאורך {::nomarkdown}\( n\){:/nomarkdown}; בכל מעבר כזה, אנחנו עוברים על כל ה-{::nomarkdown}\( i\){:/nomarkdown}-ים בתחום מ-1 ועד {::nomarkdown}\( n-r\){:/nomarkdown} - זו לולאה שניה שמספר האיטרציות בה חסום על ידי {::nomarkdown}\( n\){:/nomarkdown}. כעת אנחנו עוברים על כל הגזירות הקיימות בדקדוק לכל המשתנים - חסום על ידי {::nomarkdown}\( \left\|G\right\|\){:/nomarkdown}, ולכל גזירה כזו אנו מבצעים בדיקה שתלויה בבחירה של האינדקס {::nomarkdown}\( i\le j&lt;n-r\){:/nomarkdown} - גם כן חסום על ידי {::nomarkdown}\( n\){:/nomarkdown}. קיבלנו זמן ריצה של {::nomarkdown}\( O\left(n^{3}\left\|G\right\|\right)\){:/nomarkdown}. שזה לא רע, גם אם לא נפלא כמו זמן הריצה {::nomarkdown}\( O\left(n\right)\){:/nomarkdown} של אוטומט סופי דטרמיניסטי על מילה. כמובן, במרבית היישומים הפרקטיים זה לא מספיק טוב, ומשתמשים באלגוריתמים פחות כלליים שמותאמים לדקדוקים יותר ספציפיים ויעילים - אבל זה נושא לדיון כשמדברים על פרסור שפות חסרות הקשר (למשל, בקומפילציה).

סיימנו! לטעמי עם הפוסט הזה גמרתי לכסות את נושאי הבסיס שבדרך כלל מציגים כמבוא לתורת השפות הפורמליות (אם כי דילגתי על דברים פה ושם - למשל צורות נורמליות). עם זאת, אני עדיין לא רוצה להיפרד; בפוסטים הבאים אדבר קצת על נושאים מתוחכמים יותר, ואחזור למשפטים קיימים ואתן להם הרחבות ועוד נקודות מבט. לדעתי החלק המגניב באמת רק מתחיל.
