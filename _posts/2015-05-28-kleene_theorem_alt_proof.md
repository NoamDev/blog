---
id: 3256
title: "משפט קלייני - הוכחה נוספת"
date: 2015-05-28 16:35:49
layout: post
categories: 
  - תורת הסיבוכיות
tags: 
  - משפט קלייני
  - שפות פורמליות
---
אולי המשפט המרכזי בסדרת הפוסטים שלי על שפות רגולריות היה משפט קלייני. כזכור, שפה רגולרית היא שפה שקיים אוטומט סופי דטרמיניסטי שמקבל אותה, אבל משפט קלייני נתן אפיון שונה לגמרי עבורה, שאפשר לנו להבין מה המבנה הכללי של אוסף השפות הרגולריות. כזכור, הוא אמר שהשפות הרגולריות הן בדיוק השפות שמתקבלות על ידי פעולות האיחוד, השרשור וסגור-קלייני ("הפעולות הרגולריות"), מתוך אוסף בסיס של שפות שכלל את השפה הריקה, השפה שהמילה היחידה בה היא המילה הריקה, ולכל אות {::nomarkdown}\( \sigma\in\Sigma\){:/nomarkdown}, השפה {::nomarkdown}\( \left\{ \sigma\right\} \){:/nomarkdown}.

ההוכחה הייתה נפלאה, לטעמי. הרעיון היה להתחיל מאוטומט {::nomarkdown}\( A\){:/nomarkdown} ולהגדיר שפות שאיכשהו ממדלות חישובים ב-{::nomarkdown}\( A\){:/nomarkdown}: השפה {::nomarkdown}\( L_{i,j}^{k}\){:/nomarkdown} תיארה את כל המילים שמעבירות את האוטומט מהמצב {::nomarkdown}\( q_{i}\){:/nomarkdown} למצב {::nomarkdown}\( q_{j}\){:/nomarkdown} בלי לעבור במצב עם אינדקס גדול מ-{::nomarkdown}\( k\){:/nomarkdown} בתוך החישוב הזה. את השפות הללו היה ניתן לתאר בצורה רקורסיבית באמצעות הפעולות הרגולריות, כשתנאי הבסיס של הרקורסיה היו שפות פשוטות במיוחד שמתקבלות משפות הבסיס על ידי פעולות רגולריות.

עכשיו אני רוצה לתת הוכחה קצת שונה.

כמובן, שאלה מתבקשת תמיד כשנותנים הוכחה נוספת למשהו שכבר הוכחנו היא - למה? למה בכלל לטרוח להוכיח משהו שוב? אנחנו כבר יודעים שהוא נכון! אז למה למה למה?

ובכן, כי זה מגניב.

וגם, כי זה נותן לנו עוד נקודת מבט מעניינת, וקצת יותר כללית, על המשפט ומה שהוא אומר. מה שאני אעשה יהיה להוכיח את המשפט לא עבור אוטומטים סופיים דטרמיניסטיים, אלא עבור סוג מוכלל שלהם, והמשפט שאוכיח יהיה יותר כללי מאשר משפט קלייני הרגיל. ובנוסף לכל זה, ההוכחה עצמה היא מאוד טבעית ומתבקשת - מתחילים מאוטומט מוכלל שכזה, ואז באופן איטרטיבי מעיפים ממנו מצבים ומתקנים את האוטומט בהתאם; איכשהו בסוף נגיע לאוטומט טריוויאלי שכולל תיאור "מיידי" של השפה. בהמשך הדיבור המעורפל הזה יתברר.

לאוטומט רגיל יש פונקציית מעברים שמקבלת את המצב הנוכחי ואות מ-{::nomarkdown}\( \Sigma\){:/nomarkdown}, ומחזירה את המצב שעוברים עליו. מבחינה רעיונית, אנחנו "אוכלים" את האות הזו מהקצה הימני של הקלט תוך כדי ביצוע המעבר. כבר ראינו הרחבה של המודל הרגיל שבו את האות מ-{::nomarkdown}\( \Sigma\){:/nomarkdown} מחליפה המילה הריקה, ואז האינטואיטיציה הייתה שביצענו מעבר אבל לא אכלנו כלום מהקלט. אם כן, בואו ניקח את הרעיון הזה צעד אחד קדימה ונגדיר פונקציית מעברים שיכולה לקבל כל מילה שהיא: {::nomarkdown}\( \delta:Q\times\Sigma^{*}\to2^{Q}\){:/nomarkdown}. שימו לב שאני מצהיר מראש שהפונקציה הזו מתארת אוטומט <strong>אי דטרמיניסטי</strong>: עבור זוג של מצב ומילה, ייתכן שעוברים ליותר ממצב אחד, וייתכן גם שלא עוברים לשום מצב עבורה.

איך נראה "חישוב" באוטומט כזה? ובכן, זה לא כזה מסובך: בכל צעד חישוב "מנחשים" מילה {::nomarkdown}\( w\){:/nomarkdown} כלשהי שהיא רישא של הקלט הנוכחי, "אוכלים" אותה מהקלט, ועוברים למצב כלשהו מתוך {::nomarkdown}\( \delta\left(q,w\right)\){:/nomarkdown}, כאשר {::nomarkdown}\( q\){:/nomarkdown} הוא המצב הנוכחי. להגדיר את פונקציית המעברים המורחבת מבחינה פורמלית זה עניין קצת מעצבן ולא ניכנס אליו - תחת זאת, בואו נראה עוד דרך לחשוב על האוטומט הזה.

בתיאור הרגיל של אוטומט, אנחנו מציירים אותו בתור גרף שבו הצמתים הם מצבי האוטומט, ויש קשת ממצב אחד לאחר עם סימונים שהם האותיות שמעבירות את המצב הראשון לשני. בהכללה שלי אפשר לחשוב שיש קשת בין <strong>כל</strong> זוג מצבים (וגם בין מצב לעצמו), ולכל קשת כזו יש סימון שהוא <strong>שפה</strong> (שיכולה להיות גם השפה הריקה, למשל, ובמצב הזה אני אתייחס לכך כאילו פשוט אין קשת). פורמלית, לכל זוג מצבים {::nomarkdown}\( q_{i},q_{j}\){:/nomarkdown} קיימת שפה {::nomarkdown}\( L_{ij}\subseteq\Sigma^{*}\){:/nomarkdown} שמכילה את כל המילים שמעבירות בצעד יחיד את {::nomarkdown}\( q_{i}\){:/nomarkdown} אל {::nomarkdown}\( q_{j}\){:/nomarkdown}: {::nomarkdown}\( L_{ij}=\left\{ w\in\Sigma^{*}\ \|\ q_{j}\in\delta\left(q_{i},w\right)\right\} \){:/nomarkdown}. אפשר להגדיר את השפה שהאוטומט מקבל בצורה הבאה: לכל מסלול {::nomarkdown}\( q_{i_{1}}\to q_{i_{2}}\to\dots\to q_{i_{k}}\){:/nomarkdown} כך שהמצב הראשון בו הוא התחלתי והמצב האחרון בו הוא מקבל, נסתכל על השרשור {::nomarkdown}\( L_{i_{1}i_{2}}L_{i_{2}i_{3}}\cdots L_{i_{k-1}i_{k}}\){:/nomarkdown}. נאחד את כל השרשורים הללו, לכל (אולי אינסוף) המסלולים ממצב התחלתי למצב מקבל - קיבלנו את שפת האוטומט.

המודל הזה כמובן חזק בצורה פסיכית. כל שפה {::nomarkdown}\( L\){:/nomarkdown} ניתן לקבל על ידי אוטומט טריוויאלי לגמרי, עם מצב התחלתי {::nomarkdown}\( q_{0}\){:/nomarkdown}, מצב מקבל יחיד {::nomarkdown}\( q_{f}\){:/nomarkdown}, ומעבר {::nomarkdown}\( \delta\left(q_{0},L\right)=q_{f}\){:/nomarkdown}. למעשה, זו הפואנטה - בגישת "צמצום האוטומט" שתיארתי קודם, אנחנו נתחיל מאוטומט כללי ונצטמצם בסוף לאוטומט טריוויאלי שכזה. עדיין, אם המודל חזק כל כך, מה הטעם בו? מה למדנו ממנו?

ובכן, זה פשוט. הנה הגרסה המורחבת של קלייני: השפה שמתקבלת על ידי אוטומט נתון כלשהו מהמודל הזה נמצאת בקבוצה האינדוקטיבית שנוצרת על ידי הפעולות הרגולריות, כשקבוצת שפות הבסיס כוללת בדיוק את השפות {::nomarkdown}\( L_{ij}\){:/nomarkdown} עבור האוטומט הזה. למה זו גרסה מורחבת של קלייני? כי <strong>כל</strong> אוטומט סופי רגיל הוא כזה שהשפות {::nomarkdown}\( L_{ij}\){:/nomarkdown} שלו כוללות לכל היותר את כל השפות מהצורה {::nomarkdown}\( \left\{ \sigma\right\} \){:/nomarkdown}, את השפה {::nomarkdown}\( \left\{ \varepsilon\right\} \){:/nomarkdown} (למשל, במעבר ממצב לעצמו, או אם יש לנו מסעי-{::nomarkdown}\( \varepsilon\){:/nomarkdown}) ואת השפה {::nomarkdown}\( \emptyset\){:/nomarkdown} (כשיש זוג מצבים שאין בכלל מעבר מהראשון אל השני), ואיחודים שלהן (למשל, אם {::nomarkdown}\( \delta\left(q,a\right)=p\){:/nomarkdown} וגם {::nomarkdown}\( \delta\left(q,b\right)=p\){:/nomarkdown} ואלו המעברים היחידים שמעבירים את {::nomarkdown}\( q\){:/nomarkdown} אל {::nomarkdown}\( p\){:/nomarkdown} אז נקבל ש-{::nomarkdown}\( L_{qp}=\left\{ a,b\right\} \){:/nomarkdown}). זה בדיוק הבסיס שלנו במשפט קלייני ה"רגיל".

נעבור להוכחת המשפט עצמו. בואו ניקח אוטומט מוכלל {::nomarkdown}\( A\){:/nomarkdown} כלשהו. נסמן את מצביו ב-{::nomarkdown}\( Q=\left\{ q_{1},q_{2},\dots,q_{n}\right\} \){:/nomarkdown}. נוסיף שני מצבים מיוחדים {::nomarkdown}\( q_{s},q_{f}\){:/nomarkdown} כך ש-{::nomarkdown}\( q_{s}\){:/nomarkdown} יהיה המצב ההתחלתי היחיד, {::nomarkdown}\( q_{f}\){:/nomarkdown} יהיה המצב המקבל היחיד, ויהיה מעבר-{::nomarkdown}\( \varepsilon\){:/nomarkdown} מ-{::nomarkdown}\( q_{s}\){:/nomarkdown} לכל מצב התחלתי ב-{::nomarkdown}\( A\){:/nomarkdown} ומכל מצב מקבל ב-{::nomarkdown}\( A\){:/nomarkdown} ל-{::nomarkdown}\( q_{f}\){:/nomarkdown}. הרעיון עכשיו יהיה להעיף באופן סדרתי את הצמתים {::nomarkdown}\( q_{1},q_{2},\dots,q_{n}\){:/nomarkdown} מהאוטומט, כך שאחרי כל העפה אנחנו מתקנים את הסימונים על הקשתות שנותרו באוטומט בצורה שמבטיחה שנקבל אוטומט שקול (כלומר, שמקבל את אותה שפה). אחרי שנעיף את כל הצמתים הללו נישאר רק עם {::nomarkdown}\( q_{s},q_{f}\){:/nomarkdown}, והקשת מ-{::nomarkdown}\( q_{s}\){:/nomarkdown} אל {::nomarkdown}\( q_{f}\){:/nomarkdown} תקודד בדיוק את השפה שלנו (שאר הקשתות בגרף לא ישפיעו; הקשת מ-{::nomarkdown}\( q_{f}\){:/nomarkdown} אל {::nomarkdown}\( q_{s}\){:/nomarkdown} היא עם הסימון {::nomarkdown}\( \emptyset\){:/nomarkdown} והקשתות מהצמתים לעצמם הן עם הסימון {::nomarkdown}\( \left\{ \varepsilon\right\} \){:/nomarkdown}). לכן כל מה שאנחנו צריכים לעשות כדי להוכיח את המשפט הוא להראות איך כל "תיקון סימוני קשתות" ניתן לביצוע עם הסימונים הנוכחיים שעל הקשתות והפעולות הרגולריות. כאן זה כבר תרגיל נחמד שאפשר לתת לסטודנטים לאוטומטים והם יצליחו לפתור בעצמם; אבל בואו נעשה אותו במפורש. כפי שתראו, זה מאוד מזכיר את הבניה שבה השתמשנו בהוכחת משפט קלייני המקורי.

נניח שאנחנו רוצים להעיף את הצומת {::nomarkdown}\( q_{i}\){:/nomarkdown}. זה יחסל את כל המסלולים שעוברים דרך {::nomarkdown}\( q_{i}\){:/nomarkdown}. מכיוון ש-{::nomarkdown}\( q_{i}\){:/nomarkdown} הוא לא המצב ההתחלתי או הסופי, אנחנו מתעניינים מלכתחילה רק במסלולים ש-{::nomarkdown}\( q_{i}\){:/nomarkdown} מופיע במהלכם, כלומר שיש צומת שנכנסים ממנו אל {::nomarkdown}\( q_{i}\){:/nomarkdown} וצומת שיוצאים מ-{::nomarkdown}\( q_{i}\){:/nomarkdown} אליו. נרצה, אם כן, לחבר את כל הצמתים שנכנסים ל-{::nomarkdown}\( q_{i}\){:/nomarkdown} אל כל הצמתים שיוצאים מ-{::nomarkdown}\( q_{i}\){:/nomarkdown}.

בואו ניקח שני צמתים כאלו: צומת {::nomarkdown}\( q_{j}\){:/nomarkdown} כך שיש קשת {::nomarkdown}\( q_{j}\to q_{i}\){:/nomarkdown}, וצומת {::nomarkdown}\( q_{k}\){:/nomarkdown} כך שיש קשת {::nomarkdown}\( q_{i}\to q_{k}\){:/nomarkdown} (זכרו שאצלנו בעצם יש קשת מכל צומת לכל צומת, אבל היא עשויה להיות מסומנת בשפה הריקה ואם תבדקו, תראו שזה שקול לכך שלא תהיה קשת). אנחנו רוצים "להוסיף" קשת מ-{::nomarkdown}\( q_{j}\){:/nomarkdown} אל {::nomarkdown}\( q_{k}\){:/nomarkdown}, אבל כמובן שאולי כבר יש כזו - השפה {::nomarkdown}\( L_{jk}\){:/nomarkdown} מתארת את הסימון שלה. אז אנחנו רוצים לבנות {::nomarkdown}\( L_{jk}^{\prime}\){:/nomarkdown} "מתוקנת".

מה השפה המתוקנת צריכה לכלול? את כל המילים שמעבירות את {::nomarkdown}\( q_{j}\){:/nomarkdown} אל {::nomarkdown}\( q_{k}\){:/nomarkdown} באופן ישיר, כלומר את {::nomarkdown}\( L_{jk}\){:/nomarkdown}, וכמו כן את כל המילים שמעבירות את {::nomarkdown}\( q_{j}\){:/nomarkdown} אל {::nomarkdown}\( q_{k}\){:/nomarkdown} באמצעות שימוש במצב הביניים {::nomarkdown}\( q_{i}\){:/nomarkdown}. נאיבית אפשר לחשוב שהמילים הללו הן בדיוק {::nomarkdown}\( L_{ji}\cdot L_{ik}\){:/nomarkdown}, כלומר שרשור של מילה שמעבירה אותנו מ-{::nomarkdown}\( q_{j}\){:/nomarkdown} אל {::nomarkdown}\( q_{i}\){:/nomarkdown} ואז מ-{::nomarkdown}\( q_{i}\){:/nomarkdown} אל {::nomarkdown}\( q_{k}\){:/nomarkdown}; אבל זכרו שאנחנו עשויים להישאר ב-{::nomarkdown}\( q_{i}\){:/nomarkdown} במשך מספר צעדים שבהם נלך מ-{::nomarkdown}\( q_{i}\){:/nomarkdown} אל עצמה. מכאן שהשפה היא {::nomarkdown}\( L_{ji}\cdot L_{ii}^{*}\cdot L_{ik}\){:/nomarkdown}, וקיבלנו ש-{::nomarkdown}\( L_{jk}^{\prime}=L_{jk}\cup L_{ji}\cdot L_{ii}^{*}\cdot L_{ik}\){:/nomarkdown}. זה מסיים את ההוכחה, ובצורה מאוד נחמדה - אנחנו רואים בדיוק איך כל שלוש הפעולות הרגולריות באות לידי ביטוי באותה משוואה.

שאלה מעניינת אחת עולה מכל העניין הזה. משפט קלייני נותן לנו, דה פקטו, דרך לבנות ביטוי רגולרי עבור שפה בהינתן האוטומט שלה - ביטוי רגולרי די מסובך, אבל ביטוי רגולרי. האם הביטוי שנקבל מתוך ההוכחה ה"חדשה" שונה מהותית מאשר הביטוי שנקבל מההוכחה ה"ישנה"? התשובה היא כן ולא. כן, כי אכן אנחנו עשויים לקבל ביטויים שונים (ושימו לב ששתי ההוכחות היו תלויות בסדר כלשהו על מצבי האוטומט, וסדרים שונים יניבו ביטויים רגולריים שונים). לא, כי ישנן מניפולציות סינטקטיות מסויימות שניתן לבצע על הביטויים הרגולריים כדי לקבל מתוך האחד את השני. זה מביא אותנו לתחום שאני לא הולך להיכנס אליו בפוסטים הללו כי לטעמי הוא יותר מדי טכני מכדי להצדיק פוסטים מעניינים - הבדיקה עד כמה שני ביטויים רגולריים הם שקולים, על פי סוג המניפולציות הסינטקטיות שמעבירות אחד אל השני (ככל שנדרשות יותר פעולות מתוחכמות יותר כך השקילות היא פחות "ברורה").

אם כן, ההוכחה לא נותנת לנו שום דבר חדש לגמרי - אבל מה אכפת לי, היא ממש יפה.
