---
id: 3202
title: "שפות רגולריות - משפט קלייני"
date: 2014-12-24 14:05:16
layout: post
categories: 
  - תורת הסיבוכיות
tags: 
  - משפט קלייני
  - שפות רגולריות
---
את הדיון שלי על שפות רגולריות התחלתי בהצגה של מושג האוטומט הסופי הדטרמיניסטי. האוטומט הזה היה מין מכונת חישוב תאורטית שמבצעת פעולה של <strong>זיהוי</strong> מתי מילה שייכת או לא שייכת לשפה כלשהי. הגדרתי את אוסף <strong>השפות הרגולריות</strong> בתור השפות שמתקבלות על ידי אוטומט כזה. אחר כך התחלתי להתעסק בתכונות סגור של שפות רגולריות - פעולות שאפשר להפעיל על שפות רגולריות קיימות ולקבל כתוצרים שפות רגולריות חדשות - כשחלק מהיעד שלי היה למצוא קבוצה קטנה יחסית של פעולות סגור ו"שפות בסיס" שמהן ניתן ליצור את כל השפות הרגולריות. את מה שהגעתי אליו בסופו של דבר אפשר לנסח כך: שפות הבסיס הן כל השפות שיש בהן לכל היותר מילה אחת מאורך לכל היותר 1; ופעולות הסגור הן איחוד, שרשור וסגור-קלייני. הטענה הזו נקראת לפעמים "משפט קלייני" וכך אקרא לה כאן (אין קונצנזוס בשפות על מה בדיוק נקרא "משפט קלייני" בהקשר של שפות רגולריות; יש כמה ניסוחים שונים ואני לא אכנס לדיון הזה כי הוא משעמם).

בפוסט הזה אני רוצה להוכיח את הטענה הזו בצורה פורמלית יחסית. בואו נתחיל.

אם כבר פורמליזם, צריך לזכור שברקע של הדיון שלנו תמיד יש קבוצה סופית {::nomarkdown}\( \Sigma\){:/nomarkdown} שנקראת <strong>אלפבית</strong> - מתוכה נלקחות האותיות שמהן נבנות מילים. כשאני מדבר על שפות רגולריות, אני בעצם אומר "השפות הרגולריות שמורכבות ממילים שבנויות מתוך אותיות {::nomarkdown}\( \Sigma\){:/nomarkdown}". כל מה שאעשה בהמשך לא ממש תלוי ב-{::nomarkdown}\( \Sigma\){:/nomarkdown} (אולי אניח באופן מובלע שזו לא קבוצה ריקה אחרת אין בכלל מילים חוץ מהמילה הריקה) במובן זה שלכל {::nomarkdown}\( \Sigma\){:/nomarkdown} סופית ההוכחות עובדות באותה מידה בדיוק.

קבוצת שפות הבסיס שלי, אם כן, היא הקבוצה הבאה: {::nomarkdown}\( \left\{ \emptyset,\left\{ \varepsilon\right\} \right\} \cup\left\{ \left\{ \sigma\right\} \ \|\ \sigma\in\Sigma\right\} \){:/nomarkdown}. דהיינו, השפה הריקה, השפה שהאיבר היחיד שלה הוא המילה הריקה, והשפה שהאיבר היחיד שלה הוא המילה מאורך 1 {::nomarkdown}\( \sigma\){:/nomarkdown}, לכל אות {::nomarkdown}\( \sigma\in\Sigma\){:/nomarkdown}.

מבין פעולות הסגור, איחוד שפות זו פשוט פעולת האיחוד הרגילה של קבוצות. שרשור של שפות הוגדר להיות {::nomarkdown}\( L_{1}\cdot L_{2}\triangleq\left\{ w_{1}w_{2}\ \|\ w_{1}\in L_{1},w_{2}\in L_{2}\right\} \){:/nomarkdown} (כששרשור של מילים מוגדר בצורה הרגילה - המילה שמתקבלת מ"הדבקת" שתי המילים על פי הסדר שלהן). סגור-קלייני היה הפעולה המסובכת ביותר והפחות טבעית מבין הפעולות: {::nomarkdown}\( L^{*}\triangleq\bigcup_{n=0}^{\infty}L^{n}\){:/nomarkdown}, כאשר חזקה של שפות מוגדרת באופן הטבעי: {::nomarkdown}\( L^{0}\triangleq\left\{ \varepsilon\right\} \){:/nomarkdown} ו-{::nomarkdown}\( L^{n+1}\triangleq L^{n}\cdot L\){:/nomarkdown}. כזכור, הגדרתי את סגור-קליניי מלכתחילה כי הייתה לי "אינטואיציה" שזו הפעולה שאזדקק לה כדי להוכיח את משפט קלייני. מה שיהיה נחמד בהוכחה (בין היתר) הוא שנבין <strong>בדיוק</strong> למה צריך דווקא את הפעולה הזו.

המשפט אומר שקבוצת השפות הרגולריות היא הקבוצה שנוצרת אינדוקטיבית מהבסיס ופעולות היצירה הללו. לא חייבים להבין מה זו קבוצה נוצרת אינדוקטיבית, אבל זה לא יזיק אז אקדיש לכך כמה פסקאות ואפשר לדלג אם רוצים. הרעיון הוא שזו <strong>הקבוצה הקטנה ביותר</strong> שמכילה את הבסיס וסגורה לפעולות היצירה. באופן כללי, אם יש לי "עולם" {::nomarkdown}\( X\){:/nomarkdown}, קבוצת <strong>בסיס</strong> {::nomarkdown}\( B\subseteq X\){:/nomarkdown} וקבוצה {::nomarkdown}\( F\){:/nomarkdown} של <strong>פעולות יצירה </strong>שהן פונקציות מהצורה {::nomarkdown}\( f:X^{n}\to X\){:/nomarkdown} (כלומר, פונקציות שמקבלות {::nomarkdown}\( n\){:/nomarkdown} קלטים, כאשר {::nomarkdown}\( n\){:/nomarkdown} יכול להיות מספר טבעי חיובי כלשהו), אז אסמן ב-{::nomarkdown}\( X_{B,F}\){:/nomarkdown} את הקבוצה הקטנה ביותר כך ש-{::nomarkdown}\( B\subseteq X_{B,F}\){:/nomarkdown} ולכל {::nomarkdown}\( f\in F\){:/nomarkdown} מתקיים ש-{::nomarkdown}\( f\left(X_{B,F}\right)\subseteq X_{B,F}\){:/nomarkdown} (הסימון "{::nomarkdown}\( f\left(D\right)\){:/nomarkdown}" לקבוצה {::nomarkdown}\( D\){:/nomarkdown} כלשהו פירושו כל הפלטים שמקבלים כאשר מציבים ב-{::nomarkdown}\( f\){:/nomarkdown} את כל הקומבינציות האפשריות של איברים ב-{::nomarkdown}\( D\){:/nomarkdown}; הסיבה שאני בכלל טורח לומר זאת במפורש היא שאם {::nomarkdown}\( f\){:/nomarkdown} היא פונקציה שמקבלת כמה קלטים, יכול להיראות לחלקכם מוזר שפתאום אני מכניס לה את ה"קלט" {::nomarkdown}\( D\){:/nomarkdown}. זה לא באמת קלט; זה סימון של התמונה של {::nomarkdown}\( f\){:/nomarkdown}).

עכשיו, תשאלו, למה הקבוצה הזו בכלל קיימת? ובכן, הנה טענה חביבה: {::nomarkdown}\( X_{B,F}=\bigcap\left\{ D\subseteq X\ \|\ B\subseteq D\wedge\forall f\in F:f\left(D\right)\subseteq D\right\} \){:/nomarkdown}. במילים: {::nomarkdown}\( X_{B,F}\){:/nomarkdown} מתקבלת מחיתוך כל הקבוצות שמכילות את {::nomarkdown}\( B\){:/nomarkdown} וסגורות תחת {::nomarkdown}\( F\){:/nomarkdown}. זו דרך סטנדרטית במתמטיקה להגדיר אובייקטים "הכי קטנים" שכאלו באמצעות חיתוך מסוג זה. חשוב לשים לב לכך שהחיתוך לא נלקח מעל קבוצה ריקה של אובייקטים; {::nomarkdown}\( X\){:/nomarkdown} עצמו תמיד נכלל כאיבר בחיתוך. לכן החיתוך מוגדר היטב, ולא קשה להוכיח שהוא אכן שווה ל-{::nomarkdown}\( X_{B,F}\){:/nomarkdown}.

מה שנחמד ב-{::nomarkdown}\( X_{B,F}\){:/nomarkdown} הוא שקל להוכיח עליה טענות באינדוקציה: מוכיחים שמשהו מתקיים עבור {::nomarkdown}\( B\){:/nomarkdown} ומשתמר עבור כל {::nomarkdown}\( f\in F\){:/nomarkdown} ומקבלים שאותו משהו מתקיים לכל {::nomarkdown}\( X_{B,F}\){:/nomarkdown}. בעזרת אינדוקציית מבנה שכזו אפשר להוכיח, למשל, שאיבר כלשהו שייך ל-{::nomarkdown}\( X_{B,F}\){:/nomarkdown} אם ורק אם קיימת לו <strong>סדרת יצירה</strong> - סדרה סופית שכל איבר בה הוא או איבר של {::nomarkdown}\( B\){:/nomarkdown} או מתקבל מאיברים קודמים בסדרה על ידי הפעלת {::nomarkdown}\( f\){:/nomarkdown}, והאיבר האחרון בה הוא האיבר שהסדרה "יוצרת". אולי לחלקכם זה מזכיר את האופן שבו מתוארות הוכחות במתמטיקה - סדרה של טענות כך שכל טענה היא אקסיומה או הנחה או נובעת מקודמותיה על ידי כלל היסק. זה כמובן לא מקרי - אפשר להגדיר את "קבוצת המשפטים היכיחים" (מאקסיומות/הנחות נתונות ועם כללי היסק נתונים) בדיוק בתור קבוצה אינדוקטיבית שכזו.

חזרה לענייננו - המסקנה שלנו מכל הדיון שלמעלה היא שכדי להוכיח את משפט קלייני, צריך לעשות שני דברים. ראשית, להוכיח שקבוצת השפות הרגולריות אכן כוללת את הבסיס וסגורה ביחס לפעולות הסגור. את זה עשיתי בפוסטים הקודמים. הדבר השני שצריך להראות הוא שכל שפה רגולרית אכן ניתנת ליצירה מתוך הבסיס בעזרת פעולות הסגור, במספר סופי של פעולות (זו "סדרת היצירה" המדוברת). זה מה שנעשה בפוסט הזה.

אם כן, הבה וניקח אוטומט סופי דטרמיניסטי כלשהו, {::nomarkdown}\( A=\left(\Sigma,Q,q_{1},\delta,F\right)\){:/nomarkdown}. אני מסמן את מצבי האוטומט בתור {::nomarkdown}\( Q=\left\{ q_{1},q_{2},\dots,q_{n}\right\} \){:/nomarkdown}. שימו לב שאני בוחר הפעם לסמן את המצב ההתחלתי של האוטומט ב-{::nomarkdown}\( q_{1}\){:/nomarkdown} במקום ב-{::nomarkdown}\( q_{0}\){:/nomarkdown} כרגיל; הסיבה לכך תתברר בהמשך אבל היא לא משהו קריטי - זה פשוט יפשט קצת סימון אחר שאציג עוד מעט.

עכשיו אפשר סוף סוף לדבר על השאלה המרכזית שלנו - איך לכל הרוחות פעולות היצירה שלנו קשורות בכלל למה שאוטומט סופי דטרמיניסטי עושה? אוטומט רץ על מילים וחושב מחשבות עמוקות ובסוף פולט תשובה. פעולות יצירה... ובכן, הן בונות שפות. מה הקשר? איך בכלל ניגשים לזה? זו שאלה טובה מאוד ולא פשוטה בכלל, והעובדה שיש לה תשובה חדה ואלגנטית שפותרת את הכל היא אחת הסיבות שבגללן התוצאה הזו יפה כל כך.

כדי להגיע לתשובה הזו, בואו ננסה לחשוב שניה באופן הבא: שפות הן קבוצות של מילים. מה זו מילה עבור אוטומט? קל להגיד "מה שהוא רץ עליה ומכריע אם היא בשפה או לא", אבל בעצם מילה היא יותר מזה - מילה היא אובייקט ש<strong>פועל</strong> על האוטומט - גורם לו לעבור ממצב א' אל מצב ב'. מכיוון שאנחנו עוסקים כאן באוטומט סופי דטרמיניסטי, שאין לו זכרון בשום מקום מלבד המצבים שלו, כדי להבין באופן מלא מה האוטומט עושה, צריך רק להבין את אותן פעולות - מה גורם לאוטומט לעבור ממצב א' למצב ב'.

אז אני יכול לנסות ולהגדיר שפות באופן הבא: לכל זוג מצבים {::nomarkdown}\( q,p\in Q\){:/nomarkdown} נגדיר {::nomarkdown}\( L_{q,p}=\left\{ w\in\Sigma^{*}\ \|\ \hat{\delta}\left(q,w\right)=p\right\} \){:/nomarkdown} - שפת כל המילים שמעבירות את האוטומט מ-{::nomarkdown}\( q\){:/nomarkdown} אל {::nomarkdown}\( p\){:/nomarkdown}. אם נצליח לבנות את השפות הללו, בבירור סיימנו, כי {::nomarkdown}\( L\left(A\right)=\bigcup_{p\in F}L_{q_{0},p}\){:/nomarkdown} (שפת האוטומט היא אוסף כל המילים שמעבירות את האוטומט מהמצב ההתחלתי {::nomarkdown}\( q_{0}\){:/nomarkdown} אל מצב מקבל כלשהו {::nomarkdown}\( p\in F\){:/nomarkdown}). אז מה הבעיה? שאין לי מושג איך לבנות את {::nomarkdown}\( L_{q,p}\){:/nomarkdown}, מן הסתם. זו עדיין שפה מסובכת, אפילו אם היא אולי פחות מסובכת מ"כל המילים שהאוטומט מקבל".

אם השתמשתי בטריק של "לעבור מהשפה הקשה {::nomarkdown}\( L\left(A\right)\){:/nomarkdown} לאיחוד של שפות יותר פשוטות מהצורה {::nomarkdown}\( L_{q,p}\){:/nomarkdown}" אולי אפשר לעשות את התעלול הזה שוב? אני אוטומטית חושב על כך שאפשר לפרק את {::nomarkdown}\( L_{q,p}\){:/nomarkdown} על פי <strong>אורך</strong> המילים. כלומר, אסמן {::nomarkdown}\( L_{q,p}^{k}\triangleq\left\{ w\in L_{q,p}\ \|\ \left\|w\right\|=k\right\} \){:/nomarkdown} ואז {::nomarkdown}\( L_{q,p}=\bigcup_{k=0}^{\infty}L_{q,p}^{k}\){:/nomarkdown}. על פניו זה רעיון די טוב, כי אני יכול לתאר את {::nomarkdown}\( L_{q,p}^{k}\){:/nomarkdown} באופן <strong>אינדוקטיבי</strong> על פי פירוק לפי הצעד האחרון: {::nomarkdown}\( L_{q,p}^{k}=\bigcup_{i=1}^{n}\left\{ w\sigma\ \|\ w\in L_{q,q_{i}}^{k-1}\wedge\delta\left(q_{i},\sigma\right)=p\right\} \){:/nomarkdown}. במילים: {::nomarkdown}\( L_{q,p}^{k}\){:/nomarkdown} כוללת את כל המילים מהצורה {::nomarkdown}\( w\sigma\){:/nomarkdown} כך ש-{::nomarkdown}\( w\){:/nomarkdown} היא מאורך {::nomarkdown}\( k-1\){:/nomarkdown} ומעבירה את האוטומט מ-{::nomarkdown}\( q\){:/nomarkdown} אל מצב {::nomarkdown}\( q_{i}\){:/nomarkdown} כלשהו, ואילו {::nomarkdown}\( \sigma\){:/nomarkdown} מעבירה אותנו מ-{::nomarkdown}\( q_{i}\){:/nomarkdown} אל {::nomarkdown}\( p\){:/nomarkdown}.

זה לא עובד. זה רעיון נחמד, אבל זה לא עובד. לא בגלל שזה לא נכון, אלא בגלל המשוואה הזו: {::nomarkdown}\( L_{q,p}=\bigcup_{k=0}^{\infty}L_{q,p}^{k}\){:/nomarkdown}. כתבתי בכוונה את המשוואה הזו בצורה מטעה. אם נלך על פי ההגדרות היבשות שנתתי קודם, הרי ש-{::nomarkdown}\( \bigcup_{k=0}^{\infty}L_{q,p}^{k}\){:/nomarkdown} היא בעצם {::nomarkdown}\( L_{p,q}^{*}\){:/nomarkdown} וזה כמובן לא נכון, כי ה-{::nomarkdown}\( k\){:/nomarkdown} שמופיע ב-{::nomarkdown}\( L_{q,p}^{k}\){:/nomarkdown} הוא לא חזקה של שפה - הוא בסך הכל חלק מהסימון שאני משתמש בו. אני בכוונה מנסה להטעות אתכם ככה כדי להכריח אתכם לחשוב קצת ולהבין מה השתבש כאן. זה חשוב.

אם כן, המשוואה {::nomarkdown}\( L_{q,p}=\bigcup_{k=0}^{\infty}L_{q,p}^{k}\){:/nomarkdown} היא אמנם נכונה לגמרי, אבל היא מציגה את {::nomarkdown}\( L_{q,p}\){:/nomarkdown} בתור איחוד אינסופי של שפות - ואיחוד אינסופי שכזה הוא לא בהכרח רגולרי גם אם השפות המעורבות רגולריות. לכן כל הגישה שלנו של לפרק את {::nomarkdown}\( L_{q,p}\){:/nomarkdown} על פי אורך המילה נידונה לכישלון - אורכי המילים הם לא חסומים ולכן בהכרח נקבל איחודים אינסופיים בעייתיים.

אז חזרה אל שולחן השרטוט ואל השאלה הבסיסית שלנו - מה <strong>כן</strong> חסום כאן? והתשובה ברורה - מספר המצבים של האוטומט {::nomarkdown}\( A\){:/nomarkdown}, שהוא בדיוק {::nomarkdown}\( n\){:/nomarkdown}. אבל איך אפשר להשתמש בזה כדי לפשט את {::nomarkdown}\( L_{q,p}\){:/nomarkdown}?

אנחנו רוצים איכשהו <strong>להגביל</strong> את המילים ב-{::nomarkdown}\( L_{q,p}\){:/nomarkdown} ולקחת רק חלק מהן. קודם הגבלנו על פי אורך. עכשיו אני רוצה להגביל איכשהו על פי מצבי האוטומט. אני יודע שהמילים ב-{::nomarkdown}\( L_{q,p}\){:/nomarkdown} מעבירות את האוטומט מ-{::nomarkdown}\( q\){:/nomarkdown} אל {::nomarkdown}\( p\){:/nomarkdown}, אז איך שאר מצבי האוטומט יכולים להיכנס לתמונה? מתי הם רלוונטיים? ובכן, בדיוק כשאנחנו מסתכלים על <strong>המסלול</strong> שמעביר אותנו מ-{::nomarkdown}\( q\){:/nomarkdown} אל {::nomarkdown}\( p\){:/nomarkdown}. אם אני רוצה <strong>להגביל</strong>, מה אני יכול לעשות? לי נראה ברור (כי ברור שהכל נראה לי ברור בדיעבד, כשאני כבר מכיר את ההוכחה...) שהדרך הנכונה להגביל היא <strong>לאסור</strong> על מעבר במצבים מסויימים. אפשר להמשיך עם המשחק הזה עוד קצת, אבל אני מאמין שמכאן ועד להגדרה הנכונה זה בעיקר ניסוי וטעיה וגישוש, אז הנה אתן את ההגדרה המרכזית כאן, שפותרת את הכל:

אני אגדיר את {::nomarkdown}\( L_{q,p}^{k}\){:/nomarkdown} (כאשר שוב, ה-{::nomarkdown}\( k\){:/nomarkdown} הזה <strong>הוא לא</strong> חזקה, הוא סתם סימון) להיות שפת כל המילים שמעבירות את האוטומט מ-{::nomarkdown}\( q\){:/nomarkdown} אל {::nomarkdown}\( p\){:/nomarkdown}, באופן כזה שהמסלול מ-{::nomarkdown}\( q\){:/nomarkdown} אל {::nomarkdown}\( p\){:/nomarkdown} לא עובר באף מצב שהאינדקס שלו גדול מ-{::nomarkdown}\( k\){:/nomarkdown}. דגש על המילה <strong>עובר</strong>: האוטומט יכול <strong>להתחיל</strong> או <strong>לסיים</strong> את המסלול במצב שהאינדקס שלו גדול מ-{::nomarkdown}\( k\){:/nomarkdown}. כלומר, מותר ל-{::nomarkdown}\( q\){:/nomarkdown} או {::nomarkdown}\( p\){:/nomarkdown} עצמם להיות בעלי אינדקס גדול מ-{::nomarkdown}\( k\){:/nomarkdown}, כל עוד הם מופיעים רק בהתחלה ובסוף ולא בתוך המסלול בעצמם.

ומכיוון שאי אפשר רק עם הגדרה מילולית, הנה הגדרה פורמלית:

{::nomarkdown}\( L_{q,p}^{k}\triangleq\left\{ w\in\Sigma^{*}\ \|\ \hat{\delta}\left(q,w\right)=p\wedge\forall u\ne\varepsilon,w:w=uv\wedge\hat{\delta}\left(q,u\right)=q_{i}\Rightarrow i\le k\right\} \){:/nomarkdown}

ההגדרה הזו אומרת - כל המילים {::nomarkdown}\( w\in\Sigma^{*}\){:/nomarkdown} כך שקודם כל, {::nomarkdown}\( w\){:/nomarkdown} מעבירה את האוטומט מ-{::nomarkdown}\( q\){:/nomarkdown} אל {::nomarkdown}\( p\){:/nomarkdown}; וחוץ מזה, לכל פירוק {::nomarkdown}\( w=uv\){:/nomarkdown} לא טריוויאלי (כלומר, ש-{::nomarkdown}\( u\){:/nomarkdown} היא לא ריקה או לא כל {::nomarkdown}\( w\){:/nomarkdown}), המצב שאליו מגיעים מ-{::nomarkdown}\( q\){:/nomarkdown} אחרי קריאת {::nomarkdown}\( u\){:/nomarkdown} הוא בעל אינדקס קטן או שווה ל-{::nomarkdown}\( k\){:/nomarkdown}.

זהו זה. ההגדרה הזו פותרת את הכל. עד כדי כך שאני ממליץ לכם לא לנסות להמשיך לקרוא את ההוכחה אלא לנסות להמשיך להוכיח בעצמכם לפי שתיגשו לקרוא את המשך ההוכחה שלי.

המשך ההוכחה הוא זה: אני הולך להוכיח באופן אינדוקטיבי שכל השפות {::nomarkdown}\( L_{q,p}^{k}\){:/nomarkdown} הן נוצרות אינדוקטיבית מקבוצות הבסיס באמצעות פעולות הסגור (עבור {::nomarkdown}\( p,q\in Q\){:/nomarkdown} כלשהם ו-{::nomarkdown}\( 0\le k\le n\){:/nomarkdown}). זה יסיים את ההוכחה בגלל שברור לחלוטין ש-{::nomarkdown}\( L_{q,p}^{n}=L_{q,p}\){:/nomarkdown} (כי אם המגבלה שלנו על המילים ב-{::nomarkdown}\( L_{q,p}\){:/nomarkdown} היא "בקריאה שלכן אסור לעבור במצב עם אינדקס גדול מ-{::nomarkdown}\( n\){:/nomarkdown}" והאינדקס הגדול ביותר של מצב באוטומט הוא {::nomarkdown}\( n\){:/nomarkdown}, אין מגבלה). האינדוקציה תהיה על {::nomarkdown}\( k\){:/nomarkdown}.

נתחיל מ-{::nomarkdown}\( k=0\){:/nomarkdown}. במקרה הזה, {::nomarkdown}\( L_{q,p}^{k}\){:/nomarkdown} היא שפה מוגבלת במיוחד. מכיוון שבחרתי שהאינדקס של מצב באוטומט שלי יתחיל מ-1 (ו<strong>זו</strong> הסיבה שבגללה בחרתי את הבחירה הזו, אחרת הייתי צריך להתחיל מ-{::nomarkdown}\( k=-1\){:/nomarkdown}) הרי ש-{::nomarkdown}\( L_{q,p}^{0}\){:/nomarkdown} היא שפת כל המילים {::nomarkdown}\( w\){:/nomarkdown} שקריאתן מעבירה את {::nomarkdown}\( q\){:/nomarkdown} ל-{::nomarkdown}\( p\){:/nomarkdown} <strong>בלי מצבי ביניים בכלל</strong>. כלומר, מעבירה בלכל היותר צעד אחד. זה מראה מייד ש-{::nomarkdown}\( L_{q,p}^{0}\){:/nomarkdown} היא איחוד סופי של שפות בסיס שלנו, או שהיא {::nomarkdown}\( \emptyset\){:/nomarkdown} שגם היא שפת בסיס. אבל אני ארחיב קצת עבור מי שלא רואה את זה.

ראשית, שימו לב לכך ש-{::nomarkdown}\( q=p\){:/nomarkdown} אם ורק אם {::nomarkdown}\( \varepsilon\in L_{q,p}^{0}\){:/nomarkdown} (כי {::nomarkdown}\( \hat{\delta}\left(q,\varepsilon\right)=q\){:/nomarkdown} - כך זה הוגדר). כמו כן, לכל {::nomarkdown}\( \sigma\in\Sigma\){:/nomarkdown} מתקיים ש-{::nomarkdown}\( \delta\left(q,\sigma\right)=p\){:/nomarkdown} אם ורק אם {::nomarkdown}\( \sigma\in L_{q,p}^{0}\){:/nomarkdown}. זה אומר שאפשר לכתוב את השפה שלנו בקיצור בתור:

{::nomarkdown}\( L_{q,p}^{0}=\left\{ \tau\in\Sigma\cup\left\{ \varepsilon\right\} \ \|\ \hat{\delta}\left(q,\tau\right)=p\right\} =\bigcup_{\hat{\delta}\left(q,\tau\right)=p}\left\{ \tau\right\} \){:/nomarkdown}

מכיוון ש-{::nomarkdown}\( \tau\in\Sigma\cup\left\{ \varepsilon\right\} \){:/nomarkdown}, כל שפה מהצורה {::nomarkdown}\( \left\{ \tau\right\} \){:/nomarkdown} היא אחת משפות הבסיס שלנו. ואם יוצא ש-{::nomarkdown}\( L_{q,p}^{0}=\emptyset\){:/nomarkdown} גם זה בסדר כי גם {::nomarkdown}\( \emptyset\){:/nomarkdown} היא אחת משפות הבסיס שלנו. וזה כמובן לא מקרי - זו הסיבה שבגללה בחרנו את שפות הבסיס הללו.

סיימנו עם בסיס האינדוקציה שלנו. כעת לאקשן האמיתי: נניח שכל השפות {::nomarkdown}\( L_{q,p}^{k-1}\){:/nomarkdown} עבור {::nomarkdown}\( q,p\in Q\){:/nomarkdown} כלשהם הן אינדוקטיביות (נוצרו מקבוצות הבסיס על ידי פעולות הסגור) ונוכיח ש-{::nomarkdown}\( L_{q,p}^{k}\){:/nomarkdown} הן כאלו. כלומר, ניקח {::nomarkdown}\( q,p\in Q\){:/nomarkdown} כלשהם ונראה איך אפשר "לבנות" את {::nomarkdown}\( L_{q,p}^{k}\){:/nomarkdown} מתוך שפות עם {::nomarkdown}\( k-1\){:/nomarkdown} למעלה, בעזרת פעולות הסגור.

נתחיל בשאלה המתבקשת - מה ההבדל בין {::nomarkdown}\( L_{q,p}^{k}\){:/nomarkdown} ובין {::nomarkdown}\( L_{q,p}^{k-1}\){:/nomarkdown}? ברור ש-{::nomarkdown}\( L_{q,p}^{k-1}\subseteq L_{q,p}^{k}\){:/nomarkdown}; רק צריך להבין מי המילים ב-{::nomarkdown}\( L_{q,p}^{k}\){:/nomarkdown} שלא נמצאות ב-{::nomarkdown}\( L_{q,p}^{k-1}\){:/nomarkdown}. על פי הגדרה, אלו כל המילים שלא עוברות באף מצב ביניים עם אינדקס גדול מ-{::nomarkdown}\( k\){:/nomarkdown}, אבל <strong>כן </strong>עוברות במצב ביניים עם אינדקס גדול מ-{::nomarkdown}\( k-1\){:/nomarkdown} - כלומר, אלו בדיוק המילים שעוברות במצב {::nomarkdown}\( q_{k}\){:/nomarkdown} לפחות פעם אחת.

עכשיו, בואו נניח ש-{::nomarkdown}\( w\in L_{q,p}^{k}\){:/nomarkdown} היא מילה שמעבירה את {::nomarkdown}\( q\){:/nomarkdown} ל-{::nomarkdown}\( p\){:/nomarkdown} ועוברת ב-{::nomarkdown}\( q_{k}\){:/nomarkdown} <strong>בדיוק</strong> פעם אחת (ובשאר הזמן היא עוברת רק במצבים עם אינדקס קטן יותר). זה אומר שאפשר לפרק אותה כך - {::nomarkdown}\( w=uv\){:/nomarkdown} כך ש-{::nomarkdown}\( u\){:/nomarkdown} מעבירה את {::nomarkdown}\( q\){:/nomarkdown} אל {::nomarkdown}\( q_{k}\){:/nomarkdown} ואילו {::nomarkdown}\( v\){:/nomarkdown} מעבירה את {::nomarkdown}\( q_{k}\){:/nomarkdown} אל {::nomarkdown}\( p\){:/nomarkdown}, ובשני המקרים הללו לא עוברים במצב ביניים עם אינדקס גדול מ-{::nomarkdown}\( k-1\){:/nomarkdown} - כי בכל {::nomarkdown}\( w\){:/nomarkdown} לא עוברים במצב ביניים עם אינדקס גדול מ-{::nomarkdown}\( k\){:/nomarkdown}, וכי <strong>בתוך</strong> הריצה של {::nomarkdown}\( u\){:/nomarkdown} ושל {::nomarkdown}\( v\){:/nomarkdown} לא מופיע {::nomarkdown}\( q_{k}\){:/nomarkdown}, אלא רק ב<strong>קצוות</strong> של הריצה הזו (בסיום הריצה על {::nomarkdown}\( u\){:/nomarkdown} ובתחילת הריצה על {::nomarkdown}\( v\){:/nomarkdown}. מכאן ש-{::nomarkdown}\( v\in L_{q,q_{k}}^{k-1}\){:/nomarkdown} ואילו {::nomarkdown}\( u\in L_{q_{k},p}^{k-1}\){:/nomarkdown}.

המקרה הזה היה פשוט יחסית. בואו נעבור לרמת הסיבוך הבאה: נניח ש-{::nomarkdown}\( w\in L_{q,p}^{k}\){:/nomarkdown} היא מילה שמעבירה את {::nomarkdown}\( q\){:/nomarkdown} ל-{::nomarkdown}\( p\){:/nomarkdown} ועוברת ב-{::nomarkdown}\( q_{k}\){:/nomarkdown} בדיוק <strong>פעמיים</strong>. עכשיו אפשר לפרק את {::nomarkdown}\( w\){:/nomarkdown} כך: {::nomarkdown}\( w=uzv\){:/nomarkdown} כך ש-{::nomarkdown}\( v\in L_{q,q_{k}}^{k-1}\){:/nomarkdown} ואילו {::nomarkdown}\( u\in L_{q_{k},p}^{k-1}\){:/nomarkdown}. ומה עם {::nomarkdown}\( z\){:/nomarkdown}? ובכן, הוא מייצג את החלק בריצה שבין ההגעה הראשונה ל-{::nomarkdown}\( q_{k}\){:/nomarkdown} ובין ההגעה השניה ל-{::nomarkdown}\( q_{k}\){:/nomarkdown}, כלומר {::nomarkdown}\( z\in L_{q_{k},q_{k}}^{k-1}\){:/nomarkdown}.

ועכשיו בואו נניח ש-{::nomarkdown}\( w\in L_{q,p}^{k}\){:/nomarkdown} היא מילה שמעבירה את {::nomarkdown}\( q\){:/nomarkdown} ל-{::nomarkdown}\( p\){:/nomarkdown} ועוברת ב-{::nomarkdown}\( q_{k}\){:/nomarkdown} בדיוק <strong>שלוש פעמיים</strong>. עכשיו אפשר לפרק את {::nomarkdown}\( w\){:/nomarkdown} בתור {::nomarkdown}\( w=uz_{1}z_{2}v\){:/nomarkdown} כאשר {::nomarkdown}\( z_{1},z_{2}\in L_{q_{k},q_{k}}^{k-1}\){:/nomarkdown}.כבר הבנתם לאן אני חותר? אם לא, בואו נדבר על מילה שעוברת ב-{::nomarkdown}\( q_{k}\){:/nomarkdown} בדיוק <strong>ארבע</strong> פעמים - עכשיו נפרק אותה בתור {::nomarkdown}\( uz_{1}z_{2}z_{3}v\){:/nomarkdown} כאשר {::nomarkdown}\( z_{1},z_{2},z_{3}\in L_{q_{k},q_{k}}^{k-1}\){:/nomarkdown}. ובאופן כללי? באופן כללי זה מסורבל מדי לכתוב את כל ה-{::nomarkdown}\( z\){:/nomarkdown}-ים הללו, ולכן אפשר להשתמש ב<strong>חזקה של שפה</strong>: אם {::nomarkdown}\( w\in L_{q,p}^{k}\){:/nomarkdown} היא מילה שמעבירה את {::nomarkdown}\( q\){:/nomarkdown} ל-{::nomarkdown}\( p\){:/nomarkdown} ועוברת ב-{::nomarkdown}\( q_{k}\){:/nomarkdown} בדיוק {::nomarkdown}\( t\){:/nomarkdown} פעמים, אז אפשר לפרק אותה כך: {::nomarkdown}\( w=uzv\){:/nomarkdown} כך ש-{::nomarkdown}\( z\in\left(L_{q_{k},q_{k}}^{k-1}\right)^{t-1}\){:/nomarkdown}. הפעם ה-{::nomarkdown}\( t-1\){:/nomarkdown} שמופיע למעלה הוא לא אינדקס אלא כן בא על תקן חזקה של שפה.

מה המסקנה? כדי לתאר את כל המילים ב-{::nomarkdown}\( w\in L_{q,p}^{k}\backslash L_{q,p}^{k-1}\){:/nomarkdown} אנחנו רוצים לתאר את כל המילים שהן <strong>שרשור</strong> של מילה אחת מתוך {::nomarkdown}\( L_{q,q_{k}}^{k-1}\){:/nomarkdown}, מילה אחת מתוך {::nomarkdown}\( L_{q_{k},p}^{k-1}\){:/nomarkdown}, וביניהן מילה אחת מתוך אחת מהחזקות האפשריות של {::nomarkdown}\( L_{q_{k},q_{k}}^{k-1}\){:/nomarkdown} - כל חזקה אפשרית. האם אנחנו מכירים פעולה שנותנת לנו את זה? בוודאי - זו <strong>בדיוק</strong> הפעולה של סגור-קלייני! אמרתי לכם שנבין סוף סוף למה <strong>בדיוק</strong> צריך את הפעולה הזו? הנה, זו הנקודה המדוייקת שבה היא צצה מעצמה.

נסכם. קיבלנו את המשוואה {::nomarkdown}\( L_{q,p}^{k}=L_{q,p}^{k-1}\cup L_{q,q_{k}}^{k-1}\left(L_{q_{k},q_{k}}^{k-1}\right)^{*}L_{q_{k},p}^{k-1}\){:/nomarkdown}, והמשוואה הזו מסיימת את ההוכחה, כי היא מתארת את היצירה של {::nomarkdown}\( L_{q,p}^{k}\){:/nomarkdown} מתוך שפות שאנחנו כבר יודעים ששייכות לקבוצה האינדוקטיבית שלנו, בעזרת פעולות הסגור שלנו (איחוד, שרשור וסגור-קלייני). בדרך כלל אני לא נוהג להתלהב ממשוואות כי זו לא הפואנטה במתמטיקה, אבל את המשוואה הזו אני אוהב בגלל הסיפור הציורי שהיא מספרת (כל הקטע הזה של "עובר ב-{::nomarkdown}\( q_{k}\){:/nomarkdown} בדיוק כך-וכך פעמים"). אני מקווה שאתם מסכימים.
