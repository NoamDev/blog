---
id: 3201
title: "שפות רגולריות - תכונות סגור (חלק ב')"
date: 2014-12-21 12:20:11
layout: post
categories: 
  - תורת הסיבוכיות
tags: 
  - שפות רגולריות
---
בפוסט הקודם דיברתי על תכונות סגור יחסית סטנדרטיות של שפות רגולריות (עם החריג של פעולת סגור קלייני, שהייתי צריך לתת לה מוטיבציה מורכבת כלשהי). עכשיו בואו נעבור לתכונת סגור שונה לגמרי - <strong>הומומורפיזם</strong>. המילה הזו בטח מוכרת לכל מי שעשה קורס באלגברה מופשטת, וספציפית בתורת החבורות. הומומורפיזם בין שתי חבורות הוא פונקציה $latex h:G\to H$ המקיימת $latex h\left(ab\right)=h\left(a\right)h\left(b\right)$ - כלומר, היא <strong>מכבדת</strong> את פעולות הכפל של החבורות (או, אם תרצו, <strong>משמרת את המבנה</strong> של החבורה). מונואיד, אמרנו, הוא "כמעט כמו חבורה" ולכן אין מניעה להגדיר הומומורפיזמים בצורה זהה עבורו. אם כן, בהינתן שני אלפביתים $latex \Sigma,\Delta$, נגדיר הומומורפיזם בתור פונקציה $latex h:\Sigma^{*}\to\Delta^{*}$ שמקיימת $latex h\left(uv\right)=h\left(u\right)h\left(v\right)$ לכל זוג מילים $latex u,v\in\Sigma^{*}$.

חיש קל מתברר שאם $latex h$ היא הומומורפיזם, אז מספיק לדעת את הערכים שלה על אברי $latex \Sigma$ כדי לדעת מה היא תחזיר לכל איבר שהוא. הרי אם $latex w=\sigma_{1}\dots\sigma_{n}$ היא מילה כלשהי, אז $latex h\left(w\right)=h\left(\sigma_{1}\dots\sigma_{n}\right)=h\left(\sigma_{1}\right)\cdots h\left(\sigma_{n}\right)$. לכן זה האופן שבו מגדירים הומומורפיזם - פונקציה $latex h:\Sigma\to\Delta^{*}$ שאחר כך כבר מורחבת באופן טבעי לכל $latex \Sigma^{*}$. איבר אחד שאולי לא ברור לגמרי איך להרחיב את $latex h$ עליו הוא המילה הריקה $latex \varepsilon$; אבל מכיוון ש-$latex h\left(\varepsilon\right)=h\left(\varepsilon\cdot\varepsilon\right)=h\left(\varepsilon\right)\cdot h\left(\varepsilon\right)$ הרי שמשיקולי אורך נטו ($latex \left|h\left(\varepsilon\right)\right|=2\left|h\left(\varepsilon\right)\right|$) כבר ברור שבהכרח $latex h\left(\varepsilon\right)=\varepsilon$.

כעת, הטענה שלי היא שהומומורפיזם הוא תכונת סגור - דהיינו, שהתמונה של כל שפה רגולרית תחת הומומורפיזם היא שפה רגולרית. כזכור, מסמנים $latex h\left(L\right)=\left\{ h\left(w\right)\ |\ w\in L\right\} $ (זה המושג הרגיל של תמונה של קבוצה תחת פונקציה). איך אני אוכיח שזו אכן תכונת סגור? ובכן, יש לי כעת כלי נשק חזק - אני מכיר את <strong>המבנה האינדוקטיבי</strong> של קבוצת השפות הרגולרית, וזה מאפשר לי להוכיח עליה דברים <strong>באינדוקציית מבנה</strong>. מספיק שאוכיח שהטענה נכונה עבור אברי הבסיס ושהיא משתמרת עבור פעולות היצירה.

אברי הבסיס של קבוצת השפות הרגולריות כוללים את $latex \emptyset$ - וכמובן ש-$latex h\left(\emptyset\right)=\emptyset$ ולכן התמונה של $latex \emptyset$ רגולרית; כוללים את $latex \left\{ \varepsilon\right\} $ וכמובן ש-$latex h\left(\left\{ \varepsilon\right\} \right)=\left\{ \varepsilon\right\} $ רגולרית; וכוללים את $latex \left\{ \sigma\right\} $ לכל $latex \sigma\in\Sigma$ וכמובן ש-$latex h\left(\left\{ \sigma\right\} \right)=\left\{ h\left(\sigma\right)\right\} $ רגולרית (כי סינגלטון הוא שפה סופית ולכן רגולרית). נשאר לטפל בפעולות היצירה.

ניקח אם כן שפות $latex L_{1},L_{2}$ ונניח שהן רגולריות ושמתקיים שגם $latex h\left(L_{1}\right),h\left(L_{2}\right)$ רגולריות. כעת שימו לב לכך ש-$latex h\left(L_{1}\cup L_{2}\right)=h\left(L_{1}\right)\cup h\left(L_{2}\right)$ ומכאן שגם $latex h\left(L_{1}\cup L_{2}\right)$ רגולרית; ושמתקיים $latex h\left(L_{1}\cdot L_{2}\right)=h\left(L_{1}\right)\cdot h\left(L_{2}\right)$ ומכאן שגם $latex h\left(L_{1}\cdot L_{2}\right)$ רגולרית; ושמתקיים $latex h\left(L_{1}^{*}\right)=\left(h\left(L_{1}\right)\right)^{*}$ ולכן גם $latex h\left(L_{1}^{*}\right)$ רגולרית - כלומר, פעולות היצירה משמרות את התכונה "$latex h$ מעבירה שפה רגולרית לשפה רגולרית". מן הסתם צריך להוכיח ה"שימו לב שמתקיים"-ים שלי אבל זה תרגיל טוב עבורכם.

את ההוכחה הזו ניתן להכליל בלי קושי גם עבור תכונת סגור יותר מופרעת - <strong>הצבה</strong>. הצבה דומה להומומורפיזם, רק שבמקום ש-$latex h$ תחזיר <strong>מילה</strong> על כל אות, היא מחזירה <strong>שפה</strong>. השוויון $latex h\left(w\right)=h\left(\sigma_{1}\right)\cdots h\left(\sigma_{n}\right)$ הוא עדיין בעל משמעות עבור הצבה שכזו שכן אנחנו יודעים לשרשר שפות, ולכן ברור איך הצבה מוגדרת למילים. ועבור שפות? $latex h\left(L\right)=\bigcup_{w\in L}h\left(w\right)$.

כעת, ההוכחה עבור הומומורפיזם עוברת כמעט אחד-לאחד עבור הצבות. מה יכול להשתבש? בדיוק דבר אחד- $latex h\left(\left\{ \sigma\right\} \right)$ אינו הסינגלטון $latex \left\{ h\left(\sigma\right)\right\} $; הוא <strong>שפה כלשהי</strong> (הרי את $latex h$ על $latex \sigma$ ניתן להגדיר איך שבא לנו). אם כן, ברור מה הדרישה שאנחנו חייבים לדרוש - ש-$latex h$ תחזיר לכל $latex \sigma$ לא סתם שפה, אלא שפה רגולרית. להצבה שעושה את זה קוראים <strong>הצבה רגולרית</strong> ומה שראינו הוא שהצבה רגולרית שכזו היא תכונת סגור של שפות רגולריות.

הומומורפיזם הוא בעצם מקרה פרטי של הצבה שבו ההצבה מחזירה סינגלטון לכל אות. אז למה טרחתי לדבר על הומומורפיזם לבד? כי יש לי עניין גם במה שנקרא <strong>ההומומורפיזם ההפוך</strong>. באופן כללי, הומומורפיזם לא בהכרח יהיה חח"ע ועל, ולכן לא יהיה הפיך בתור פונקציה, אבל זה לא מונע מאיתנו לדבר על <strong>המקור</strong> של שפה כלשהי תחת ההומומורפיזם. פורמלית, אם $latex h:\Sigma^{*}\to\Delta^{*}$ הוא הומומורפיזם, ו-$latex L\subseteq\Delta^{*}$ אז מגדירים $latex h^{-1}\left(L\right)\triangleq\left\{ w\in\Sigma^{*}\ |\ h\left(w\right)\in L\right\} $. כצפוי, אני רוצה לטעון שזו תכונת סגור, אבל בואו נראה קודם כל שימוש קלאסי בתכונת הסגור הזו כדי להבין למה היא כל כך מעניינת.

נניח ש-$latex L$ היא שפה רגולרית מעל $latex \Sigma$, ואני רוצה מסיבות השמורות עמי להתעסק עם השפה שמתקבלת מ-$latex L$ על ידי לקיחת כל מילה ב-$latex L$ מאורך זוגי והסרה של כל האותיות במקומות האי-זוגיים שלה. כלומר, אני רוצה לטפל בשפה $latex \left\{ \sigma_{2}\sigma_{4}\dots\sigma_{2n}\ |\ \exists\sigma_{1},\dots,\sigma_{2n-1}:\sigma_{1}\sigma_{2}\dots\sigma_{2n}\in L\right\} $. איך אני מראה שהשפה הזו רגולרית? אפשר עם אוטומט מחוכם שמבצע סימולציה של האוטומט עבור $latex L$ ו"מנחש" את האותיות במקומות האי-זוגיים, אבל יש דרך הרבה יותר פשוטה לקבל את השפה הזו מתוך $latex L$ באמצעות תכונות סגור, מרגע שהתרגלנו כבר לעבוד עם תכונות הסגור הללו. מה שאני ארצה לעשות הוא לקחת את המילים של $latex L$ שהן מאורך זוגי ולשים איכשהו סימון - "תג" - על כל אות במקום אי-זוגי. ואז להפעיל הומומורפיזם שמוחק את כל האותיות עם תגים ולא נוגע באחרות. עיקר העבודה כאן היא לבצע את התיוג הזה, ובשביל זה אשתמש בהומומורפיזם הפוך.

פורמלית, בואו ניקח את האלפבית $latex \Sigma$ ונגדיר לו אלפבית מקביל של "אותיות עם תג" - $latex \Sigma^{\prime}=\left\{ \sigma^{\prime}\ |\ \sigma\in\Sigma\right\} $. כעת, נגדיר הומומורפיזם $latex h:\left(\Sigma\cup\Sigma^{\prime}\right)^{*}\to\Sigma^{*}$ שמוגדר באופן הבא: $latex h\left(\sigma\right)=h\left(\sigma^{\prime}\right)=\sigma$. כלומר, ההומומורפיזם פשוט מסיר תגים מהמילה (מבלי למחוק את האותיות עם התגים!)

זה נראה כמו הומומורפיזם מטופש ולא מעניין, וזה נכון; מה שמעניין הוא ההומומורפיזם ההפוך. תחשבו על זה קצת ותראו ש-$latex h^{-1}\left(L\right)$ הוא "כל המילים מתוך $latex L$ כשכל מילה מופיעה עם כל קומבינציות התגים האפשריות עליה" (למשל: מתוייגת כולה; לא מתוייגת בכלל; כל מקום אי זוגי מתוייג; וכו' וכו').

כרגע יש <strong>יותר מדי</strong> תיוגים על המילים בשפה שקיבלנו, אבל זו לא בעיה - כדי להתמקד רק על התיוג שאנחנו רוצים, אפשר לבצע חיתוך עם שפה רגולרית אחרת: $latex h^{-1}\left(L\right)\cap\left(\Sigma^{\prime}\Sigma\right)^{*}$ זו בדיוק שפת כל המילים מ-$latex L$ שהן מאורך זוגי ומכילות תגים על המקומות האי זוגיים (למה השפה הימנית בחיתוך היא רגולרית? מתכונות הסגור שכבר ראינו).

כעת כל שנותר לעשות הוא להגדיר הומומורפיזם נוסף, $latex g:\left(\Sigma\cup\Sigma^{\prime}\right)^{*}\to\Sigma^{*}$ על ידי $latex g\left(\sigma\right)=\sigma$ ו-$latex g\left(\sigma^{\prime}\right)=\varepsilon$. כלומר, הומומורפיזם שמוחק את האותיות המתוייגות. כעת $latex g\left(h^{-1}\left(L\right)\cap\left(\Sigma^{\prime}\Sigma\right)^{*}\right)$ היא בדיוק השפה המבוקשת. תעלול התיוג הסטנדרטי פותר עוד תרגילים דומים בצורה נחמדה.

עכשיו בואו נראה שהומומורפיזם הפוך הוא תכונת סגור. אני אעשה את זה בדרך הסטנדרטית: אקח אוטומט $latex A$ עבור השפה $latex L$ ואבנה אוטומט $latex A^{\prime}$ עבור $latex h^{-1}\left(L\right)$. מכיוון שהבניה פשוטה בצורה קיצונית אני אציג אותה בצורה פורמלית. אבל קודם - הרעיון. יש לנו הומומורפיזם $latex h:\Sigma\to\Delta$. יש לנו שפה $latex L\subseteq\Delta^{*}$ (שימו לב - השפה לא מעל $latex \Sigma^{*}$ כמו בדרך כלל). כעת אנו מקבלים מילה $latex w\in\Sigma^{*}$ וצריכים לקבוע האם $latex h\left(w\right)\in L$. איך נעשה את זה? מן הסתם, סימולציה של האוטומט $latex A$ עבור השפה $latex L$, אבל סימולציה שלו על מה? על הקלט $latex h\left(w\right)$.

בואו נציג שניה את $latex w$ כשרשור אותיות: $latex w=\sigma_{1}\sigma_{2}\dots\sigma_{n}$. אז אנחנו יודעים ש-$latex h\left(w\right)=h\left(\sigma_{1}\right)\dots h\left(\sigma_{n}\right)$. מכאן שהגיוני שהסימולציה שלנו תתנהל כך: קודם כל נקרא את $latex \sigma_{1}$ מתוך הקלט האמיתי שלנו, ואז נבצע סימולציה של $latex A$ על $latex h\left(\sigma_{1}\right)$. אחר כך נקרא את $latex \sigma_{2}$ ונמשיך את הסימולציה של $latex A$, הפעם על $latex h\left(\sigma_{2}\right)$ וכן הלאה. בסוף נקבל אם ורק אם $latex A$ קיבלה. פשוט!

אם כן, פורמליזם. נסמן $latex A=\left(\Delta,Q,q_{0},\delta,F\right)$, וכעת נבנה את האוטומט החדש שלנו, $latex A^{\prime}=\left(\Sigma,Q,q_{0},\delta^{\prime},F\right)$ - אותם מצבים, אותו מצב התחלתי, אותם מצבים מקבלים. ההבדלים הם רק בא"ב, כמובן, ובפונקציית המעברים, שמוגדרת כך:

$latex \delta^{\prime}\left(q,\sigma\right)=\hat{\delta}\left(q,h\left(\sigma\right)\right)$

שימו לב שברמת הפורמליזם, אנחנו אפילו לא מבצעים סימולציה של $latex A$ על $latex h\left(\sigma\right)$ - אין לנו צורך ממש להריץ את $latex A$ צעד צעד. אנחנו פשוט קופצים אוטומטית אל המצב שאליו $latex A$ אמורה להגיע אחרי קריאת $latex h\left(\sigma\right)$ - שזה מידע שאנחנו יכולים לבצע "אופליין", לא כחלק מריצת האלגוריתם עצמו.

עדיין לא השתכנעתם שזה עובד? מצויין! הנה לכם תרגיל קל ונחמד - להוכיח שזה עובד. פורמלית.

לפני תכונת הסגור האחרונה שאני רוצה להציג, שיש בה עניין מוזר למדי, אני אקח הפסקה ואדבר על תכונה קלילה במיוחד - היפוך. בהינתן מילה $latex w=\sigma_{1}\sigma_{2}\dots\sigma_{n}$, נגדיר את ההיפוך שלה באופן המתבקש - אותן האותיות אבל בסדר הפוך: $latex w^{R}\triangleq\sigma_{n}\dots\sigma_{2}\sigma_{1}$. הקפיצה להיפוך של שפה היא מיידית: $latex L^{R}=\left\{ w^{R}\ |\ w\in L\right\} $. הטענה היא שהיפוך של שפה רגולרית הוא עדיין שפה רגולרית. איך מוכיחים את זה? אם מדגדג לכם לומר "ניקח אוטומט עבור $latex L$ ופשוט נהפוך את כיווני הקשתות", אתם צודקים. מה שנחמד פה הוא שאם עושים את ההיפוך הזה על אוטומט סופי דטרמיניסטי, רוב הסיכויים שהאוטומט שתקבלו יהיה אי-דטרמיניסטי, אבל כבר ראינו שהמודלים שקולים אז אין עם זה בעיה (אבל זה רק ממחיש כמה חשוב היה לדבר על אוטומט אי-דטרמיניסטי לפני שהתחלנו לדבר על תכונות סגור).

נעבור לתכונה האחרונה, שנקראת "חלוקה" וקצת קשה להסביר אותה. הרעיון הוא כזה: קחו שתי שפות $latex L_{1},L_{2}$. עכשיו, קחו מילה כלשהי מ-$latex L_{1}$. תבדקו אם אפשר לפרק אותה לשני חלקים - רישא וסיפא (רישא - כל האותיות החל מתחילת המילה עד מקום מסויים; סיפא - כל האותיות החל ממקום מסויים במילה ועד סופה), באופן כזה שהסיפא שייכת ל-$latex L_{2}$. אם כן, זרקו את הרישא לסל. התוצאה של פעולת החלוקה היא כל המילים שנכנסות כך לסל. פורמלית:

$latex L_{1}/L_{2}\triangleq\left\{ x\in\Sigma^{*}\ |\ \exists y\in L_{2}:xy\in L_{1}\right\} $

הפעולה הזו נקראת <strong>חלוקה מימין</strong> כי $latex y$ הוא בחלק הימני של המילה. אבל יש גם חלוקה משמאל:

$latex L_{2}\backslash L_{1}\triangleq\left\{ x\in\Sigma^{*}\ |\ \exists y\in L_{2}:yx\in L_{1}\right\} $

אני אדבר רק על חלוקה מימין, כי חלוקה משמאל אפשר לקבל באמצעות היפוך: $latex L_{2}\backslash L_{1}=\left(L_{1}^{R}/L_{2}^{R}\right)^{R}$.

על פניו, אפשר להוכיח שחלוקה מימין היא תכונת סגור באמצעות מה שכבר ראינו. נניח ש-$latex L_{1},L_{2}$ רגולריות. נשתמש בתיוג בעזרת הומומורפיזם הפוך על $latex L_{1}$ ונחתוך עם השפה $latex \Sigma^{*}L_{2}^{\prime}$ (כל המילים שמורכבות מרישא לא מתוייגת כלשהי ומסיפא מתוייגת ב-$latex L_{2}$). נפעיל על התוצאה הומומורפיזם שמוחק אותיות עם תגים, וסיימנו. אז למה בעצם אני מדבר על התכונה הזו בנפרד ולמה אני אומר שיש איתה "עניין מוזר במיוחד"? ובכן, כי אני יכול לעשות יותר ממה שכבר תיארתי - אני טוען שכל עוד $latex L_{1}$ היא רגולרית, אז החלוקה שלה ב-$latex L_{2}$ תהיה רגולרית - <strong>מבלי</strong> שאצטרך את זה ש-$latex L_{2}$ תהיה רגולרית. $latex L_{2}$ יכולה להיות כל שפה שהיא, כולל שפות שהן בכלל לא כריעות (כלומר, אין אלגוריתם שיודע לקבוע, בהינתן מילה, אם היא בשפה או לא - למשל, <a href="http://www.gadial.net/2007/09/26/halting_problem/">בעיית העצירה</a>).

אז מה עושים? נניח ש-$latex A=\left(\Sigma,Q,q_{0},\delta,F\right)$ הוא אוטומט עבור $latex L_{1}$. נבנה אוטומט $latex A^{\prime}$ עבור $latex L_{1}/L_{2}$. הרעיון, כרגיל, יהיה לבצע סימולציה של $latex A$; אנחנו קוראים מילה $latex x$ ומסמלצים עליה את $latex A$. האקשן מגיע כש-$latex x$ נגמרת. בשלב הזה אנחנו עוצרים ושואלים את עצמנו - האם קיימת איזו שהיא $latex y\in L_{2}$ שאני יכול לקרוא <strong>החל מהמקום שהגעתי אליו</strong> ולסיים במצב מקבל?

אם $latex L_{2}$ היא שפה מסובכת, אז לענות לשאלה הזו זה דבר קשה עד בלתי אפשרי. אבל, וזה קטע מבלבל אז תשארו איתי - לשאלה הזו <strong>קיימת תשובה גם אם אנחנו לא יודעים אותה</strong>, ומכך נובע שקיים אוטומט $latex A^{\prime}$ שמתאים לשפת החלוקה גם אם אנחנו לא יודעים מהו.

לפני שתספיקו להתלונן, הנה האוטומט, פורמלית: $latex A^{\prime}=\left(\Sigma,Q,q_{0},\delta,F^{\prime}\right)$. כלומר: אותה קבוצת מצבים, אותו מצב התחלתי ואותה פונקציית מעברים כמו של $latex A$. ההבדל היחיד הוא קבוצת המצבים המקבלים, שמוגדרת כך:

$latex F^{\prime}=\left\{ q\in Q\ |\ \exists y\in L_{2}:\hat{\delta}\left(q,y\right)\in F\right\} $

אין ויכוח על כך שמבחינה מתמטית $latex F^{\prime}$ <strong>קיימת</strong>, ושהיא באמת <strong>מוגדרת היטב</strong> - כלומר, עבור כל $latex q\in Q$ ההגדרה לא מאפשרת לו להיות בו זמנית בתוך ומחוץ ל-$latex F^{\prime}$. העניין הוא שלא תמיד תהיה לנו יכולת למצוא אלגוריתמית את $latex F$. אבל כל העניין הוא שזה לא באמת חשוב: כדי להראות ששפה היא רגולרית אנחנו לא צריכים <strong>למצוא</strong> אוטומט עבור השפה שלה, רק להראות שאוטומט כזה <strong>קיים</strong>. והוכחה פורמלית קצרה תראה ש-$latex F^{\prime}$ שנתתי אכן גורמת לכך ש-$latex L\left(A^{\prime}\right)=L_{1}/L_{2}$.

כהערת אגב, כל שאר תכונות הסגור שהראיתי כאן כן היו קונסטרוקיטיביות, כלומר בהינתן אוטומטים עבור השפות שמתחילים מהן, אני יודע איך לבנות אוטומטים עבור השפות שמתקבלות מפעולות הסגור. יוצאת מן הכלל אחת היא פעולת ההצבה, שבהוכחה עבורה הסתמכתי על כך שאני יודע לתאר כל שפה רגולרית באמצעות פעולות החיבור-שרשור-סגור קלייני מתוך שפות הבסיס (ריקה והסינגלטונים). זה ה"חוב" שנשאר לי, ובפוסט הזה אשלם אותו בשמחה, כי ההוכחה שאראה (שאינה קשה בצורה חריגה אבל יש בה רעיון אחד מבריק) היא אחד מהדברים החביבים עלי בנושא הזה.
