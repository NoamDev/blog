---
id: 2982
title: "פותרים את SAT: המקרים של HORNSAT ו-2SAT"
date: 2013-11-24 16:54:19
layout: post
categories: 
  - לוגיקה
  - מבני נתונים ואלגוריתמים
  - תורת הסיבוכיות
tags: 
  - 2SAT
  - HORNSAT
  - SAT
---
בפוסטים הקודמים דיברתי על בעיית SAT ועל השיטה שבה ניתן להוכיח שפסוק CNF אינו ספיק, אבל כל מה שעשיתי עד כה היה מאוד באוויר - עדיין לא הסברתי איך אפשר בפועל לקחת פסוק CNF ולקבוע אם הוא ספיק או לא.

ובכן, באופן כללי הבעיה היא קשה, לפחות מבחינה תיאורטית, אבל יש <strong>מקרים פרטיים</strong> מסויימים של פסוקי CNF שהם פתירים באופן יעיל, גם מנקודת המבט התיאורטית של זמן הריצה הגרוע ביותר. בפוסט הזה אני רוצה להציג שני מקרים פרטיים שכאלו ואיך פותרים אותם; הרעיונות שנראה כאן יעזרו לנו להבין את הרעיון הכללי של האלגוריתמים לפתרון SAT (בפועל, לא במובן התיאורטי) שאציג בהמשך.

נתחיל עם בעיה שנקראת HORNSAT, על שם הלוגיקאי אלפרד הורן. בבעיה הזו נתון לנו CNF מצורה מיוחדת מאוד: כל פסוקית שלו מכילה לכל היותר ליטרל חיובי אחד - כל יתר הליטרלים הם בשלילה. פסוקית כזו נקראת <strong>פסוקית הורן</strong>. למשל, {::nomarkdown}\( \left(\neg x\vee y\vee\neg z\vee\neg w\right)\){:/nomarkdown} היא פסוקית הורן; גם {::nomarkdown}\( \left(\neg x\vee\neg y\right)\){:/nomarkdown} שאין בה בכלל ליטרלים חיוביים היא פסוקית הורן.

בואו נסתכל לרגע על הפסוקית {::nomarkdown}\( \left(\neg x\vee y\vee\neg z\vee\neg w\right)\){:/nomarkdown}. אם נציב 0 ב-{::nomarkdown}\( x\){:/nomarkdown}, או 0 ב-{::nomarkdown}\( z\){:/nomarkdown}, או 0 ב-{::nomarkdown}\( w\){:/nomarkdown}, זה יספק את הפסוקית. אבל מה יקרה אם נציב 1 בשלושתם? במקרה זה, כדי לספק את הפסוקית אנחנו חייבים להציב 1 ב-{::nomarkdown}\( y\){:/nomarkdown}. כלומר, הפסוקית ממדלת טענה מהצורה "אם {::nomarkdown}\( x,w,z\){:/nomarkdown} מתקיימים כולם אז גם {::nomarkdown}\( y\){:/nomarkdown} מתקיים". פורמלית כותבים את זה כך: {::nomarkdown}\( \left(x\wedge w\wedge z\to y\right)\){:/nomarkdown}. באופן כללי, את הקשר {::nomarkdown}\( \to\){:/nomarkdown} אפשר "לקודד" עם שלילה ו-{::nomarkdown}\( \vee\){:/nomarkdown}: {::nomarkdown}\( \alpha\to\beta\){:/nomarkdown} שקול לוגית ל-{::nomarkdown}\( \neg\alpha\vee\beta\){:/nomarkdown}, ומכאן האופן שבו פסוקית כמו {::nomarkdown}\( \left(x\wedge w\wedge z\to y\right)\){:/nomarkdown} מוצגת כ-CNF. עם זאת, אני חושב שהרבה יותר קל להבין פסוקיות הורן כשחושבים עליהן כעל משהו מהצורה {::nomarkdown}\( \left(x\wedge w\wedge z\to y\right)\){:/nomarkdown}.

איך בודקים את הספיקות של פסוק הורן שכזה? הפתרון פשוט עד להפתיע: באופן איטרטיבי, אם יש משתנה ש<strong>חייב</strong> לקבל 1, מציבים בו 1; אחרת, מציבים 0 בכל המשתנים וסיימנו.

מה זה אומר "חייב" לקבל 1? זה אומר שאם הוא לא מקבל 1, תהיה לנו פסוקית שאינה מסתפקת. אבל כדי שהדרך היחידה לספק פסוקית CNF היא על ידי הצבת 1 במשתנה {::nomarkdown}\( x\){:/nomarkdown} כלשהו, הפסוקית חייבת להיות מהצורה {::nomarkdown}\( \left(x\right)\){:/nomarkdown} (כי אם היה בה ליטרל נוסף, היינו מקבלים דרכים נוספות לספק את הפסוקית). פסוקית כזו נקראת <strong>פסוקית יחידה</strong> (Unit clause).

אם אין בפסוק שלנו אף פסוקית יחידה עם משתנה חיובי, אז הצבה של 0 לכל המשתנים תספק בודאות את כל הפסוקיות. למה? כי בואו ניקח פסוקית כלשהי: היא לא פסוקית יחידה עם משתנה חיובי, ולכן יש בה לפחות משתנה שלילי אחד, או לפחות שני משתנים חיוביים. המקרה השני בלתי אפשרי עבור פסוקיות הורן, כי בפסוקית הורן על פי הגדרה יש לכל היותר ליטרל חיובי אחד. מסקנה: בפסוקית יש ליטרל שלילי אחד לפחות, ובהשמה שנותנת 0 לכל המשתנים הוא יקבל 1. סיימנו.

אם בפסוק שלנו יש פסוקית יחידה עם משתנה חיובי {::nomarkdown}\( x\){:/nomarkdown}, מבצעים את מה שנקרא Unit Propagation ובעברית פשוט אקרא לו "פעפוע": מבחינה רעיונית, אנחנו מציבים 1 ב-{::nomarkdown}\( x\){:/nomarkdown} (כי אין לנו ברירה!). בפועל, אנחנו פשוט מסלקים מה-CNF שלנו את כל הפסוקיות שבהן הופיע הליטרל {::nomarkdown}\( x\){:/nomarkdown} (כי הן סופקו) ומסירים את הליטרל {::nomarkdown}\( \neg x\){:/nomarkdown} מכל הפסוקיות שבהן הוא הופיע (כי {::nomarkdown}\( \neg x\){:/nomarkdown} קיבל את הערך 0 וכבר לא יספק את הפסוקית). אם קיבלנו פסוקית ריקה, הפסדנו; הפסוק לא ספיק. אם קיבלנו פסוק ריק, כלומר סילקנו ממנו את כל הפסוקיות, הצלחנו; מצאנו השמה מספקת (משתנים שהערך שלהם טרם נקבע יכולים להיות בעלי כל אחד משני הערכים האפשריים - זה לא ישנה).

אחרי שגמרנו עם {::nomarkdown}\( x\){:/nomarkdown}, צריך לבדוק אם יש לנו עוד פסוקיות יחידה חיוביות. ייתכן שקודם לא היו כאלו אבל הן נוצרו במהלך הפעפוע (למשל, אם קודם הייתה לנו הפסוקית {::nomarkdown}\( \left(\neg x\vee y\right)\){:/nomarkdown}). אם כן, מפעפעים גם את המשתנה החדש, וכן הלאה וכן הלאה. אם אין עוד פסוקיות יחידה חיוביות, אז כאמור פשוט מציבים 0 בכל המשתנים שנותרו וסיימנו.

האלגוריתם הזה ממש, ממש פשוט. בביצוע נאיבי זמן הריצה שלו הוא {::nomarkdown}\( O\left(n^{2}\right)\){:/nomarkdown}, אבל עם קצת התחכמויות אפשר גם לבצע אותו בזמן לינארי ({::nomarkdown}\( O\left(n\right)\){:/nomarkdown}) מה שאומר שהוא גם יעיל מאוד. זה מעניין, כי מצד שני זו גם בעיה שהיא במובן מסויים "הכי קשה ב-P'' (כאן P מייצג את אוסף הבעיות עם אלגוריתם פולינומי שפותר אותן), במובן זה שכל בעיה אחרת שיש אלגוריתם פולינומי המכריע אותה ניתנת לתרגום ל-HORNSAT תוך שימוש בכמות קטנה יחסית של זכרון - פולי-לוגריתמית (כלומר, כמות זכרון שהיא פולינום בלוגריתם של {::nomarkdown}\( n\){:/nomarkdown}). פורמלית אומרים שזו שפה שהיא P-שלמה (כמו שיש NP-שלמה) ביחס לרדוקציות logspace (ולכן, למשל, אם קיים אלגוריתם שפותר אותה בזכרון פולי-לוגריתמי - לא סביר בכלל - אז לכל שפה ב-P קיים אלגוריתם עם דרישות זכרון מצומצמות שכאלה).

בואו נעבור עכשיו לוריאנט אחר של SAT, שנקרא 2SAT. הפעם אנחנו מרשים לליטרל חיובי להופיע פעמיים בתוך פסוקית, אבל מטילים על הפסוק מגבלה די קשיחה: בכל פסוקית יש <strong>בדיוק</strong> שני ליטרלים (אנחנו מרשים גם פסוקיות כמו {::nomarkdown}\( \left(x\vee x\right)\){:/nomarkdown} שהן בפועל פסוקית עם ליטרל יחיד). ייתכן שהמגבלה הזו נראית לנו קשיחה <strong>מדי</strong>, כי אנחנו מגבילים את המספר המקסימלי של ליטרלים שיכולים להופיע בתוך פסוקית, אבל האינטואיציה שלנו בעייתית בהקשר הזה: וריאנט אחר הוא 3SAT שבו כל פסוקית מכילה בדיוק שלושה ליטרלים, ומסתבר שאפשר לקודד <strong>כל</strong> פסוק CNF כפסוק 3CNF במחיר של הגדלה לא משמעותית (לינארית באורך הכולל של הפסוקיות בפסוק המקורי) של גודל הפסוק. כך שהמגבלה פחות קטלנית מאשר היא נראית במבט ראשון, ועדיין - פסוקי 2CNF הם משמעותית יותר פשוטים ולכן אני יכול להציג אלגוריתם יעיל שבודק את הספיקות שלהם.

הסיבה שבגללה פסוקי 2CNF הם פשוטים ברמה שעוזרת לנו היא שאפשר לחשוב על כל פסוק כזה בתור אוסף אילוצים מהצורה "ליטרל אחד גורר ליטרל אחר". את {::nomarkdown}\( \left(x\vee y\right)\){:/nomarkdown} אפשר לכתוב גם כ-{::nomarkdown}\( \neg x\to y\){:/nomarkdown} וגם כ-{::nomarkdown}\( \neg y\to x\){:/nomarkdown}, כלומר כל פסוקית נותנת לנו שתי גרירות שמערבות ליטרלים. היופי פה הוא שגרירה היא <strong>יחס טרנזיטיבי</strong>: אם {::nomarkdown}\( x\to y\){:/nomarkdown} ו-{::nomarkdown}\( y\to z\){:/nomarkdown} אז גם {::nomarkdown}\( x\to z\){:/nomarkdown} גם אם הם לא מופיעים יחד באף פסוקית (אם תחשבו על זה לרגע, תראו שזה בעצם כלל הרזולוציה בתחפושת: מ-{::nomarkdown}\( \left(\neg x\vee y\right)\){:/nomarkdown} ו-{::nomarkdown}\( \left(\neg y\vee z\right)\){:/nomarkdown} אנו מסיקים את {::nomarkdown}\( \left(\neg x\vee z\right)\){:/nomarkdown}).

עכשיו, נניח שעל ידי שרשרת של הסקות כאלו קיבלנו את הגרירה {::nomarkdown}\( x\to\neg x\){:/nomarkdown}. מה זה אומר? זה אומר שאם {::nomarkdown}\( x\){:/nomarkdown} שווה 1 אז גם {::nomarkdown}\( \neg x\){:/nomarkdown} צריך להיות שווה 1, אבל זה כמובן בלתי אפשרי, והמסקנה היא ש-{::nomarkdown}\( x\){:/nomarkdown} חייב לקבל 0 על ידי כל השמה שאנחנו מקווים שתספק את הפסוק שלנו ({::nomarkdown}\( x\to\neg x\){:/nomarkdown} הוא פשוט הפסוקית {::nomarkdown}\( \left(\neg x\vee\neg x\right)\){:/nomarkdown} בתחפושת, כלומר פסוקית היחידה {::nomarkdown}\( \left(\neg x\right)\){:/nomarkdown}).

ומה קורה אם קיבלנו גם את {::nomarkdown}\( x\to\neg x\){:/nomarkdown} וגם את {::nomarkdown}\( \neg x\to x\){:/nomarkdown}? הגרירה הראשונה מראה ש-{::nomarkdown}\( x\){:/nomarkdown} לא יכול לקבל 1, והשניה מראה ש-{::nomarkdown}\( x\){:/nomarkdown} לא יכול לקבל 0, ולכן המשחק נגמר - הפסוק אינו ספיק. במונחי רזולוציה, קיבלנו את {::nomarkdown}\( \left(x\right),\left(\neg x\right)\){:/nomarkdown} ואחרי רזולוציה לשניהם נקבל את הפסוקית הריקה. אם כן, יש לנו קריטריון להכרעה מתי פסוק 2CNF אינו ספיק: אם קיימת שרשרת גרירות מ-{::nomarkdown}\( x\){:/nomarkdown} אל {::nomarkdown}\( \neg x\){:/nomarkdown} וקיימת שרשרת גרירות מ-{::nomarkdown}\( \neg x\){:/nomarkdown} אל {::nomarkdown}\( x\){:/nomarkdown} עבור משתנה {::nomarkdown}\( x\){:/nomarkdown} כלשהו. מה שיפה כאן הוא שהקריטריון הזה הוא קריטריון של אם ורק אם: אם לאף משתנה אין שתי שרשראות גרירה כאלו, הפסוק ספיק. בואו נוכיח את זה.

בואו ניקח פסוק {::nomarkdown}\( \varphi\){:/nomarkdown} עם התכונה המבוקשת, כלומר שאין משתנה שגורר את שלילתו וגם שלילתו גוררת אותו. נתחיל לבנות לו השמה. נבחר שרירותית משתנה {::nomarkdown}\( x\){:/nomarkdown}. אם לא מתקיים {::nomarkdown}\( x\to\neg x\){:/nomarkdown}, נציב ב-{::nomarkdown}\( x\){:/nomarkdown} 1; אם כן מתקיים {::nomarkdown}\( x\to\neg x\){:/nomarkdown} אז מובטח לנו שלא מתקיים ההפך, {::nomarkdown}\( \neg x\to x\){:/nomarkdown}, ואז נציב 0 ב-{::nomarkdown}\( x\){:/nomarkdown}.

בואו נניח שהצבנו 1 ב-{::nomarkdown}\( x\){:/nomarkdown}; עבור הצבה של 0 ההמשך דומה. מה שיקרה עכשיו הוא שכל פסוקית שבה {::nomarkdown}\( x\){:/nomarkdown} הופיע תוסר מ-{::nomarkdown}\( \varphi\){:/nomarkdown}, ואילו כל פסוקית שבה {::nomarkdown}\( \neg x\){:/nomarkdown} הופיע תיוותר עם ליטרל יחיד, שנהיה חייבים להציב בו 1. ואז אולי נקבל פסוקיות יחידה נוספות שגם בליטרלים שלהן נצטרך להציב 1, וכן הלאה. בקיצור, יש לנו פעפוע כמו קודם. האבחנה היא שאם {::nomarkdown}\( ,l\){:/nomarkdown} הוא ליטרל כלשהו שקיבל 1 כחלק מהפעפוע, אז {::nomarkdown}\( x\to l\){:/nomarkdown} ניתן להסקה מתוך אוסף הגרירות שהפסוק מגדיר.

תהליך הפעפוע יכול להסתיים בשתי דרכים שונות: או שניוותר לבסוף בלי פסוקיות יחידה, ואז נוכל לבחור משתנה חדש ולהציב בו ערך (אם עוד יש כזה שטרם הצבנו בו ערך), או שנגיע לפסוקית ריקה ולסתירה. אני רוצה לשכנע אתכם שאי אפשר להגיע לפסוקית ריקה. כדי להגיע לפסוקית ריקה, צריכים להיות שני ליטרלים {::nomarkdown}\( l_{1},l_{2}\){:/nomarkdown} כך ש-{::nomarkdown}\( \left(l_{1}\vee l_{2}\right)\){:/nomarkdown} היא פסוקית של {::nomarkdown}\( \varphi\){:/nomarkdown}, ובנוסף לכך {::nomarkdown}\( x\to\neg l_{1}\){:/nomarkdown} ו-{::nomarkdown}\( x\to\neg l_{2}\){:/nomarkdown}.

עכשיו, שימו לב לתעלול הבא: אם {::nomarkdown}\( \left(l_{1}\vee l_{2}\right)\){:/nomarkdown} היא פסוקית של {::nomarkdown}\( \varphi\){:/nomarkdown}, אז למאגר הגרירות שלנו אפשר להוסיף את {::nomarkdown}\( \neg l_{1}\to l_{2}\){:/nomarkdown}. כעת, מכיוון ש-{::nomarkdown}\( x\to\neg l_{1}\){:/nomarkdown} נקבל {::nomarkdown}\( x\to l_{2}\){:/nomarkdown}. שקול לוגי של הפסוק הזה הוא {::nomarkdown}\( \neg l_{2}\to\neg x\){:/nomarkdown} (בדקו זאת!) ומכיוון ש-{::nomarkdown}\( x\to\neg l_{2}\){:/nomarkdown} נסיק {::nomarkdown}\( x\to\neg x\){:/nomarkdown}, אבל הנחנו שזה לא קורה - סתירה! לכן תהליך הפעפוע לא יכול להיגמר עם פסוקית ריקה, וההצלחה של האלגוריתם מובטחת.

עד כאן התיאוריה, אבל איך מבצעים את האלגוריתם בפועל? ובכן, צריך למצוא משתנה {::nomarkdown}\( x\){:/nomarkdown} שאינו גוזר את {::nomarkdown}\( \neg x\){:/nomarkdown}, צריך להציב בו ובכל מה שנגזר ממנו 1, ולוודא שלא נגרמו בעיות בשל כך. הדרך הנוחה לחשוב על זה (וגם לממש בפועל) היא בתור אלגוריתם שפועל על <strong>גרף מכוון</strong>. הצמתים של הגרף יהיו הליטרלים של הפסוק שלנו, כלומר כל צומת הוא מהצורה {::nomarkdown}\( x\){:/nomarkdown} או מהצורה {::nomarkdown}\( \neg x\){:/nomarkdown} עבור משתנה {::nomarkdown}\( x\){:/nomarkdown} כלשהו, והקשתות מייצגות גרירה: אם {::nomarkdown}\( \left(l_{1}\vee l_{2}\right)\){:/nomarkdown} היא פסוקית ב-{::nomarkdown}\( \varphi\){:/nomarkdown}, אז מוסיפים לגרף את הקשתות {::nomarkdown}\( \neg l_{1}\to l_{2}\){:/nomarkdown} ו-{::nomarkdown}\( \neg l_{2}\to l_{1}\){:/nomarkdown}. כעת יש לנו פירוש פשוט לכך שליטרל אחד נגרר על ידי אחר: נסתכל על צומת {::nomarkdown}\( l\){:/nomarkdown} ואז נסתכל על כל צומת ש<strong>ישיג</strong> ממנו, כלומר שיש מסלול מכוון ממנו אליו. כל הצמתים הללו מייצגים ליטרלים שנובעים מ-{::nomarkdown}\( l\){:/nomarkdown}.

כעת האלגוריתם ברור: בוחרים משתנה {::nomarkdown}\( x\){:/nomarkdown} באופן שרירותי, ומריצים עליו אלגוריתם DFS, שמוצא את כל הצמתים הישיגים ממנו. אם {::nomarkdown}\( \neg x\){:/nomarkdown} הוא לא בין הצמתים שהיו ישיגים מ-{::nomarkdown}\( x\){:/nomarkdown}, אז מציבים 1 ב-{::nomarkdown}\( x\){:/nomarkdown} ובכל ליטרל אחר שצץ במהלך ה-DFS. לא ייתכן שנצטרך להציב 1 גם בליטרל וגם בשלילתו, כי כפי שכבר ראינו, זה היה גורם לכך שמ-{::nomarkdown}\( x\){:/nomarkdown} כן אפשר יהיה להגיע אל {::nomarkdown}\( \neg x\){:/nomarkdown}.

אם כן ראינו שאפשר להגיע אל {::nomarkdown}\( \neg x\){:/nomarkdown} מתוך {::nomarkdown}\( x\){:/nomarkdown}, אז נריץ DFS חדש מ-{::nomarkdown}\( \neg x\){:/nomarkdown} ונפעל באותו האופן כמו קודם. אם הגענו אל {::nomarkdown}\( x\){:/nomarkdown} במהלך ה-DFS אפשר לסיים - זו הוכחה שהפסוק לא ספיק (וקל לזקק ממנה הוכחת רזולוציה אמיתית).

אחרי שסיימנו לעשות כל מה שאפשר עם {::nomarkdown}\( x\){:/nomarkdown}, אם יש משתנים שטרם הצבנו בהם ערכים בוחרים אחד מהם - נאמר, {::nomarkdown}\( y\){:/nomarkdown} - וחוזרים על הסיפור יחד איתו. על פניו יכולה לצוץ בעיה חדשה: אולי יש איזה שהוא משתנה {::nomarkdown}\( z\){:/nomarkdown} שכבר הצבנו בו ערך בשלב של הטיפול ב-{::nomarkdown}\( x\){:/nomarkdown} - נניח שהצבנו בו 1, אבל גם עבור 0 זה אותו עקרון - אבל עכשיו בשלב הטיפול ב-{::nomarkdown}\( y\){:/nomarkdown} נצטרך להציב בו 0? זה יקרה אם נגלה ש-{::nomarkdown}\( \neg z\){:/nomarkdown} ישיג מ-{::nomarkdown}\( y\){:/nomarkdown} ולכן נרצה להציב 1 ב-{::nomarkdown}\( \neg z\){:/nomarkdown}, מה שמכריח אותנו להציב 0 ב-{::nomarkdown}\( z\){:/nomarkdown}.

ובכן, התשובה לכך פשוטה מאוד: אם {::nomarkdown}\( \neg z\){:/nomarkdown} ישיג מ-{::nomarkdown}\( y\){:/nomarkdown}, אז זה אומר ש-{::nomarkdown}\( \neg y\){:/nomarkdown} ישיג מ-{::nomarkdown}\( z\){:/nomarkdown} (למה?) ולכן אם {::nomarkdown}\( \neg z\){:/nomarkdown} היה ישיג מ-{::nomarkdown}\( x\){:/nomarkdown}, אז {::nomarkdown}\( \neg y\){:/nomarkdown} היה ישיג מ-{::nomarkdown}\( x\){:/nomarkdown}, מה שאומר שכבר בשלב הקודם של {::nomarkdown}\( x\){:/nomarkdown} היינו אמורים להציב ערך ב-{::nomarkdown}\( y\){:/nomarkdown} ולא ייתכן שהוא שרד עד לשלב הזה. זה מסיים עם החששות שלנו; מי שעדיין מודאג מוזמן להוכיח פורמלית לעצמו שזה עובד.

אם כן, ראינו אלגוריתמים שעובדים טוב מאוד על מקרים פרטיים של SAT. מה עושים במקרה הכללי? על כך נדבר בפוסט הבא.
