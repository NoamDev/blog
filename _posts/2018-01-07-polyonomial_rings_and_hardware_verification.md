---
id: 3530
title: "מה הקשר בין חוגי פולינומים לאימות חומרה?"
date: 2018-01-07 22:32:46
layout: post
categories: 
  - אלגברה מופשטת
tags: 
  - אימות חומרה
  - בסיס גרובנר
  - חוגי פולינומים
---
ביקשו ממני לכתוב פוסט שיתן שימוש כלשהו למה שדיברתי עליו על חוגים במדעי המחשב. ובכן, לא הצלחתי לחשוב על משהו מוחץ ממש. התחום השימושי ביותר הוא ככל הנראה תורת השדות, בפרט שדות סופיים, אבל אני לא מחשיב את התחום הזה כחלק מתורת החוגים אלא כתחום העומד בפני עצמו. האם אני יכול לשלוף מהשרוול דוגמא שמשתמשת רק בדברים שראינו עד כה - וספציפית, אידאלים?

ואז קפץ לי לראש <a href="http://www.cs.utexas.edu/users/hunt/FMCAD/FMCAD17/preprints/s1p3.pdf">מאמר</a> מ-2017 שקראתי לא מזמן ("Column-Wise Verification of Multipliers Using Computer Algebra" של Ritirc, Biere, Kauers) ונותן הצצה לשימוש בחוגים שהוא אולי לא מתבקש לגמרי במבט ראשון - שימוש בתחום של <strong>אימות חומרה</strong>. אני לא טוען שמה שמוצג במאמר הזה הוא הדבר הכי טוב שאפשר לעשות עם חוגים באימות חומרה (וממילא רוב הטכניקות לאימות חומרה שאני מכיר לא משתמשות בכלל בחוגים) אבל המאמר הזה נותן הקדמה טובה ל"איך עושים את זה" שהיא מה שאני רוצה לדבר עליו פה, ולא על התוכן היותר ספציפי וטכני שלו.

הבעיה הבסיסית של <strong>אימות חומרה</strong> היא זו: נתון לנו מעגל לוגי כלשהו עם קלט ופלט, שאמור לחשב פונקציה מסויימת. אנחנו רוצים לוודא שהוא אכן מחשב אותה. מה זה "מעגל לוגי"? אפשר לחשוב עליו בתור גרף מכוון וחסר מעגלים שבו כל צומת מייצג ביט בודד (0 או 1). הצמתים שאין להם כניסות הם הקלטים, הצמתים שאין להם יציאות הם הפלטים, ולכל צומת שאיננו קלט מתאימה פעולה לוגית כלשהי. למשל, פעולת AND שמחזירה 1 רק אם שני הקלטים שלה הם בעצמם 1, ואחרת מחזירה 0, או פעולת NOT שמקבלת קלט בודד ומחזירה 1 אם הקלט היה 0 ואחרת מחזירה 0. הרעיון הוא זה: תציבו ערכים באופן שרירותי בקלטים, תבצעו את החישוב שמתאים לצמתים שאינם קלט ותראו איזה פלט תקבלו בסוף.

נשמע פשוט? ובכן, צריך לזכור שבמעגלים אמיתיים יכולים להיות עשרות אלפי קלטים ומיליוני צמתים פנימיים. במעגלים אמיתיים הסיטואציה גם מסובכת יותר כי החישוב מתבצע ב"סיבובים" כשהפלטים של כל סיבוב יכולים להיות חלק מהקלטים של הסיבוב הבא, וסוג השאלות שנשאל הוא בסגנון "האם אחרי עשרים סיבובים הפלט הזה-והזה עשוי לצאת 0?". מצד שני, הבעיה היא <strong>באמת</strong> פשוטה יחסית לניסוח; באימות תוכנה, למשל, הסיטואציה הרבה יותר מורכבת.

צורה מקובלת מאוד בתחום לתאר מעגל היא באמצעות שערי AND ו-NOT בלבד, ואפילו בצורה מפושטת: בגרף מציירים רק שערי AND, ואילו שערי ה-NOT מופיעים בתור סימונים שיכולים להופיע על הקשתות שנכנסות לשערי ה-AND. הנה דוגמא מתוך המאמר:

<a href="http://www.gadial.net/wp-content/uploads/2018/01/CircuitsAndPolynomialRings.png" rel="attachment wp-att-3531"><img class="aligncenter size-full wp-image-3531" src="http://www.gadial.net/wp-content/uploads/2018/01/CircuitsAndPolynomialRings.png" alt="CircuitsAndPolynomialRings" width="571" height="338" /></a>

במעגל השמאלי ביותר הפונקציה שמחושבת היא {::nomarkdown}\(g=a\wedge\neg b\){:/nomarkdown}. באמצעי החישוב כבר כולל שלושה צמתי ביניים:
<ul>
	<li>{::nomarkdown}\(l=a\wedge b\){:/nomarkdown}</li>
	<li>{::nomarkdown}\(r=\neg a\wedge\neg b\){:/nomarkdown}</li>
	<li>{::nomarkdown}\(s=\neg l\wedge\neg r\){:/nomarkdown}</li>
</ul>
ואם חושבים על זה לרגע, רואים שהפונקציה שמחושבת פה היא {::nomarkdown}\(s=\left(a\ne b\right)\){:/nomarkdown} (כלומר, {::nomarkdown}\(s\){:/nomarkdown} מקבלת 1 אם ורק אם {::nomarkdown}\(a,b\){:/nomarkdown} שונים זה מזה). עכשיו בואו תעשו כמוני עבור המעגל הימני ביותר ותגלו איזו פונקציה הוא מחשב כי בחיי שאין לי כוח לבדוק בעצמי.

המבנה הזה של גרף, שנקרא AIG (קיצור של And-Inverter Graph) הוא מאוד מועיל בתור ייצוג ביניים שמופק ממעגל חומרה "אמיתי" (כזה שנכתב ב-VHDL, למשל) ואפשר לבצע בו אופטימיזציות ואז לשלוח אותו הלאה, לאלגוריתם שמבצע אימות חומרה בפועל. אבל האלגוריתמים הללו על פי רוב משתמשים בייצוגים שונים ויותר מתאימים להם של <strong>הפונקציה</strong> שהגרף מחשב. בעבר הייצוג הפופולרי היה סוג של גרף מאופטמז שנקרא BDD, אבל לא אציג כאן. הייצוג הפופולרי ביותר בימינו הוא נוסחת CNF שמקודדת את המעגל - למשל, המעגל השמאלי ניתן לתיאור על ידי הנוסחה {::nomarkdown}\(\left(\neg a\vee b\vee g\right)\wedge\left(a\vee\neg c\right)\wedge\left(\neg b\vee\neg c\right)\){:/nomarkdown} שמקבלת 1 אם ורק אם מתקיים {::nomarkdown}\(g=a\wedge\neg b\){:/nomarkdown}. בצורה הזו, <strong>השמה מספקת</strong> לנוסחת ה-CNF מתאימה ל<strong>חישוב חוקי</strong> במעגל. אבל אם לא הבנתם כלום מזה, לא חשוב - אני לא הולך לדבר על שיטת הייצוג הזו מעבר לאזכור שלה.

מה שאנחנו רוצים לדבר עליו הוא ייצוג של המעגל בעזרת <strong>פולינומים</strong>. הרעיון הוא כזה: נניח ש-{::nomarkdown}\(g,a,b\){:/nomarkdown} הם כולם <strong>משתנים</strong> (מה שבדרך כלל אנחנו משתמשים עבורו ב-{::nomarkdown}\(x,y,z\){:/nomarkdown}). הנה פולינום לדוגמא שמשתמש במשתנים הללו: {::nomarkdown}\(p\left(g,a,b\right)=a\left(1-b\right)-g\){:/nomarkdown}. לפולינום הזה יש את התכונה הבאה: אם נציב למשתנים ערכים שהם או 0 או 1, אז הפולינום יתאפס רק על ערכים שבהם {::nomarkdown}\(g=a\wedge\neg b\){:/nomarkdown}. כלומר, <strong>השורשים של הפולינום</strong> מתאימים ל<strong>חישוב חוקי</strong> של {::nomarkdown}\(g=a\wedge\neg b\){:/nomarkdown}. דרך אחת לומר את זה היא לומר שהקשר {::nomarkdown}\(g=a\wedge\neg b\){:/nomarkdown} ניתן לתיאור באמצעות <strong>זהות פולינומית</strong>.

הנה האופן שבו אפשר להמיר את כל השערים הבסיסיים שאפשר לצפות לפגוש במעגל בוליאני בזהויות פולינומיות מתאימות:
<ul>
	<li>את {::nomarkdown}\(g=\neg a\){:/nomarkdown} אפשר לתאר עם {::nomarkdown}\(p\left(g,a\right)=\left(1-a\right)-g\){:/nomarkdown}</li>
	<li>את {::nomarkdown}\(g=a\wedge b\){:/nomarkdown} אפשר לתאר עם {::nomarkdown}\(p\left(g,a,b\right)=ab-g\){:/nomarkdown}</li>
	<li>את {::nomarkdown}\(g=a\vee b\){:/nomarkdown} אפשר לתאר עם {::nomarkdown}\(p\left(g,a,b\right)=ab-\left(a+b\right)+g\){:/nomarkdown} (אפשר להגיע לזה בקלות משני הקודמים בעזרת כללי דה-מורגן).</li>
	<li>את {::nomarkdown}\(g=a\oplus b\){:/nomarkdown} אפשר לתאר עם {::nomarkdown}\(p\left(g,a,b\right)=2ab-\left(a+b\right)+g\){:/nomarkdown}</li>
</ul>
באופן כללי, "זהות פולינומית" במעגל {::nomarkdown}\(C\){:/nomarkdown} היא פולינום {::nomarkdown}\(p\left(x_{1},\dots,x_{n}\right)\){:/nomarkdown} שהמשתנים שלו מתאימים לצמתים במעגל (דהיינו יש לנו משתנה לכל צומת של {::nomarkdown}\(C\){:/nomarkdown} והפולינום {::nomarkdown}\(p\){:/nomarkdown} משתמש בחלק מהם) כך שכל הצבה למשתנים <strong>שמתאימה למה שקורה במעגל</strong> מחזירה 0.

במאמר מסמנים ב-{::nomarkdown}\(I\left(C\right)\){:/nomarkdown} את קבוצת כל הזהויות הפולינומיות שמתאימות למעגל {::nomarkdown}\(C\){:/nomarkdown} מסויים. זו הגדרה סטנדרטית בתחום שנקרא <strong>גאומטריה אלגברית</strong>: שם בהינתן קבוצת נקודות {::nomarkdown}\(V\){:/nomarkdown} במרחב כלשהו, מסמנים ב-{::nomarkdown}\(I\left(V\right)\){:/nomarkdown} את אוסף כל הפולינומים שמתאפסים מעל המרחב הזה. האוסף הזה הוא <strong>אידאל</strong>: אם שני פולינומים מתאפסים על אותן נקודות, אז גם הסכום שלהם יתאפס על אותן נקודות, וכמובן שאם {::nomarkdown}\(p\left(a\right)=0\){:/nomarkdown} ו-{::nomarkdown}\(q\){:/nomarkdown} הוא פולינום כלשהו, אז {::nomarkdown}\(\left(pq\right)\left(a\right)=0\){:/nomarkdown} גם כן (כי מקבלים את המכפלה של 0 ב-{::nomarkdown}\(q\left(a\right)\){:/nomarkdown} שלא משנה מה הוא).

רוצים לדעת אם המעגל {::nomarkdown}\(C\){:/nomarkdown} מקיים תכונה כלשהי שניתן לנסח בתור זהות פולינומית? יפה! כל מה שנשאר לעשות הוא לבדוק שייכות לאידאל {::nomarkdown}\(I\left(C\right)\){:/nomarkdown}. במאמר מדגימים את זה עבור התכונה של "המעגל מבצע פעולת כפל". כדי לנסח את זה, מסמנים את הקלטים של המעגל ב-{::nomarkdown}\(a_{0},a_{1},\dots,a_{n-1},b_{0},b_{1},\dots,b_{n-1}\){:/nomarkdown} - שתי סדרות של {::nomarkdown}\(n\){:/nomarkdown} ביטים שמקודדות שני מספרים, {::nomarkdown}\(a,b\){:/nomarkdown}. אם המעגל מחשב את {::nomarkdown}\(c=ab\){:/nomarkdown} אז התוצאה עשויה להיות בת {::nomarkdown}\(2n\){:/nomarkdown} ביטים, ולכן הפלט של המעגל יהיה {::nomarkdown}\(c_{0},c_{1},\dots,c_{2n-1}\){:/nomarkdown}. חוץ מזה יהיו במעגל גם שערים פנימיים עם משתנים נוספים שמתאימים להם, אבל זה פחות קריטי. עכשיו, הביטו בפולינום הבא:

{::nomarkdown}\(\sum_{k=0}^{2n-1}2^{k}c_{k}-\left(\sum_{k=0}^{n-1}2^{k}a_{k}\right)\left(\sum_{k=0}^{n-1}2^{k}b_{k}\right)\){:/nomarkdown}

הפולינום הזה מקודד בדיוק את הטענה ש-{::nomarkdown}\(c=ab\){:/nomarkdown}, ולכן הבדיקה של "האם המעגל מבצע כפל" היא בדיוק בדיקת שייכות של הפולינום הזה ל-{::nomarkdown}\(I\left(C\right)\){:/nomarkdown}.

אתם עשויים לשאול, כמובן, על מה כל המהומה הזו. האם אין פשוט שיטה אחת וזהו לבצע כפל באמצעות מעגל? ובכן, לא. יש דרכים רבות ושונות ומסובכות שמושפעות מאילוצים שונים ומשונים על המעגל ואני מעדיף לא להיכנס לזה בכלל. סמכו עלי שאפילו השאלה הזו של האם מעגל מבצע כפל יכולה להיות מעניינת. אתם גם עשויים לשאול אם לא פשוט יותר להציב את כל הערכים האפשריים ולבדוק - ובכן, חשבו על כך שערך טיפוסי עבור {::nomarkdown}\(n\){:/nomarkdown} הוא 64, מה שאומר שאין שום סיכוי שנוכל לעבור סדרתית על כל הקלטים האפשריים למעגל.

איך בודקים שייכות של פולינום לאידאל? כשמדובר על חוג פולינומים במספר משתנים מעל שדה, אפשר להראות שלכל אידאל קיים בסיס מיוחד, שנקרא <strong>בסיס גרובנר</strong>, שנותן אלגוריתם שמאפשר לבדוק שייכות של פולינום כלשהו לאידאל, על ידי משהו שמזכיר מעין חילוק ארוך עבור פולינומים במספר משתנים. זה נושא מרתק שראוי לפוסט משל עצמו, ולכן לא אכנס כרגע להגדרות. עבור {::nomarkdown}\(I\left(C\right)\){:/nomarkdown} המדובר כאן קיים בסיס גרובנר פשוט למדי, שכולל את הזהויות הפולינומיות שמתאימות לשערי המעגל - אותן הזהויות שכתבתי למעלה. בנוסף לכך הוא כולל גם פולינומים שהמטרה שלהם היא לומר "הקלט הוא או 0 או 1": הפולינום {::nomarkdown}\(p\left(x\right)=x\left(x-1\right)\){:/nomarkdown} משיג את המטרה הזו - החליפו את {::nomarkdown}\(x\){:/nomarkdown} ב-{::nomarkdown}\(a_{i}\){:/nomarkdown} או {::nomarkdown}\(b_{i}\){:/nomarkdown} כלשהו כדי לקבל את כל הפולינומים מהצורה הזו שמתווספים לבסיס.

המאמר לא נגמר בנקודה הזו; הוא בקושי מתחיל. כל זה הוא רק ההקדמה התיאורטית, שאחריה באה ההסתייגות הרגילה של "אבל גם עם בסיס גרובנר, זו עדיין בעיה קשה חישובית לבדוק שייכות של פולינום לאידאל" ("קשה חישובית" כאן פירושו NP-קשה). בשל הקושי הזה המשך המאמר מתמקד בשיטה שרלוונטית ספציפית לבדיקת מכפילים ומשתמשת בתעלולים שמשפרים את ביצועי החישוב, אבל לא אכנס אליהם כאן. הנקודה המעניינת שרציתי להדגים פה היא האופן שבו חוגים ואידאלים (וספציפית חוגי פולינומים במספר משתנים ובסיס גרובנר) צצים "בשטח", גם במקומות לא לגמרי צפויים.
