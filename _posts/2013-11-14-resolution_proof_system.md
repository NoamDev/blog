---
id: 2975
title: "רזולוציה - איך אפשר להוכיח שאי אפשר?"
date: 2013-11-14 19:59:52
layout: post
categories: 
  - לוגיקה
  - מבני נתונים ואלגוריתמים
  - תורת הסיבוכיות
tags: 
  - SAT
  - מערכות הוכחה
  - רזולוציה
---
ב<a href="http://www.gadial.net/2013/11/11/sat_intro/">פוסט הקודם</a> תיארתי את בעיית SAT וסיימתי בכך שהבטחתי להסביר איך אפשר להשתכנע בכך שפסוק CNF <strong>אינו</strong> ספיק, מבלי שיהיה צורך לבדוק את כל ההשמות האפשריות עבורו. בפוסט הזה אציג את השיטה הנפוצה ביותר לשימוש כדי להוכיח זאת - <strong>רזולוציה</strong>. מובטח לנו שאם {::nomarkdown}\( \varphi\){:/nomarkdown} הוא פסוק CNF לא ספיק, אז קיימת הוכחה לכך המבוססת על רזולוציה. זה עדיין לא מבטיח שיהיה קל למצוא את ההוכחה הזו, או שההוכחה תהיה קצרה (על חשיבות ה<strong>אורך</strong> של ההוכחה אדבר בהמשך), אבל זה יהיה לרוב שיפור אל מול בדיקת כל ההשמות האפשריות, ובעולם האמיתי יש להוכחות כאלו שימושים רבים.

מהי רזולוציה? פשוט מאוד - זה כלל שבו משתי פסוקיות CNF מסיקים פסוקית חדשה. הכלל אומר כך: אם יש לי פסוקית {::nomarkdown}\( C\){:/nomarkdown} שבה מופיע משתנה {::nomarkdown}\( x\){:/nomarkdown}, ויש לי פסוקית {::nomarkdown}\( D\){:/nomarkdown} שבה מופיע אותו המשתנה, אבל בשלילה - כלומר, היא כוללת את הליטרל {::nomarkdown}\( \neg x\){:/nomarkdown}, אז אפשר לבנות משתי הפסוקיות הללו פסוקית חדשה (שלפעמים מסמנים {::nomarkdown}\( C\otimes D\){:/nomarkdown}) שכוללת את כל הליטרלים ב-{::nomarkdown}\( C\){:/nomarkdown} פרט ל-{::nomarkdown}\( x\){:/nomarkdown} וכל הליטרלים ב-{::nomarkdown}\( D\){:/nomarkdown} פרט ל-{::nomarkdown}\( \neg x\){:/nomarkdown}.

כלומר, פורמלית, אם {::nomarkdown}\( C=\left(x\vee l_{1}^{c}\vee\dots\vee l_{k}^{c}\right)\){:/nomarkdown} ו-{::nomarkdown}\( D=\left(\neg x\vee l_{1}^{d}\vee\dots\vee l_{t}^{d}\right)\){:/nomarkdown} אז {::nomarkdown}\( C\otimes D=\left(l_{1}^{c}\vee\dots\vee l_{k}^{c}\vee l_{1}^{d}\vee\dots\vee l_{t}^{d}\right)\){:/nomarkdown}.

חדי העין שביניכם אולי יתריעו כעת שהסימון בעייתי כי הוא לא מבהיר מה המשתנה שעל פיו עושים רזולוציה - אולי יש יותר ממשתנה אחד שמופיע בפסוק אחד ושלילתו מופיעה בשני? ובכן, אנחנו מניחים תמיד שברור מההקשר מה המשתנה הרלוונטי, אבל כשאהיה ממש ממש פורמלי אכתוב {::nomarkdown}\( C\otimes_{x}D\){:/nomarkdown} כדי שלא יהיה מקום לספק.

מה ההגיון מאחורי הכלל הזה? הרעיון הוא שכל השמה שמספקת בו זמנית גם את {::nomarkdown}\( C\){:/nomarkdown} וגם את {::nomarkdown}\( D\){:/nomarkdown} חייבת לספק גם את {::nomarkdown}\( C\otimes D\){:/nomarkdown}. מדוע? ובכן, נניח לרגע שההשמה הזו נותנת 1 ל-{::nomarkdown}\( x\){:/nomarkdown}, אז היא אוטומטית מספקת את {::nomarkdown}\( C\){:/nomarkdown}, אבל מה עם {::nomarkdown}\( D\){:/nomarkdown}? ל-{::nomarkdown}\( \neg x\){:/nomarkdown} ההשמה תיתן 0, ולכן כדי לספק את {::nomarkdown}\( D\){:/nomarkdown} חייבים לספק אחד מבין הליטרלים של {::nomarkdown}\( D\){:/nomarkdown}. אותו ליטרל מופיע גם ב-{::nomarkdown}\( C\otimes D\){:/nomarkdown} ולכן ההשמה מספקת את {::nomarkdown}\( C\otimes D\){:/nomarkdown}. באופן דומה, אם ההשמה נתנה 0 ל-{::nomarkdown}\( x\){:/nomarkdown} אז כדי שהיא תספק את {::nomarkdown}\( C\){:/nomarkdown} היא הייתה חייבת לספק את אחד מהליטרלים האחרים של {::nomarkdown}\( C\){:/nomarkdown}, שמופיע ב-{::nomarkdown}\( C\otimes D\){:/nomarkdown}. כפי שאתם רואים, אין שום רעיון גאוני כאן - זו אבחנה בסיסית למדי. זה מה שהופך את העובדה שבעצם די בפעולה הפשוטה הזו כדי להוכיח שפסוק הוא לא ספיק למעניינת.

איך מתנהלת "הוכחה" כזו? פשוט מאוד - מייצרים בעזרת רזולוציה עוד ועוד פסוקיות (תוך הפעלת רזולוציה על הפסוקיות שכבר יש לנו - בהתחלה אלו רק הפסוקיות של {::nomarkdown}\( \varphi\){:/nomarkdown}). אם מתישהו קיבלנו את הפסוקית הריקה, זה מוכיח שהפסוק המקורי היה לא ספיק. למה? כי כל השמה שסיפקה את {::nomarkdown}\( \varphi\){:/nomarkdown} מספקת גם את כל מה שאפשר לגזור מ-{::nomarkdown}\( \varphi\){:/nomarkdown} על ידי רזולוציה (זה בדיוק מה שהוכחנו), אבל אי אפשר לספק את הפסוקית הריקה.

האמירה האחרונה אולי עשויה להישמע לכם חשודה, ובצדק - הטענה ש"אי אפשר לספק את הפסוקית הריקה" נשמעת קצת שרירותית. אם כן, חשבו לרגע איך רזולוציה יכולה בכלל ליצור את הפסוקית הריקה מלכתחילה: בהכרח אנחנו חייבים להפעיל אותה על שתי פסוקיות מהצורה {::nomarkdown}\( C=\left(x\right)\){:/nomarkdown} ו-{::nomarkdown}\( D=\left(\neg x\right)\){:/nomarkdown}, כלומר פסוקיות שכוללות כל אחת רק ליטרל יחיד, שהוא של משתנה כלשהו באחת מהן, ושלילתו בשני. בבירור אף השמה אינה יכולה לספק את שתי הפסוקיות הללו בו זמנית, ולכן כבר כאן ברור ש"אי אפשר לספק את {::nomarkdown}\( \varphi\){:/nomarkdown}" (אם {::nomarkdown}\( C,D\){:/nomarkdown} נגזרו מ-{::nomarkdown}\( \varphi\){:/nomarkdown} על ידי רזולוציה). מכאן שהגיוני להגדיר את הפסוקית הריקה ככזו שאינה מסתפקת לאף השמה. עוד דרך לחשוב על זה היא זו: פסוקית מסתפקת על ידי השמה כלשהי אם <strong>קיים</strong> משתנה כלשהו שמקבל 1 תחת ההשמה הזו. אם אין משתנים בפסוקית, אז לא יכול להיות קיים משתנה כזה.

עכשיו, הבנו את הרעיון הכללי, אבל אני רוצה לקשר אותו לדברים שכבר ראינו בעבר בבלוג בכל הנוגע ללוגיקה. בעבר <a href="http://www.gadial.net/2012/04/04/propositional_caclulus_proofs/">הצגתי בבלוג</a> מערכת הוכחה לתחשיב הפסוקים - בואו נחזור שניה על מה היא כללה. היו בה <strong>אקסיומות</strong>, שהן פסוקים שמהווים טאוטולוגיות (כלומר, שמסתפקים עבור כל השמה) - היו אינסוף אקסיומות שכאלו, אבל הן היו שייכות לשלוש תבניות אפשריות. כמו כן היה לנו <strong>כלל היסק</strong> יחיד - מודוס פוננס. הוכחה במערכת הזו הייתה סדרה של פסוקים, כך שכל פסוק הוא אקסיומה או נובע מפסוקים קודמים בהוכחה באמצעות הפעלת מודוס פוננס. מערכת ההוכחה הזו הייתה עקבית ושלמה, במובן זה שניתן היה להוכיח מתוכה <strong>רק</strong> טאוטולוגיות (עקביות), ואת <strong>כל </strong>הטאוטולוגיות (שלמות). אחר כך ראינו שאפשר להשתמש במערכת ההוכחה גם למשהו יותר מורכב - אם יש לנו קבוצה {::nomarkdown}\( \Phi\){:/nomarkdown}של פסוקים, אפשר לחשוב עליהן בתור <strong>הנחות</strong> - משהו שאנחנו מצרפים זמנית לקבוצת האקסיומות שלנו - ועם קבוצת האקסיומות ה"משודרגת" הזו כל הפסוקים שיכלנו להוכיח הם בדיוק כל הפסוקים ש<strong>נובעים לוגית</strong> מ-{::nomarkdown}\( \Phi\){:/nomarkdown} ({::nomarkdown}\( \varphi\){:/nomarkdown} נובע לוגית מ-{::nomarkdown}\( \Phi\){:/nomarkdown} אם כל השמה שמספקת את כל הפסוקים ב-{::nomarkdown}\( \Phi\){:/nomarkdown} בו זמנית מספקת גם את {::nomarkdown}\( \varphi\){:/nomarkdown}). מערכת הוכחה מסוג זה - עם אקסיומות, הנחות וכללי היסק - נקראת לפעמים <strong>מערכת הוכחה מסוג הילברט</strong>.

ההוכחה שמערכת ההוכחה שהצגתי היא אכן שלמה ונאותה הייתה די מורכבת, כך שלא סביר לצפות שרזולוציה תיתן לנו מערכת הוכחה חזקה באותה מידה בלי שנצטרך לעבוד די קשה לשם כך, אבל המטרות שלי בפוסט הזה הן צנועות יותר. הרעיון הוא כזה: מתחילים עם פסוק CNF {::nomarkdown}\( \varphi\){:/nomarkdown}, שעליו חושבים בתור קבוצה של פסוקיות שהיא קבוצת ה"הנחות" שלנו. אחר כך בונים הוכחה שהיא סדרה של פסוקים שכל אחד מהם הוא פסוקית CNF שהיא הנחה או נובעת מקודמותיה על ידי רזולוציה. כלומר, גם פה יש לנו מערכת הוכחה מסוג הילברט, אבל ויתרנו על דרישת השלמות של המערכת ה"כללית" - יהיה די קל למצוא פסוקים שנובעים לוגית מ-{::nomarkdown}\( \varphi\){:/nomarkdown} אבל לא יכיחים ממנה במערכת. עם זאת, נאותות עדיין תתקיים - כל פסוק שמתקבל במערכת אכן ינבע לוגית מ-{::nomarkdown}\( \varphi\){:/nomarkdown}, ותתקיים תכונת שלמות <strong>מוחלשת</strong>, שמספיקה לצרכינו: אם {::nomarkdown}\( \varphi\){:/nomarkdown} אינה ספיקה, אז {::nomarkdown}\( \varphi\vdash\mbox{F}\){:/nomarkdown} כאשר {::nomarkdown}\( \mbox{F}\){:/nomarkdown} הוא הסימון שלי לפסוקית הריקה שאינה כוללת ליטרלים. במילים פשוטות, <strong>אם {::nomarkdown}\( \varphi\){:/nomarkdown} לא ספיק המערכת תוכל להוכיח זאת</strong>, על ידי גזירה של הפסוקית הריקה. לכן אולי יותר נכון לחשוב על רזולוציה בתור "מערכת הפרכה" ולא מערכת הוכחה.

הבה ונוכיח את הטענה הזו. ההוכחה די קלה מבחינה רעיונית אבל הפרטים הטכניים יכולים להקשות על ההבנה שלה, אז בואו נתחיל מהרעיון. זוכרים איך במטריקס אמרו "Guns, lots of guns''? אז כאן זה "רזולוציה, הרבה רזולוציה". הרעיון הוא לעשות כמה רזולוציה שרק אפשר ובסוף {::nomarkdown}\( \mbox{F}\){:/nomarkdown} יהיה חייב לצוץ.

אה... לא משכנע במיוחד, נכון? אז הנה הטריק: אם תשימו לב, מה שרזולוציה עושה ל-{::nomarkdown}\( C,D\){:/nomarkdown} כשהיא יוצרת מהם את {::nomarkdown}\( C\otimes D\){:/nomarkdown} הוא <strong>לסלק את המשתנה</strong> {::nomarkdown}\( x\){:/nomarkdown} מתוכם. הדרך היחידה שבה ב-{::nomarkdown}\( C\otimes D\){:/nomarkdown} יופיע המשתנה {::nomarkdown}\( x\){:/nomarkdown} היא שב-{::nomarkdown}\( C\){:/nomarkdown} או ב-{::nomarkdown}\( D\){:/nomarkdown} יופיעו גם {::nomarkdown}\( x\){:/nomarkdown} וגם {::nomarkdown}\( \neg x\){:/nomarkdown}, אבל זה אומר שהפסוקית שבה זה קורה היא ממילא חסרת ערך עבורנו - היא טאטולוגיה, כלומר מסתפקת על ידי כל השמה, ולכן לא תעזור לנו <strong>להגביל</strong> את כמות ההשמות שאולי יש להן פוטנציאל לספק את {::nomarkdown}\( \varphi\){:/nomarkdown}.

אז הרעיון הוא כזה: קודם כל ניקח את כל הפסוקיות ב-{::nomarkdown}\( \varphi\){:/nomarkdown} (פרט לטאוטולוגיות שנזרקות לפח) ונבצע כמה שיותר רזולוציות שרק אפשר ביחס למשתנה כלשהו, נאמר {::nomarkdown}\( x_{1}\){:/nomarkdown}. אחר כך נזרוק לפח את כל הפסוקיות שבהן הופיע {::nomarkdown}\( x_{1}\){:/nomarkdown}, וניוותר עם אוסף פסוקיות CNF שבהן המשתנה {::nomarkdown}\( x_{1}\){:/nomarkdown} פשוט לא מופיע. באופן הזה נמשיך גם למשתנה הבא, ולזה שאחריו, וכן הלאה - בדרך הזו נחסל את כל המשתנים. בשלב האחרון יוכל לקרות אחד משני דברים: או שנסיים עם הפסוקית הריקה ביד ואז נדע ש-{::nomarkdown}\( \varphi\){:/nomarkdown} הוא לא ספיק; או שנסיים בלי פסוקיות כלל (כי נקבל טאוטולוגיות שנזרוק לפח) ואז {::nomarkdown}\( \varphi\){:/nomarkdown} ספיק.

זה אולי נשמע נחמד ברמת נפנופי הידיים, אבל אני בהחלט מבין את מי שזה עדיין נראה לו חשוד. אז בואו נעבור לפורמליסטיקה. אני הולך לחשוב על כל פסוק CNF בתור קבוצה של פסוקיות. נניח ש-{::nomarkdown}\( \varphi\){:/nomarkdown} המקורי מכיל את המשתנים {::nomarkdown}\( x_{1},\dots,x_{n}\){:/nomarkdown}, אז אני הולך להגדיר סדרה של פסוקי CNF {::nomarkdown}\( \varphi_{0},\varphi_{1},\varphi_{2},\dots,\varphi_{n}\){:/nomarkdown} כך ש-{::nomarkdown}\( \varphi_{0}=\varphi\){:/nomarkdown} ובאופן כללי {::nomarkdown}\( \varphi_{k}\){:/nomarkdown} מכיל רק את המשתנים עם אינדקס גדול מ-{::nomarkdown}\( k\){:/nomarkdown} ({::nomarkdown}\( x_{k+1},\dots,x_{n}\){:/nomarkdown}) ולכן בפרט {::nomarkdown}\( \varphi_{n}\){:/nomarkdown} לא יכול להכיל משתנים בכלל ומכאן שהוא או פסוק שמכיל פסוקית אחת, ריקה, ולכן אינו ספיק, או שהוא פסוק שאינו מכיל פסוקיות כלל, ולכן הוא טאוטולוגיה.

כדי להגדיר את {::nomarkdown}\( \varphi_{k+1}\){:/nomarkdown} מתוך {::nomarkdown}\( \varphi_{k}\){:/nomarkdown} אני הולך לחלק את הפסוקיות של {::nomarkdown}\( \varphi_{k}\){:/nomarkdown} לארבע קבוצות זרות ומשלימות: פסוקיות שבהן מופיעים גם {::nomarkdown}\( x_{k}\){:/nomarkdown} וגם {::nomarkdown}\( \neg x_{k}\){:/nomarkdown}, כלומר הן טאוטולוגיות ואני הולך להתעלם מהן; פסוקיות שבהן לא {::nomarkdown}\( x_{k}\){:/nomarkdown} ולא {::nomarkdown}\( \neg x_{k}\){:/nomarkdown} מופיעים ואני הולך להעביר אותן כמות שהן ל-{::nomarkdown}\( \varphi_{k+1}\){:/nomarkdown} ; פסוקיות שבהן {::nomarkdown}\( x_{k}\){:/nomarkdown} מופיע אבל לא {::nomarkdown}\( \neg x_{k}\){:/nomarkdown}, ופסוקיות שבהן {::nomarkdown}\( \neg x_{k}\){:/nomarkdown} מופיע אבל לא {::nomarkdown}\( x_{k}\){:/nomarkdown}. בבירור אלו כל המקרים האפשריים. אז בואו נגדיר: {::nomarkdown}\( \varphi_{k}=T_{k}\cup N_{k}\cup A_{k}\cup B_{k}\){:/nomarkdown} כך ש-

{::nomarkdown}\( T_{k}=\left\{ C\in\varphi_{k}\ \|\ x_{k}\in C\wedge\neg x_{k}\in C\right\} \){:/nomarkdown}

{::nomarkdown}\( N_{k}=\left\{ C\in\varphi_{k}\ \|\ x_{k}\notin C\wedge\neg x_{k}\notin C\right\} \){:/nomarkdown}

{::nomarkdown}\( A_{k}=\left\{ C\in\varphi_{k}\ \|\ x_{k}\in C\wedge\neg x_{k}\notin C\right\} \){:/nomarkdown}

{::nomarkdown}\( B_{k}=\left\{ C\in\varphi_{k}\ \|\ x_{k}\notin C\wedge\neg x_{k}\in C\right\} \){:/nomarkdown}

עכשיו נגדיר את {::nomarkdown}\( A_{k}\otimes B_{k}\){:/nomarkdown} בתור "מה שמקבלים כשעושים את כל הרזולוציות שרק אפשר עם {::nomarkdown}\( A_{k},B_{k}\){:/nomarkdown}":

{::nomarkdown}\( A_{k}\otimes B_{k}=\left\{ C\otimes_{x_{k}}D\ \|\ C\in A_{k},D\in B_{k}\right\} \){:/nomarkdown}

ועכשיו נגדיר:

{::nomarkdown}\( \varphi_{k+1}=N_{k}\cup A_{k}\otimes B_{k}\){:/nomarkdown}

כלומר, זרקנו לפח את כל הפסוקיות שהיו טאוטולוגיות ב-{::nomarkdown}\( \varphi_{k}\){:/nomarkdown}, זרקנו לפח את כל הפסוקיות שהכילו את {::nomarkdown}\( x_{k}\){:/nomarkdown} בצורה זו או אחרת, ובתור פיצוי הכנסנו פנימה את התוצר של כל הרזולוציות של פסוקיות ב-{::nomarkdown}\( A_{k},B_{k}\){:/nomarkdown}. מצד אחד, {::nomarkdown}\( \varphi_{k+1}\){:/nomarkdown} יכול להיות הרבה יותר מסובך מ-{::nomarkdown}\( \varphi_{k}\){:/nomarkdown} במובן זה שהוא יכיל הרבה יותר פסוקיות; מצד שני, הוא יו תר פשוט מ-{::nomarkdown}\( \varphi_{k}\){:/nomarkdown} במובן זה שהפסוקיות שלו כוללות משתנה אחד פחות - לא כוללות את {::nomarkdown}\( x_{k}\){:/nomarkdown}.

עכשיו, בגלל הנאותות של רזולוציה, כל השמה שמספקת את {::nomarkdown}\( \varphi\){:/nomarkdown} מספקת כל אחד מה-{::nomarkdown}\( \varphi_{k}\){:/nomarkdown}-ים. לכן בפרט ברור שאם {::nomarkdown}\( \varphi_{n}\){:/nomarkdown} כולל את הפסוקית הריקה (שאין אף השמה שמספקת אותה) הרי ש-{::nomarkdown}\( \varphi\){:/nomarkdown}לא ספיק. אנחנו רוצים להוכיח גם את הכיוון השני: שאם {::nomarkdown}\( \varphi\){:/nomarkdown} לא ספיק אז {::nomarkdown}\( \varphi_{n}\){:/nomarkdown} יכיל את הפסוקית הריקה. נוכיח את זה על ידי הוכחה של טענה שקולה לוגית: שאם {::nomarkdown}\( \varphi_{n}\){:/nomarkdown} לא מכיל את הפסוקית הריקה אז {::nomarkdown}\( \varphi\){:/nomarkdown} ספיק. ואת זה נוכיח במעין אינדוקציה הפוכה: נתחיל עם השמה שמספקת את {::nomarkdown}\( \varphi_{n}\){:/nomarkdown} ואז נוכיח שבאופן כללי אם יש לנו השמה שמספקת את {::nomarkdown}\( \varphi_{k}\){:/nomarkdown} אז אפשר לקבל ממנה השמה שמספקת את {::nomarkdown}\( \varphi_{k-1}\){:/nomarkdown}. וכך נמשיך עד {::nomarkdown}\( \varphi_{0}\){:/nomarkdown} שהוא {::nomarkdown}\( \varphi\){:/nomarkdown} המקורי.

איזו השמה מספקת את {::nomarkdown}\( \varphi_{n}\){:/nomarkdown} שאין בו בכלל משתנים? ובכן, לא תאהבו את זה אבל ההשמה הריקה - השמה שלא נותנת ערך לאף משתנה. אם זה מפריע לכם, אפשר לתקן את הניסוח ל"כל השמה למשתנים {::nomarkdown}\( x_{1},\dots,x_{n}\){:/nomarkdown} מספקת את {::nomarkdown}\( \varphi_{n}\){:/nomarkdown}" וזה תקין באותה המידה, אבל אני מעדיף מבחינה רעיונית לדבר על השמה ריקה. עכשיו, בואו נניח שיש לנו השמה {::nomarkdown}\( \tau\){:/nomarkdown} שמספקת את {::nomarkdown}\( \varphi_{k}\){:/nomarkdown} ומוגדרת רק עבור המשתנים {::nomarkdown}\( x_{k+1},\dots,x_{n}\){:/nomarkdown} (או לחילופין, לא משנה איך נגדיר אותה עבור {::nomarkdown}\( x_{1},\dots,x_{k}\){:/nomarkdown}, עדיין נקבל שהיא מספקת את {::nomarkdown}\( \varphi_{k}\){:/nomarkdown}). עכשיו השאלה שעומדת בפנינו היא זו: איך נקבל מתוך {::nomarkdown}\( \tau\){:/nomarkdown} השמה שמספקת את {::nomarkdown}\( \varphi_{k-1}\){:/nomarkdown}?

יש בסך הכל שתי השמות שנראות כמו מועמדות מתאימות לספק את {::nomarkdown}\( \varphi_{k-1}\){:/nomarkdown} - אקרא להן {::nomarkdown}\( \tau_{0},\tau_{1}\){:/nomarkdown}. הן זהות ל-{::nomarkdown}\( \tau\){:/nomarkdown} על המשתנים {::nomarkdown}\( x_{k+1},\dots,x_{n}\){:/nomarkdown} שעליהם {::nomarkdown}\( \tau\){:/nomarkdown} מוגדרת, ונבדלים בהגדרתם על {::nomarkdown}\( x_{k}\){:/nomarkdown}: {::nomarkdown}\( \tau_{0}\left(x_{k}\right)=0\){:/nomarkdown} ו-{::nomarkdown}\( \tau_{1}\left(x_{k}\right)=1\){:/nomarkdown}. עכשיו אני רוצה לטעון שלפחות אחת מההשמות הללו מספקת את {::nomarkdown}\( \varphi_{k-1}\){:/nomarkdown} - לשם כך אני אניח בשלילה שאף אחת מהן לא מספקת את {::nomarkdown}\( \varphi_{k-1}\){:/nomarkdown} ואסיק מכך שלא ייתכן ש-{::nomarkdown}\( \tau\){:/nomarkdown} סיפקה את {::nomarkdown}\( \varphi_{k}\){:/nomarkdown}.

מה זה אומר ש-{::nomarkdown}\( \tau_{0}\){:/nomarkdown} אינה מספקת את {::nomarkdown}\( \varphi_{k-1}\){:/nomarkdown}? זה אומר שקיימת פסוקית {::nomarkdown}\( C\in\varphi_{k-1}\){:/nomarkdown} שאותה {::nomarkdown}\( \tau_{0}\){:/nomarkdown} אינה מספקת, כלומר לא קיים ליטרל ב-{::nomarkdown}\( C\){:/nomarkdown} ש-{::nomarkdown}\( \tau_{0}\){:/nomarkdown} נותנת לו 1. עכשיו, לא ייתכן ש-{::nomarkdown}\( C\in T_{k-1}\){:/nomarkdown} כי ב-{::nomarkdown}\( T_{k-1}\){:/nomarkdown} היו רק טאוטולוגיות שמסתפקות על ידי כל השמה. כמו כן, אם {::nomarkdown}\( C\in N_{k-1}\){:/nomarkdown} אז על פי הגדה, {::nomarkdown}\( C\in\varphi_{k}\){:/nomarkdown} ו-{::nomarkdown}\( C\){:/nomarkdown} לא כוללת ליטרל עבור המשתנה {::nomarkdown}\( x_{k}\){:/nomarkdown} ולכן {::nomarkdown}\( \tau\){:/nomarkdown} נותנת ל-{::nomarkdown}\( C\){:/nomarkdown} אותו ערך כמו {::nomarkdown}\( \tau_{0}\){:/nomarkdown}, כלומר {::nomarkdown}\( \tau\){:/nomarkdown} אינה מספקת את {::nomarkdown}\( C\){:/nomarkdown} ולכן לא מספקת את {::nomarkdown}\( \varphi_{k}\){:/nomarkdown}, כפי שרצינו. אז סיימנו גם עם המקרה הזה. לבסוף, האם ייתכן ש-{::nomarkdown}\( C\in B_{k-1}\){:/nomarkdown}? שוב לא, כי אם {::nomarkdown}\( C\in B_{k-1}\){:/nomarkdown} אז {::nomarkdown}\( C\){:/nomarkdown} היא מהצורה {::nomarkdown}\( C=\left(\neg x_{k}\vee l_{1}\vee\dots\vee l_{t}\right)\){:/nomarkdown} ולכן {::nomarkdown}\( \tau_{0}\){:/nomarkdown} מספקת את הליטרל {::nomarkdown}\( \neg x_{k}\){:/nomarkdown} של {::nomarkdown}\( C\){:/nomarkdown}. מסקנה: בהכרח {::nomarkdown}\( C\in A_{k-1}\){:/nomarkdown}.

בדיוק באותו האופן, מכך ש-{::nomarkdown}\( \tau_{1}\){:/nomarkdown} אינה מספקת את {::nomarkdown}\( \varphi_{k-1}\){:/nomarkdown} אנחנו מסיקים שקיימת פסוקית {::nomarkdown}\( D\in B_{k-1}\){:/nomarkdown} שאינה מסתפקת על ידי {::nomarkdown}\( \tau_{1}\){:/nomarkdown}. עכשיו מגיע הפאנץ': בואו נסתכל על {::nomarkdown}\( C\otimes D\){:/nomarkdown}. זו פסוקית ששייכת ל-{::nomarkdown}\( \varphi_{k}\){:/nomarkdown}, מה שאומר ש-{::nomarkdown}\( \tau\){:/nomarkdown} מספקת אותה. אבל זה בלתי אפשרי: על כל המשתנים שאינם {::nomarkdown}\( x_{k}\){:/nomarkdown}, ההשמה {::nomarkdown}\( \tau\){:/nomarkdown} זהה להשמות {::nomarkdown}\( \tau_{0},\tau_{1}\){:/nomarkdown}, וההשמות הללו נותנות 0 לכל הליטרלים ב-{::nomarkdown}\( C,D\){:/nomarkdown} למעט {::nomarkdown}\( x_{k},\neg x_{k}\){:/nomarkdown} שאינם מופיעים ב-{::nomarkdown}\( C\otimes D\){:/nomarkdown}. הגענו לסתירה, והמסקנה היא שלפחות אחת מבין שתי ההשמות {::nomarkdown}\( \tau_{0},\tau_{1}\){:/nomarkdown} מספקת את {::nomarkdown}\( \varphi_{k-1}\){:/nomarkdown}, וזה משלים את האינדוקציה ואת ההוכחה כולה.

ההוכחה הזו היא מאוד תיאורטית. היא משכנעת אותנו שתמיד קיימת הוכחה, אבל הגישה שהיא נוקטת כדי למצוא את ההוכחה הזו היא מאוד ברוטלית - פשוט לעשות כל מה שאפשר בערך (אבל רק בערך; להקפדה על חיסול משתנים לפי הסדר יש חשיבות גדולה כאן). מכיוון שיש לנו {::nomarkdown}\( n\){:/nomarkdown} שלבים בהוכחה שבכל אחד מהם מבצעים רזולוציה על שתי קבוצות, לא קשה להשתכנע שבמקרה הגרוע מספר הפסוקיות שלנו עלול לגדול בערך בצורה ריבועית בכל שלב, ולכן האלגוריתם כולו הוא אקספוננציאלי - גם מבחינת זמן הריצה שלו וגם מבחינת כמות הזכרון שהוא דורש. אשאיר לכם לבצע את החישובים המדוייקים אם זה מסקרן אתכם. השאלה המעניינת היא, אם כן, האם בהכרח <strong>קיימת</strong> הוכחה קצרה ברזולוציה תמיד? והאם אפשר למצוא אותה תמיד ביעילות?

מציאה של הוכחה קצרה בפרט גם דורשת שההוכחה עצמה תהיה קצרה, כך שהשאלה השניה היא חזקה יותר מהראשונה ופחות סביר שהתשובה לה תהיה חיובית: אם התשובה חיובית אז אפשר יהיה להכריע את בעיית SAT בזמן יעיל, מה שגורר ש-P=NP, וזו <a href="http://www.gadial.net/2010/08/15/p_vs_np_overview/">תוצאה מאוד לא סבירה</a>. מצד שני, אולי יש הוכחות קצרות אבל פשוט אי אפשר למצוא אותן בזמן יעיל? כאן כדי להשוות את זה לבעיה ה"משלימה" - בהינתן פסוק CNF ספיק, האם יש לכך הוכחה קצרה? כאן התשובה היא בוודאי חיובית: ההשמה שמספקת את הפסוק כוללת בסך הכל {::nomarkdown}\( n\){:/nomarkdown} ביטים, אחד לכל משתנה. אז זו דוגמה לבעיה שבה יש הוכחה קצרה אבל כנראה (אם P שונה מ-NP) אין אלגוריתם יעיל שמוצא אותה.

ובכן, אם תמיד קיימות הוכחות קצרות לכך שפסוק CNF <strong>אינו</strong> ספיק, גם זה יגרור תשובה לא צפויה לבעיה פתוחה בסיבוכיות - השאלה האם NP=coNP. גם לשאלה הזו התשובה הצפויה היא שלילית (אם כי תמיד מעניין להזכיר כאן את <a href="http://www.gadial.net/2011/03/05/immerman_theorem/">משפט אימרמן</a> שמראה שעבור סיבוכיות <strong>זכרון</strong> התשובה היא דווקא חיובית). עבור רזולוציה יש גם בעיות שאפשר להוכיח שאין להן הוכחות קצרות - זה נושא בסיסי בתחום שנקרא Proof Complexity ואני מקווה להזכיר אותו בהמשך. באופן מעניין למדי, הפסוקים "הקשים ביותר" עבור רזולוציה (כאלו שעבורם ההוכחות הקצרות ביותר הקיימות הן הכי ארוכות) הם כאלו שמקודדים את <strong>בעיית שובך היונים</strong>, שלכאורה נשמעת כמו דבר פשוט. כאמור - נתעסק בזה בהמשך, אני מקווה.

אז באופן כללי אין לצפות למצוא הוכחות רזולוציה קצרות. אבל מה קורה בעולם האמיתי? מוצאים, ומשתמשים בהן. אלגוריתמים מודרניים לפתרון SAT לעתים קרובות מסוגלים ליצור הוכחת רזולוציה לאי-ספיקות הפסוק שהם בודקים; גם לזה אני מקווה שנגיע בהמשך.
