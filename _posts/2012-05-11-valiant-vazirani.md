---
id: 1616
title: "משפט Valiant-Vazirani, או: איך להרוג השמות מספקות עם פונקציות תמצות אקראיות"
date: 2012-05-11 13:23:44
layout: post
categories: 
  - תורת הסיבוכיות
tags: 
  - SAT
  - הסתברות
  - עקרון ההכלה וההפרדה
  - תורת הסיבוכיות
---
מזמן לא היה פה פוסט על סיבוכיות ומתחשק לי. מה שאני רוצה לדבר עליו הפעם הוא תוצאה מפתיעה יחסית (אם כי לא מפתיעה מספיק כדי להכנס לפנתאון של <a href="http://www.gadial.net/?tag=%D7%A4%D7%A8%D7%95%D7%99%D7%99%D7%A7%D7%98-%D7%AA%D7%95%D7%A6%D7%90%D7%95%D7%AA-%D7%9E%D7%A4%D7%AA%D7%99%D7%A2%D7%95%D7%AA-%D7%91%D7%A1%D7%99%D7%91%D7%95%D7%9B%D7%99%D7%95%D7%AA">"תוצאות מפתיעות בסיבוכיות"</a>) של Valiant ו-Vazirani שיש בה את כל מה שטוב בסיבוכיות - גם תוצאה מפתיעה, גם הוכחה אלגנטית ויפה, וגם רעיון שאחר כך אפשר להרחיב אותו עוד יותר לתוצאה שהיא <strong>ממש </strong>מפתיעה (משפט Toda, שאני מקווה להגיע גם אליו מתישהו). אבל לפני שנגיע לאקשן, רקע.

אולי הבעיה הקונקרטית המפורסמת ביותר בתורת הסיבוכיות היא SAT. בבעיה הזו נתון לנו פסוק לוגי בצורת CNF, כלומר הוא נראה כך: {::nomarkdown}\( C_{1}\wedge C_{2}\wedge\dots\wedge C_{k}\){:/nomarkdown}, כך שכל {::nomarkdown}\( C_{i}\){:/nomarkdown} נראה כך: {::nomarkdown}\( \left(l_{1}\vee l_{2}\vee\dots\vee l_{r}\right)\){:/nomarkdown}, כך שכל {::nomarkdown}\( l_{j}\){:/nomarkdown} הוא או משתנה {::nomarkdown}\( x\){:/nomarkdown} או שלילה של משתנה, {::nomarkdown}\( \neg x\){:/nomarkdown}. ל-{::nomarkdown}\( l\){:/nomarkdown} כזה קוראים "ליטרל", ל-{::nomarkdown}\( C\){:/nomarkdown} כזה קוראים "פסוקית CNF'', והשאלה היא זו: האם יש השמה למשתנים של הפסוק {::nomarkdown}\( \varphi\){:/nomarkdown} שמספקת אותו? השמה נותנת לכל משתנה ערך {::nomarkdown}\( \mbox{T}\){:/nomarkdown} או {::nomarkdown}\( \mbox{F}\){:/nomarkdown} (אמת או שקר). אם הליטרל {::nomarkdown}\( l\){:/nomarkdown} הוא מהצורה {::nomarkdown}\( x\){:/nomarkdown} הוא מקבל את הערך של {::nomarkdown}\( x\){:/nomarkdown} ואם הוא מהצורה {::nomarkdown}\( \neg x\){:/nomarkdown} הוא מקבל את הערך ההפוך לערך של {::nomarkdown}\( x\){:/nomarkdown}; הפסוקית {::nomarkdown}\( C_{i}\){:/nomarkdown} מקבלת את הערך {::nomarkdown}\( \mbox{T}\){:/nomarkdown} אם לפחות אחד מהליטרלים שלה קיבל {::nomarkdown}\( \mbox{T}\){:/nomarkdown} ואחרת היא מקבלת {::nomarkdown}\( \mbox{F}\){:/nomarkdown}; והפסוק כולו מקבל {::nomarkdown}\( \mbox{T}\){:/nomarkdown} רק אם כל הפסוקיות שבו קיבלו {::nomarkdown}\( \mbox{T}\){:/nomarkdown}. תחשבו על פסוק {::nomarkdown}\( \varphi\){:/nomarkdown} בתור "רשימה של אילוצים", כך שכל אילוץ הוא פסוקית, חייבים שכל האילוצים
יתקיימו בו זמנית, וכל אילוץ קל יחסית לקיים - רק צריך שאחד מהליטרלים בתוכו יתקיים.

דוגמה: {::nomarkdown}\( \varphi=\left(x\vee\neg y\right)\wedge\left(\neg x\vee z\right)\){:/nomarkdown}. זה פסוק שדי קל לספק, למשל על ידי ההשמה {::nomarkdown}\( x=\mbox{\ensuremath{\mbox{T}},y=\ensuremath{\mbox{F}},z=\ensuremath{\mbox{T}}}\){:/nomarkdown}. יש גם השמות שלא מספקות אותו, למשל {::nomarkdown}\( x=\mbox{F},y=\mbox{T},z=\mbox{F}\){:/nomarkdown}. אפשר, אם באמת רוצים, לספור כמה השמות מספקות יש ל-{::nomarkdown}\( \varphi\){:/nomarkdown}- די ברור שיש יותר מאחת.

אוקיי, תגידו, אז הבנו/נזכרנו מה הבעיה הזו. אבל למה בעיה ספציפית כזו מתחום הלוגיקה מעניינת בכלל? ובכן, בגלל שהיא האמא של הבעיות ה-NP-שלמות. יש לי <a href="http://www.gadial.net/?p=705">פוסט שמסביר</a> את הנושאים הללו ולכן רק תזכורת קצרה: בעיה NP-שלמה היא בעיה שאם היא נפתרת בצורה יעילה, אז עוד אלפי בעיות שכיום נחשבות קשות ולא ידוע פתרון יעיל עבורן ייפתרו גם הן. במילים אחרות, פתרון יעיל ל-SAT יהיה הסנסציה הגדולה ביותר במדעי המחשב מאז ומעולם (גם הוכחה לכך שאין פתרון יעיל ל-SAT תהיה סנסציה אדירה, אם כי צפויה קצת יותר ולכן גם מרגשת פחות). בינתיים המעמד של SAT הוא של "בעיה קשה, קשה, קשה לפתרון" (שקר גס, בפועל פותרים בעיות כאלו בעזרת היוריסטיקות ומסתדרים לא רע יחסית).

מה מתמטיקאים עושים עם בעיות קשות שאין לאף אחד מושג איך לפתור? חושבים עליהן יותר חזק? לא. מנסים לפתח תורה מתמטית חדשה שתתמודד עם הבעיה? לא. מתכנסים בליל ירח מלא בתוך <a href="http://www.gadial.net/?p=835">המלון של הילברט</a>, מקריבים את <a href="http://www.gadial.net/?p=134">הצב של זנון</a> על מזבח הריגורוזיות ומתפללים ל<a href="http://www.gadial.net/?p=428">נוסחת אוילר</a>? לא. מנסים לפתור מקרה פרטי של הבעיה הקשה שהוא אולי יותר קל? או, עכשיו אנחנו בכיוון.

אז בואו נאמר שאנחנו רוצים להיות מסוגלים להבדיל רק בין שני מקרים - המקרה שבו ל-{::nomarkdown}\( \varphi\){:/nomarkdown} אין בכלל השמות מספקות, והמקרה שבו יש ל-{::nomarkdown}\( \varphi\){:/nomarkdown} השמה מספקת אחת. ויותר מזה - אנחנו מרשים לאלגוריתם שלנו להיות הסתברותי עם טעות חד-צדדית. כלומר, <strong>אם</strong> {::nomarkdown}\( \varphi\){:/nomarkdown} אינו ספיק, אנחנו דורשים שהאלגוריתם יעצור ובודאות יגיד "לא", אבל אם {::nomarkdown}\( \varphi\){:/nomarkdown} ספיק על ידי השמה מספקת אחת <strong>בדיוק</strong> כל מה שאנחנו דורשים הוא שהוא יעצור ויגיד "כן" בהסתברות נמוכה כלשהי (כמה נמוכה? נדון בכך אחר כך). אם {::nomarkdown}\( \varphi\){:/nomarkdown} ספיק על ידי יותר מהשמה מספקת אחת ממש לא אכפת לנו מה האלגוריתם יעשה. האינטואיציה היא זו: אם המקרה הזה קל יותר מהבעיה הכללית, אולי הבנה של הפתרון שלו תעזור לנו להבין איך לפתור את הבעיה הכללית או היכן טמון הקושי בבעיה הכללית; ואילו אם הוא קשה מספיק לכשעצמו אז אולי נקבל אינטואיציה טובה יותר לגבי הקושי הזה. ובכן, משפט VV מראה לנו, באופן די מפתיע, שגם המקרה הזה הוא קשה למדי; ספציפית, אם יש אלגוריתם שפותר אותו נובע מכך ש<strong>לכל</strong> בעיה ב-NP יש אלגוריתם הסתברותי עם טעות חד צדדית שפותר
אותה, בפרט ל-SAT עצמה (בלשון סיבוכיותית, {::nomarkdown}\( \mbox{RP=NP}\){:/nomarkdown}). משפט VV מראה זאת על ידי תיאור של דרך לפתור את {::nomarkdown}\( \mbox{SAT}\){:/nomarkdown} בעזרת פתרון לבעיה הפשוטה יותר - הוא עושה זאת באמצעות <strong>רדוקציה אקראית</strong>, ואסביר עכשיו מה זה בדיוק אומר.

באופן פורמלי, המשפט אומר שאם נתון לנו פסוק CNF {::nomarkdown}\( \varphi\){:/nomarkdown} אז אפשר להמיר אותו (באופן הסתברותי) לפסוק {::nomarkdown}\( \mbox{CNF}\){:/nomarkdown} {::nomarkdown}\( \varphi^{\prime}\){:/nomarkdown} כך ש:
<ol>
	<li> ההמרה מתבצעת בזמן יעיל (פולינומי באורך של {::nomarkdown}\( \varphi\){:/nomarkdown}).</li>
	<li> אם {::nomarkdown}\( \varphi\){:/nomarkdown} לא ספיק אז גם {::nomarkdown}\( \varphi^{\prime}\){:/nomarkdown} לא ספיק.</li>
	<li> אם {::nomarkdown}\( \varphi\){:/nomarkdown} ספיק אז בהסתברות לא רעה ל-{::nomarkdown}\( \varphi^{\prime}\){:/nomarkdown} יש בדיוק השמה מספקת אחת ("הסתברות לא רעה" כאן היא {::nomarkdown}\( \frac{1}{8n}\){:/nomarkdown} כש-{::nomarkdown}\( n\){:/nomarkdown} הוא מספר המשתנים של {::nomarkdown}\( \varphi\){:/nomarkdown}).</li>
</ol>
יפה, אז הבנו מה המשפט אומר. עכשיו אפשר לגשת לאקשן האמיתי - ההוכחה.

הבניה עצמה היא פשוטה באופן מפתיע. מה שנעשה יהיה להוסיף ל-{::nomarkdown}\( \varphi\){:/nomarkdown} עוד אילוצים; פורמלית, {::nomarkdown}\( \varphi^{\prime}\left(x\right)=\varphi\left(x\right)\wedge\left(h\left(x\right)=0\right)\){:/nomarkdown}, כאשר {::nomarkdown}\( h\left(x\right)=0\){:/nomarkdown} כאן הוא קידוד של פסוק CNF שבודק ש-{::nomarkdown}\( h\left(x\right)=0\){:/nomarkdown} עבור פונקציה {::nomarkdown}\( h\){:/nomarkdown} שמוגרלת באופן מסויים שאסביר בקרוב. מייד נשאלת השאלה איך מקודדים את {::nomarkdown}\( h\left(x\right)=0\){:/nomarkdown} בתור פסוק CNF; נדחה את השאלה הזו להמשך.

לב הרעיון, שמשתמשים בו במקומות נוספים בסיבוכיות, הוא לבחור את {::nomarkdown}\( h\){:/nomarkdown} מתוך אוסף של <strong>פונקציות תמצות בלתי תלויות בזוגות</strong>. עזבו אתכם ממה זה אומר באופן כללי ובואו נדבר קונקרטית. אנחנו חושבים על {::nomarkdown}\( x\){:/nomarkdown} (שהוא וקטור של {::nomarkdown}\( \mbox{T}\){:/nomarkdown} ו-{::nomarkdown}\( \mbox{F}\){:/nomarkdown}) בתור איבר של {::nomarkdown}\( \mathbb{Z}_{2}^{n}\){:/nomarkdown} - סדרה מאורך {::nomarkdown}\( n\){:/nomarkdown} של אפסים ואחדים - ואנחנו מגרילים מטריצה {::nomarkdown}\( A\in\mathbb{Z}_{2}^{k\times n}\){:/nomarkdown} עם {::nomarkdown}\( k\){:/nomarkdown} שורות ו-{::nomarkdown}\( n\){:/nomarkdown} עמודות, כך ש-{::nomarkdown}\( k\){:/nomarkdown} עצמו נבחר באקראי מתוך {::nomarkdown}\( \left\{ 2,3,\dots,n+1\right\} \){:/nomarkdown} (למה התחום המוזר הזה? יהיה הסבר, סבלנות) ובנוסף אנחנו מגרילים וקטור {::nomarkdown}\( b\in\mathbb{Z}_{2}^{k}\){:/nomarkdown}, וכעת מגדירים {::nomarkdown}\( h\left(x\right)=Ax+b\){:/nomarkdown}. כלומר, {::nomarkdown}\( h\){:/nomarkdown} תלויה בביטים של {::nomarkdown}\( A\){:/nomarkdown} ושל {::nomarkdown}\( b\){:/nomarkdown}.

כדאי לחשוב על העניין כך: כל שורה {::nomarkdown}\( a^{i}\in\mathbb{Z}_{2}^{n}\){:/nomarkdown} של {::nomarkdown}\( A\){:/nomarkdown} מגדירה אילוץ מהצורה {::nomarkdown}\( a^{i}\cdot x=b_{i}\){:/nomarkdown} (העברתי את ה-{::nomarkdown}\( b\){:/nomarkdown} אגף, ומכיוון שאנחנו מעל {::nomarkdown}\( \mathbb{Z}_{2}\){:/nomarkdown} אין צורך לשנות סימן). עכשיו, די בבירור אם אני מגריל את {::nomarkdown}\( a\){:/nomarkdown} ואת {::nomarkdown}\( b_{i}\){:/nomarkdown} בהתפלגות אחידה אז יש ל-{::nomarkdown}\( x\){:/nomarkdown} נתון הסתברות של {::nomarkdown}\( \frac{1}{2}\){:/nomarkdown} לקיים את האילוץ, כי אם "נקפיא" את {::nomarkdown}\( a\){:/nomarkdown} אז עבור אחד מהערכים האפשריים של {::nomarkdown}\( b_{i}\){:/nomarkdown} האילוץ יתקיים ועבור הערך השני של {::nomarkdown}\( b_{i}\){:/nomarkdown} האילוץ לא יתקיים, ולכן הוא מתקיים בדיוק עבור חצי מהזוגות {::nomarkdown}\( \left(a,b_{i}\right)\){:/nomarkdown}. במילים אחרות, לכל {::nomarkdown}\( x\){:/nomarkdown} יש הסתברות של {::nomarkdown}\( \frac{1}{2}\){:/nomarkdown} לשרוד כל אחד מהאילוצים, ומכיוון שכל {::nomarkdown}\( k\){:/nomarkdown} האילוצים נבחרים באופן בלתי תלוי זה בזה, יש ל-{::nomarkdown}\( x\){:/nomarkdown} סיכוי של {::nomarkdown}\( 2^{-k}\){:/nomarkdown} לשרוד את כל האילוצים. אם כן, {::nomarkdown}\( h\){:/nomarkdown} מדללת באופן <strong>אקספוננציאלי</strong> את כמות ה-{::nomarkdown}\( x\){:/nomarkdown}-ים שמספקים את {::nomarkdown}\( \varphi\){:/nomarkdown}, ובגלל שיש לנו שליטה על {::nomarkdown}\( k\){:/nomarkdown} נוכל לבחור את רמת הדילול המדוייקת שאנחנו צריכים, בהסתברות לא רעה. פורמלית: {::nomarkdown}\( \mbox{Pr}_{h}\left[h\left(x\right)=0\right]=2^{-k}\){:/nomarkdown}. אסמן {::nomarkdown}\( p=2^{-k}\){:/nomarkdown} לצורך פשטות.

בינתיים כל מה שעשיתי נראה מטופש להפליא. למה בכלל הגרלתי {::nomarkdown}\( A\){:/nomarkdown}? הרי היא לא סייעה לי בטיעון. הייתי יכול להגריל רק את {::nomarkdown}\( b\){:/nomarkdown} ולהשוות אותו בכל פעם ל-{::nomarkdown}\( x_{1}+x_{2}+\dots+x_{n}\){:/nomarkdown} וחסל. אלא שאני זקוק לעוד תכונה של ה-{::nomarkdown}\( h\){:/nomarkdown} שאני מגריל - בדיוק תכונת ה<strong>בלתי תלויות בזוגות</strong> שהוזכרה קודם; בלעדיה אני באמת לא אוכל לעשות הרבה. מה שאני רוצה לומר הוא שלא רק ש-{::nomarkdown}\( h\){:/nomarkdown} מדללת "הרבה", אלא גם שהיא מדללת באופן ש<strong>יוצר פער</strong> בין, נאמר, דילול שמשאיר רק השמה מספקת אחת בחיים ודילול שמשאיר שתיים כאלו בחיים. בשביל להראות את זה אני צריך להראות שההסתברות לכך ששתי השמות נתונות שונות זו מזו יישארו בחיים קטן משמעותית מההסתברות של השמה אחת להישאר בחיים. ספציפית, אני רוצה לחשב את {::nomarkdown}\( \mbox{Pr}\left[h\left(x\right)=0\wedge h\left(y\right)=0\right]\){:/nomarkdown} עבור {::nomarkdown}\( x\ne y\){:/nomarkdown}. כאן מגיע תעלול רעיוני שהוא לב ההוכחה ולטעמי הוא רעיון מקסים ביותר, למרות שהוא גם מאוד פשוט.

הרעיון הוא כזה: מכיוון ש-{::nomarkdown}\( x\ne y\){:/nomarkdown} יש ביט, נאמר {::nomarkdown}\( i\){:/nomarkdown}, כך ש-{::nomarkdown}\( x_{i}=0\){:/nomarkdown} ו-{::nomarkdown}\( y_{i}=1\){:/nomarkdown} (או הפוך). נסתכל על אילוץ {::nomarkdown}\( \left(a^{k},b_{k}\right)\){:/nomarkdown} כלשהו ש-{::nomarkdown}\( x\){:/nomarkdown} <strong>מספק</strong>, כלומר {::nomarkdown}\( a^{k}\cdot x=b_{k}\){:/nomarkdown}. אז מכיוון ש-{::nomarkdown}\( x_{i}=0\){:/nomarkdown}, זה אומר שהביט במקום ה-{::nomarkdown}\( i\){:/nomarkdown} בוקטור {::nomarkdown}\( a^{k}\){:/nomarkdown} <strong>לא משנה</strong> את הערך של {::nomarkdown}\( a^{k}\cdot x\){:/nomarkdown}; בפרט, אם אגדיר {::nomarkdown}\( c^{k}\){:/nomarkdown} כך ש-{::nomarkdown}\( a^{k}=c^{k}\){:/nomarkdown} בכל ביט פרט לביט ה-{::nomarkdown}\( i\){:/nomarkdown} ושם הם הפוכים, אז יתקיים גם {::nomarkdown}\( c^{k}\cdot x=b_{k}\){:/nomarkdown}.

לעומת זאת, <strong>לא ייתכן</strong> ש-{::nomarkdown}\( a^{k}\cdot y=c^{k}\cdot y\){:/nomarkdown}, כי הערכים של {::nomarkdown}\( a^{k}\cdot y,c^{k}\cdot y\){:/nomarkdown} נבדלים ב-1 בדיוק (הסבירו את זה לעצמכם!) ולכן {::nomarkdown}\( y\){:/nomarkdown} מקיים <strong>בדיוק אחד משני האילוצים</strong> {::nomarkdown}\( a^{k}\cdot y=b_{k}\){:/nomarkdown} ו-{::nomarkdown}\( c^{k}\cdot y=b_{k}\){:/nomarkdown}, כלומר {::nomarkdown}\( y\){:/nomarkdown} מקיים בדיוק <strong>חצי</strong> מהאילוצים ש-{::nomarkdown}\( x\){:/nomarkdown} מקיים, כלומר ההסתברות לכך ש-{::nomarkdown}\( y\){:/nomarkdown} יקיים אילוץ בהינתן ש-{::nomarkdown}\( x\){:/nomarkdown} מקיים אותו היא {::nomarkdown}\( \frac{1}{2}\){:/nomarkdown}, כלומר ההסתברות ש-{::nomarkdown}\( x,y\){:/nomarkdown} יקיימו אילוץ מסויים בו זמנית היא {::nomarkdown}\( \frac{1}{4}\){:/nomarkdown}, ולכן ההסתברות ששניהם יקיימו זמנית את כל האילוצים היא {::nomarkdown}\( 4^{-k}\){:/nomarkdown}, כלומר {::nomarkdown}\( \mbox{Pr}\left[h\left(x\right)=0\wedge h\left(y\right)=0\right]=p^{2}\){:/nomarkdown}. אם הבנתם את זה - הבנתם את העיקר בהוכחה (שימו לב שהעיקר הזה הוא תכונה כללית של פונקציות תמצות בלתי תלויות בזוגות; זה לא משהו שייחודי למשפט הנוכחי).

עכשיו בואו נבין איך זה עוזר לנו. נסמן ב-{::nomarkdown}\( S\){:/nomarkdown} את קבוצת ההשמות שמספקות את {::nomarkdown}\( \varphi\){:/nomarkdown}. בבירור אם {::nomarkdown}\( S\){:/nomarkdown} ריקה אז אין השמה שמספקת את {::nomarkdown}\( \varphi^{\prime}\){:/nomarkdown} (כי כל השמה שמספקת את {::nomarkdown}\( \varphi^{\prime}\){:/nomarkdown} בפרט צריכה לספק את {::nomarkdown}\( \varphi\){:/nomarkdown}). לכן נניח ש-{::nomarkdown}\( \left\|S\right\|\ge1\){:/nomarkdown}. נסמן ב-{::nomarkdown}\( N\){:/nomarkdown} את מספר ההשמות ב-{::nomarkdown}\( S\){:/nomarkdown} שמקיימות {::nomarkdown}\( h\left(x\right)=0\){:/nomarkdown}; זה משתנה מקרי שתלוי בבחירת {::nomarkdown}\( h\){:/nomarkdown}. אנחנו רוצים למצוא מהו {::nomarkdown}\( \mbox{Pr}_{h}\left[N=1\right]\){:/nomarkdown}. דרך אחת לעשות זאת היא כך: {::nomarkdown}\( \mbox{Pr}_{h}\left[N=1\right]=\mbox{Pr}_{h}\left[N\ge1\right]-\mbox{Pr}_{h}\left[N\ge2\right]\){:/nomarkdown} (הסבירו לעצמכם למה!) ולכן, אם אנחנו רוצים למצוא חסם מלמטה עבור {::nomarkdown}\( \mbox{Pr}_{h}\left[N=1\right]\){:/nomarkdown} (אין צורך לחשב את ההסתברות במדויק) מספיק למצוא חסם מלמטה עבור {::nomarkdown}\( \mbox{Pr}_{h}\left[N\ge1\right]\){:/nomarkdown} וחסם מלמעלה עבור {::nomarkdown}\( \mbox{Pr}_{h}\left[N\ge2\right]\){:/nomarkdown}.

כדי להקל על הסימונים, בואו נסמן בתור {::nomarkdown}\( A_{x}\){:/nomarkdown} את המאורע "{::nomarkdown}\( h\left(x\right)=0\){:/nomarkdown}" (כלומר, {::nomarkdown}\( A_{x}\){:/nomarkdown} היא קבוצת ה-{::nomarkdown}\( h\){:/nomarkdown}-ים שמקיימים {::nomarkdown}\( h\left(x\right)=0\){:/nomarkdown}) ובדומה נסמן ב-{::nomarkdown}\( A_{x,y}\){:/nomarkdown} את המאורע "{::nomarkdown}\( h\left(x\right)=0\wedge h\left(y\right)=0\){:/nomarkdown}". כעת:

{::nomarkdown}\( \mbox{Pr}_{h}\left[N\ge2\right]=\mbox{Pr}\left[\bigcup_{x&lt;y\in S}A_{x,y}\right]\le\sum_{x&lt;y\in S}\mbox{Pr}\left[A_{x,y}\right]=\sum_{x&lt;y\in S}p^{2}={\left\|S\right\| \choose 2}p^{2}\){:/nomarkdown}

השתמשתי כאן במה שנקרא Union-bound - ההסתברות של איחוד מאורעות חסומה מלעיל על ידי סכום ההסתברויות של כולם. זה לרוב חסם גס מאוד, אבל כאן הוא מספיק טוב לנו.

לחסום את {::nomarkdown}\( \mbox{Pr}\left[N\ge1\right]\){:/nomarkdown} מלמטה זה קצת יותר מחוכם. התעלול הוא להשתמש ב<strong><a href="http://www.gadial.net/?p=1468">עקרון הההכלה וההפרדה</a></strong>. כשמפעילים אותו על המקרה הנוכחי, מקבלים:

{::nomarkdown}\( \mbox{Pr}\left[N\ge1\right]=\mbox{Pr}\left[\bigcup A_{x}\right]-\mbox{Pr}\left[\bigcup A_{x,y}\right]+\mbox{Pr}\left[\bigcup A_{x,y,z}\right]-\dots\){:/nomarkdown}

(למה? ובכן, אם נכפול את שני אגפי המשוואה במספר ה-{::nomarkdown}\( h\){:/nomarkdown}-ים הכולל האפשרי, נוכל להפסיק לדבר על הסתברות ולעבור לדבר על קומבינטוריקה סופית טהורה ואז יהיה יותר ברור שעקרון ההכלה וההפרדה תקף כאן). הנקודה הקריטית כאן היא שה"זנב" {::nomarkdown}\( \mbox{Pr}\left[\bigcup A_{x,y,z}\right]-\mbox{Pr}\left[\bigcup A_{x,y,z,w}\right]+\dots\){:/nomarkdown} הוא חיובי, כי אפשר לפרק אותו לזוגות של "משהו חיובי פחות משהו קטן ממנו". לכן אפשר להיפטר מהזנב לגמרי:

{::nomarkdown}\( \mbox{Pr}\left[N\ge1\right]\ge\mbox{Pr}\left[\bigcup A_{x}\right]-\mbox{Pr}\left[\bigcup A_{x,y}\right]=\left\|S\right\|p-{\left\|S\right\| \choose 2}p^{2}\){:/nomarkdown}

ועכשיו מחיבור שני האי שוויונות שמצאנו, נקבל:

{::nomarkdown}\( \mbox{Pr}\left[N=1\right]=\mbox{Pr}_{h}\left[N\ge1\right]-\mbox{Pr}_{h}\left[N\ge2\right]\ge\left\|S\right\|p-2{\left\|S\right\| \choose 2}p^{2}\ge\left\|S\right\|p-\left(\left\|S\right\|p\right)^{2}\){:/nomarkdown}

עכשיו, את הפונקציה {::nomarkdown}\( f\left(t\right)=t-t^{2}\){:/nomarkdown} קל לחקור אם יודעים טיפה אינפי; מהר מאוד רואים שבקטע {::nomarkdown}\( \left[\frac{1}{4},\frac{1}{2}\right]\){:/nomarkdown} היא פונקציה עולה, לכן המינימום שלה מתקבל ב-{::nomarkdown}\( t=\frac{1}{4}\){:/nomarkdown} והוא {::nomarkdown}\( \frac{1}{4}-\frac{1}{16}=\frac{3}{16}&gt;\frac{1}{8}\){:/nomarkdown}. לכן הגענו למסקנה הבאה: אם {::nomarkdown}\( \frac{1}{4}\le\left\|S\right\|p\le\frac{1}{2}\){:/nomarkdown}, אז {::nomarkdown}\( \mbox{Pr}\left[N=1\right]\ge\frac{1}{8}\){:/nomarkdown}. לא רע בכלל!

עכשיו, מהו {::nomarkdown}\( p\){:/nomarkdown}? כזכור, {::nomarkdown}\( p=2^{-k}\){:/nomarkdown}. ומי זה {::nomarkdown}\( k\){:/nomarkdown}? את {::nomarkdown}\( k\){:/nomarkdown} בחרנו באקראי בתחום {::nomarkdown}\( \left\{ 2,\dots,n+1\right\} \){:/nomarkdown}. אז כדי שיתקיים {::nomarkdown}\( \frac{1}{4}\le\left\|S\right\|p\le\frac{1}{2}\){:/nomarkdown} צריך שיתקיים {::nomarkdown}\( 2^{k-2}\le\left\|S\right\|\le2^{k-1}\){:/nomarkdown}. אבל, מכיוון ש-{::nomarkdown}\( 1\le\left\|S\right\|\le2^{n}\){:/nomarkdown}, זה <strong>בהכרח</strong> קורה לאחד מה-{::nomarkdown}\( k\){:/nomarkdown}-ים בדיוק בתחום {::nomarkdown}\( \left\{ 2,\dots,n+1\right\} \){:/nomarkdown}, שאני מקווה שעכשיו נראה קצת יותר ברור. לכן ההסתברות שלנו לבחור {::nomarkdown}\( k\){:/nomarkdown} "נכון" היא {::nomarkdown}\( \frac{1}{n}\){:/nomarkdown} (גודל התחום), ולכן ההסתברות של הרדוקציה כולה לעבור היא לפחות {::nomarkdown}\( \frac{1}{8n}\){:/nomarkdown} - בדיוק מה שהבטחתי שאוכיח. סיימנו!

ובכן, לא, עוד לא סיימנו כי עוד לא הסברתי איך לקודד את {::nomarkdown}\( h\left(x\right)=0\){:/nomarkdown}. זה לא מובן מאליו; צריך להיזהר ולא לקודד את הביטוי הזה על ידי נוסחת CNF גדולה <strong>מדי</strong>. כדי לעשות את זה אהיה חייב להשתמש במשתני עזר; קיימת הוכחה לכך שאפילו מקרה פרטי - הנוסחה {::nomarkdown}\( x_{1}\oplus\dots\oplus x_{n}=0\){:/nomarkdown}, הידועה גם בתור הפונקציה PARITY - לא ניתן לקודד כפסוק CNF קצר (פולינומי) באופן כזה שכל השמה למשתנים תחזיר את הערך הנכון של הפרדיקט {::nomarkdown}\( x_{1}\oplus\dots\oplus x_{n}=0\){:/nomarkdown}. אז מה שאעשה יהיה שונה: אני אקודד את {::nomarkdown}\( h\left(x\right)=0\){:/nomarkdown} על ידי פסוק {::nomarkdown}\( \psi\left(x,z\right)\){:/nomarkdown} כך ש-{::nomarkdown}\( z\){:/nomarkdown} הם משתני עזר, כך ש<strong>אם</strong> {::nomarkdown}\( h\left(x\right)=0\){:/nomarkdown} אז קיימת השמה <strong>יחידה</strong> למשתני העזר כך ש-{::nomarkdown}\( \psi\left(x,z\right)=\mbox{T}\){:/nomarkdown}; ואחרת אף השמה לא תספק את {::nomarkdown}\( \psi\){:/nomarkdown}. לבקיאים רק אציין שאפשר לעצור כבר כאן באמירה "ניקח מכונת טיורינג דטרמיניסטית שבודקת אם {::nomarkdown}\( h\left(x\right)=0\){:/nomarkdown} ומקבלת אם כן, ו-{::nomarkdown}\( \psi\){:/nomarkdown} יהיה קידוד קוק-לוין של הריצה שלה" אבל לטובת אלו מכם שאין להם מושג מה אמרתי, או לא זוכרים
את הפרטים של קוק-לוין, אתן כאן בניה ישירה. ולמען הסר ספק: אני עצמי לא ממש זוכר את הפרטים של קוק-לוין ומעדיף הרבה יותר לראות בניה ישירה מאשר את נפנוף הידיים המתועב הזה.

בואו נתחיל ממשהו פשוט: איך אני מקודד ב-CNF את {::nomarkdown}\( x\oplus y\){:/nomarkdown}? פשוט מאוד: {::nomarkdown}\( \left(x\vee y\right)\wedge\left(\neg x\vee\neg y\right)\){:/nomarkdown}. מה קורה פה? אם {::nomarkdown}\( x=y\){:/nomarkdown} אז או ש-{::nomarkdown}\( x\vee y\){:/nomarkdown} לא יסתפק (אם {::nomarkdown}\( x=y=\mbox{F}\){:/nomarkdown}) או ש-{::nomarkdown}\( \neg x\vee\neg y\){:/nomarkdown} לא יסתפק (אם {::nomarkdown}\( x=y=\mbox{T}\){:/nomarkdown}). ההכללה של זה לשלושה משתנים לא מסובכת: את {::nomarkdown}\( x\oplus y\oplus w\){:/nomarkdown} נקודד בתור {::nomarkdown}\( \left(x\vee\neg y\vee\neg w\right)\wedge\left(\neg x\vee\neg y\vee w\right)\wedge\left(\neg x\vee y\vee\neg w\right)\wedge\left(x\vee y\vee w\right)\){:/nomarkdown}. האם אתם רואים את העקרון? בכל זוג סוגריים צריכים להיות מספר זוגי של שלילות. כך, אם יש לנו השמה כלשהי למשתנים שבה מספר זוגי של משתנים קיבל {::nomarkdown}\( \mbox{T}\){:/nomarkdown}, יהיה זוג סוגריים שיחזיר {::nomarkdown}\( \mbox{F}\){:/nomarkdown} (בדיוק זה שבו אותם המשתנים מופיעים עם {::nomarkdown}\( \neg\){:/nomarkdown}) ולעומת זאת כל השמה שבה מספר אי זוגי של משתנים קיבל {::nomarkdown}\( \mbox{T}\){:/nomarkdown} בהכרח תספק את כל זוגות הסוגריים (כי אז אז או שאחד מהמשתנים שקיבלו {::nomarkdown}\( \mbox{T}\){:/nomarkdown} מופיע בלי {::nomarkdown}\( \neg\){:/nomarkdown}, או שאחד מהמשתנים שקיבל {::nomarkdown}\( \mbox{F}\){:/nomarkdown} מופיע עם {::nomarkdown}\( \neg\){:/nomarkdown}). אלא
שאם יש לנו {::nomarkdown}\( n\){:/nomarkdown} משתנים, זה אומר שנצטרך ליצור פסוק עם המון פסוקיות - {::nomarkdown}\( 2^{n-1}\){:/nomarkdown} (פורמלית, {::nomarkdown}\( {n \choose 0}+{n \choose 2}+\dots\){:/nomarkdown} ויש תעלולים שמראים שהסכום אכן יוצא {::nomarkdown}\( 2^{n-1}\){:/nomarkdown}). בקיצור, אקספוננציאלי. אז השיטה הישירה לא תעבוד כאן ואנחנו חייבים משהו מתוחכם יותר.

הנה תעלול אפשרי אחד: אם אנחנו רוצים לקודד את {::nomarkdown}\( x_{1}\oplus x_{2}\oplus\dots\oplus x_{n}\){:/nomarkdown}, אפשר תחת זאת לקודד את {::nomarkdown}\( \left(z_{1}=x_{1}\oplus x_{2}\right)\wedge\left(z_{2}=z_{1}\oplus x_{3}\right)\wedge\dots\wedge\left(z_{n-1}=z_{n-2}\oplus x_{n}\right)\wedge\left(z_{n-1}\right)\){:/nomarkdown}. זה יפתור לנו את הבעיה, בהינתן שאפשר לקודד משהו כמו {::nomarkdown}\( z=x\oplus y\){:/nomarkdown} בעזרת פסוק CNF מאורך פולינומי. ובכן, איך מוצאים דבר כזה באופן שיטתי, בלי ניסוי וטעיה? ראשית כותבים את {::nomarkdown}\( z\ne x\oplus y\){:/nomarkdown} בתור DNF דווקא; לכתוב DNF זה קל כי פשוט מבצעים {::nomarkdown}\( \vee\){:/nomarkdown} על כל ארבע ההשמות האפשריות שיספקו את {::nomarkdown}\( z\ne x\oplus y\){:/nomarkdown}: {::nomarkdown}\( \left(x\wedge y\wedge z\right)\vee\left(\neg x\wedge\neg y\wedge z\right)\vee\left(\neg x\wedge y\wedge\neg z\right)\vee\left(x\wedge\neg y\wedge\neg z\right)\){:/nomarkdown}. עכשיו מפעילים שלילה על הפסוק כולו ומשתמשים בכללי דה-מורגן, ומקבלים {::nomarkdown}\( \left(\neg x\vee\neg y\vee\neg z\right)\wedge\left(x\vee y\vee\neg z\right)\wedge\left(x\vee\neg y\vee z\right)\wedge\left(\neg x\vee y\vee z\right)\){:/nomarkdown}. זה מסיים את ההוכחה כולה.

ההוכחה עצמה יפה מספיק כדי להצדיק פוסט, לטעמי, אבל הסיפור לא נגמר כאן. המשכים אפשריים הם ההוכחה של משפט Toda שמשתמשת ב-VV בתור כלי בסיסי, והוכחה של תוצאות מרהיבות אחרות בסיבוכיות שעושות שימוש באותו תעלול של פונקציות תמצות בלתי תלויות בזוגות. אני מקווה להציג את כל הדברים הללו בעתיד.
