---
id: 3227
title: "מבוא לדקדוקים חסרי הקשר"
date: 2015-03-05 16:54:32
layout: post
categories: 
  - תורת הסיבוכיות
tags: 
  - דקדוקים
  - שפות חסרות הקשר
  - שפות רגולריות
---
הפוסט על משפט נרוד מהווה לטעמי סיום הולם לנושא של שפות רגולריות, אבל מהנושא הזה יש קפיצה טבעית מאוד אל נושא קרוב ברוחו - שפות חסרות הקשר. בזמן שהכלי העיקרי שבו השתמשנו כדי לתאר שפות רגולריות היה אוטומטים, עבור שפות חסרות הקשר הכלי הזה הוא דקדוקים. באופן כללי דקדוקים הם דבר מאוד מועיל ומעניין שכדאי להציג ואפשר לגשת אליו בכמה דרכים שונות; בפוסט הזה אנקוט בדרך קצת מוזרה יחסית (אבל נחמדה, לטעמי, אחרת לא הייתי מציג אותה) שבה נגיע אל המושג של דקדוק מתוך המושג של ביטוי רגולרי.

בואו ניזכר מה זה ביטוי רגולרי. זה סימון שבא לתאר שפות, באופן הבא: {::nomarkdown}\( \emptyset\){:/nomarkdown} מסמן את השפה הריקה; {::nomarkdown}\( \varepsilon\){:/nomarkdown} מסמן שפה שהאיבר היחיד שלה הוא המילה הריקה, {::nomarkdown}\( \sigma\){:/nomarkdown} מסמן שפה שהאיבר היחיד שלה הוא המילה בעלת האות הבודדת {::nomarkdown}\( \sigma\){:/nomarkdown}, ואם {::nomarkdown}\( r_{1},r_{2}\){:/nomarkdown} הם ביטויים רגולריים אז {::nomarkdown}\( \left(r_{1}+r_{2}\right)\){:/nomarkdown} מסמן את איחוד השפות שלהם, {::nomarkdown}\( \left(r_{1}\cdot r_{2}\right)\){:/nomarkdown} את שרשור השפות שלהם ו-{::nomarkdown}\( \left(r_{1}^{*}\right)\){:/nomarkdown} את סגור קלייני של שפת {::nomarkdown}\( r_{1}\){:/nomarkdown} - אוסף כל השרשורים של אפס או יותר מילים מהשפה של {::nomarkdown}\( r_{1}\){:/nomarkdown}.

למשל, אם {::nomarkdown}\( \Sigma=\left\{ a,b\right\} \){:/nomarkdown} הוא האלפבית שלנו, אז שפת כל המילים מאורך זוגי מעל האלפבית הזה מתוארת על ידי הביטוי הרגולרי {::nomarkdown}\( \left(\left(a+b\right)\left(a+b\right)\right)^{*}\){:/nomarkdown}. כאן כבר הרשיתי לעצמי להשמיט סוגריים ואת הסימן {::nomarkdown}\( \cdot\){:/nomarkdown}.

עד עכשיו חשבנו על ביטויים רגולריים בתור כלי לתיאור של שפה, ואולי גם בתור מין "מתכון" לבניית אוטומט שמזהה אותה. עכשיו אני רוצה להציג דרך טיפה שונה להתבונן עליהן - בתור מתכון עבור אלגוריתם ל<strong>ייצור</strong> של מילים בשפה של הביטוי. האלגוריתם הולך לייצר את כל המילים בשפה, ורק אותן. כל הרצה שלו תסתיים אחרי מספר סופי של צעדים עם פלט שהוא אחת מהמילים בשפה, או שתודיע "נתקעתי" ולא תייצר מילה בריצה הזו, וריצות שונות ייבדלו זו מזו על ידי בחירות שונות שהאלגוריתם יכול לבצע בחלק משלביו.

כדי להבין איך זה הולך, בואו ניקח את הביטוי הרגולרי לשפת המילים מאורך זוגי ונחשוב על האופן שבו אפשר לייצג אותו במחשב, בצורה שהיא קצת יותר חכמה מסתם מחרוזת אלא כוללת מידע על המבנה שלו. אפשר לומר שיש משתנה כלשהו, נסמן אותו {::nomarkdown}\( S\){:/nomarkdown}, שמייצג את כל הביטוי; ושיש משתנה {::nomarkdown}\( A\){:/nomarkdown} שמייצג את החלק שבין הסוגריים החיצוניים, כלומר {::nomarkdown}\( S=A^{*}\){:/nomarkdown}. גם את {::nomarkdown}\( A\){:/nomarkdown} נוכל להציג בעזרת משתנה אחר, {::nomarkdown}\( A=BB\){:/nomarkdown}; ואת {::nomarkdown}\( B\){:/nomarkdown} אפשר להציג בתור {::nomarkdown}\( B=C+D\){:/nomarkdown}, כאשר {::nomarkdown}\( C=a\){:/nomarkdown} ו-{::nomarkdown}\( D=b\){:/nomarkdown}.

כעת האלגוריתם פועל כך: התחילו עם {::nomarkdown}\( S\){:/nomarkdown}. כעת, בחרו {::nomarkdown}\( n\ge0\){:/nomarkdown} טבעי והחליפו את {::nomarkdown}\( S\){:/nomarkdown} ב-{::nomarkdown}\( A^{n}\){:/nomarkdown} (אם {::nomarkdown}\( n=0\){:/nomarkdown} אז מחליפים את {::nomarkdown}\( S\){:/nomarkdown} ב-{::nomarkdown}\( \varepsilon\){:/nomarkdown}). כעת, לכל מופע של {::nomarkdown}\( A\){:/nomarkdown}, החליפו אותו ב-{::nomarkdown}\( BB\){:/nomarkdown}; כעת, לכל מופע של {::nomarkdown}\( B\){:/nomarkdown}, החליפו אותו ב-{::nomarkdown}\( C\){:/nomarkdown} או החליפו אותו ב-{::nomarkdown}\( D\){:/nomarkdown}. לבסוף, החליפו כל מופע של {::nomarkdown}\( C\){:/nomarkdown} ב-{::nomarkdown}\( a\){:/nomarkdown} וכל מופע של {::nomarkdown}\( D\){:/nomarkdown} ב-{::nomarkdown}\( b\){:/nomarkdown}, והופה - קיבלתם מילה.

מה בעצם עשינו כאן? התחלנו מאיזה משתנה {::nomarkdown}\( S\){:/nomarkdown} וביצענו עליו <strong>פעולת שכתוב</strong> שהחליפה אותו במשתנים אחרים. גם עליהם הפעלנו פעולות שכתוב וכן הלאה וכן הלאה עד אשר קיבלנו אותיות ששייכות לאלפבית שלנו, ואותן כבר לא שכתבנו יותר. זה הרעיון הבסיסי מאחורי דקדוקים: יש לנו אוסף של <strong>משתנים</strong>, ואנחנו מבצעים עליהם פעולות שכתוב, עד שכל מה שנשאר לנו הוא רק אותיות-שאינן-משתנים. נכניס כבר עכשיו קצת טרמינולוגיה: לאותיות-שאינן-משתנים אני קורא <strong>טרמינלים</strong> ("טרמינלי" - סופי, שכן האותיות הללו מסיימות את סדרת פעולות השכתוב שלנו) ולפעולת השכתוב אני קורא "גזירה". <strong>דקדוק </strong>מורכב מארבעה רכיבים - קבוצת משתנים, קבוצת טרמינלים, משתנה ספציפי שמתפקד בתור <strong>משתנה התחלתי</strong> (אצלנו זהו {::nomarkdown}\( S\){:/nomarkdown}) וקבוצת <strong>כללי גזירה</strong> אפשריים. עוד מעט יגיעו גם הגדרות פורמליות יותר.

יש נקודה מעניינת אחת שטרם התייחסתי אליה - מה קורה אם {::nomarkdown}\( \emptyset\){:/nomarkdown} מופיע כחלק מהביטוי הרגולרי? מה עושה המשתנה שלו? פשוט מאוד - למשתנה הזה לא יהיו כללי גזירה, ולכן אם הוא מופיע משהו במהלך גזירת מילה, "נתקענו" והאלגוריתם שלנו יעצור ויגיד "נתקעתי" (לא סתם הצעתי את האפשרות הזו קודם!). זכרו שביטוי כמו {::nomarkdown}\( \emptyset^{*}\){:/nomarkdown} לא מגדיר שפה ריקה, אלא את השפה שיש בה רק את {::nomarkdown}\( \varepsilon\){:/nomarkdown}. זה מתאים לכך שאם {::nomarkdown}\( A=B^{*}\){:/nomarkdown} כך ש-{::nomarkdown}\( B=\emptyset\){:/nomarkdown} אז {::nomarkdown}\( A\){:/nomarkdown} יוכל לגזור את {::nomarkdown}\( \varepsilon\){:/nomarkdown} או את {::nomarkdown}\( B^{n}\){:/nomarkdown} עבור {::nomarkdown}\( n\ge1\){:/nomarkdown}, כשכל הגזירות מהצורה {::nomarkdown}\( B^{n}\){:/nomarkdown} "ייתקעו" ולכן נישאר רק עם {::nomarkdown}\( \varepsilon\){:/nomarkdown}.

עכשיו, כשיש לנו פורמליזציה חדשה כלשהי, אפשר גם לבחון את הדרכים השרירותיות שבהן אנחנו מגבילים אותה ולראות מה קורה אם מסירים את המגבלות. במקרה שלנו המגבלות מגיעות בצורה כמעט סמויה מהאופן שבו אנחנו "מסיקים" את הדקדוק מתוך ביטוי רגולרי. ראשית, כל משתנה יכול לעשות בדיוק אחד מבין הדברים הבאים: או לגזור אחד מבין שני משתנים (אם {::nomarkdown}\( A=B+C\){:/nomarkdown}), או לגזור שני משתנים ברצף (עבור {::nomarkdown}\( A=BC\){:/nomarkdown}) או לגזור משתנה אחד {::nomarkdown}\( n\ge0\){:/nomarkdown} פעמים (עבור {::nomarkdown}\( A=B^{*}\){:/nomarkdown}), או לגזור אות בודדת, או את המילה הריקה. או כלום. למה לא להרשות לו לעשות הרבה דברים שונים? מה רע בלגזור <strong>שלושה</strong> משתנים ברצף, למשל? או שתהיה יכולת לבחור בין גזירה של משתנה אחד לבין גזירה של שרשור של <strong>שני</strong> משתנים? אם נחשוב על זה קצת נראה שאפשר "לסמלץ" את היכולות הללו גם בעזרת הכללים הקיימים. למשל, אם אני רוצה ש-{::nomarkdown}\( A\){:/nomarkdown} יוכל לגזור את {::nomarkdown}\( BCD\){:/nomarkdown} אני יכול להוסיף "משתנה עזר" {::nomarkdown}\( E\){:/nomarkdown}, את הגזירה שבה {::nomarkdown}\( A\){:/nomarkdown} גוזר את {::nomarkdown}\( BE\){:/nomarkdown} וגזירה שבה {::nomarkdown}\( E\){:/nomarkdown} גוזר את {::nomarkdown}\( CD\){:/nomarkdown}. אם כן, ההגבלה האמיתית היא לא כאן. איפה היא כן?

אם אני מתחיל מלדבר על משתנים שגוזרים משתנים אחרים, אני לא אומר במפורש שום מגבלה על <strong>אילו משתנים</strong> יכול משתנה כלשהו לגזור. למשל, אני לא אוסר על משתנה לגזור את עצמו. ואני לא אוסר על סיטואציה שבה {::nomarkdown}\( A\){:/nomarkdown} גוזר את {::nomarkdown}\( B\){:/nomarkdown} ו-{::nomarkdown}\( B\){:/nomarkdown} גוזר את {::nomarkdown}\( A\){:/nomarkdown} בחזרה, וכדומה. כלומר, אני מאפשר "מעגלים". במשתנים שמגיעים מביטוי רגולרי זה לא יכול לקרות, כי כל משתנה מייצג תת-ביטוי-רגולרי, כאשר {::nomarkdown}\( B\){:/nomarkdown} יכול להיגזר מ-{::nomarkdown}\( A\){:/nomarkdown} רק אם הביטוי של {::nomarkdown}\( B\){:/nomarkdown} <strong>קטן ממש</strong> מהביטוי של {::nomarkdown}\( A\){:/nomarkdown}. זו המגבלה הקריטית. נניח לרגע שאני מעיף אותה - בואו תראו איך אני בונה בלי בעיה דקדוק עבור {::nomarkdown}\( L=\left\{ a^{n}b^{n}\ \|\ n\ge0\right\} \){:/nomarkdown}, שהיא הדוגמה לשפה לא רגולרית שאני משתמש בה כל הזמן. הדקדוק שלי יכלול משתנה יחיד {::nomarkdown}\( S\){:/nomarkdown}, שגוזר את המילה {::nomarkdown}\( aSb\){:/nomarkdown} או את המילה {::nomarkdown}\( \varepsilon\){:/nomarkdown}, וזהו. תנסו לפרמל אותו באמצעות סוגי כללי הגזירה שהצגתי - אני תכף אעשה את זה, אחרי שאציג את ההגדרות הפורמליות סוף כל סוף.

ובכן, מספיק עם המוטיבציה הרעיונית, בואו נעבור לניסוח המלא. <strong>דקדוק חסר הקשר</strong> הוא רביעייה {::nomarkdown}\( G=\left(V,T,S,P\right)\){:/nomarkdown} שכוללת קבוצה סופית של <strong>משתנים</strong> {::nomarkdown}\( V\){:/nomarkdown}, קבוצה סופית של <strong>טרמינלים</strong> {::nomarkdown}\( T\){:/nomarkdown}, <strong>משתנה התחלתי</strong> {::nomarkdown}\( S\in V\){:/nomarkdown} וקבוצה סופית של<strong> כללי גזירה</strong> {::nomarkdown}\( P\){:/nomarkdown}, כאשר <strong>כלל גזירה</strong> הוא מחרוזת מהצורה {::nomarkdown}\( A\to\alpha\){:/nomarkdown} כאשר {::nomarkdown}\( \alpha\in\left(V\cup T\right)^{*}\){:/nomarkdown} הוא סדרה כלשהי של משתנים וטרמינלים. למשתנה יכולים להיות כמה כללי גזירה שונים שבהם הוא מופיע באגף שמאל, ולפעמים נוח לכתוב כמה מהם בבת אחת כשהם מופרדים על ידי קו אנכי. למשל, הדקדוק עבור {::nomarkdown}\( \left\{ a^{n}b^{n}\ \|\ n\ge0\right\} \){:/nomarkdown} נכתב כך: {::nomarkdown}\( S\to aSb\|\varepsilon\){:/nomarkdown}. כאן {::nomarkdown}\( V=\left\{ S\right\} \){:/nomarkdown} ו-{::nomarkdown}\( T=\left\{ a,b\right\} \){:/nomarkdown} אבל לרוב אני לא אציין את הקבוצות הללו במפורש אלא רק אתן את כללי הגזירה של הדקדוק.

עכשיו צריך להסביר מהי גזירה - איך מילים מתקבלות על ידי הדקדוק. הרעיון בגזירה הוא שמתחילים מ-{::nomarkdown}\( S\){:/nomarkdown} ובכל צעד מבצעים <strong>שכתוב</strong> שבו עבור משתנה {::nomarkdown}\( A\){:/nomarkdown} כלשהו אנחנו בוחרים כלל גזירה כלשהו מהצורה {::nomarkdown}\( A\to\alpha\){:/nomarkdown} ומחליפים את {::nomarkdown}\( A\){:/nomarkdown} ב-{::nomarkdown}\( \alpha\){:/nomarkdown}. פורמלית, אנחנו אומרים ש-{::nomarkdown}\( \alpha\Rightarrow\beta\){:/nomarkdown} אם {::nomarkdown}\( \alpha=\gamma A\delta\){:/nomarkdown} עבור {::nomarkdown}\( A\in V\){:/nomarkdown} כלשהו ו-{::nomarkdown}\( \gamma,\delta\in\left(V\cup T\right)^{*}\){:/nomarkdown}, ו-{::nomarkdown}\( \beta=\gamma\lambda\delta\){:/nomarkdown} כך ש-{::nomarkdown}\( A\to\lambda\in P\){:/nomarkdown}. זה פורמליזם קצת מתוסבך אבל הרעיון הוא בדיוק מה שאמרתי במילים לפני רגע.

כפי שאתם רואים, אני משתמש די הרבה בביטויים שהם סדרה כלשהי של משתנים וטרמינלים. אני אקרא להם בשם <strong>תבנית פסוקית</strong>, ובכך אני טיפה מרמה כי בכל מני מקומות משתמשים במילה הזו כדי לתאר רק סדרות של משתנים וטרמינלים שיכולות להופיע במהלך גזירה חוקית מדקדוק כלשהו. אני גם אשתמש באותיות יווניות קטנות כדי לתאר אותן, כך שאפשר יהיה להבין מההקשר למה אני מתכוון בלי שאומר זאת במפורש.

כעת, הגדרנו יחס {::nomarkdown}\( \alpha\Rightarrow\beta\){:/nomarkdown} בין שתי תבניות פסוקיות, שאומר שבדקדוק {::nomarkdown}\( G\){:/nomarkdown} אפשר לגזור את {::nomarkdown}\( \beta\){:/nomarkdown} מתוך {::nomarkdown}\( \alpha\){:/nomarkdown}. בואו ניקח את <strong>הסגור הרפלקסיבי-טרנזיטיבי</strong> של היחס הזה ונסמן אותו ב-{::nomarkdown}\( \Rightarrow^{*}\){:/nomarkdown}. זה נשמע מפוצץ, אבל המשמעות של {::nomarkdown}\( \alpha\Rightarrow^{*}\beta\){:/nomarkdown} היא מאוד פשוטה - קיים {::nomarkdown}\( n\ge0\){:/nomarkdown} טבעי כך ש-{::nomarkdown}\( \alpha\Rightarrow^{n}\beta\){:/nomarkdown} כאשר {::nomarkdown}\( \Rightarrow^{n}\){:/nomarkdown} מציין בדיוק {::nomarkdown}\( n\){:/nomarkdown} צעדי גזירה (ב-0 צעדי גזירה תבנית פסוקית כלשהי "גוזרת" את עצמה). כעת אפשר להגדיר את השפה של דקדוק בתור אוסף כל המילים שמורכבות מטרמינלים בלבד שהדקדוק גוזר: {::nomarkdown}\( L\left(G\right)=\left\{ w\in T^{*}\ \|\ S\Rightarrow^{*}w\right\} \){:/nomarkdown}.

למה מה שהגדרתי נקרא "דקדוק חסר הקשר" ולא סתם "דקדוק"? ובכן, כי יש סוגים כלליים יותר של דקדוקים. באופן הכי כללי, כללי הגזירה של דקדוק לא חייבים להיות מהצורה {::nomarkdown}\( A\to\alpha\){:/nomarkdown} אלא מהצורה {::nomarkdown}\( \alpha\to\beta\){:/nomarkdown} כאשר {::nomarkdown}\( \alpha\){:/nomarkdown} היא תבנית פסוקית כלשהי שהדרישה היחידה שלנו עליה היא שהיא תכיל משתנה <strong>כלשהו</strong> (אפשר כמה). זה בעצם אומר שהאופן שבו משתנים נגזרים יכול להיות תלוי ב<strong>הקשר</strong> שלהם (האותיות שנמצאות "סביבן" במילה). אני לא אציג את הדקדוקים הללו כרגע כי הם מעניינים מספיק כדי להצדיק דיון נפרד, שיגיע יותר מאוחר, אחרי שכבר נתרגל לדקדוקים חסרי הקשר.

עכשיו בואו נחזור לביטויים הרגולריים שלנו. הפורמליזם של דקדוק שהגדרתי מאפשר לנו לטפל ב-{::nomarkdown}\( A=B+C\){:/nomarkdown}: זה יתורגם לכללי הגזירה {::nomarkdown}\( A\to B\|C\){:/nomarkdown}. כמובן שגם {::nomarkdown}\( A=BC\){:/nomarkdown} מטופל על ידי הגזירה {::nomarkdown}\( A\to BC\){:/nomarkdown}. אבל מה עם {::nomarkdown}\( A=B^{*}\){:/nomarkdown}? על פניו אין לי משהו שיודע "לסמלץ" אותו בפורמליזם שלי. אבל בפועל כמובן שיש, כל עוד אין לי איסור על כך שמשתנה יגזור את עצמו: כללי הגזירה {::nomarkdown}\( A\to BA\|\varepsilon\){:/nomarkdown} מסמלצים בדיוק את הקטע הזה של לגזור את {::nomarkdown}\( B\){:/nomarkdown} 0 או יותר פעמים. אם כן, כבר אנחנו רואים שבהינתן ביטוי רגולרי, קל לבנות דקדוק חסר הקשר שמייצר את אותה שפה כמוהו, ולכן השפות שמיוצרות על ידי דקדוקים חסרי הקשר מכילות את כל השפות הרגולריות - אבל יש עוד שפות, למשל {::nomarkdown}\( \left\{ a^{n}b^{n}\ \|\ n\ge0\right\} \){:/nomarkdown}. זה מצדיק מתן שם נפרד למחלקה הזו: <strong>מחלקת השפות חסרות ההקשר</strong> כוללת את כל השפות שקיים דקדוק חסר הקשר שמייצר אותן. בהמשך נראה ש-{::nomarkdown}\( \left\{ a^{n}b^{n}c^{n}\ \|\ n\ge0\right\} \){:/nomarkdown} <strong>אינה</strong> שפה חסרת הקשר, כך שלמרות שקיבלנו מחלקה גדולה יותר מהשפות הרגולריות, היא עדיין לא גדולה <strong>מדי</strong> ויש שפות פשוטות יחסית שאינן שם.

דקדוקים חסרי הקשר הם דרך מאוד נוחה לתאר שפות בצורה יחסית קריאה וברורה - שפות תכנות מתוארות לרוב בצורה פורמלית באמצעות דקדוק, והמהדר שממיר קוד בשפת התכנות לשפת מכונה משתמש בדקדוק הזה כדי להבין מה התוכנית אומרת. זה רומז לנו שדקדוק לא סתם מתאר מילה אלא גם אומר לנו משהו על ה<strong>מבנה</strong> של המילה הזו - מן הסתם מכאן השם "דקדוק" מגיע מלכתחילה; אבל מכיוון שההבנה שלי בלשונאות ובדקדוקים לשפות טבעיות היא אפסית, אני לא אדבר על דקדוקים "אמיתיים" בכלל אלא אדבוק באלו הפורמליים. ויש לי דוגמה פשוטה שאני חושב שתבהיר היטב את עניין המבנה הזה - ביטויים חשבוניים. ביטוי חשבוני לדוגמה הוא {::nomarkdown}\( 5+3\times8\){:/nomarkdown}, שערכו המספרי הוא 29. הביטוי הזה הוא גם מילה, כשה"אותיות" שלנו הם מספרים וסימני החשבון. בואו ניתן דקדוק פשוט עבור השפה הזו. כדי לייצר מספרים אני אשתמש במשתנה {::nomarkdown}\( V\){:/nomarkdown} עם הגזירות {::nomarkdown}\( V\to VV\|0\|1\|2\|3\|4\|5\|6\|7\|8\|9\){:/nomarkdown} - הבהירו לעצמכם למה זה מספיק כדי לייצר כל מספר (וגם יכול לייצר מספרים מהצורה 0013 אבל זה מספיק לא בעייתי כדי שלא אטרח לתקן את זה - וכמובן שקל לתקן, עם עוד משתנה עזר). כעת, כדי לייצר ביטוי חשבוני, נשתמש בהגדרה כמו-רקורסיבית: ראשית, כל מה ש-{::nomarkdown}\( V\){:/nomarkdown} יכול לייצר הוא ביטוי חשבוני; שנית, אם {::nomarkdown}\( E\){:/nomarkdown} הוא ביטוי חשבוני ו-{::nomarkdown}\( \oplus\){:/nomarkdown} היא פעולה חשבונית כלשהי, אז {::nomarkdown}\( E\oplus E\){:/nomarkdown} גם הוא ביטוי חשבוני. אם כן, נוסיף משתנה {::nomarkdown}\( E\){:/nomarkdown} שיהיה גם המשתנה ההתחלתי שלנו, ואת כללי הגזירה {::nomarkdown}\( E\to V\|E+E\|E\times E\|E-E\|E\div E\){:/nomarkdown}.

ועכשיו, כיצד ניתן לגזור את {::nomarkdown}\( 5+3\times8\){:/nomarkdown}? הנה דרך אחת לעשות את זה (אני קופץ על כמה צעדים כשנוח לי):

{::nomarkdown}\( E\Rightarrow E+E\Rightarrow E+E\times E\Rightarrow^{*}V+V\times V\Rightarrow^{*}5+3\times8\){:/nomarkdown}

אבל יש עוד דרך לעשות את זה! דרך שהיא בבירור שונה:

{::nomarkdown}\( E\Rightarrow E\times E\Rightarrow E+E\times E\Rightarrow^{*}V+V\times V\Rightarrow^{*}5+3\times8\){:/nomarkdown}

ההבדל הוא שבדרך הראשונה התחלנו עם החיבור, ובדרך השניה התחלנו עם הכפל. על פניו זה לא נראה כזה שונה, אבל באופן ציורי קל לראות את ההבדל. אני הולך לצייר את <strong>עץ הגזירה</strong> של שתי הגזירות הללו. עץ גזירה הוא דרך גרפית נאה לצייר גזירות בצורה קומפקטית - בלי להיכנס לפורמליזם, זה עץ שבו כל צומת פנימי מתאים למשתנה שהופיע מתישהו בגזירה, והבנים שלו הם התווים שהוא גזר. כפי שתוכלו לראות, לשתי הגזירות השונות הללו יש עצי גזירה שונים:

<strong><a href="http://www.gadial.net/wp-content/uploads/2015/03/diagram004.png"><img class="aligncenter size-full wp-image-3228" alt="diagram004" src="http://www.gadial.net/wp-content/uploads/2015/03/diagram004.png" width="347" height="251" /></a></strong>

עץ גזירה הוא מה שמתאר את ה"מבנה" של המילה שנגזרה. במקרה של ביטוי חשבוני, אפשר לחשב את הערך של הביטוי עם עץ הגזירה, בצורה מתבקשת: הערך של עלה הוא ערך המספר שלו (אצלי זה טיפה יותר מסובך כי מספר יכול להיות מיוצג על ידי כמה עלים, אבל תתעלמו מזה או תחשבו על המקרה שבו כל המספרים הם בני ספרה אחת). הערך של צומת פנימי מתקבל מהפעלת האופרטור שכתוב באותו צומת פנימי על שני הבנים שלו. קל לראות שבעץ הגזירה הימני הערך שנקבל הוא {::nomarkdown}\( 29\){:/nomarkdown}, אבל בעץ הגזירה השמאלי הערך שנקבל הוא בכלל {::nomarkdown}\( 64\){:/nomarkdown}. מה הלך פה? ובכן, ראינו שאת הביטוי {::nomarkdown}\( 5+3\times8\){:/nomarkdown} יש <strong>שתי דרכים שונות מהותית</strong> לקרוא - זאת על פי <strong>סדר הקדימויות</strong> שאנחנו נותנים לאופרטורים - האם כפל בא קודם (השמאלי) או חיבור (הימני).

הסיטואציה הזו, של דקדוק שבו קיימת מילה עם שני עצי גזירה שונים או יותר, נקראת <strong>רב-משמעות</strong> של דקדוק והיא לרוב לא רצויה. תחשבו על זה בשפת תכנות - זה אומר שאותה תוכנית מחשב יכולה לעבור הידור לשתי תוכניות שעושות דברים שונים, בהתאם למוזריות של המהדר הספציפי. לכן לרוב משתדלים לבנות דקדוק שיהיה חד משמעי ולא רב משמעי - עבור שפת הביטויים החשבוניים יש כזה, ואציג אותו בפוסט נפרד, מאוחר יותר, שיעסוק קצת יותר בענייני הרב משמעויות הללו.

בואו נחזור לדבר עכשיו על ביטויים רגולריים. ראינו שאפשר לחשוב על ביטויים רגולריים בתור בערך דקדוק עם כל מני הגבלות מוזרות שלא נעים לנסח. האם אפשר למצוא מחלקה פשוטה יותר לתיאור של דקדוקים שהשפות שלהם הן בדיוק כל השפות הרגולריות? כמובן. והדקדוקים הללו יפעלו בצורה שמאוד דומה לסימולציה של אוטומט סופי דטרמיניסטי. אכנה את הדקדוקים הללו <strong>דקדוקים לינאריים ימניים</strong>. דקדוק הוא לינארי ימני אם כל כללי הגזירה שלו הם מהצורה {::nomarkdown}\( A\to aB\){:/nomarkdown} או {::nomarkdown}\( A\to\varepsilon\){:/nomarkdown} כאשר {::nomarkdown}\( a\){:/nomarkdown} הוא טרמינל ו-{::nomarkdown}\( B\){:/nomarkdown} הוא משתנה. כלומר, בכל צעד גזירה המשתנה הנוכחי גוזר אות אחת ומשתנה אחד, או מחליט שהספיק לו ומתפוגג (גוזר את {::nomarkdown}\( \varepsilon\){:/nomarkdown}) גזירה בדקדוק הזה נראית כמו כתיבה משמאל לימין של המילה (ומכאן שם הדקדוק - לינארי, כלומר בקו ישר, וימני, כלומר הולך ימינה):

{::nomarkdown}\( S\Rightarrow aA\Rightarrow abB\Rightarrow abc\){:/nomarkdown}

האם אתם רואים את הדמיון לאוטומט סופי דטרמיניסטי? הרי גם אוטומט כזה קורא את המילה שלו מימין לשמאל, ויש לו "מצב" שמשתנה בכל צעד, כמו שלדקדוק הלינארי הימני יש "מצב" שמשתנה בכל צעד ומתבטא בזהות המשתנה היחיד שנמצא בקצה הימני של המילה. ההבדל העקרוני הוא שאוטומטים <strong>מזהים</strong> מילים (רצים על כל המילה ואז עונים כן או לא) ואילו דקדוקים <strong>מייצרים</strong> מילים. אבל קל לגשר על ההבדלים הללו ולכל אוטומט סופי דטרמיניסטי {::nomarkdown}\( A\){:/nomarkdown} לבנות דקדוק לינארי ימני שקול {::nomarkdown}\( G\){:/nomarkdown}, וההפך. בואו נראה את הבניות הללו.

נתחיל מבניה של אוטומט {::nomarkdown}\( A\){:/nomarkdown} עבור דקדוק {::nomarkdown}\( G=\left(V,T,S,P\right)\){:/nomarkdown} נתון. הרעיון יהיה לנסות ולסמלץ גזירה בדקדוק תוך כדי קריאת המילה. המצב של האוטומט יהיה המשתנה של הדקדוק, והאוטומט יבחר באופן אי דטרמיניסטי גזירה כלשהי שאפשרית מהמשתנה הנוכחי ומייצרת את האות שהוא כרגע קורא. הנה האוטומט: {::nomarkdown}\( A=\left(V,T,S,\delta,F\right)\){:/nomarkdown}. כלומר, {::nomarkdown}\( Q=V\){:/nomarkdown} ו-{::nomarkdown}\( \Sigma=T\){:/nomarkdown} ו-{::nomarkdown}\( q_{0}=S\){:/nomarkdown}, אם להשתמשב בסימנים שאנחנו רגילים אליהם מאוטומטים.

נותר רק לתאר את {::nomarkdown}\( \delta\){:/nomarkdown} ואת {::nomarkdown}\( F\){:/nomarkdown}. ראשית, {::nomarkdown}\( \delta\left(A,a\right)=\left\{ B\in V\ \|\ A\to aB\in P\right\} \){:/nomarkdown}; ושנית, {::nomarkdown}\( F=\left\{ A\in V\ \|\ A\to\varepsilon\in P\right\} \){:/nomarkdown}. עכשיו צריך להוכיח זה עובד, ועושים את זה בצורה סטנדרטית: מוכיחים שמתקיים {::nomarkdown}\( \hat{\delta}\left(A,w\right)=B\){:/nomarkdown} אם ורק אם {::nomarkdown}\( A\Rightarrow^{*}wB\){:/nomarkdown}, באינדוקציה על אורך {::nomarkdown}\( w\){:/nomarkdown}, ולכן {::nomarkdown}\( \hat{\delta}\left(S,w\right)=B\){:/nomarkdown} כאשר {::nomarkdown}\( B\in F\){:/nomarkdown} אם ורק אם {::nomarkdown}\( S\Rightarrow^{*}wB\Rightarrow w\){:/nomarkdown}, כלומר {::nomarkdown}\( w\in L\left(A\right)\){:/nomarkdown} אם ורק אם {::nomarkdown}\( w\in L\left(G\right)\){:/nomarkdown}.

בכיוון השני, נניח שיש לנו אוטומט סופי דטרמיניסטי {::nomarkdown}\( A=\left(Q,\Sigma,q_{0},\delta,F\right)\){:/nomarkdown}. נבנה דקדוק שמחקה ריצה של האוטומט על מילה כלשהי, וגוזר אפסילון רק אם האוטומט הגיע למצב מקבל. כלומר, {::nomarkdown}\( G=\left(Q,\Sigma,q_{0},P\right)\){:/nomarkdown} כאשר לכל {::nomarkdown}\( q\in Q\){:/nomarkdown} ו-{::nomarkdown}\( \sigma\in\Sigma\){:/nomarkdown} נסמן {::nomarkdown}\( \delta\left(q,\sigma\right)=p\){:/nomarkdown} ונוסיף את כלל הגזירה {::nomarkdown}\( q\to\sigma p\){:/nomarkdown}, וכמו כן אם {::nomarkdown}\( q\in F\){:/nomarkdown} נוסיף את הגזירה {::nomarkdown}\( q\to\varepsilon\){:/nomarkdown}. גם כאן הוכחת הנכונות דומה.

לסיום המבוא הזה, בואו נציג עוד דוגמה לדקדוק שסוגרת את המעגל שהתחלנו ממנו. התחלנו מביטויים רגולריים? אז בואו נציג דקדוק שגוזר ביטויים רגולריים! המבנה הרקורסיבי שלהם הופך את העניין לפשוט מאוד, כמובן: {::nomarkdown}\( S\to\emptyset\|\varepsilon\|\sigma_{1}\|\dots\|\sigma_{n}\|\left(S+S\right)\|\left(S\cdot S\right)\|\left(S^{*}\right)\){:/nomarkdown}.
